# Griffe

> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.

# Usage

# Welcome

> Griffe, pronounced "grif" (`/É¡Êif/`), is a french word that means "claw", but also "signature" in a familiar way. "On reconnaÃ®t bien lÃ  sa griffe."

- **Getting started**

  ______________________________________________________________________

  Learn how to quickly install and use Griffe.

  [Installation](installation/) [Introduction](introduction/)

- **Deep dive**

  ______________________________________________________________________

  Learn everything you can do with Griffe.

  [Guide](guide/users/) [API reference](reference/api/)

## What is Griffe?

Griffe is a Python tool and library that gives you signatures for entire Python programs. It extracts the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.

Griffe can be used as a Python library. For example, the [Python handler](https://mkdocstrings.github.io/python) of [mkdocstrings](https://mkdocstrings.github.io/) uses Griffe to collect API data and render API documentation in HTML. Griffe can also be used on the command-line, to load and serialize your API data to JSON, or find breaking changes in your API since the previous version of your library.

Serializing as JSON

```
$ griffe dump griffe -ssrc -r 2>/dev/null | head -n29
{
  "griffe": {
    "analysis": "static",
    "docstring": {
      "endlineno": 163,
      "lineno": 5,
      "value": "Griffe package.\n\nSignatures for entire Python programs.\nExtract the structure, the frame, the skeleton of your project,\nto generate API documentation or find breaking changes in your API.\n\nThe entirety of the public API is exposed here, in the top-level `griffe` module.\n\nAll messages written to standard output or error are logged using the `logging` module.\nOur logger's name is set to `\"griffe\"` and is public (you can rely on it).\nYou can obtain the logger from the standard `logging` module: `logging.getLogger(\"griffe\")`.\nActual logging messages are not part of the public API (they might change without notice).\n\nRaised exceptions throughout the package are part of the public API (you can rely on them).\nTheir actual messages are not part of the public API (they might change without notice).\n\nThe following paragraphs will help you discover the package's content.\n\n## CLI entrypoints\n\nGriffe provides a command-line interface (CLI) to interact with the package. The CLI entrypoints can be called from Python code.\n\n- [`griffe.main`][]: Run the main program.\n- [`griffe.check`][]: Check for API breaking changes in two versions of the same package.\n- [`griffe.dump`][]: Load packages data and dump it as JSON.\n\n## Loaders\n\nTo load API data, Griffe provides several high-level functions.\n\n- [`griffe.load`][]: Load and return a Griffe object.\n- [`griffe.load_git`][]: Load and return a module from a specific Git reference.\n- [`griffe.load_pypi`][]: Load and return a module from a specific package version downloaded using pip.\n\n## Models\n\nThe data loaded by Griffe is represented by several classes.\n\n- [`griffe.Module`][]: The class representing a Python module.\n- [`griffe.Class`][]: The class representing a Python class.\n- [`griffe.Function`][]: The class representing a Python function or method.\n- [`griffe.Attribute`][]: The class representing a Python attribute.\n- [`griffe.Alias`][]: This class represents an alias, or indirection, to an object declared in another module.\n\nAdditional classes are available to represent other concepts.\n\n- [`griffe.Decorator`][]: This class represents a decorator.\n- [`griffe.Parameters`][]: This class is a container for parameters.\n- [`griffe.Parameter`][]: This class represent a function parameter.\n\n## Agents\n\nGriffe is able to analyze code both statically and dynamically, using the following \"agents\".\nHowever most of the time you will only need to use the loaders above.\n\n- [`griffe.visit`][]: Parse and visit a module file.\n- [`griffe.inspect`][]: Inspect a module.\n\n## Serializers\n\nGriffe can serizalize data to dictionary and JSON.\n\n- [`griffe.Object.as_json`][griffe.Object.as_json]\n- [`griffe.Object.from_json`][griffe.Object.from_json]\n- [`griffe.JSONEncoder`][]: JSON encoder for Griffe objects.\n- [`griffe.json_decoder`][]: JSON decoder for Griffe objects.\n\n## API checks\n\nGriffe can compare two versions of the same package to find breaking changes.\n\n- [`griffe.find_breaking_changes`][]: Find breaking changes between two versions of the same API.\n- [`griffe.Breakage`][]: Breakage classes can explain what broke from a version to another.\n\n## Extensions\n\nGriffe supports extensions. You can create your own extension by subclassing the `griffe.Extension` class.\n\n- [`griffe.load_extensions`][]: Load configured extensions.\n- [`griffe.Extension`][]: Base class for Griffe extensions.\n\n## Docstrings\n\nGriffe can parse docstrings into structured data.\n\nMain class:\n\n- [`griffe.Docstring`][]: This class represents docstrings.\n\nDocstring section and element classes all start with `Docstring`.\n\nDocstring parsers:\n\n- [`griffe.parse`][]: Parse the docstring.\n- [`griffe.parse_auto`][]: Parse a docstring by automatically detecting the style it uses.\n- [`griffe.parse_google`][]: Parse a Google-style docstring.\n- [`griffe.parse_numpy`][]: Parse a Numpydoc-style docstring.\n- [`griffe.parse_sphinx`][]: Parse a Sphinx-style docstring.\n\n## Exceptions\n\nGriffe uses several exceptions to signal errors.\n\n- [`griffe.GriffeError`][]: The base exception for all Griffe errors.\n- [`griffe.LoadingError`][]: Exception for loading errors.\n- [`griffe.NameResolutionError`][]: Exception for names that cannot be resolved in a object scope.\n- [`griffe.UnhandledEditableModuleError`][]: Exception for unhandled editables modules, when searching modules.\n- [`griffe.UnimportableModuleError`][]: Exception for modules that cannot be imported.\n- [`griffe.AliasResolutionError`][]: Exception for aliases that cannot be resolved.\n- [`griffe.CyclicAliasError`][]: Exception raised when a cycle is detected in aliases.\n- [`griffe.LastNodeError`][]: Exception raised when trying to access a next or previous node.\n- [`griffe.RootNodeError`][]: Exception raised when trying to use siblings properties on a root node.\n- [`griffe.BuiltinModuleError`][]: Exception raised when trying to access the filepath of a builtin module.\n- [`griffe.ExtensionError`][]: Base class for errors raised by extensions.\n- [`griffe.ExtensionNotLoadedError`][]: Exception raised when an extension could not be loaded.\n- [`griffe.GitError`][]: Exception raised for errors related to Git.\n\n# Expressions\n\nGriffe stores snippets of code (attribute values, decorators, base class, type annotations) as expressions.\nExpressions are basically abstract syntax trees (AST) with a few differences compared to the nodes returned by [`ast`][].\nGriffe provides a few helpers to extract expressions from regular AST nodes.\n\n- [`griffe.get_annotation`][]: Get a type annotation as expression.\n- [`griffe.get_base_class`][]: Get a base class as expression.\n- [`griffe.get_class_keyword`][]: Get a class keyword as expression.\n- [`griffe.get_condition`][]: Get a condition as expression.\n- [`griffe.get_expression`][]: Get an expression from an AST node.\n- [`griffe.safe_get_annotation`][]: Get a type annotation as expression, safely (returns `None` on error).\n- [`griffe.safe_get_base_class`][]: Get a base class as expression, safely (returns `None` on error).\n- [`griffe.safe_get_class_keyword`][]: Get a class keyword as expression, safely (returns `None` on error).\n- [`griffe.safe_get_condition`][]: Get a condition as expression, safely (returns `None` on error).\n- [`griffe.safe_get_expression`][]: Get an expression from an AST node, safely (returns `None` on error).\n\nThe base class for expressions.\n\n- [`griffe.Expr`][]\n\nExpression classes all start with `Expr`.\n\n# Loggers\n\nIf you want to log messages from extensions, get a logger with `get_logger`.\nThe `logger` attribute is used by Griffe itself. You can use it to temporarily disable Griffe logging.\n\n- [`griffe.logger`][]: Our global logger, used throughout the library.\n- [`griffe.get_logger`][]: Create and return a new logger instance.\n\n# Helpers\n\nTo test your Griffe extensions, or to load API data from code in memory, Griffe provides the following helpers.\n\n- [`griffe.temporary_pyfile`][]: Create a Python file containing the given code in a temporary directory.\n- [`griffe.temporary_pypackage`][]: Create a package containing the given modules in a temporary directory.\n- [`griffe.temporary_visited_module`][]: Create and visit a temporary module with the given code.\n- [`griffe.temporary_visited_package`][]: Create and visit a temporary package.\n- [`griffe.temporary_inspected_module`][]: Create and inspect a temporary module with the given code.\n- [`griffe.temporary_inspected_package`][]: Create and inspect a temporary package."
    },
    "exports": [
      "DEFAULT_LOG_LEVEL",
      "Alias",
      "AliasResolutionError",
      "Attribute",
      "AttributeChangedTypeBreakage",
      "AttributeChangedValueBreakage",
      "AutoOptions",
      "Breakage",
      "BreakageKind",
      "BuiltinModuleError",
      "Class",
      "ClassRemovedBaseBreakage",
      "CyclicAliasError",
      "DataclassesExtension",
      "Decorator",
      "DelMembersMixin",
      "Docstring",
      "DocstringAdmonition",
      "DocstringAttribute",
      "DocstringClass",
```

Checking for API breaking changes

```
$ griffe check griffe -ssrc -b0.46.0 -a0.45.0 --verbose
src/griffe/mixins.py:303: ObjectAliasMixin.is_exported:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/mixins.py:353: ObjectAliasMixin.is_public:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/dataclasses.py:520: Object.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/diff.py:535: find_breaking_changes(ignore_private):
Parameter default was changed:
  Old: True
  New: _sentinel

src/griffe/extensions/base.py:463: load_extensions(exts):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/dataclasses.py:1073: Alias.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional
```

[Playground](playground/) [Join our Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im)

# Getting started

To begin using Griffe, refer to [Installation](../installation/) and take a look at our [short introduction](../introduction/). If you'd like to experiment with Griffe without installing it, try our [playground](../playground/) directly in your browser.

If you have questions, need help, or want to contribute, feel free to reach out to the community! You can open [new discussions on GitHub](https://github.com/mkdocstrings/griffe/discussions) or join our [Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im) for a quick chat.

- [Installation](../installation/)
- [Introduction (short tour)](../introduction/)
- [Guide (advanced tour)](../guide/)
- [Getting help](../getting-help/)

# Installation

Griffe is a Python package, so you can install it with your favorite Python package installer or dependency manager.

## Install as a tool & library

```
pip install griffe
```

[pip](https://pip.pypa.io/en/stable/) is the main package installer for Python.

```
pdm add griffe
```

[PDM](https://pdm-project.org/en/latest/) is an all-in-one solution for Python project management.

```
poetry add griffe
```

[Poetry](https://python-poetry.org/) is an all-in-one solution for Python project management.

```
rye add griffe
```

[Rye](https://rye.astral.sh/) is an all-in-one solution for Python project management, written in Rust.

```
uv add griffe
```

[uv](https://docs.astral.sh/uv/) is an extremely fast Python package and project manager, written in Rust.

## Install as a tool only

```
pip install --user griffe
```

[pip](https://pip.pypa.io/en/stable/) is the main package installer for Python.

```
pipx install griffe
```

[pipx](https://pipx.pypa.io/stable/) allows to install and run Python applications in isolated environments.

```
rye install griffe
```

[Rye](https://rye.astral.sh/) is an all-in-one solution for Python project management, written in Rust.

```
uv tool install griffe
```

[uv](https://docs.astral.sh/uv/) is an extremely fast Python package and project manager, written in Rust.

# Introduction

Griffe is able to read Python source code and inspect objects at runtime to extract information about the API of a Python package. This information is then stored into data models (Python classes), and these model instances together form a tree that statically represent the package's API: starting with the top-level module, then descending into submodules, classes, functions, attributes and type aliases. From there, it's possible to explore and exploit this API representation in various ways.

## Command line tool

Griffe is both a command line tool and a Python library. The command line tool offers a few commands to, for example, serialize API data to JSON and check for API breaking changes between two versions of your project.

```
# Load API of `my_package`, serialize it to JSON,
# print it to standard output.
griffe dump my_package
```

```
# Check for API breaking changes
# between current version and version 1.0 (Git reference).
griffe check my_package --against 1.0
```

Both commands accept a `-h`, `--help` argument to show all the available options. For a complete reference of the command line interface, see [Reference / Command line interface](../reference/cli/).

## Python library

As a library, Griffe exposes all its public API directly in the top-level module. It means you can simply import `griffe` to access all its API.

```
import griffe

griffe.load(...)
griffe.find_breaking_changes(...)
griffe.main(...)
griffe.visit(...)
griffe.inspect(...)
```

To start exploring your API within Griffe data models, use the load function to load your package and access its various objects:

```
import griffe

my_package = griffe.load("my_package")

some_method = my_package["some_module.SomeClass.some_method"]
print(some_method.docstring.value)
print(f"Is `some_method` public? {'yes' if some_method.is_public else 'no'}")
```

Use the load_git function to load your API at a particular moment in time, specified with a Git reference (commit hash, branch name, tag name):

```
import griffe

my_package_v2_1 = griffe.load_git("my_package", ref="2.1")
```

For more advanced usage, see our guide on [loading and navigating data](../guide/users/loading/).

For a complete reference of the application programming interface, see [Reference / Python API](../reference/api/).

# User guide

Welcome to the Griffe user guide!

## Manipulating APIs

The following topics will guide you through the various methods Griffe offers for exploring and exploiting Python APIs.

- **Loading**

  ______________________________________________________________________

  Griffe can find packages and modules to scan them statically or dynamically and extract API-related information.

  [Learn how to load data](loading/)

- **Navigating**

  ______________________________________________________________________

  Griffe exposes the extracted API information into data models, making it easy to navigate your API.

  [Learn how to navigate data](navigating/)

- **Serializing**

  ______________________________________________________________________

  Griffe can serialize your API data into JSON, for other tools to navigate or manipulate it.

  [Learn how to serialize data](serializing/)

- **Checking**

  ______________________________________________________________________

  Griffe can compare snapshots of the same API to find breaking changes.

  [Learn how to detect and handle breaking changes](checking/)

- **Extending**

  ______________________________________________________________________

  API data can be augmented or modified thanks to Griffe's extension system.

  [Learn how to write and use extensions](extending/)

## Recommendations

These topics explore the user side: how to write code to better integrate with Griffe.

- **Public API**

  ______________________________________________________________________

  See our recommendations for exposing public APIs to your users.

  [See our public API recommendations](recommendations/public-apis/)

- **Python code best practices**

  ______________________________________________________________________

  See our best practices for writing Python code.

  [See our best practices](recommendations/python-code/)

- **Docstrings**

  ______________________________________________________________________

  Griffe supports multiple docstring styles. Learn about these different styles, and see our recommendations to write docstrings.

  [See our docstring recommendations](recommendations/docstrings/)

## How-to

These how-tos will show you how to achieve specific things with Griffe.

- **Parse docstrings**

  ______________________________________________________________________

  Griffe can be used as a docstring-parsing library.

  [See how to parse docstrings](how-to/parse-docstrings/)

- **@ Support custom decorators**

  ______________________________________________________________________

  Griffe will rarely support custom decorators through static analysis, but you can easily write extensions to do so.

  [See how to support custom decorators](how-to/support-decorators/)

- **Selectively inspect objects**

  ______________________________________________________________________

  Sometimes static analysis is not enough, so you might want to use dynamic analysis (inspection) on certain objects.

  [See how to selectively inspect objects](how-to/selectively-inspect/)

- **Set objects' docstring style**

  ______________________________________________________________________

  Sometimes the wrong docstring styles are attached to objects. You can fix this with a few different methods.

  [See how to set the correct docstring styles on objects](how-to/set-docstring-styles/)

- **Set Git source info on objects**

  ______________________________________________________________________

  Griffe tries to find the right Git remote URL to provide source links to loaded objects. In some cases you might want to override the Git information or the source link directly.

  [See how to set the correct Git information or source link on objects](how-to/set-git-info/)

# Loading APIs

Griffe can load API data from both source code (static analysis) and objects at runtime through introspection (dynamic analysis). Both static and dynamic analysis can be used at the same time: Griffe will first try to find sources, and will fall back to introspection if it cannot find any. When Griffe finds compiled modules within a packages, it uses introspection again to extract API information. There are various options to configure how Griffe loads data, for example to force or disallow dynamic analysis, but first let see the interface.

## The `load` function

The main interface to load API data is Griffe's load function:

```
import griffe

my_package = griffe.load("my_package")
```

You can ask to load a specific object rather than a package:

```
import griffe

my_method = griffe.load("my_package.MyClass.my_method")
```

Griffe will load the whole package anyway, but return the specified object directly, so that you don't have to access it manually. To manually access the object representing the method called `my_method`, you would have used the `my_package` variable instantiated before, like this:

```
my_method = my_package["MyClass.my_method"]
```

The [Navigating](../navigating/) topic will show you all the ways Griffe objects can be navigated.

Finally, you can even load packages or modules by passing absolute or relative file paths. This is useful when the module or package is not installed within the current Python environment and therefore cannot be found in the default search paths (see [Search paths](#search-paths) below).

```
import griffe

griffe.load("src/my_package")
griffe.load("some_script.py")
```

In case of ambiguity, you can instruct Griffe to ignore existing relative file paths with `try_relative_paths=False`. For example, when using [the flat layout (in contrast to the src-layout)](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/), your Python package is in the root of the repository.

```
ðŸ“ ./
â”œâ”€â”€ ðŸ“ my_package/
â”‚   â””â”€â”€  __init__.py
â””â”€â”€  pyproject.toml
```

Here if you ask Griffe to load `my_package`, it will find it as a relative path, in `./my_package`. If you want Griffe to use the version installed in your environment's site packages instead, set `try_relative_path` to false:

```
import griffe

my_installed_package = griffe.load("my_package", try_relative_path=False)
```

## The `GriffeLoader` class

The load function is a shortcut for instantiating the GriffeLoader class and calling its load method. Calling the load function multiple times will instantiate a new Griffe loader each time. If you care about efficiency, it is better to instantiate the loader yourself and use its `load` method:

```
import griffe

loader = GriffeLoader()
my_package = loader.load("my_package")
my_other_package = loader.load("my_other_package")
```

Keeping a reference to the loader will reduce the number of IO operations on the file-system, as the contents of the directories that the loader searches into will be cached (only the lists of files and directories will be cached, not the file contents).

Reusing the same loader will also help resolving aliases across different packages. See [Alias resolution](#alias-resolution) below.

## Search paths

To specify in which directories Griffe should search for packages and modules, you can use the `search_paths` parameter on both the load function and the GriffeLoader class.

```
import griffe

my_package = griffe.load("my_package", search_paths=["src"])
```

```
import griffe

loader = GriffeLoader(search_paths=["src"])
my_package = loader.load("my_package")
```

By default it will search in the paths found in sys.path, which can be influenced through the PYTHONPATH environment variable.

If Griffe cannot find sources for the specified object in the given search paths, it will try to import the specified object and use dynamic analysis on it (introspection). See [Forcing dynamic analysis](#forcing-dynamic-analysis) and [Disallowing dynamic analysis](#disallowing-dynamic-analysis).

## Forcing dynamic analysis

Griffe always tries first to find sources for the specified object. Then, unless told otherwise, it uses static analysis to load API data, i.e. it parses the sources and visits the AST (Abstract Syntax Tree) to extract information. If for some reason you want Griffe to use dynamic analysis instead (importing and inspecting runtime objects), you can pass the `force_inspection=True` argument:

```
import griffe

my_package = griffe.load("my_package", force_inspection=True)
```

Forcing inspection can be useful when your code is highly dynamic, and static analysis has trouble keeping up.

**However we don't recommend forcing inspection**, for a few reasons:

- dynamic analysis requires that you either mock your dependencies, or install them
- dynamic analysis will **execute code**, possibly ***arbitrary code*** if you import third-party dependencies, putting you at risk
- dynamic analysis will potentially consume more resources (CPU, RAM) since it executes code
- dynamic analysis will sometimes give you less precise or incomplete information
- it's possible to write Griffe extensions that will *statically handle* the highly dynamic parts of your code (like custom decorators) that Griffe doesn't understand by default
- if really needed, it's possible to [handle only a subset of objects with dynamic analysis](../how-to/selectively-inspect/), while the rest is loaded with static analysis, again thanks to Griffe extensions

The [Extending](../extending/) topic will explain how to write and use extensions for Griffe.

## Disallowing dynamic analysis

If you want to be careful about what gets executed in the current Python process, you can choose to disallow dynamic analysis by passing the `allow_inspection=False` argument. If Griffe cannot find sources for a package, it will not try to import it and will instead fail with a `ModuleNotFoundError` directly.

```
import griffe

# Here Griffe will fall back on dynamic analysis and import `itertools`.
griffe.load("itertools")

# While here it will raise `ModuleNotFoundError`.
griffe.load("itertools", allow_inspection=False)
```

## Alias resolution

What's that?

In Griffe, indirections to objects are called *aliases*. These indirections, or aliases, represent two kinds of objects: imported objects and inherited objects. Indeed, an imported object is "aliased" in the module that imports it, while its true location is in the module it was imported from. Similarly, a method inherited from a parent class is "aliased" in the subclass, while its true location is in the parent class.

The name "alias" comes from the fact that imported objects can be aliased under a different name: `from X import A as B`. In the case of inherited members, this doesn't really apply, but we reuse the concept for conciseness.

An Alias instance is therefore a pointer to another object. It has its own name, parent, line numbers, and stores the path to the target object. Thanks to this path, we can access the actual target object and all its metadata, such as name, parent, line numbers, docstring, etc.. Obtaining a reference to the target object is what we call "alias resolution".

**To summarize, alias resolution is a post-process task that resolves imports after loading everything.**

To resolve an alias, i.e. obtain a reference to the object it targets, we have to wait for this object to be loaded. Indeed, during analysis, objects are loaded in breadth-first order (in the object hierarchy, highest objects are loaded first, deepest ones are loaded last), so when we encounter an imported object, we often haven't loaded this object yet.

Once a whole package is loaded, we are ready to try and resolve all aliases. But we don't *have* to resolve them. First, because the user might not need aliases to be resolved, and second, because each alias can be resolved individually and transparently when accessing its target object properties.

Therefore, alias resolution is optional and enabled with the `resolve_aliases` parameter.

Lets take an example.

File layout

```
ðŸ“ ./
â””â”€â”€ ðŸ“ my_package/
    â”œâ”€â”€  __init__.py
    â””â”€â”€  my_module.py
```

my_package/__init__.py

```
from my_package.my_module import my_function
```

my_package/my_module.py

```
def my_function():
    print("hello")
```

When loading this package, `my_package.my_function` will be an alias pointing at `my_package.my_module.my_function`:

```
import griffe

my_package = griffe.load("my_package")
my_package["my_function"].resolved  # False
```

```
import griffe

my_package = griffe.load("my_package", resolve_aliases=True)
my_package["my_function"].resolved  # True
my_package["my_function"].target is my_package["my_module.my_function"]  # True
```

The [Navigating](../navigating/) topic will tell you more about aliases and how they behave.

### Modules collection

In the first section of this page, we briefly mentioned that Griffe always loads the entire package containing the object you requested. One of the reasons it always loads entire packages and not just single, isolated objects, is that alias resolution requires all objects of a package to be loaded. Which means that if an alias points to an object that is part of *another* package, it can only be resolved if the *other* package is *also loaded*. For example:

File layout

```
ðŸ“ ./
â”œâ”€â”€ ðŸ“ package1/
â”‚   â””â”€â”€  __init__.py
â””â”€â”€ ðŸ“ package2/
    â””â”€â”€  __init__.py
```

package1/__init__.py

```
X = 0
```

package2/__init__.py

```
from package1 import X
```

```
>>> import griffe
>>> package2 = griffe.load("package2", resolve_aliases=True)
>>> package2["X"].target_path
'package1.X'
>>> package2["X"].resolved
False
>>> package2["X"].target
Traceback (most recent call last):
  File "griffe/_internal/models.py", line 1375, in _resolve_target
    resolved = self.modules_collection.get_member(self.target_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "griffe/_internal/mixins.py", line 84, in get_member
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
           ~~~~~~~~~~~~^^^^^^^^^^
KeyError: 'package1'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "griffe/_internal/dataclasses.py", line 1310, in target
    self.resolve_target()
  File "griffe/_internal/dataclasses.py", line 1369, in resolve_target
    self._resolve_target()
  File "griffe/_internal/dataclasses.py", line 1377, in _resolve_target
    raise AliasResolutionError(self) from error
griffe._internal.exceptions.AliasResolutionError: Could not resolve alias package2.X pointing at package1.X (in package2/__init__.py:1)
```

As you can see in the interpreter session above, Griffe did not resolve the `X` alias. When we tried to access its target object anyway, it failed with a `KeyError`, which was raised again as an AliasResolutionError.

Lets try again, but this time by loading both packages.

```
>>> import griffe
>>> package1 = griffe.load("package1")  # nothing to resolve
>>> package2 = griffe.load("package2", resolve_aliases=True)
>>> package2["X"].target_path
'package1.X'
>>> package2["X"].resolved
False  # Hmm?
>>> package2["X"].target
Traceback (most recent call last):
...
griffe._internal.exceptions.AliasResolutionError: Could not resolve alias package2.X pointing at package1.X (in package2/__init__.py:1)
```

The same exception again? What happened here? We loaded both packages, but Griffe still failed to resolve the alias. That is expected; here is the explanation.

If you look closely at the first exception traceback, you will see that Griffe searched the target path in `self.modules_collection`. So what is this modules collection?

Each instance of GriffeLoader holds a reference to an instance of ModulesCollection. If you don't create such a collection manually to pass it to the loader, it will instantiate one itself. All objects loaded with this loader are added to this very modules collection, and gain a reference to it.

Since the load function is just a shortcut for creating a loader and calling its load method, when we called `griffe.load(...)` twice, it actually created two distinct collections of modules. When Griffe tried to resolve aliases of `package2`, it looked for `package1` in `package2`'s collection, and couldn't find it. Indeed, `package1` was in another modules collection.

Therefore, to resolve aliases *across different packages*, these packages must be loaded within the same modules collection. In order to do that, you have a few options:

- instantiate a single loader, and use it to load both packages
- create your own modules collection, and pass it to the load function each time you call it
- create your own modules collection, and pass it to the different instances of GriffeLoader you create

```
>>> import griffe
>>> loader = griffe.GriffeLoader()
>>> package1 = loader.load("package1")
>>> package2 = loader.load("package2")
>>> loader.resolve_aliases()
>>> package2["X"].resolved
True
>>> package2["X"].target
Attribute('X', lineno=1, endlineno=1)
```

```
>>> import griffe
>>> collection = griffe.ModulesCollection()
>>> package1 = griffe.load("package1", modules_collection=collection)
>>> package2 = griffe.load("package2", modules_collection=collection, resolve_aliases=True)
>>> package2["X"].resolved
True
>>> package2["X"].target
Attribute('X', lineno=1, endlineno=1)
```

```
>>> import griffe
>>> collection = griffe.ModulesCollection()
>>> loader1 = griffe.GriffeLoader(modules_collection=collection, ...)
>>> package1 = loader1.load("package1")
>>> loader2 = griffe.GriffeLoader(modules_collection=collection, ...)  # different parameters
>>> package2 = loader2.load("package2")
>>> package2["X"].resolved
True
>>> package2["X"].target
Attribute('X', lineno=1, endlineno=1)
```

There is no preferred way, it depends on whether you need to instantiate different loaders with different parameters (search paths for example) while keeping every loaded module in the same collection, or if a single loader is enough, or if you explicitly need a reference to the collection, etc..

### Loading external packages automatically

By default, when resolving aliases, Griffe loaders will not be able to resolve aliases pointing at objects from "external" packages. By external, we mean that these packages are external to the current modules collection: they are not loaded. But sometimes users don't know in advance which packages need to be loaded in order to resolve aliases (and compute class inheritance). For these cases, Griffe loaders can be instructed to automatically load external packages. If we take the previous example again:

```
import griffe

package2 = griffe.load("package2", resolve_aliases=True, resolve_external=True)
print(package2["X"].target.name)  # X
```

Here Griffe automatically loaded `package1` while resolving aliases, even though we didn't explicitly load it ourselves.

While automatically resolving aliases pointing at external packages can be convenient, we advise cautiousness: this can trigger the loading of *a lot* of external packages, *recursively*.

One special case that we must mention is that Griffe will by default automatically load *private sibling packages*. For example, when resolving aliases for the `ast` module, Griffe will automatically try and load `_ast` too (if dynamic analysis is allowed, since this is a builtin module), even without `resolve_external=True`. If you want to prevent this behavior, you can pass `resolve_external=False` (it is `None` by default).

## Source information

By default, Griffe runs some Git commands to find the following information about a package:

- the repository local path
- the Git remote URL
- what service it corresponds to (GitHub, etc.)
- the current commit hash

It then assigns this information to each package it loads, in the git_info attribute. This attribute can be reassigned on any object, if necessary. Each object who has it set to `None` will look into its parents.

In the following cases, the information will not be set:

- Griffe couldn't find the source for an object, or line numbers in the source
- the source of a package is not tracked within the identified repository
- Griffe cannot identify a known, supported service from the remote URL
- any Git command failed

Griffe supports the services listed in the KnownGitService symbol. Please open a feature request if you would like to add support for other services.

Thanks to this source information, Griffe can then compute source links for each objects, by combining the information with the object's filepath and line numbers.

You can globally change how Griffe obtains the source information with the following environment variables:

- `GRIFFE_GIT_REMOTE_URL`: It is the repository remote URL, as an HTTPS link that readers of your documentation can access to see the repository online, on the service it is hosted on. Example: `GRIFFE_GIT_REMOTE_URL=https://app.radicle.at/nodes/seed.radicle.at/rad:z4M5XTPDD4Wh1sm8iPCenF85J3z8Z`.
- `GRIFFE_GIT_REMOTE`: You can also let Griffe obtain the remote URL by getting it from the Git local configuration. The Git remote defaults to `origin`. This environment variable lets you change it to something else. Example: `GRIFFE_GIT_REMOTE=upstream`.
- `GRIFFE_GIT_SERVICE`: Griffe infers the service by looking at the remote URL. If the remote URL contains a known service name, Griffe will use it as service. You can otherwise explicitly set the service using this environment variable. Example: `GRIFFE_GIT_SERVICE=codeberg`.
- `GRIFFE_GIT_COMMIT_HASH`: Griffe gets the commit hash by running a Git command. If you prefer using another commit hash, you can set it using this environment variable. Example: `GRIFFE_GIT_COMMIT_HASH=77f928aeab857cb45564462a4f849c2df2cca99a`.

For more complex cases, see [How to programmatically set the correct Git information or source link on objects](../how-to/set-git-info/).

## Next steps

Now that the API is loaded, you can start [navigating it](../navigating/), [serializing it](../serializing/) or [checking for API breaking changes](../checking/). If you find out that the API data is incorrect or incomplete, you might want to learn how to [extend it](../extending/).

# Navigating APIs

Griffe loads API data into data models. These models provide various attributes and methods to access or update specific fields. The different models are:

- Module, representing Python modules;
- Class, representing Python classes;
- Function, representing Python functions and class methods;
- Attribute, representing object attributes that weren't identified as modules, classes or functions;
- Type Alias, representing Python type aliases;
- Alias, representing indirections such as imported objects or class members inherited from parent classes.

When [loading an object](../loading/), Griffe will give you back an instance of one of these models. A few examples:

```
>>> import griffe
>>> type(griffe.load("markdown"))
<class 'griffe._internal.models.Module'>
>>> type(griffe.load("markdown.core.Markdown"))
<class 'griffe._internal.models.Class'>
>>> type(griffe.load("markdown.Markdown"))
<class 'griffe._internal.models.Alias'>
>>> type(griffe.load("markdown.core.markdown"))
<class 'griffe._internal.models.Function'>
>>> type(griffe.load("markdown.markdown"))
<class 'griffe._internal.models.Alias'>
>>> type(griffe.load("markdown.Markdown.references"))
<class 'griffe._internal.models.Attribute'>
```

However deep the object is, Griffe loads the entire package. It means that in all the cases above, Griffe loaded the whole `markdown` package. The model instance Griffe gives you back is therefore part of a tree that you can navigate.

## Moving up: parents

Each object holds a reference to its parent (except for the top-level module, for which the parent is `None`). Shortcuts are provided to climb up directly to the parent module, or the top-level package. As we have seen in the [Loading chapter](../loading/), Griffe stores all loaded modules in a modules collection; this collection can be accessed too, through the modules_collection attribute.

## Moving down: members

To access an object's members, there are a few options:

- Access to regular members through the members attribute, which is a dictionary. The keys are member names, the values are Griffe models.

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown.members["Markdown"]
  Alias('Markdown', 'markdown.core.Markdown')
  >>> markdown.members["core"].members["Markdown"]
  Class('Markdown', 46, 451)
  ```

- Access to both regular and inherited members through the all_members attribute, which is a dictionary again. See [Inherited members](#inherited-members).

- Convenient dictionary-like item access, thanks to the subscript syntax `[]`. With this syntax, you will not only be able to chain accesses, but also merge them into a single access by using dot-separated paths to objects:

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown["core"]["Markdown"]  # chained access
  Class('Markdown', 46, 451)
  >>> markdown["core.Markdown"]  # merged access
  Class('Markdown', 46, 451)
  ```

  The dictionary-like item access also accepts tuples of strings. So if for some reason you don't have a string equal to `"core.Markdown"` but a tuple equal to `("core", "Markdown")` (for example obtained from splitting another string), you can use it too:

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown[("core", "Markdown")]  # tuple access
  Class('Markdown', 46, 451)
  >>> # Due to the nature of the subscript syntax,
  >>> # you can even use implicit tuples.
  >>> markdown["core", "Markdown"]
  Class('Markdown', 46, 451)
  ```

- Less convenient, but safer access to members while the object tree is being built (while a package is still being loaded), using the get_member() method.

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown.get_member("core.Markdown")
  Class('Markdown', 46, 451)
  ```

  In particular, Griffe extensions should always use `get_member` instead of the subscript syntax `[]`. The `get_member` method only looks into regular members, while the subscript syntax looks into inherited members too (for classes), which cannot be correctly computed until a package is fully loaded (which is generally not the case when an extension is running).

- In addition to this, models provide the attributes, functions, classes, type_aliases or modules attributes, which return only members of the corresponding kind. These attributes are computed dynamically each time (they are Python properties).

The same way members are accessed, they can also be set:

- Dictionary-like item assignment: `markdown["thing"] = ...`, also supporting dotted-paths and string tuples. This will (re)assign only regular members: inherited members (classes only) are re-computed everytime they are accessed.
- Safer method for extensions: `markdown.set_member("thing", ...)`, also supporting dotted-paths and string tuples.
- Regular member assignment: `markdown.members["thing"] = ...`. **This is not recommended, as the assigned member's `parent` attribute will not be automatically updated.**

...and deleted:

- Dictionary-like item deletion: `del markdown["thing"]`, also supporting dotted-paths and string tuples. This will delete only regular members: inherited members (classes only) are re-computed everytime they are accessed.
- Safer method for extensions: `markdown.del_member("thing")`, also supporting dotted-paths and string tuples.
- Regular member deletion: `del markdown.members["thing"]`. **This is not recommended, as the aliases attribute of other objects in the tree will not be automatically updated.**

### Inherited members

Griffe supports class inheritance, both when visiting and inspecting modules.

To access members of a class that are inherited from base classes, use the inherited_members attribute. Everytime you access inherited members, the base classes of the given class will be resolved, then the MRO (Method Resolution Order) will be computed for these base classes, and a dictionary of inherited members will be built. Make sure to store the result in a variable to avoid re-computing it everytime (you are responsible for the caching part). Also make sure to only access `inherited_members` once everything is loaded by Griffe, to avoid computing things too early. Don't try to access inherited members in extensions, while visiting or inspecting modules.

Inherited members are aliases that point at the corresponding members in parent classes. These aliases will have their inherited attribute set to true.

**Important:** only classes from already loaded packages will be used when computing inherited members. This gives users control over how deep into inheritance to go, by pre-loading packages from which you want to inherit members. For example, if `package_c.ClassC` inherits from `package_b.ClassB`, itself inheriting from `package_a.ClassA`, and you want to load `ClassB` members only:

```
import griffe

loader = griffe.GriffeLoader()
# note that we don't load package_a
loader.load("package_b")
loader.load("package_c")
```

If a base class cannot be resolved during computation of inherited members, Griffe logs a DEBUG message.

If you want to access all members at once (both declared and inherited), use the all_members attribute. If you want to access only declared members, use the members attribute.

Accessing the attributes, functions, classes, type_aliases or modules attributes will trigger inheritance computation, so make sure to only access them once everything is loaded by Griffe. Don't try to access inherited members in extensions, while visiting or inspecting modules.

#### Limitations

Currently, there are three limitations to our class inheritance support:

1. when visiting (static analysis), some objects are not yet properly recognized as classes, for example named tuples. If you inherit from a named tuple, its members won't be added to the inherited members of the inheriting class.

   ```
   MyTuple = namedtuple("MyTuple", "attr1 attr2")


   class MyClass(MyTuple):
       ...
   ```

1. when visiting (static analysis), subclasses using the same name as one of their parent classes will prevent Griffe from computing the MRO and therefore the inherited members. To circumvent that, give a different name to your subclass:

   ```
   from package import SomeClass


   # instead of
   class SomeClass(SomeClass):
       ...


   # do
   class SomeOtherClass(SomeClass):
       ...
   ```

1. when inspecting (dynamic analysis), ephemeral base classes won't be resolved, and therefore their members won't appear in child classes. To circumvent that, assign these dynamic classes to variables:

   ```
   # instead of
   class MyClass(namedtuple("MyTuple", "attr1 attr2")):
       ...


   # do
   MyTuple = namedtuple("MyTuple", "attr1 attr2")


   class MyClass(MyTuple):
       ...
   ```

We will try to lift these limitations in the future.

## Aliases

Aliases represent indirections, such as objects imported from elsewhere, attributes, or methods inherited from parent classes. They are pointers to the object they represent. The path of the object they represent is stored in their target_path attribute. Once they are resolved, the target object can be accessed through their target attribute.

Aliases can be found in objects' members. Each object can also access its own aliases (the aliases pointing at it) through its aliases attribute. This attribute is a dictionary whose keys are the aliases paths and values are the aliases themselves.

Most of the time, aliases simply act as proxies to their target objects. For example, accessing the `docstring` of an alias will simply return the docstring of the object it targets.

Accessing fields on aliases will trigger their resolution. If they are already resolved (their `target` attribute is set to the target object), the field is returned. If they are not resolved, their target path will be looked up in the modules collection, and if it is found, the object at this location will be assigned to the alias' `target` attribute. If it isn't found, an AliasResolutionError exception will be raised.

Since merely accessing an alias field can raise an exception, it is often useful to check if an object is an alias before accessing its fields. There are multiple ways to check if an object is an alias:

- using the `is_alias` boolean (Object.is_alias, Alias.is_alias), which won't trigger resolution
- using `isinstance` to check if the object is an instance of Alias

```
>>> import griffe
>>> load = griffe.load("griffe.load")
>>> load.is_alias
True
>>> isinstance(load, griffe.Alias)
True
```

The kind of an alias will only return ALIAS if the alias is not resolved and cannot be resolved within the current modules collection.

You can of course also catch any raised exception with a regular try/except block:

```
try:
    print(obj.source)
except griffe.AliasResolutionError:
    pass
```

To check if an alias is already resolved, you can use its resolved attribute.

### Alias chains

Aliases can be chained. For example, if module `a` imports `X` from module `b`, which itself imports `X` from module `c`, then `a.X` is an alias to `b.X` which is an alias to `c.X`: `a.X` -> `b.X` -> `c.X`. To access the final target directly, you can use the final_target attribute. Most alias properties that act like proxies actually fetch the final target rather than the next one to return the final field.

Sometimes, when a package makes use of complicated imports (wildcard imports from parents and submodules), or when runtime objects are hard to inspect, it is possible to end up with a cyclic chain of aliases. You could for example end up with a chain like `a.X` -> `b.X` -> `c.X` -> `a.X`. In this case, the alias *cannot* be resolved, since the chain goes in a loop. Griffe will raise a CyclicAliasError when trying to resolve such cyclic chains.

Aliases chains are never partially resolved: either they are resolved down to their final target, or none of their links are resolved.

## Object kind

The kind of an object (module, class, function, attribute, type alias or alias) can be obtained in several ways.

- With the kind attribute and the Kind enumeration: `obj.kind is Kind.MODULE`.

- With the is_kind() method:

  - `obj.is_kind(Kind.MODULE)`
  - `obj.is_kind("class")`
  - `obj.is_kind({"function", Kind.ATTRIBUTE})`

  When given a set of kinds, the method returns true if the object is of one of the given kinds.

- With the is_module, is_class, is_function, is_attribute, is_type_alias, and is_alias attributes.

Additionally, it is possible to check if an object is a sub-kind of module, with the following attributes:

- is_init_module, for `__init__.py` modules
- is_package, for top-level packages
- is_subpackage, for non-top-level packages
- is_namespace_package, for top-level [namespace packages](https://packaging.python.org/en/latest/guides/packaging-namespace-packages/)
- is_namespace_subpackage, for non-top-level namespace packages

Finally, additional labels are attached to objects to further specify their kind. The has_labels() method can be used to check if an object has several specific labels.

## Object location

An object is identified by its path, which is its location in the object tree. The path is composed of all the parent names and the object name, separated by dots, for example `mod.Class.meth`. This `path` is the canonical_path on regular objects. For aliases however, the `path` is *where they are imported* while the canonical path is *where they come from*. Example:

```
# pkg1.py
from pkg2 import A as B
```

```
>>> import griffe
>>> B = griffe.load("pkg1.B")
>>> B.path
'pkg1.B'
>>> B.canonical_path
'pkg2.A'
```

### Source

Information on the actual source code of objects is available through the following attributes:

- filepath, the absolute path to the module the object appears in, for example `~/project/src/pkg/mod.py`
- relative_filepath, the relative path to the module, compared to the current working directory, for example `src/pkg/mod.py`
- relative_package_filepath, the relative path to the module, compared to the parent of the top-level package, for example `pkg/mod.py`
- lineno and endlineno, the starting and ending line numbers of the object in the source
- lines, the lines of code defining the object (or importing the alias)
- source, the source lines concatenated as a single multiline string

Each object holds a reference to a lines_collection. Similar to the modules collection, this lines collection is a dictionary whose keys are module file-paths and values are their contents as list of lines. The lines collection is populated by the loader.

## Object visibility

Each object has fields that are related to their visibility within the API.

- is_public: whether this object is public (destined to be consumed by your users). For module-level objects, Griffe considers that the object is public if:

  - it is listed in its parent module's `__all__` attribute
  - or if its parent module does not declare `__all__`, and the object doesn't have a private name, and the object is not imported from elsewhere

  ```
  # package1/__init__.py
  from package2 import A  # not public
  from package1 import submodule  # not public

  b = 0  # public
  _c = 1  # not public
  __d = 2  # not public

  def __getattr__(name: str):  # public
      ...
  ```

  For class-level objects, Griffe considers that the object is public if the object doesn't have a private name, and the object is not imported from elsewhere.

  ```
  # package1/__init__.py
  class A:
      from package1.module import X  # not public
      from package2 import Y  # not public

      b = 0  # public
      _c = 1  # not public
      __d = 2  # not public

      def __eq__(self, other):  # public
          ...
  ```

- is_deprecated: whether this object is deprecated and shouldn't be used.

- is_special: whether this object has a special name like `__special__`

- is_private: whether this object has a private name like `_private` or `__private`, but not `__special__`

- is_class_private: whether this object has a class-private name like `__private` and is a member of a class

Since `is_private` only checks the name of the object, it is not mutually exclusive with `is_public`. It means an object can return true for both `is_public` and `is_private`. We invite Griffe users to mostly rely on `is_public` and `not is_public`.

It is possible to force `is_public` and `is_deprecated` to return true or false by setting the public and deprecated fields respectively. These fields are typically set by extensions that support new ways of marking objects as public or deprecated.

## Imports/exports

Modules and classes populate their imports field with names that were imported from other modules. Similarly, modules populate their exports field with names that were exported by being listed into the module's `__all__` attribute. Each object then provides then is_imported and is_exported fields, which tell if an object was imported or exported respectively. Additionally, objects also provide an is_wildcard_exposed field that tells if an object is exposed to wildcard imports, i.e. will be imported when another module does `from this_module import *`.

## Docstrings

Each object has an optional docstring attached to it. To check whether it has one without comparing against `None`, the two following fields can be used:

- has_docstring: whether this object has a docstring (even empty)
- has_docstrings: same thing, but recursive; whether this object or any of its members has a docstring (even empty)

Docstrings provide their cleaned-up value (de-indented string, stripped from leading and trailing newlines), as well as their starting and ending line numbers with lineno and endlineno.

Docstrings can be parsed against several [docstring-styles](../../../reference/docstrings/), which are micro-formats that allow documenting things such as parameters, returned values, raised exceptions, etc..

When loading a package, it is possible to specify the docstring style to attach to every docstring (see the `docstring_parser` parameter of griffe.load). Accessing the parsed field of a docstring will use this style to parse the docstring and return a list of docstring sections. Each section has a `value` whose shape depends on the section kind. For example, parameter sections have a list of parameter representations as value, while a text section only has a string as value.

After a package is loaded, it is still possible to change the style used for specific docstrings by either overriding their parser and parser_options attributes, or by calling their parse() method with a different style:

```
>>> import griffe
>>> markdown = griffe.load("markdown", docstring_parser="google")
>>> markdown["Markdown"].docstring.parse("numpy")
[...]
```

Do note, however, that the `parsed` attribute is cached, and won't be reset when overriding the `parser` or `parser_options` values.

Docstrings have a parent field too, that is a reference to their respective module, class, function, attribute or type alias.

## Model-specific fields

Models have most fields in common, but also have specific fields.

### Modules

- imports_future_annotations: Whether the module imports [future annotations](https://peps.python.org/pep-0563/), which changes the way we parse type annotations.
- overloads: A dictionary to store overloads for module-level functions.

### Classes

- bases: A list of class bases in the form of expressions.
- resolved_bases: A list of class bases, in the form of Class objects. Only the bases that were loaded are returned, the others are discarded.
- mro(): A method to compute the Method Resolution Order in the form of a list of Class objects.
- overloads: A dictionary to store overloads for class-level methods.
- decorators: The decorators applied to the class.
- parameters: The parameters of the class' `__init__` method, if any.
- type_parameters: The type parameters of the class.

### Functions

- decorators: The decorators applied to the function.
- overloads: The overloaded signatures of the function.
- parameters: The parameters of the function.
- returns: The type annotation of the returned value, in the form of an expression. The `annotation` field can also be used, for compatibility with attributes.
- type_parameters: The type parameters of the function.

### Attributes

- annotation: The type annotation of the attribute, in the form of an expression.
- value: The value of the attribute, in the form of an expression.
- deleter: The property deleter.
- setter: The property setter.

### Type aliases

- value: The value of the type alias, in the form of an expression.
- type_parameters: The type parameters of the type alias.

### Alias

- alias_lineno: The alias line number (where the object is imported).
- alias_endlineno: The alias ending line number (where the object is imported).
- target: The alias target (a module, class, function or attribute).
- target_path: The path of the alias target, as a string.
- wildcard: Whether this alias represents a wildcard import, and if so from which module.
- resolve_target(): A method that resolves the target when called.

## Expressions

When parsing source code, Griffe builds enhanced ASTs for type annotations, decorators, parameter defaults, attribute values, etc.

These "expressions" are very similar to what Python's ast module gives you back when parsing source code, with a few differences: attributes like `a.b.c.` are flattened, and names like `a` have a parent object attached to them, a Griffe object, allowing to resolve this name to its full path given the scope of its parent.

You can write some code below and print annotations or attribute values with [Rich](https://rich.readthedocs.io/en/stable/)'s pretty printer to see how expressions look like.

Editor (session: default) Run

```
from griffe import temporary_visited_module
from rich.pretty import pprint

code = """
    from dataclasses import dataclass
    from random import randint

    @dataclass
    class Bar:
        baz: int

    def get_some_baz() -> int:
        return randint(0, 10)

    foo: Bar = Bar(baz=get_some_baz())
"""

with temporary_visited_module(code) as module:
    pprint(module["foo"].annotation)
    pprint(module["foo"].value)
```

Output Clear

Ultimately, these expressions are what allow downstream tools such as [mkdocstrings' Python handler](https://mkdocstrings.github.io/python) to render cross-references to every object it knows of, coming from the current code base or loaded from object inventories (objects.inv files).

During static analysis, these expressions also allow analyzing decorators, dataclass fields, and many more things in great detail, and in a robust manner, to build third-party libraries support in the form of [Griffe extensions](../extending/).

To learn more about expressions, read their [API reference](../../../reference/api/expressions/).

### Modernization

The Python language keeps evolving, and often library developers must continue supporting a few minor versions of Python. Therefore they cannot use some features that were introduced in the latest versions.

Yet this doesn't mean they can't enjoy latest features in their own docs: Griffe allows to "modernize" expressions, for example by replacing `typing.Union` with PEP 604 type unions `|`. Thanks to this, downstream tools like [mkdocstrings](https://mkdocstrings.github.io/python) can automatically transform type annotations into their modern equivalent. This improves consistency in your docs, and shows users how to use your code with the latest features of the language.

To modernize an expression, simply call its modernize() method. It returns a new, modernized expression. Some parts of the expression might be left unchanged, so be careful if you decide to mutate them.

Modernizations applied:

- `typing.Dict[A, B]` becomes `dict[A, B]`
- `typing.List[A]` becomes `list[A]`
- `typing.Set[A]` becomes `set[A]`
- `typing.Tuple[A]` becomes `tuple[A]`
- `typing.Union[A, B]` becomes `A | B`
- `typing.Optional[A]` becomes `A | None`

## Next steps

In this chapter we saw many of the fields that compose our models, and how and why to use them. Now you might be interested in [extending](../extending/) or [serializing](../serializing/) the API data, or [checking for API breaking changes](../checking/).

# Serializing APIs

Griffe can be used to load API data and output it as JSON on standard output or in writable files. An example of what real data looks like can be found here: [Griffe's full JSON dump](../../../griffe.json). We also provide a [JSON schema](../../../schema.json).

## Command-line

The easiest way to load and serialize API data is to use the command-line tool:

```
$ griffe dump httpx fastapi
{
  "httpx": {
    "name": "httpx",
    ...
  },
  "fastapi": {
    "name": "fastapi",
    ...
  }
}
```

It will output a JSON-serialized version of the package's API data.

Try it out on Griffe itself:

```
$ griffe dump griffe
{
  "griffe": {
    "name": "griffe",
    ...
  }
}
```

To output in a file instead of standard output, use the `-o`, `--output` option:

```
$ griffe dump griffe -o griffe.json
```

If you load multiple packages' signatures, you can dump each in its own file with a templated filepath:

```
$ griffe dump griffe -o './dumps/{package}.json'
```

By default, Griffe will search in `sys.path`, so if you installed it through *pipx*, there are few chances it will find your packages. To explicitly specify search paths, use the `-s, --search <PATH>` option. You can use it multiple times. You can also add the search paths to the `PYTHONPATH` environment variable. If Griffe can't find the packages, it will fail with a `ModuleNotFoundError`.

See all the options for the `dump` command in the [CLI reference](../../../reference/cli/).

## Python API

If you have read through the [Navigating](../navigating/) chapter, you know about our six data models for modules, classes, functions, attributes, type aliases and aliases. Each one of these model provide the two following methods:

- as_json, which allows to serialize an object into JSON,
- from_json, which allows loading JSON back into a model instance.

These two methods are convenient wrappers around our JSON encoder and JSON decoder. The JSON encoder and decoder will give you finer-grain control over what you serialize or load, as the methods above are only available on data models, and not on sub-structures like decorators or parameters.

Under the hood, `as_json` just calls as_dict, which converts the model instance into a dictionary, and then serializes this dictionary to JSON.

When serializing an object, by default the JSON will only contain the fields required to load it back to a Griffe model instance. If you are not planning on loading back the data into our data models, or if you want to load them in a different implementation which is not able to infer back all the other fields, you can choose to serialize every possible field. We call this a full dump, and it is enabled with the `full` option of the encoder or the as_json method.

## Schema

For anything automated, we suggest relying on our [JSON schema](../../../schema.json).

When serializing multiple packages with the `dump` command, you get a map with package names as keys. Map values are the serialized objects (modules, classes, functions, etc.). They are maps too, with field names and values as key-value pairs.

For example:

```
{
  "kind": "class",
  "name": "Expr",
  "lineno": 82,
  "endlineno": 171,
  "docstring": {
    "value": "Base class for expressions.",
    "lineno": 84,
    "endlineno": 84
  },
  "labels": [
    "dataclass"
  ],
  "members": [
    ...
  ],
  "bases": [],
  "decorators": [
    {
      "value": {
        "name": "dataclass",
        "cls": "ExprName"
      },
      "lineno": 82,
      "endlineno": 82
    }
  ]
}
```

The `members` value, truncated here, just repeats the pattern: it's an array of maps. We use an array for members instead of a map to preserve order, which could be important to downstream tools.

The other fields do not require explanations, except maybe for expressions. You will sometimes notice deeply nested structures with `cls` keys. These are serialized Griffe [expressions](../../../reference/api/expressions/). They represent actual code.

## Next steps

That's it! There is not much to say about serialization. We are interested in getting your feedback regarding serialization as we didn't see it being used a lot. Next you might be interested in learning how to [check](../checking/) or [extend](../extending/) your API data.

# Checking APIs

Griffe is able to compare two snapshots of your project to detect API breakages between the old and the new snapshot. By snapshot we mean a specific point in your Git history. For example, you can ask Griffe to compare your current code against a specific tag.

## Command-line

### Using Git

By default, Griffe will compare the current code to the latest tag:

```
$ griffe check mypackage
```

To specify another Git reference to check against, use the `--against` or `-a` option:

```
$ griffe check mypackage -a 0.2.0
```

You can specify a Git tag, commit (hash), or even a branch: Griffe will create a worktree at this reference in a temporary directory, and clean it up after finishing.

If you want to also specify the *base* reference to use (instead of the current code), use the `--base` or `-b` option. Some examples:

```
$ griffe check mypackage -b HEAD -a 2.0.0
$ griffe check mypackage -b 2.0.0 -a 1.0.0
$ griffe check mypackage -b fix-issue-90 -a 1.2.3
$ griffe check mypackage -b 8afcfd6e
```

Important:

Remember that the base is the most recent reference, and the one we compare it against is the oldest one.

The package name you pass to `griffe check` must be found relative to the repository root. For Griffe to find packages in subfolders, pass the parent subfolder to the `--search` or `-s` option. Example for `src`-layouts:

```
$ griffe check -s src griffe
```

Example in a monorepo, within a deeper file tree:

```
$ griffe check -s back/services/identity-provider/src identity_provider
```

### Using PyPI

It's also possible to directly **check packages from PyPI.org** (or other indexes configured through `PIP_INDEX_URL`). This feature requires that you install Griffe with the `pypi` extra:

```
$ pip install griffe[pypi]
```

The command syntax is:

```
$ griffe check package_name -b project-name==2.0 -a project-name==1.0
```

You can let Griffe guess the package name by passing an empty string:

```
$ griffe check "" -b project-name==2.0 -a project-name==1.0
```

[PEP 508 version specifiers](https://peps.python.org/pep-0508/) are supported (`<`, `<=`, `!=`, `==`, `>=`, `>`, `~=`). For example, to compare v2 against the version just before it:

```
$ griffe check "" -b project-name==2.0 -a project-name<2.0
```

Without a version specifier on the base reference, or without a base reference at all, Griffe will use the latest available version. The two following commands compare the latest version against v1:

```
$ griffe check "" -b project-name -a project-name==1.0
$ griffe check "" -a project-name==1.0
```

Griffe will actually install packages in a cache directory. It means a few things: source distributions are supported, and only packages that are compatible with your current environment can be checked.

## Python API

To programmatically check for API breaking changes, you have to load two snapshots of your code base, for example using our load_git() utility, and then passing them both to the find_breaking_changes() function. This function will yield instances of Breakage. It's up to you how you want to use these breakage instances.

```
import griffe

my_pkg_v1 = griffe.load_git("my_pkg", ref="v1")
my_pkg_v2 = griffe.load_git("my_pkg", ref="v2")

for breaking_change in find_breaking_changes(my_pkg_v1, my_pkg_v2):
    print(breaking_change.explain())
```

## In CI

It is of course possible to Griffe in CI (Continuous Integration) to make sure no breaking changes are introduced in pull/merge requests.

### GitHub

Here is a quick example on how to use Griffe in a GitHub workflow:

```
jobs:
  check-api:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5
        with:
          fetch-depth: 0  # We the need the full Git history.
    - uses: astral-sh/setup-uv@v6
    # The following command will compare current changes to latest tag.
    - run: uvx griffe check --search src --format github your_package_name
```

The last step will fail the workflow if any breaking change is found.

## Detected breakages

In this section, we will describe the breakages that Griffe detects, giving some code examples and hints on how to properly communicate breakages with deprecation messages before actually releasing them.

Obviously, these explanations and the value of the hints we provide depend on your definition of what is a public Python API. There is no clear and generally agreed upon definition of "public Python API". A public Python API might vary from one project to another. In essence, your public API is what you say it is.

However, we do have conventions like prefixing objects with an underscore to tell users these objects are part of the private API, or internals, and therefore should not be used. For the rest, Griffe can detect changes that *will* trigger immediate errors in your users code', and changes that *might* cause issues in your users' code. Although the latter sound less impactful, they do have a serious impact, because they can *silently* change the behavior of your users' code, leading to issues that are hard to detect, understand and fix.

[Knowing that every change is a breaking change](https://xkcd.com/1172/), the more we detect and document (potentially) breaking changes in our changelogs, the better.

### Parameter moved

> Positional parameter was moved.

Moving the order of positional parameters can *silently* break your users' code.

before

```
# your code
def greet(prefix, name):
    print(prefix + " " + name)

# user's code
greet("hello", "world")
```

after

```
# your code
def greet(name, prefix):
    print(prefix + " " + name)

# user's code: no immediate error, broken behavior
greet("hello", "world")
```

Note

Moving required parameters around is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. The function expects a number of arguments, and the developer passes it this same number of arguments: the contract is fulfilled. But parameters very often have specific meaning, and changing their order will *silently lead* (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

Hint

If you often add, move or remove parameters, consider making them keyword-only, so that their order doesn't matter.

before

```
def greet(*, prefix, name):
    print(prefix + " " + name)

greet(prefix="hello", name="world")
```

after

```
def greet(*, name, prefix):
    print(prefix + " " + name)

# still working as expected
greet(prefix="hello", name="world")
```

### Parameter removed

> Parameter was removed.

Removing a parameter can immediately break your users' code.

before

```
# your code
def greet(prefix, name):
    print(prefix + " " + name)

# user's code
greet("hello", "world")
```

after

```
# your code
def greet(name):
    print("hello " + name)

# user's code: immediate error
greet("hello", "world")

# even with keyword parameters: immediate error
greet(prefix="hello", name="world")
```

Hint

Allow a deprecation period for the removed parameter by swallowing it in a variadic positional parameter, a variadic keyword parameter, or both.

before

```
# your parameters are positional-only parameters (difficult deprecation)
def greet(prefix, name, /):
    print(prefix + " " + name)

greet("hello", "world")
```

after

```
# swallow prefix using a variadic positional parameter
def greet(*args):
    if len(args) == 2:
        prefix, name = args
    elif len(args) == 1:
        prefix = None
        name = args[0]
    else:
        raise ValueError("missing parameter 'name'")
    if prefix is not None:
        warnings.warn(DeprecationWarning, "prefix is deprecated")
    print("hello " + name)

# still working as expected
greet("hello", "world")
```

before

```
# your parameters are keyword-only parameters (easy deprecation)
def greet(*, prefix, name):
    print(prefix + " " + name)

greet(prefix="hello", name="world")
```

after

```
# swallow prefix using a variadic keyword parameter
def greet(name, **kwargs):
    prefix = kwargs.get("prefix", None)
    if prefix is not None:
        warnings.warn(DeprecationWarning, "prefix is deprecated")
    print("hello " + name)

# still working as expected
greet(prefix="hello", name="world")
```

before

```
# your parameters are positional or keyword parameters (very difficult deprecation)
def greet(prefix, name):
    print(prefix + " " + name)

greet("hello", name="world")
```

after

```
# no other choice than swallowing both forms...
# ignoring the deprecated parameter becomes quite complex
def greet(*args, **kwargs):
    if len(args) == 2:
        prefix, name = args
    elif len(args) == 1:
        prefix = None
        name = args[0]
    if "name" in kwargs:
        name = kwargs["name"]
    if "prefix" in kwargs:
        prefix = kwargs["prefix"]
    if prefix is not None:
        warnings.warn(DeprecationWarning, "prefix is deprecated")
    print("hello " + name)

# still working as expected
greet("hello", "world")
greet("hello", name="world")
greet(prefix="hello", name="world")
```

### Parameter changed kind

> Parameter kind was changed

Changing the kind of a parameter to another (positional-only, keyword-only, positional or keyword, variadic positional, variadic keyword) can immediately break your users' code.

before

```
# your code
def greet(name):
    print("hello " + name)

def greet2(name):
    print("hello " + name)

# user's code: all working fine
greet("tim")
greet(name="tim")
greet2("tim")
greet2(name="tim")
```

after

```
# your code
def greet(name, /):
    print("hello " + name)

def greet2(*, name):
    print("hello " + name)

# user's code: working as expected
greet("tim")
greet2(name="tim")

# immediate error
greet(name="tim")
greet2("tim")
```

Hint

Although it actually is a breaking change, changing your positional or keyword parameters' kind to keyword-only makes your public function more robust to future changes (forward-compatibility).

For functions with lots of optional parameters, and a few (one or two) required parameters, it can be a good idea to accept the required parameters as positional or keyword, while accepting the optional parameters as keyword-only parameters:

```
def greet(name, *, punctuation=False, bold=False, italic=False):
    ...

# simple cases are easy to write
greet("tim")
greet("tiff")

# complex cases are never ambiguous
greet("tim", italic=True, bold=True)
greet(name="tiff", bold=True, punctuation=True)
```

Positional-only parameters are useful in some specific cases, such as when a function takes two or more numeric values, and their order does not matter, and naming the parameters would not make sense:

```
def multiply3(a, b, c, /):
    return a * b * c

# all the following are equivalent
multiply3(4, 2, 3)
multiply3(4, 3, 2)
multiply3(2, 3, 4)
# etc.
```

### Parameter changed default

> Parameter default was changed

Changing the default value of a parameter can *silently* break your users' code.

before

```
# your code
def compute_something(value: int, to_float=True):
    value = ...
    if to_float:
        return float(value)
    return value

# user's code: condition is entered
if isinstance(compute_something(7), float):
    ...
```

after

```
# your code
def compute_something(value: int, to_float=False):
    value = ...
    if to_float:
        return float(value)
    return value

# user's code: condition is not entered anymore
if isinstance(compute_something(7), float):
    ...
```

Note

Changing default value of parameters is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. Not using the parameter still provides the argument with a default value: the contract is fulfilled. But default values very often have specific meaning, and changing them will *silently lead* (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

Hint

Allow a deprecation period for the old default value by using a sentinel value to detect when the parameter wasn't used by the user:

in the coming release

```
_sentinel = object()

def compute_something(value: int, to_float=_sentinel):
    value = ...
    if to_float is _sentinel:
        to_float = True
        warnings.warn(
            DeprecationWarning,
            "default value of 'to_float' will change from True to False, "
            "please provide 'to_float=True' if you want to retain the current behavior"
        )
    if to_float:
        return float(value)
    return value
```

In a later release you can remove the sentinel, the deprecation warning, and set `False` as default to `to_float`.

in a later release

```
def compute_something(value: int, to_float=False):
    value = ...
    if to_float:
        return float(value)
    return value
```

### Parameter changed required

> Parameter is now required

Changing an optional parameter to a required one (by removing its default value) can immediately break your users' code.

before

```
# your code
def greet(name, prefix="hello"):
    print(prefix + " " + name)

# user's code
greet("tiff")
```

after

```
# your code
def greet(name, prefix):
    print(prefix + " " + name)

# user's code: immediate error
greet("tiff")
```

Hint

Allow a deprecation period for the default value by using a sentinel value to detect when the parameter wasn't used by the user:

in the coming release

```
_sentinel = object()

def greet(name, prefix=_sentinel):
    if prefix is _sentinel:
        prefix = "hello"
        warnings.warn(DeprecationWarning, "'prefix' will become required in the next release")
    print(prefix + " " + name)
```

In a later release you can remove the sentinel, the deprecation warning, and the default value of `prefix`.

in a later release

```
def greet(name, prefix):
    print(prefix + " " + name)
```

### Parameter added required

> Parameter was added as required

Adding a new, required parameter can immediately break your users' code.

before

```
# your code
def greet(name):
    print("hello " + name)

# user's code
greet("tiff")
```

after

```
# your code
def greet(name, prefix):
    print(prefix + " " + name)

# user's code: immediate error
greet("tiff")
```

Hint

You can delay (or avoid) and inform your users about the upcoming breakage by temporarily (or permanently) providing a default value for the new parameter:

in the coming release

```
def greet(name, prefix="hello"):
    print(prefix + " " + name)
```

### Return changed type

> Return types are incompatible

Not yet supported!

Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.

### Object removed

> Public object was removed

Removing a public object from a module can immediately break your users' code.

before

```
# your/module.py
special_thing = "hey"

# user/module.py
from your.module import special_thing

# other/user/module.py
from your import module
print(module.special_thing)
```

after

```
# user/module.py: import error
from your.module import special_thing

# other/user/module.py: attribute error
from your import module
print(module.special_thing)
```

Hint

Allow a deprecation period by declaring a module-level `__getattr__` function that returns the given object while warning about its deprecation:

```
def __getattr__(name):
    if name == "special_thing":
        warnings.warn(DeprecationWarning, "'special_thing' is deprecated and will be removed")
        return "hey"
```

### Object changed kind

> Public object points to a different kind of object

Changing the kind (type alias, attribute, function, class, module) of a public object can *silently* break your users' code.

before

```
# your code
class Factory:
    def __call__(self, ...):
        ...

factory = Factory(...)

# user's code: condition is entered
if isinstance(factory, Factory):
    ...
```

after

```
# your code
class Factory:
    ...

def factory(...):
    ...

# user's code: condition is not entered anymore
if isinstance(factory, Factory):
    ...
```

Note

Changing the kind of an object is not really an API breakage, depending on our definition of API, since this won't always raise immediate errors like `TypeError`. The object is still here and accessed: the contract is fulfilled. But developers sometimes rely on the kind of an object, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

### Attribute changed type

> Attribute types are incompatible

Not yet supported!

Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.

### Attribute changed value

> Attribute value was changed

Changing the value of an attribute can *silently* break your users' code.

before

```
# your code
PY_VERSION = os.getenv("PY_VERSION")

# user's code: condition is entered
if PY_VERSION is None:
    ...
```

after

```
# your code
PY_VERSION = os.getenv("PY_VERSION", "3.8")

# user's code: condition is not entered anymore
if PY_VERSION is None:
    ...
```

Note

Changing the value of an attribute is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. The attribute is still here and accessed: the contract is fulfilled. But developers heavily rely on the value of public attributes, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

Hint

Make sure to document the change of value of the attribute in your changelog, particularly the previous and new range of values it can take.

### Class removed base

> Base class was removed

Removing a class from another class' bases can *silently* break your users' code.

before

```
# your code
class A: ...
class B: ...
class C(A, B): ...

# user's code: condition is entered
if B in klass.__bases__:
    ...
```

after

```
# your code
class A: ...
class B: ...
class C(A): ...

# user's code: condition is not entered anymore
if B in klass.__bases__:
    ...
```

Note

Unless inherited members are lost in the process, removing a class base is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. The class is here, its members as well: the contract is fulfilled. But developers sometimes rely on the actual bases of a class, so changing them will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

## Output style

Griffe supports writing detected breakages in multiple formats, or styles.

### One-line

- **CLI**: `-f oneline` / no flags
- **API**: `check(...)` / `check(..., style="oneline")` / `check(..., style=ExplanationStyle.ONE_LINE)`

This is the default format. Griffe will print each detected breakage on a single line:

```
$ griffe check griffe -ssrc -b0.46.0 -a0.45.0
src/griffe/mixins.py:303: ObjectAliasMixin.is_exported: Public object points to a different kind of object: function -> attribute
src/griffe/mixins.py:353: ObjectAliasMixin.is_public: Public object points to a different kind of object: function -> attribute
src/griffe/dataclasses.py:520: Object.has_labels(labels): Parameter kind was changed: positional or keyword -> variadic positional
src/griffe/diff.py:535: find_breaking_changes(ignore_private): Parameter default was changed: True -> _sentinel
src/griffe/extensions/base.py:463: load_extensions(exts): Parameter kind was changed: positional or keyword -> variadic positional
src/griffe/dataclasses.py:1073: Alias.has_labels(labels): Parameter kind was changed: positional or keyword -> variadic positional
```

### Verbose

- **CLI**: `-f verbose` / `-v`
- **API**: `check(..., style="verbose")` / `check(..., style=ExplanationStyle.VERBOSE)` / `check(..., verbose=True)`

Depending on the detected breakages, the lines might be hard to read (being too compact), so `griffe check` also accepts a `--verbose` or `-v` option to add some space to the output:

```
$ griffe check griffe -ssrc -b0.46.0 -a0.45.0 --verbose
src/griffe/mixins.py:303: ObjectAliasMixin.is_exported:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/mixins.py:353: ObjectAliasMixin.is_public:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/dataclasses.py:520: Object.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/diff.py:535: find_breaking_changes(ignore_private):
Parameter default was changed:
  Old: True
  New: _sentinel

src/griffe/extensions/base.py:463: load_extensions(exts):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/dataclasses.py:1073: Alias.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional
```

### Markdown

- **CLI**: `-f markdown`
- **API**: `check(..., style="markdown")` / `check(..., style=ExplanationStyle.MARKDOWN)`

The Markdown format is adapted for changelogs. It doesn't show the file and line number, and instead prints out the complete path of your API objects. With a bit of automation, you will be able to automatically insert a summary of breaking changes in your changelog entries.

```
- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(max_iterations)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_exported)`: *Parameter was removed*
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_known_modules)`: *Parameter was removed*
- `griffe.git.tmp_worktree(commit)`: *Parameter was removed*
- `griffe.git.tmp_worktree(repo)`: *Positional parameter was moved*: position: from 2 to 1 (-1)
- `griffe.git.load_git(commit)`: *Parameter was removed*
- `griffe.git.load_git(repo)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(submodules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(try_relative_path)`: *Parameter was removed*
- `griffe.git.load_git(extensions)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(search_paths)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_parser)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_options)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(lines_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(modules_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(allow_inspection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
```

- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(max_iterations)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_exported)`: *Parameter was removed*
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_known_modules)`: *Parameter was removed*
- `griffe.git.tmp_worktree(commit)`: *Parameter was removed*
- `griffe.git.tmp_worktree(repo)`: *Positional parameter was moved*: position: from 2 to 1 (-1)
- `griffe.git.load_git(commit)`: *Parameter was removed*
- `griffe.git.load_git(repo)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(submodules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(try_relative_path)`: *Parameter was removed*
- `griffe.git.load_git(extensions)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(search_paths)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_parser)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_options)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(lines_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(modules_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(allow_inspection)`: *Parameter kind was changed*: positional or keyword -> keyword-only

### GitHub

- **CLI**: `-f github`
- **API**: `check(..., style="github")` / `check(..., style=ExplanationStyle.GITHUB)`

When running `griffe check` in CI, you can enable GitHub's annotations thanks to the GitHub output style. Annotations are displayed on specific lines of code. They are visible in the Checks tab. When you create an annotation for a file that is part of the pull request, the annotations are also shown in the Files changed tab.

```
% python -m griffe check -fgithub -ssrc griffe
::warning file=src/griffe/finder.py,line=58,title=Package.name::Attribute value was changed: `name` -> unset
::warning file=src/griffe/finder.py,line=60,title=Package.path::Attribute value was changed: `path` -> unset
::warning file=src/griffe/finder.py,line=62,title=Package.stubs::Attribute value was changed: `stubs` -> `None`
::warning file=src/griffe/finder.py,line=75,title=NamespacePackage.name::Attribute value was changed: `name` -> unset
::warning file=src/griffe/finder.py,line=77,title=NamespacePackage.path::Attribute value was changed: `path` -> unset
```

## Next steps

If you are using a third-party library to mark objects as public, or if you follow conventions different than the one Griffe understands, you might get false-positives, or breaking changes could go undetected. In that case, you might be interested in [extending](../extending/) how Griffe loads API data to support these third-party libraries or other conventions.

# Extending APIs

Griffe has an extension system that can be used to enhance or customize the data that Griffe collects. Extensions are written in Python.

## Using extensions

Extensions can be specified both on the command-line (in the terminal), and programmatically (in Python).

### On the command-line

On the command-line, you can specify extensions to use with the `-e`, `--extensions` option. This option accepts a single positional argument which can take two forms:

- a comma-separated list of extensions
- a JSON list of extensions

Extensions can accept options: the comma-separated list does not allow to specify options, while the JSON list does. See examples below.

With both forms, each extension refers to one of these three things:

- the name of a built-in extension's module, for example `dynamic_docstrings` (this is just an example, this built-in extension does not exist)
- the Python dotted-path to a module containing one or more extensions, or to an extension directly, for example `package.module` and `package.module.ThisExtension`
- the file path to a Python script, and an optional extension name, separated by a colon, for example `scripts/griffe_exts.py` and `scripts/griffe_exts.py:ThisExtension`

The specified extension modules can contain more than one extension: Griffe will pick up and load every extension declared or imported within the modules. If options are specified for a module that contains multiple extensions, the same options will be passed to all the extensions, so extension writers must make sure that all extensions within a single module accept the same options. If they don't, Griffe will abort with an error.

To specify options in the JSON form, use a dictionary instead of a string: the dictionary's only key is the extension identifier (built-in name, Python path, file path) and its value is a dictionary of options.

Some examples:

```
griffe dump griffe -e pydantic,scripts/exts.py:DynamicDocstrings,griffe_attrs
```

```
griffe check --search src griffe -e '[
  {"pydantic": {"schema": true}},
  {
    "scripts/exts.py:DynamicDocstrings": {
      "paths": ["mypkg.mymod.myobj"]
    }
  },
  "griffe_attrs"
]'
```

In the above two examples, `pydantic` would be a built-in extension, `scripts/exts.py:DynamicDocstrings` the file path plus name of a local extension, and `griffe_attrs` the name of a third-party package that exposes one or more extensions.

### Programmatically

Within Python code, extensions can be specified with the `extensions` parameter of the GriffeLoader class or load function.

The parameter accepts an instance of the Extensions class. Such an instance is created with the help of the load_extensions function, which itself accepts a list of strings, dictionaries, extension classes and extension instances.

Strings and dictionaries are used the same way as [on the command-line](#on-the-command-line). Extension instances are used as such, and extension classes are instantiated without any options.

Example:

```
import griffe

from mypackage.extensions import ThisExtension, ThisOtherExtension

extensions = griffe.load_extensions(
    {"pydantic": {"schema": true}},
    {"scripts/exts.py:DynamicDocstrings": {"paths": ["mypkg.mymod.myobj"]}},
    "griffe_attrs",
    ThisExtension(option="value"),
    ThisOtherExtension,
)

data = griffe.load("mypackage", extensions=extensions)
```

### In MkDocs

MkDocs and its mkdocstrings plugin can be configured to use Griffe extensions:

mkdocs.yml

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - pydantic: {schema: true}
          - scripts/exts.py:DynamicDocstrings:
              paths: [mypkg.mymod.myobj]
          - griffe_attrs
```

The `extensions` key accepts a list that is passed to the load_extensions function. See [how to use extensions programmatically](#programmatically) to learn more.

## Writing extensions

In the next section we give a bit of context on how Griffe works, to show how extensions can integrate into the data collection process. Feel free to skip to the [Events and hooks](#events-and-hooks) section or the [Full example](#full-example) section if you'd prefer to see concrete examples first.

### How it works

To extract information from your Python sources, Griffe tries to build Abstract Syntax Trees by parsing the sources with ast utilities.

If the source code is not available (the modules are built-in or compiled), Griffe imports the modules and builds object trees instead.

Griffe then follows the [Visitor pattern](https://www.wikiwand.com/en/Visitor_pattern) to walk the tree and extract information. For ASTs, Griffe uses its Visitor agent and for object trees, it uses its Inspector agent.

Sometimes during the walk through the source or runtime objects, both the visitor and inspector agents will trigger events, called **analysis events**. These events can be hooked on by extensions to alter or enhance Griffe's behavior. Some hooks will be passed just the current node being visited, others will be passed both the node and an instance of an Object subclass, such as a Module, a Class, a Function, an Attribute, or a Type Alias. Extensions will therefore be able to modify these instances.

Once the Griffe tree for a given package has been fully constructed, Griffe will trigger a second set of events, called **load events**, by walking the tree again. **It is safer to use load events as they are triggered only once data is complete for a given package**, contrary to the analysis events which are triggered *while the Griffe tree is still being built*.

The following flow chart shows an example of an AST visit. The tree is simplified: actual trees have a lot more nodes like `if/elif/else` nodes, `try/except/else/finally` nodes, and many more.

```
flowchart TB
M(Module definition) --- C(Class definition) & F(Function definition)
C --- m(Function definition) & A(Variable assignment)
```

The following flow chart shows an example of an object tree inspection. The tree is simplified as well: many more types of objects are handled.

```
flowchart TB
M(Module) --- C(Class) & F(Function)
C --- m(Method) & A(Attribute)
```

For a more concrete example, let say that we visit (or inspect) an AST (or object tree) for a given module, and that this module contains a single class, which itself contains a single method:

- the agent (visitor or inspector) will walk through the tree by starting with the module node
- it will instantiate a Module, then walk through its members, continuing with the class node
- it will instantiate a Class, then walk through its members, continuing with the function node
- it will instantiate a Function
- then it will go back up and finish walking since there are no more nodes to walk through

Every time the agent enters a node, creates an object instance, or finishes handling members of an object, it will trigger an event.

The flow of events is drawn in the following flowchart:

```
flowchart TB
visit_mod{{enter module node}}
event_mod_node{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_node'><b><code style='color: var(--md-accent-fg-color)'>on_node</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_module_node'><b><code style='color: var(--md-accent-fg-color)'>on_module_node</code></b></a> event"}}
create_mod{{create module instance}}
event_mod_instance{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_instance'><b><code style='color: var(--md-accent-fg-color)'>on_instance</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_module_instance'><b><code style='color: var(--md-accent-fg-color)'>on_module_instance</code></b></a> event"}}
visit_mod_members{{visit module members}}
visit_cls{{enter class node}}
event_cls_node{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_node'><b><code style='color: var(--md-accent-fg-color)'>on_node</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_class_node'><b><code style='color: var(--md-accent-fg-color)'>on_class_node</code></b></a> event"}}
create_cls{{create class instance}}
event_cls_instance{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_instance'><b><code style='color: var(--md-accent-fg-color)'>on_instance</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_class_instance'><b><code style='color: var(--md-accent-fg-color)'>on_class_instance</code></b></a> event"}}
visit_cls_members{{visit class members}}
visit_func{{enter func node}}
event_func_node{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_node'><b><code style='color: var(--md-accent-fg-color)'>on_node</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_function_node'><b><code style='color: var(--md-accent-fg-color)'>on_function_node</code></b></a> event"}}
create_func{{create function instance}}
event_func_instance{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_instance'><b><code style='color: var(--md-accent-fg-color)'>on_instance</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_function_instance'><b><code style='color: var(--md-accent-fg-color)'>on_function_instance</code></b></a> event"}}
event_cls_members{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_members'><b><code style='color: var(--md-accent-fg-color)'>on_members</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_class_members'><b><code style='color: var(--md-accent-fg-color)'>on_class_members</code></b></a> event"}}
event_mod_members{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_members'><b><code style='color: var(--md-accent-fg-color)'>on_members</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_module_members'><b><code style='color: var(--md-accent-fg-color)'>on_module_members</code></b></a> event"}}

start{start} --> visit_mod
visit_mod --> event_mod_node
event_mod_node --> create_mod
create_mod --> event_mod_instance
event_mod_instance --> visit_mod_members
visit_mod_members --1--> visit_cls
visit_cls --> event_cls_node
event_cls_node --> create_cls
create_cls --> event_cls_instance
event_cls_instance --> visit_cls_members
visit_cls_members --1--> visit_func
visit_func --> event_func_node
event_func_node --> create_func
create_func --> event_func_instance
event_func_instance --> visit_cls_members
visit_cls_members --2--> event_cls_members
event_cls_members --> visit_mod_members
visit_mod_members --2--> event_mod_members
event_mod_members --> finish{finish}

class event_mod_node event
class event_mod_instance event
class event_cls_node event
class event_cls_instance event
class event_func_node event
class event_func_instance event
class event_cls_members event
class event_mod_members event
classDef event stroke:#3cc,stroke-width:2
```

Hopefully this flowchart gives you a pretty good idea of what happens when Griffe collects data from a Python module. The next section will explain in more details the different events that are triggered, and how to hook onto them in your extensions.

### Events and hooks

There are two kinds of events in Griffe: [**load events**](#load-events) and [**analysis events**](#analysis-events). Load events are scoped to the Griffe loader (triggered once a package is fully loaded). Analysis events are scoped to the visitor and inspector agents (triggered during static and dynamic analysis).

**Hooks** are methods that are called when a particular event is triggered. To target a specific event, the hook must be named after it. See [Extensions and hooks](#extensions-and-hooks).

#### Load events

**Load events** are triggered once the tree for a given package has been fully constructed.

There is 1 generic **load event**:

- on_object: The "on object" event is triggered on any kind of object (except for aliases and packages, so modules, classes, functions, attributes and type aliases), once the tree for the object's package has been fully constructed.

There are also specific **load events** for each object kind:

- on_module: The "on module" event is triggered on modules.
- on_class: The "on class" event is triggered on classes.
- on_function: The "on function" event is triggered on functions.
- on_attribute: The "on attribute" event is triggered on attributes.
- on_type_alias: The "on type alias" event is triggered on type aliases.
- on_alias: The "on alias" event is triggered on aliases (imported/inherited objects).
- on_package: The "on package" event is triggered on top-level modules (packages) only.

#### Analysis events

**Analysis events** are triggered while modules are being scanned (with static or dynamic analysis). Data is incomplete when these events are triggered, so we recommend only hooking onto these events if you know what you are doing. In doubt, prefer using **load events** above.

There are 3 generic **analysis events**:

- on_node: The "on node" events are triggered when the agent (visitor or inspector) starts handling a node in the tree (AST or object tree).
- on_instance: The "on instance" events are triggered when the agent just created an instance of Module, Class, Function, Attribute, or Type Alias, and added it as a member of its parent. The "on instance" event is **not** triggered when an Alias is created.
- on_members: The "on members" events are triggered when the agent just finished handling all the members of an object. Functions, attributes and type aliases do not have members, so there are no "on members" events for these kinds.

There are also specific **analysis events** for each object kind:

- on_module_node
- on_module_instance
- on_module_members
- on_class_node
- on_class_instance
- on_class_members
- on_function_node
- on_function_instance
- on_attribute_node
- on_attribute_instance
- on_type_alias_node
- on_type_alias_instance
- on_alias_instance

#### Extensions and hooks

**Extensions** are classes that inherit from Griffe's Extension base class and define some hooks as methods:

```
import griffe


class MyExtension(griffe.Extension):
    def on_object(
        self,
        *,
        obj: griffe.Object,
        loader: griffe.GriffeLoader,
        **kwargs,
    ) -> None:
        """Do something with `obj`."""
```

Hooks are always defined as methods of a class inheriting from Extension, never as standalone functions. IDEs should autocomplete the signature when you start typing `def` followed by a hook name.

Since hooks are declared in a class, feel free to also declare state variables (or any other variable) in the `__init__` method:

```
import ast
from griffe import Extension, Object, ObjectNode


class MyExtension(Extension):
    def __init__(self) -> None:
        super().__init__()
        self.state_thingy = "initial stuff"
        self.list_of_things = []

    def on_object(
        self,
        *,
        obj: griffe.Object,
        loader: griffe.GriffeLoader,
        **kwargs,
    ) -> None:
        """Do something with `obj`."""
```

### Static/dynamic support

Extensions can support both static and dynamic analysis of modules.

Objects have an `analysis` attribute whose value will be `"static"` if they were loaded using static analysis, or `"dynamic"` if they were loaded using dynamic analysis. If the value is `None`, it means the object was created manually (for example by another extension).

To support static analysis, dynamic analysis, or both in your load events, you can therefore check the value of the `analysis` attribute:

```
import griffe


class MyExtension(griffe.Extension):
    def on_object(self, *, obj: griffe.Object, **kwargs) -> None:
        """Do something with `obj`."""
        if obj.analysis == "static":
            ...  # Apply logic for static analysis.
        elif obj.analysis == "dynamic":
            ...  # Apply logic for dynamic analysis.
        else:
            ...  # Apply logic for manually built objects.
```

### Visiting trees

Extensions provide basic functionality to help you visit trees during analysis of the code:

- visit: call `self.visit(node)` to start visiting an abstract syntax tree.
- generic_visit: call `self.generic_visit(node)` to visit each subnode of a given node.
- inspect: call `self.inspect(node)` to start visiting an object tree. Nodes contain references to the runtime objects, see ObjectNode.
- generic_inspect: call `self.generic_inspect(node)` to visit each subnode of a given node.

Calling `self.visit(node)` or `self.inspect(node)` will do nothing unless you actually implement methods that handle specific types of nodes:

- for ASTs, methods must be named `visit_<node_type>` where `<node_type>` is replaced with the lowercase name of the node's class. For example, to allow visiting ClassDef nodes, you must implement the `visit_classdef` method:

  ```
  import ast
  from griffe import Extension


  class MyExtension(Extension):
      def visit_classdef(node: ast.ClassDef) -> None:
          # Do something with the node...
          ...
          # ...then visit the subnodes
          # (it only makes sense if you implement other methods
          # such as visit_functiondef or visit_assign for example).
          self.generic_visit(node)
  ```

  See the [list of existing AST classes](#ast-nodes) to learn what method you can implement.

- for object trees, methods must be named `inspect_<node_type>`, where `<node_type>` is replaced with the string value of the node's kind. The different kinds are listed in the ObjectKind enumeration. For example, to allow inspecting coroutine nodes, you must implement the `inspect_coroutine` method:

  ```
  from griffe import Extension, ObjectNode


  class MyExtension(Extension):
      def inspect_coroutine(node: ObjectNode) -> None:
          # Do something with the node...
          ...
          # ...then visit the subnodes if it makes sense.
          self.generic_inspect(node)
  ```

### Triggering other extensions

If your extension creates new objects, you might want to trigger the other enabled extensions on these object instances. To do this you can use agent.extensions.call:

```
import ast
import griffe


class MyExtension(griffe.Extension):
    # Example from within a load event:
    def on_package(self, *, pkg: griffe.Module, loader: griffe.GriffeLoader, **kwargs) -> None:
        # New object created for whatever reason.
        function = griffe.Function(...)

        # Trigger other extensions.
        loader.extensions.call("on_function", func=function, loader=loader)

    # Example from within an analysis event:
    def on_node(self, *, node: ast.AST | griffe.ObjectNode, agent: griffe.Visitor | griffe.Inspector, **kwargs) -> None:
        # New object created for whatever reason.
        function = griffe.Function(...)

        # Trigger other extensions.
        agent.extensions.call("on_function_instance", node=node, agent=agent, func=function, **kwargs)
```

### Extra data

All Griffe objects (modules, classes, functions, attributes, type aliases) can store additional (meta)data in their `extra` attribute. This attribute is a dictionary of dictionaries. The first layer is used as namespacing: each extension writes into its own namespace, or integrates with other projects by reading/writing in their namespaces, according to what they support and document.

```
import griffe

self_namespace = "my_extension"


class MyExtension(griffe.Extension):
    def on_object(self, obj: griffe.Object, **kwargs) -> None:
        obj.extra[self_namespace]["some_key"] = "some_value"
```

For example, [mkdocstrings-python](https://mkdocstrings.github.io/python) looks into the `mkdocstrings` namespace for a `template` key. Extensions can therefore provide a custom template value by writing into `extra["mkdocstrings"]["template"]`:

```
import griffe

self_namespace = "my_extension"
mkdocstrings_namespace = "mkdocstrings"


class MyExtension(griffe.Extension):
    def on_class(self, cls: griffe.Class, **kwargs) -> None:
        cls.extra[mkdocstrings_namespace]["template"] = "my_custom_template"
```

[Read more about mkdocstrings handler extensions.](https://mkdocstrings.github.io/usage/handlers/#handler-extensions)

### Options

Extensions can be made to support options. These options can then be passed from the [command-line](#on-the-command-line) using JSON, from Python directly, or from other tools like MkDocs, in `mkdocs.yml`.

```
import griffe


class MyExtension(griffe.Extension):
    def __init__(self, option1: str, option2: bool = False) -> None:
        super().__init__()
        self.option1 = option1
        self.option2 = option2

    def on_attribute(self, attr: griffe.Attribute, **kwargs) -> None:
        if self.option2:
            ...  # Do something.
```

### Logging

To better integrate with Griffe and other tools in the ecosystem (notably MkDocs), use Griffe loggers to log messages:

```
import griffe

logger = griffe.get_logger(__name__)


class MyExtension(griffe.Extension):
    def on_module(self, mod: griffe.Module, **kwargs) -> None:
        logger.info("Doing some work on module %s", mod.path)
```

### Full example

The following example shows how one could write a "dynamic docstrings" extension that dynamically imports objects that declare their docstrings dynamically, to improve support for such docstrings. The extension is configurable to run only on user-selected objects.

Package structure (or just write your extension in a local script):

```
ðŸ“ ./
â”œâ”€â”€  pyproject.toml
â””â”€â”€ ðŸ“ src/
    â””â”€â”€ ðŸ“ dynamic_docstrings/
        â”œâ”€â”€  __init__.py
        â””â”€â”€  extension.py
```

./src/dynamic_docstrings/extension.py

```
import ast
import inspect
import griffe

logger = griffe.get_logger(__name__)


class DynamicDocstrings(griffe.Extension):
    def __init__(self, object_paths: list[str] | None = None) -> None:
        self.object_paths = object_paths

    def on_object(
        self,
        obj: griffe.Object,
        loader: griffe.GriffeLoader,
        **kwargs,
    ) -> None:
        if obj.analysis == "dynamic":
            return  # Skip runtime objects, their docstrings are already right.

        if self.object_paths and obj.path not in self.object_paths:
            return  # Skip objects that were not selected.

        # Import object to get its evaluated docstring.
        try:
            runtime_obj = griffe.dynamic_import(obj.path)
            docstring = runtime_obj.__doc__
        except ImportError:
            logger.debug(f"Could not get dynamic docstring for {obj.path}")
            return
        except AttributeError:
            logger.debug(f"Object {obj.path} does not have a __doc__ attribute")
            return

        # Update the object instance with the evaluated docstring.
        docstring = inspect.cleandoc(docstring)
        if obj.docstring:
            obj.docstring.value = docstring
        else:
            obj.docstring = griffe.Docstring(
                docstring,
                parent=obj,
                docstring_parser=loader.docstring_parser,
                docstring_options=loader.docstring_options,
            )
```

You can then expose this extension in the top-level module of your package:

./src/dynamic_docstrings/__init__.py

```
from dynamic_docstrings.extension import DynamicDocstrings

__all__ = ["DynamicDocstrings"]
```

This will allow users to load and use this extension by referring to it as `dynamic_docstrings` (your Python package name).

See [how to use extensions](#using-extensions) to learn more about how to load and use your new extension.

## AST nodes

> |     |
> | --- |
> |     |
>
> - Add
> - alias
> - And
> - AnnAssign
> - arg
> - arguments
> - Assert
> - Assign
> - AsyncFor
> - AsyncFunctionDef
> - AsyncWith
> - Attribute
> - AugAssign
> - Await
> - BinOp
> - BitAnd
> - BitOr
> - BitXor
> - BoolOp
> - Break
> - `Bytes`[1](#fn:1)
> - Call
> - ClassDef
> - Compare
> - comprehension
> - Constant
> - Continue
> - Del
> - Delete
> - Dict
>
> |
>
> - DictComp
> - Div
> - `Ellipsis`[1](#fn:1)
> - Eq
> - ExceptHandler
> - Expr
> - `Expression`[1](#fn:1)
> - `ExtSlice`[2](#fn:2)
> - FloorDiv
> - For
> - FormattedValue
> - FunctionDef
> - GeneratorExp
> - Global
> - Gt
> - GtE
> - If
> - IfExp
> - Import
> - ImportFrom
> - In
> - `Index`[2](#fn:2)
> - `Interactive`[3](#fn:3)
> - Invert
> - Is
> - IsNot
> - JoinedStr
> - keyword
> - Lambda
> - List
>
> |
>
> - ListComp
> - Load
> - LShift
> - Lt
> - LtE
> - Match
> - MatchAs
> - match_case
> - MatchClass
> - MatchMapping
> - MatchOr
> - MatchSequence
> - MatchSingleton
> - MatchStar
> - MatchValue
> - MatMult
> - Mod
> - `Module`[3](#fn:3)
> - Mult
> - Name
> - `NameConstant`[1](#fn:1)
> - NamedExpr
> - Nonlocal
> - Not
> - NotEq
> - NotIn
> - `Num`[1](#fn:1)
> - Or
> - ParamSpec
> - Pass
>
> |
>
> - `pattern`[3](#fn:3)
> - Pow
> - `Print`[4](#fn:4)
> - Raise
> - Return
> - RShift
> - Set
> - SetComp
> - Slice
> - Starred
> - Store
> - `Str`[1](#fn:1)
> - Sub
> - Subscript
> - Try
> - `TryExcept`[5](#fn:5)
> - `TryFinally`[6](#fn:6)
> - Tuple
> - TypeAlias
> - TypeVar
> - TypeVarTuple
> - UAdd
> - UnaryOp
> - USub
> - While
> - With
> - withitem
> - Yield
> - YieldFrom

## Next steps

Extensions are a powerful mechanism to customize or enhance the data loaded by Griffe. But sometimes, all you need to do to improve the data is to make Griffe happy by following a few conventions. We therefore invite you to read our recommendations on [public APIs](../recommendations/public-apis/), [Python code best practices](../recommendations/python-code/) and [docstrings](../recommendations/docstrings/).

______________________________________________________________________

1. Deprecated since Python 3.8.Â [â†©](#fnref:1 "Jump back to footnote 1 in the text")[â†©](#fnref2:1 "Jump back to footnote 1 in the text")[â†©](#fnref3:1 "Jump back to footnote 1 in the text")[â†©](#fnref4:1 "Jump back to footnote 1 in the text")[â†©](#fnref5:1 "Jump back to footnote 1 in the text")[â†©](#fnref6:1 "Jump back to footnote 1 in the text")
1. Deprecated since Python 3.9.Â [â†©](#fnref:2 "Jump back to footnote 2 in the text")[â†©](#fnref2:2 "Jump back to footnote 2 in the text")
1. Not documented.Â [â†©](#fnref:3 "Jump back to footnote 3 in the text")[â†©](#fnref2:3 "Jump back to footnote 3 in the text")[â†©](#fnref3:3 "Jump back to footnote 3 in the text")
1. `print` became a builtin (instead of a keyword) in Python 3.Â [â†©](#fnref:4 "Jump back to footnote 4 in the text")
1. Now `ExceptHandler`, in the `handlers` attribute of `Try` nodes.Â [â†©](#fnref:5 "Jump back to footnote 5 in the text")
1. Now a list of expressions in the `finalbody` attribute of `Try` nodes.Â [â†©](#fnref:6 "Jump back to footnote 6 in the text")
# Recommendations

# Docstrings

Here are explanations on what docstrings are, and a few recommendations on how to write them. This guide uses the [Google-style](../../../../reference/docstrings/#google-style), because that is our preferred and recommended style, but you can also use any other supported style. Skip to the [Styles](#styles) section to learn about the existing docstring styles. We invite you to read their own style guides as they are full of examples and good advice.

## Definition

A docstring is a line or block of text describing objects such as modules, classes, functions, attributes and type aliases. They are written below the object signature or assignment, or appear as first expression in a module:

module.py

```
"""This is the module docstring."""

type X = dict[str, int]
"""This is a type alias docstring."""

a = 0
"""This is an attribute docstring."""


def b():
    """This is a function docstring."""


class C:
    """This is a class docstring."""

    def d(self):
        """This is a method docstring."""
```

## Multi-line docstrings

Each docstring can span multiple lines if it is wrapped in triple double-quotes (which is generally the case and the official recommendation even for single-line docstrings):

```
def function():
    """This is a longer docstring.

    It spans on multiple lines.
    Blank lines are allowed, too.
    """
```

When writing multi-line docstrings, it is recommended to write a short description on the first line, then separate the rest of the docstring with a blank line. The first line is called the **summary**, and the rest of docstring is called the **body**. The summary is useful to documentation generators and other tools to show the short description of an object.

## Markup

Docstrings are just text, so you can use any markup you want. The markup you choose will generally depend on what you decide to do with your docstrings: if you generate API documentation from your docstrings, and the documentation renderer expects Markdown, then you should write your docstrings in Markdown.

Examples of markups are [Markdown](https://daringfireball.net/projects/markdown/) (which has many different implementations and many different "flavors"), [reStructuredText](https://docutils.sourceforge.io/rst.html), [AsciiDoc](https://asciidoc.org/), and [Djot](https://djot.net/).

For example, if you are using [MkDocs](https://www.mkdocs.org) and [mkdocstrings](https://mkdocstrings.github.io/) to generate your API documentation, you should write your docstrings in Markdown. If you are using [Sphinx](https://www.sphinx-doc.org/en/master/), you should probably write your docstrings in reStructuredText, unless you are also using the [MyST](https://myst-parser.readthedocs.io/en/latest/index.html) extension.

Whatever markup you choose, try to stay consistent within your code base.

## Styles

Docstrings can be written for modules, classes, functions, attributes, and type aliases. But there are other aspects of a Python API that need to be documented, such as function parameters, returned values, and raised exceptions, to name a few. We could document everything in natural language, but that would make it hard for downstream tools such as documentation generators to extract information in a structured way, to allow dedicated rendering such as tables for parameters.

To compensate for the lack of structure in natural languages, docstring "styles" emerged. A docstring style is a micro-format for docstrings, allowing to structure the information by following a specific format. With the most popular Google and Numpydoc styles, information in docstrings is decomposed into **sections** of different kinds, for example "parameter" sections or "return" sections. Some kinds of section then support documenting multiple items, or support a single block of markup. For example, we can document multiple parameters in "parameter" sections, but a "note" section is only composed of a text block.

Structuring the information in sections and items allows documentation-related tools to extract and provide this information in a structured way, by parsing the docstrings according to the style they follow. Griffe has parsers for [Google-style](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings), [Numpydoc-style](https://numpydoc.readthedocs.io/en/latest/format.html), and [Sphinx-style](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html) docstrings. See the complete reference for these parsers and styles in the [Docstrings reference](../../../../reference/docstrings/). We recommend that you read the style guides mentioned here as they are full of examples and good advice too.

Google-style

```
def greet(name: str, end: str = "!") -> None:
    """Greet someone.

    Parameters:
        name: The name to greet.
        end: The punctuation mark at the end.

    Note:
        Greetings are cool!
    """
    print(f"Hey {name}{end}")



â€Ž
```

Numpydoc-style

```
def greet(name: str, end: str = "!") -> None:
    """Greet someone.

    Parameters
    ----------
    name
        The name to greet.
    end
        The punctuation mark at the end.

    Note
    ----
    Greetings are cool!
    """
    print(f"Hey {name}{end}")
```

Our preferred style for docstrings is the **Google-style**, because it is in our opinion the most markup-agnostic style: it is based on any kind of markup or documentation generator. Our second choice would be the Numpydoc-style, for its readability.

For the adventurers, have a look at [PEP 727](https://peps.python.org/pep-0727/) (draft) and [griffe-typingdoc](https://mkdocstrings.github.io/griffe-typingdoc/), a Griffe extension to support PEP 727. PEP 727 proposes an alternative way to provide information in a structured way, that does not rely on a docstring micro-format. It takes advantage of `typing.Annotated` to attach documentation to any type-annotated object, like attributes, parameters and returned values. With PEP 727, docstrings styles and their sections aren't required anymore, and docstrings can be written in plain markup, without following any particular style. This makes it easier for tools like Griffe who then don't have to parse docstrings *at all*. The PEP is a bit controversial (lots of different opinions), so we invite you to make your own opinion by looking at real-world projects using it, such as [FastAPI](https://github.com/tiangolo/fastapi/blob/master/fastapi/applications.py), or by reading the (very-long) [discussion on discuss.python.org](https://discuss.python.org/t/pep-727-documentation-metadata-in-typing/32566/17). The PEP was actually written by FastAPI's author, SebastiÃ¡n RamÃ­rez.

PEP 727

```
from typing_extensions import Annotated, Doc


def greet(
    name: Annotated[str, Doc("The name to greet."),
    end: Annotated[str, Doc("The punctuation mark at the end.")] = "!",
) -> None:
    """Greet someone.

    > [!NOTE]
    > Greetings are cool!
    """ # (1)!
    print(f"Hey {name}{end}")
```

1. Here we use the [GitHub syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts) for a "note" callout. It assumes our documentation renderer supports this syntax. The point is that we rely purely on Markdown rather than docstrings styles.

## General tips

Your docstrings will typically be used to document your API, either on a deployed (static) website, or locally, on the command line or in a Python interpreter. Therefore, when writing your docstrings, you should address the right audience: the users of your code. Try to stay succinct and give clear examples. Docstrings are not really the place to explain architectural or technical decisions made while developing the project: this information, while extremely valuable, is better written in *code comments*, where the audience is other developers working on the code base.

Your docstrings will typically again be read online (HTML) or other types of documents such as manual pages or PDFs. Make sure to write complete sentences, with correct punctuation. That means for example, to start each parameter description with a capital letter, and to end it with a period.

When documenting objects acting as namespaces (modules, classes, enumerations), prefer documenting each attribute separately than with an Attributes section in the namespace object docstring. For example, add a docstring to each enumeration value rather than describing each value in the docstring of the enumeration class.

## Modules

Module docstrings should briefly explain what the module contains, and for what purposes these objects can be used. If the documentation generator you chose does not support generating member summaries automatically, you might want to add docstrings sections for attributes, functions, classes, type aliases and submodules.

package/__init__.py

```
"""A generic package to demonstrate docstrings.

This package does not really exist, and is only used as a demonstration purpose for docstrings.
Anyway, this package contains the following API, exposed directly at the top-level,
meaning you can import everything from `package` directly.

Attributes:
    ghost: A ghost wandering in this desolated land.
    dummy: A dummy you can practice on. Not for ghosts.

Classes:
    Ghost: Ah, so this is where our ghost comes from.
        Maybe create some additional ghosts so they can pass the time together?

Functions:
    deploy(): Deploy something on the web (we're not sure what exactly).
"""
```

Do the same thing for every other module of the package, except if you are [hiding your module layout](../public-apis/#module-layout).

## Classes, methods, properties

Class docstrings follow the same logic as module docstrings. Explain what the class is used for, and maybe show a few of its attributes and methods thanks to sections of the same name. A class is already more concrete than a module, so we can maybe start adding usage examples too. Such examples should only show how to create instances of the class. Examples of use for methods can be written in each respective method.

```
class Ghost:
    """Ghosts that wander the earth.

    Ghosts are meant to... we're actually unsure.
    All we know is that, as a user, you might find it amusing to instantiate
    a few of them and put them together to see what they do.

    Methods:
        wander: Wander the earth.
        spook: Spook living organisms.
        pass_through: Pass through anything.

    Examples:
        Create a new ghost with a cool nickname:

        >>> ghost = Ghost(nickname="Rattlesnake")
    """

    def wander(self) -> None:
        """Wander the earth.

        That's it, really.

        Examples:
            >>> ghost.wander()
        """
        ...

    @property
    def weight(self) -> int:
        """The ghost's weight (spoiler: it's close to 0)."""
        ...
```

Note that blocks of lines starting with `>>>` or `...` are automatically parsed as code blocks by Griffe, until a blank line is found. This only works in Examples (plural!) sections. If you rely on [Python-Markdown](https://python-markdown.github.io/) to convert Markdown to HTML (which is the case for MkDocs), you can use the [markdown-pycon](https://pawamoy.github.io/markdown-pycon/) extension to recognize such `pycon` code blocks anywhere, without having to wrap them in fences. You can also choose to use explicit fences everywhere:

````
    """
    Examples:
        Create a new ghost with a cool nickname:

        ```pycon
        >>> ghost = Ghost(nickname="Rattlesnake")
        ```
    """
````

## Functions

Function and method docstrings will typically describe their parameters and return values. For generators, it's also possible to describe what the generator yields and what it can receive, though the latter is not often used.

```
import datetime
from typing import Generator, Iterator


class GhostOlympicGames:
    ...


class GOGTicket:
    ...


def organize_gog(date: datetime.date) -> GhostOlympicGames:
    """Organize Olympic Games for Ghosts.

    The ghost world is much simpler than the living world,
    so it's super easy to organize big events like this.

    Parameters:
        date: The date of the games.

    Returns:
        The prepared games.
    """
    ...


def yield_athletes(quantity: int) -> Iterator[Ghost]:
    """Yield a certain quantity of athletes.

    Parameters:
        quantity: How many ghost athletes you want.

    Yields:
        Ghost athletes. They're just regular ghosts.
    """
    ...



def gog_tickets_factory() -> Generator[GOGTicket, int, None]:
    """Generate tickets for the GOG.

    We value fairness: tickets are priced randomly.
    Unless we send a specific price to the generator.

    Yields:
        Tickets for the games.

    Receives:
        Price for the next ticket, in ghost money (???).
    """
    ...
```

## Attributes

Attribute docstrings are written below their assignment. As usual, they should have a short summary, and an optional, longer body.

```
GHOST_MASS_CONSTANT: float = 1e-100
"""The ghost mass constant.

This is a very small number. Use it scientifically
for all ghost-related things.

Note:
    There is actually nothing scientific about any of this.
""" # (1)!
```

1. Our `Note` section here is parsed as an admonition. See [Google-style admonitions](../../../../reference/docstrings/#google-admonitions) for reference.

Class and instance attributes can be documented the same way:

```
class GhostTown:
    instances: str
    """All the existing towns."""

    def __init__(self, name: str, size: int) -> None:
        self.name = name
        """The town's name."""

        self.size = size
        """The town's size."""
```

## Type aliases

Type alias docstrings are written below their assignment. As usual, they should have a short summary, and an optional, longer body.

```
type Callback = typing.Callable[[int, str], typing.Any]
"""Callback type for Frobnicators.

The first argument is the number of rounds to run, the second argument
is the name of the widget being frobnicated.
"""
```

## Exceptions, warnings

Callables that raise exceptions or emit warnings can document each of these exceptions and warnings. Documenting them informs your users that they could or should catch the raised exceptions, or that they could filter or configure warnings differently. The description next to each exception or warning should explain how or when they are raised or emitted.

```
def verify_spirit_chest():
    """Do a verification routine on the spirit chest.

    Raises:
        OverflowError: When the verification failed
            and all the ghosts escaped from the spirit chest.
    """
    ...


def negotiate_return_to_the_spirit_chest():
    """Negotiate with ghost for them to return in the spirit chest.

    Warns:
        ResourceWarning: When the ghosts refuse to go back in the chest
            because the chest is too tight.
    """
    ...
```

## Going further

There are more sections and more features to discover and use. For a complete reference on docstring styles syntax, see our [reference](../../../../reference/docstrings/).

# Public APIs

## What is a public API?

An API (Application Programming Interface) in the interface with which developers interact with your software. In the Python world, the API of your Python library is the set of modules, classes, functions and other attributes made available to your users. For example, users can do `from your_library import this_function`: `this_function` is part of the API of `your_library`.

Oftentimes, when you develop a library, you create functions, classes, etc. that are only useful internally: they are not supposed to be used by your users. Python does not provide easy or standard ways to actually *prevent* users from using internal objects, so, to distinguish public objects from internal objects, we usually rely on conventions, such as prefixing internal objects' names with an underscore, for example `def _internal_function(): ...`, to mark them as "internal".

Prefixing an object's name with an underscore still does not prevent users from importing and using this object, but it *informs* them that they are not supposed to import and use it, and that this object might change or even disappear in the future, *without notice*.

On the other hand, public objects are supposed to stay compatible with previous versions of your library for at least a definite amount of time, to prevent downstream code from breaking. Any change that could break downstream code is supposed to be communicated *before* it is actually released. Maintainers of the library usually allow a period of time where the public object can still be used as before, but will emit deprecation warnings when doing so, hinting users that they should upgrade their use of the object (or use another object that will replace it). This period of time is usually called a deprecation period.

So, how do we mark an object as public? How do we inform our users which objects can safely be used, and which ones are subject to unnotified changes? Usually, we rely again on the underscore prefix convention: if an object isn't prefixed with an underscore, it means that it is public. But essentially, your public API is what you say it is. If you clearly document that a single function of your package is public, and that all others are subject to unnotified changes and whose usage by users is not supported, then your public API is composed of this single function, and nothing else. **Public APIs are a matter of communication.** Concretely, it's about deciding what parts of your code base are public, and communicating that clearly.

Some components are obviously considered for the public API of a Python package:

- the module layout
- functions and their signature
- classes (their inheritance), their methods and signatures
- the rest of the module or class attributes, their types and values

Other components *should* be considered for the public API but are often forgotten:

- CLI options: see [The CLI is API too](#the-cli-is-api-too) section
- logger names: users might rely on them to filter logs (see [Logger names](#logger-names))
- exceptions raised: users definitely rely on them to catch errors

Other components *could* be considered for the public API, but usually require too much maintenance:

- logging messages: users might rely on them to grep the logs
- exception messages: users might rely on them for various things

Besides, logging and exception messages simply cannot allow deprecation periods where both old and new messages are emitted. Maintainers could however consider adding unique, short codes to messages for more robust consumption.

Our recommendation â€” Communicate your public API, verify what you can.

Take the time to learn about and use ways to declare, communicate and deprecate your public API. Your users will have an easier time using your library. On the maintenance side, you won't get bug reports for uses that are not supported, or you will be able to quickly close them by pointing at the documentation explaining what your public API is, or why something was deprecated, for how long, and how to upgrade.

Automate verifications around your public API with tools like Griffe. Currently Griffe doesn't support checking CLI configuration options, logger names or raised exceptions. If you have the capacity to, verify these manually before each release. [Griffe checks](../../checking/) and [API rules enforcement](#ensuring-api-rules) are a very good starting point.

## Conventions

Python does not provide any standard way to declare public APIs. However we do have official recommendations and a few conventions.

### Underscore prefix

In the Python ecosystem we very often prefix objects with an underscore to mark them as internal, or private. Objects that are not prefixed are then implicitly considered public. For example:

```
def public_function():
    ...

def _internal_function():
    ...
```

The exception to this rule is that imported objects are not considered public. For example:

```
from elsewhere import something
```

Even though `something` doesn't start with an underscore, it was imported so it is not considered public.

### `__all__` list

There is another convention that lets you do the opposite: explicitly mark objects as public. This convention uses the `__all__` module-level attribute, which is a list of strings containing the names of the public objects.

package/module.py

```
__all__ [
    "this_function",
    "ThisClass",
]

def this_function():
    ...

def this_other_function():
    ...

class ThisClass:
    ...

class ThisOtherClass:
    ...
```

Here, even though `this_other_function` and `ThisOtherClass` are *not* prefixed with underscores, they are not considered public, because we explicitly and only marked `this_function` and `ThisClass` as public.

Declaring `__all__` has another beneficial effect: it affects wildcard imports. When your users use wildcard imports to import things from one of your modules, Python will only import the objects that are listed in `__all__`. Without `__all__`, it would import all objects that are not prefixed with an underscore, *including objects already imported from elsewhere*. This can cause serious namespace pollution, and even slow down Python code when wildcard imports are chained. [We actually recommend avoiding wildcard imports](../python-code/#avoid-wildcard-imports).

By declaring `__all__`, your public API becomes explicit, and explicit is better than implicit. But `__all__` only works for module-level objects. Within classes, you will still have to rely on the underscore prefix convention to mark methods or attributes as internal/private.

```
class Thing:
    def public_method(self):
        ...

    def _internal_method(self):
        ...
```

### Redundant aliases

When you expose your public API in `__init__` modules by importing most objects from the underlying modules, it can be a bit tedious to import everything, and then list everything again in the `__all__` list attribute. For this reason, another convention emerged where objects imported and aliased with the same name are considered public.

my_package/__init__.py

```
from elsewhere import something as something
from my_package._internal_module import Thing as Thing
```

Here `Thing` and `something` are considered public even though they were imported. If `__all__` was defined, it would take precedence and redundant aliases wouldn't apply.

### Wildcard imports

Same as for redundant aliases, this convention says that all objects imported thanks to wildcard imports are public. This can again be useful in `__init__` modules where you expose lots of objects declared in submodules.

my_package/__init__.py

```
from my_package._internal_module1 import *
from my_package._internal_module2 import *
```

Note that the wildcard imports logic stays the same, and imports either all objects that do not start with an underscore (imported objects included!), or all objects listed in `__all__` if it is defined. It doesn't care about other conventions such as redundant aliases, or the wildcard imports convention itself.

______________________________________________________________________

Our recommendation â€” Use the underscore prefix and `__all__` conventions.

Use both the underscore prefix convention for consistent naming at module and class levels, and the `__all__` convention for declaring your public API. We do not recommend using the redundant aliases convention, because it doesn't provide any information at runtime. We do not recommend the wildcard import convention either, for the same reason and [for additional reasons mentioned here](../python-code/#avoid-wildcard-imports). We still provide the [`griffe-public-redundant-aliases`](https://mkdocstrings.github.io/griffe-public-redundant-aliases/) and [`griffe-public-wildcard-imports`](https://mkdocstrings.github.io/griffe-public-wildcard-imports/) extensions for those who would still like to rely on these conventions.

Our recommendation matches [PEP 8](https://peps.python.org/pep-0008/#public-and-internal-interfaces):

> To better support introspection, modules should explicitly declare the names in their public API using the `__all__` attribute. Setting `__all__` to an empty list indicates that the module has no public API.
>
> Even with `__all__` set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore.

Concatenating `__all__` for easier maintenance of `__init__` modules.

If you worry about maintenance of your `__init__` modules, know that you can very well concatenate `__all__` lists from submodules into the current one:

```
ðŸ“ my_package/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  module.py
â”œâ”€â”€ ðŸ“ subpackage1/
â”‚   â”œâ”€â”€  __init__.py
â”‚   â””â”€â”€  _module1a.py
â””â”€â”€ ðŸ“ subpackage2/
    â”œâ”€â”€  __init__.py
    â””â”€â”€  _module2a.py
```

my_package/subpackage1/__init__.py

```
from my_package.subpackage1.module1a import this1a, that1a

__all__ = ["this1a", "that1a"]
```

my_package/subpackage2/__init__.py

```
from my_package.subpackage2.module2a import this2a, that2a

__all__ = ["this2a", "that2a"]
```

my_package/__init__.py

```
from my_package.module import this
from my_package.subpackage1 import this1a, that1a, __all__ as subpackage1_all
from my_package.subpackage2 import this2a, that2a, __all__ as subpackage2_all

__all__ = ["this", *subpackage1_all, *subpackage2_all]

# Griffe supports the `+` and `+=` operators too:
# __all__ = ["this"] + subpackage1_all + subpackage2_all
# __all__ = ["this"]; __all__ += subpackage1_all; __all__ += subpackage2_all
```

However we would argue that `this1a`, `that1a`, `this2a` and `that2a` should not be exposed publicly in more than one location. See our section on [unique names and public locations](#unique-names-and-public-locations).

## Module layout

We usually split the code of our packages into different modules. The code can be split according to domains, types of objects, logic, etc.: we don't have any recommendation on that. However, your package layout is part of your API, so it should be taken into account when deciding what you expose as your public API.

Most of the time, packages implicitly expose their module layout in their public API. Indeed, when you start a new project, you create new modules but don't immediately think about making them private. Then the project grows organically, you add more modules, and users start actually relying on their layout, importing specific objects from specific modules. Now when you want to move objects around, to reorganize your layout, you introduce breaking changes. So you have to create a deprecation period where objects that moved around are still importable in the old locations, but emit deprecation warnings. A module-level `__getattr__` function is commonly used for that.

package/old_module.py

```
import warnings
from typing import Any

def __getattr__(name: str) -> Any:
    if name == "my_object":
        warnings.warn(
            "Importing `my_object` from `old_module` is deprecated, import it from `new_module` instead.",
            DeprecationWarning,
            stacklevel=2,
        )

        from package.new_module import my_object

        return my_object

    raise AttributeError(f"module 'old_module' has no attribute '{name}'")
```

Such changes sometimes go unnoticed before the breaking change is released, because users don't enable deprecation warnings. These changes can also be confusing to users when they do notice the warnings: maybe they don't use the deprecated import themselves, and are not sure where to report the deprecated use. These changes also require time to upgrade, and time to maintain.

What if we could make this easier?

By hiding your module layout from your public API, you're removing all these pain points at once. Any object can freely move around without ever impacting users. Maintainers do not need to set deprecation periods where old and new uses are supported, or bump the major part of their semantic version when they stop supporting the old use. Hiding the module layout also removes the ambiguity of whether a submodule is considered public or not: [PEP 8](https://peps.python.org/pep-0008/#public-and-internal-interfaces) doesn't mention anything about it, and it doesn't look like the `__all__` convention expects developers to list their submodules too. In the end it looks like submodules are only subject to the underscore prefix convention.

So, how do we hide the module layout from the public API?

The most common way to hide the module layout is to make all your modules private, by prefixing their name with an underscore:

```
ðŸ“ my_package/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  _combat.py
â”œâ”€â”€  _exploration.py
â””â”€â”€  _sorcery.py
```

Then, you expose public objects in the top-level `__init__` module thanks to its `__all__` attribute:

my_package/__init__.py

```
from my_package._combat import Combat
from my_package._exploration import navigate
from my_package._sorcery import cast_spell

__all__ [
    "Combat",
    "navigate",
    "cast_spell",
]
```

Now, if you want to move `cast_spell` into the `_combat` module, you can do so without impacting users. You can even rename your modules. All you have to do when doing so is update your top-level `__init__` module to import the objects from the right locations.

If you have more than one layer of submodules, you don't have to make the next layer private: only the first one is enough, as it informs users that they shouldn't import from this layer anyway:

```
ðŸ“ my_package/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  _combat.py
â”œâ”€â”€  _exploration.py
â””â”€â”€ ðŸ“ _sorcery/
    â”œâ”€â”€  __init__.py
    â”œâ”€â”€  dark.py
    â””â”€â”€  light.py
```

If you don't want to bother prefixing every module with an underscore, you could go one step further and do one of these two things:

- move everything into an `_internal` directory:

  ```
  ðŸ“ my_package/
  â”œâ”€â”€  __init__.py
  â””â”€â”€ ðŸ“ _internal/
      â”œâ”€â”€  __init__.py
      â”œâ”€â”€  combat.py
      â”œâ”€â”€  exploration.py
      â””â”€â”€ ðŸ“ sorcery/
          â”œâ”€â”€  __init__.py
          â”œâ”€â”€  dark.py
          â””â”€â”€  light.py
  ```

- or move everything into a private package:

  ```
  ðŸ“ my_package/
  â””â”€â”€  __init__.py
  ðŸ“ _my_package/
  â”œâ”€â”€  __init__.py
  â”œâ”€â”€  combat.py
  â”œâ”€â”€  exploration.py
  â””â”€â”€ ðŸ“ sorcery/
      â”œâ”€â”€  __init__.py
      â”œâ”€â”€  dark.py
      â””â”€â”€  light.py
  ```

Whatever *hidden* layout you choose (private modules, internals, private package), it is not very important, as you will be able to switch from one to another easily. In Griffe we chose to experiment and go with the private package approach. This highlighted a few shortcomings that we were able to address in both Griffe and mkdocstrings-python. We later moved the private package under an internal folder.

Top-level-only exposition doesn't play well with large packages.

The *fully* hidden layout plays well with small to medium projects. If you maintain a large project, it can become very impractical for both you and your users to expose every single object in the top-level `__init__` module. For large projects, it therefore makes sense to keep at least one or two additional public layers in your module layout. Sometimes packages also implement many variations of the same abstract class, using the same name in many different modules: in these cases, the modules are effective namespaces that could be kept in the public API.

Our recommendation â€” Hide your module layout early.

Start hiding your module layout early! It is much easier to (partially) expose the layout later than to hide it after your users started relying on it. It will also make code reorganizations much easier.

## Unique names and public locations

Whether or not you are planning to hide your module layout, as recommended in the previous section, one thing that will help both you and your users is making sure your object names are unique across your code base. Having unique names ensures that you can expose everything at the top-level module of your package without having to alias objects (using `from ... import x as y`). It will also ensure that your users don't end up importing multiple different objects with the same name, again having to alias them. Finally, it forces you to use meaningful names for your objects, names that don't need the context of the above namespaces (generally modules) to understand what they mean. For example, in Griffe we previously exposed `griffe.docstrings.utils.warning`. Exposing `warning` at the top-level made it very vague: what does it do? So we renamed it `docstring_warning`, which is much clearer.

Ensuring unique names across a code base is sometimes not feasible, or not desirable; in this case, try to use namespacing while still hiding the module layout the best you can.

In accordance with our recommendation on module layouts, it is also useful to ensure that a single public object is exposed in a single location. Ensuring a unique public location for each object removes any ambiguity on the user side as to where to import the object from. It also helps documentation generators that try to cross-reference objects: with several locations, they cannot know for sure which one is the best to reference (which path is best to use and display in the generated documentation). With a fully hidden layout, all objects are *only* exposed in the top-level module, so there is no ambiguity. With partially hidden layouts, or completely public layouts, make sure to declare your public API so that each object is only exposed in a single location. Example:

```
ðŸ“ my_package/
â”œâ”€â”€  __init__.py
â””â”€â”€  module.py
```

Here the `Hello` class is exposed in both `my_package.module` and `my_package`.

my_package/module.py

```
__all__ ["Hello"]

class Hello:
    ...
```

my_package/__init__

```
from my_package.module import Hello

__all__ = ["Hello"]
```

Here the `Hello` class is only exposed in `my_package.module`.

my_package/module.py

```
__all__ ["Hello"]

class Hello:
    ...
```

my_package/__init__

```
# Nothing to see here.
```

If you wanted to expose it in the top-level `__init__` module instead, then you should hide your module layout by making `module.py` private, renaming it `_module.py`, or using other hiding techniques such as described in the [Module layout](#module-layout) section.

Here the `Hello` class is only exposed in `package`.

my_package/module.py

```
__all__ = []

class Hello:
    ...
```

my_package/__init__

```
from my_package.module import Hello

__all__ = ["Hello"]
```

It feels weird to "unpublicize" the `Hello` class in `my_package.module` by declaring an empty `__all__`, so maybe the module should be made private instead: `my_package/_module.py`. See other hiding techniques in the [Module layout](#module-layout) section.

Our recommendation â€” Expose public objects in single locations, use meaningful names.

We recommend making sure that each public object is exposed in a single location. Ensuring unique names might be more tricky depending on the code base, so we recommend ensuring meaningful names at least, not requiring the context of modules above to understand what the objects are for.

## Logger names

The documentation of the standard `logging` library recommends to use `__name__` as logger name when obtaining a logger with `logging.getLogger()`, *unless we have a specific reason for not doing that*. Unfortunately, no examples of such specific reasons are given. So let us give one.

Using `__name__` as logger names means that your loggers have the same name as your module paths. For example, the module `package/module.py`, whose path and `__name__` value are `package.module`, will have a logger with the same name, i.e. `package.module`. If your module layout is public, that's fine: renaming the module or moving it around is already a breaking change that you must document.

However if your module layout is hidden, or if this particular module is private, then even though renaming it or moving it around is *not* breaking change, the change of name of its logger *is*. Indeed, by renaming your module (or moving it), you changed its `__name__` value, and therefore you changed its logger name.

Now, users that were relying on this name (for example to silence WARNING-level logs and below coming from this particular module) will see their logic break without any error and without any deprecation warning.

```
# For example, the following would have zero effect if `_module` was renamed `_other_module`.
package_module_logger = logging.getLogger("package._module")
package_module_logger.setLevel(logging.ERROR)
```

Could we emit a deprecation warning when users obtain the logger with the old name? Unfortunately, there is no standard way to do that. This would require patching `logging.getLogger`, which means it would only work when users actually use this method, in a Python interpreter, and not for all the other ways logging can be configured (configuration files, configuration dicts, etc.).

Since it is essentially impossible to deprecate a logger name, we recommend to avoid using `__name__` as logger name, at the very least in private modules.

Our recommendation â€” Use a single logger.

Absolutely avoid using `__name__` as logger name in private modules. If your module layout is hidden, or does not matter for logging purposes, just use the same logger everywhere by using your package name as logger name. Example: `logger = logging.getLogger("griffe")`. Show your users how to temporarily alter your global logger (typically with context managers) so that altering subloggers becomes unnecessary. Maybe even provide the utilities to do that.

## Documentation

Obviously, your public API should be documented. Each object should have a docstring that explains why the object is useful and how it is used. More on that in our [docstrings recommendations](../docstrings/). Docstrings work well for offline documentation; we recommend exposing your public API online too, for example with [MkDocs](https://www.mkdocs.org/) and [mkdocstrings' Python handler](https://mkdocstrings.github.io/python/), or with other SSGs (Static Site Generators). Prefer a tool that is able to create a [Sphinx-like](https://sphobjinv.readthedocs.io/en/stable/syntax.html) inventory of objects (an `objects.inv` file) that will allow other projects to easily cross-reference your API from their own documentation. Make sure each and every object of your public API is documented in your web docs and therefore added to the objects inventory (and maybe that nothing else is added to this inventory as "public API").

Our recommendation â€” Document your public API extensively.

Write docstrings for each and every object of your public API. Deploy online documentation where each object is documented and added to an object inventory that can be consumed by third-party projects. If you find yourself reluctant to document a public object, it means that this object should maybe be internal instead.

Our documentation framework of choice is of course [MkDocs](https://www.mkdocs.org) combined with our [mkdocstrings](https://mkdocstrings.github.io/) plugin.

## Ensuring API rules

If you already follow some of these recommendations, or if you decide to start following them, it might be a good idea to make sure that these recommendations keep being followed as your code base evolves. The intent of these recommendations, or "rules", can be captured in tests relatively easily thanks to Griffe.

We invite you to check out our own test file: [`test_api.py`](https://github.com/mkdocstrings/griffe/blob/main/tests/test_api.py). This test module asserts several things:

- all public objects are exposed in the top-level `griffe` module
- all public objects have unique names
- all public objects have single locations
- all public objects are added to the inventory (which means they are documented in our API docs)
- no private object is added to the inventory

Our recommendation â€” Test your API declaration early.

The sooner you test your API declaration, the better your code base will evolve. This will force you to really think about how your API is exposed to your users. This will prevent mistakes like leaving a new object as public while you don't want users to start relying on it, or forgetting to expose a public object in your top-level module or to document it in your API docs.

## Linters

Depending on their configuration, many popular Python linters will warn you that you access or import private objects. This doesn't play well with hidden module layouts, where modules are private or moved under a private (sub-)package. Sometimes it doesn't even play well with private methods

Our recommendation â€” Ignore "protected access" warnings for your own package, or make the warnings smarter.

To users of linters, we recommend adding `# noqa` comments on the relevant code lines, or globally disabling warnings related to "private object access" if per-line exclusion requires too much maintenance.

To authors of linters, we recommend (if possible) making these warnings smarter: they shouldn't be triggered when private objects are accessed from within the *same package*. Marking objects as private is meant to prevent downstream code from using them, not to prevent the developers of the current package themselves from using them: they know what they are doing and should be allowed to use their own private objects without warnings. At the same time, they don't want to disable these warnings *globally*, so the warnings should be derived in multiple versions, or made smarter.

## The CLI is API too

This section deserves an entire article, but we will try to stay succinct here.

Generally, we distinguish the API (Application Programming Interface) from the CLI (Command Line Interface), TUI (Textual User Interface) or GUI (Graphical User Interface). Contrary to TUIs or GUIs which are not likely to be controlled programmatically (they typically work with keyboard and mouse inputs), the CLI can easily be called by various scripts or programs, including from Python programs.

Even if a project was not designed to be used programmatically (doesn't expose a public API), it is *a certainty* that with enough popularity, it *will* be used programmatically. And the CLI will even more so be used programmatically if there is no API. Even if there is an API, sometimes it makes more sense to hook into the CLI rather than the API (cross-language integrations, wrappers, etc.).

Therefore, we urge everyone to consider their CLI as an API too. We urge everyone to always design their project as library-first APIs rather than CLI-first tools.

The first user of your CLI as API is... you. When you declare your project's CLI entrypoint in pyproject.toml:

```
[project.scripts]
griffe = "griffe:main"
```

...this entrypoint ends up as a Python script in the `bin` directory of your virtual environment:

```
#!/media/data/dev/griffe/.venv/bin/python
# -*- coding: utf-8 -*-
import re
import sys
from griffe import main
if __name__ == "__main__":
    sys.argv[0] = re.sub(r"(-script\.pyw|\.exe)?$", "", sys.argv[0])
    sys.exit(main())
```

In this script, we find our entrypoint, `griffe.main`, used programmatically.

______________________________________________________________________

The second user of your CLI as API is... you again. When you write tests for your CLI, you import your entrypoints and call them by passing CLI options and arguments, maybe asserting the exit code raised with a `SystemExit` or the standard output/error thanks to [pytest's capture fixtures](https://docs.pytest.org/en/6.2.x/capture.html). Some simplified examples from our own test suite:

tests/test_cli.py

```
import pytest
import griffe


def test_main() -> None:
    assert griffe.main(["dump", "griffe", "-s", "src", "-o/dev/null"]) == 0


def test_show_help(capsys: pytest.CaptureFixture) -> None:
    with pytest.raises(SystemExit):
        griffe.main(["-h"])
    captured = capsys.readouterr()
    assert "griffe" in captured.out


def test_show_version(capsys: pytest.CaptureFixture) -> None:
    with pytest.raises(SystemExit):
        griffe.main(["-V"])
    captured = capsys.readouterr()
    assert griffe.get_version() in captured.out
```

Now, when you start testing the logic of your CLI subcommands, such as our `dump` subcommand above, you might feel like passing again and again through the command-line arguments parser (here `argparse`) is wasteful and redundant. It is important to test that your arguments are parsed correctly (as you expect them to be parsed), but they shouldn't *have* to be parsed when you are testing the underlying logic.

It's a hint that your command-line arguments parsing (and command-line handling generally) should be *decoupled* from the logic below it: write functions with proper parameters! Then call these functions from your main CLI entrypoint, with the arguments obtained from parsing the command-line arguments and options. It will make testing and debugging much, much easier:

```
import argparse
import sys


def dump(...):
    ...


def main(args: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(...)
    opts = parser.parse_args(args)
    if opts.subcommand == "dump":
        return dump(opts.arg1, opts.arg2, ...)
    elif ...

    print(f"Unknown subcommand {opts.subcommand}", file=sys.stderr)
    return 1
```

Now instead of having to call `main(["dump", "..."])` in your tests, you can directly call `dump(...)`, with all the benefits from static-typing and your IDE features, such as autocompletion, linting, etc..

______________________________________________________________________

The third and next users of your CLI as API are your users: just as you made your own life easier, you made their life easier for when they want to call some subcommands of your tool programmatically. No more messing with lists of strings without autocompletion or linting, no more patching of `sys.argv`, no more following the maze of transformations applied by this fancy CLI framework before finally reaching the crux of the subcommand you want to call, no more trying to replicate these transformations yourself with the CLI framework's API to avoid copy-pasting the dozens of lines you're only interested in.

Our recommendation â€” Decouple command-line parsing from your CLI entrypoints.

Do not tie the command parsing logic with your program's logic. Create functions early, make them accept arguments using basic types (`int`, `str`, `list`, etc.) so that your users can call your main command or subcommands with a single import and single statement. Do not encode all the logic in a single big `main` function. Decoupling the CLI-parsing logic from your entrypoints will make them much easier to test and use programmatically. Consider your entrypoints part of your API!

Our CLI framework of choice is [Cappa](https://pypi.org/project/cappa/).

## Deprecations

With time, the code base of your project evolves. You add features, you fix bugs, and you generally reorganize code. Some of these changes might make your project's public API incompatible with previous versions. In that case, you usually have to "deprecate" previous usage in favor of the new usage. That means you have to support both, and emit deprecation warnings when old usage is detected.

There are many different ways of deprecating previous usage of code, which depend on the change itself. We invite you to read our [Checking APIs](../../checking/) chapter, which describes all the API changes Griffe is able to detect, and provides hints on how to allow deprecation periods for each kind of change.

In addition to emitting deprecation warnings, you should also update the docstrings and documentation for the old usage to point at the new usage, add "deprecated" labels where possible, and mark objects as deprecated when possible.

Our recommendation â€” Allow a deprecation period, document deprecations.

Try allowing deprecation periods for every breaking change. Most changes can be made backward-compatible at the cost of writing legacy code. Use tools like [Yore](https://pawamoy.github.io/yore) to manage legacy code, and standard utilities like warnings.deprecated to mark objects as deprecated. Griffe extensions such as [griffe-warnings-deprecated](https://mkdocstrings.github.io/griffe-warnings-deprecated/) can help you by dynamically augmenting docstrings for your API documentation.

## Third-party libraries

A few third-party libraries directly or indirectly related to public APIs deserve to be mentioned here.

[public](https://pypi.org/project/public/) lets you decorate objects with `@public.add` to dynamically add them to `__all__`, so that you don't have to build a list of strings yourself. The "public visibility" marker is closer to each object, and might help avoid mistakes like forgetting to update `__all__` when an object is removed or renamed.

[modul](https://pypi.org/project/modul/), from Frost Ming, the author of [PDM](https://pdm-project.org/en/latest/), goes one step further and actually hides attributes that are not marked "exported" from users: they won't be able to access un-exported attributes, leaving *only* the public API visible.

[Deprecated](https://pypi.org/project/Deprecated/), which was probably a source of inspiration for [PEP 702](https://peps.python.org/pep-0702/), allows decorating objects with `@deprecated` to mark them as deprecated. Such decorated callables will emit deprecation warnings when called. PEP 702's `warnings.deprecated` could be seen as its successor, bringing the feature directly into the standard library so that type checkers and other static analysis tools can converge on this way to mark objects as deprecated.

# Python code best practices

This document describes some best practices to adopt when using Griffe, or when writing Python code that will be analyzed by Griffe.

## Avoid member-submodule name shadowing

Sometimes we find that an `__init__` module defines or imports an object which has the same name as a submodule of the parent package.

**Case 1**

```
ðŸ“ package/
â”œâ”€â”€  __init__.py
â””â”€â”€ ðŸ“ subpackage/
    â”œâ”€â”€  __init__.py
    â””â”€â”€  thing.py
```

package/subpackage/__init__.py

```
thing = "thing from init module"
```

package/subpackage/thing.py

```
other_thing = "other thing from thing submodule"
```

We recommend not doing that.

Why? Because the `package.subpackage.thing` submodule can eventually **shadow** the `package.subpackage.thing` attribute. Try this:

```
# Replicate the file tree from above.
mkdir -p package/subpackage
echo 'thing = "thing from init module"' > package/subpackage/__init__.py
echo 'other_thing = "other thing from thing submodule"' > package/subpackage/thing.py
# Run a Python interpreter.
python
```

```
>>> from package import subpackage
>>> subpackage.thing
'thing from init module'
>>> # OK, but...
>>> from package.subpackage.thing import other_thing
>>> subpackage.thing
<module 'package.subpackage.thing' from 'package/subpackage/thing.py'>
```

By simply importing from the `thing` submodule, the `thing` attribute of `subpackage` was overwritten by the `thing` submodule.

**Case 2**

In a particular case though, the situation improves: if we *import* `thing` in the init module instead of declaring it, then further imports will not overwrite anything:

package/subpackage/__init__.py

```
from package.subpackage.thing import thing
```

package/subpackage/thing.py

```
thing = "thing from thing submodule"
```

```
# Update the modules.
echo 'from package.subpackage.thing import thing' > package/subpackage/__init__.py
echo 'thing = "thing from thing submodule"' > package/subpackage/thing.py
# Run a Python interpreter.
python
```

```
>>> from package import subpackage
>>> subpackage.thing
'thing from thing'
>>> # OK
>>> from package.subpackage.thing import thing
>>> subpackage.thing
'thing from thing'
>>> # Still OK
```

From an API perspective, and given that both cases are very similar but differ in behavior, we recommend not doing that either.

If the goal is to isolate a single object into its own module, to then expose it in the parent module, then it would make sense that this object is the only object of the submodule to be exposed in the public API, and therefore the submodule could be marked as private by prefixing its name with an underscore:

```
ðŸ“ package/
â”œâ”€â”€  __init__.py
â””â”€â”€ ðŸ“ subpackage/
    â”œâ”€â”€  __init__.py
    â””â”€â”€  _thing.py
```

With this, there is no ambiguity as to what `subpackage.thing` points to.

For the reasons mentioned above, **Griffe does not support this kind of name shadowing.** During static analysis, the submodule will take precedence over the attribute. During dynamic analysis, Griffe's behavior is undefined.

## Avoid wildcard imports

Wildcard imports allow importing from a module all objects that do not start with an underscore `_`, or all objects that are listed in the module's `__all__` attribute, if it is defined.

```
ðŸ“ package/
â”œâ”€â”€  __init__.py
â””â”€â”€  module.py
```

**Explicitly exposed to wildcard imports**

package/module.py

```
__all__ = [
    "SomeClass",
    "some_function",
    "some_attribute",
]

class SomeClass: ...
class SomeOtherClass: ...

def some_function(): ...
def some_other_function(): ...

some_attribute = 0
some_other_attribute = 1
```

**Implicitly exposed to wildcard imports**

package/module.py

```
class SomeClass: ...
class _SomeOtherClass: ...

def some_function(): ...
def _some_other_function(): ...

some_attribute = 0
_some_other_attribute = 1
```

In both cases, using a wildcard import will only import `SomeClass`, `some_function` and `some_attribute`, and not their "other" counterparts:

package/__init__.py

```
from package.module import *
```

While we recommend declaring your public API with `__all__` lists, we do not recommend using wildcard imports.

In the implicit case, any other object imported in `module.py` will also be exported by the wildcard:

package/module.py

```
from somewhere_else import this, that

class SomeClass: ...
class _SomeOtherClass: ...

def some_function(): ...
def _some_other_function(): ...

some_attribute = 0
_some_other_attribute = 1
```

Here, `this` and `that` will also be imported when we do `from package.module import *`. To prevent that, we would have to alias these names as such:

package/module.py

```
from somewhere_else import this as _this, that as _that
```

...which is not ideal.

It gets even worse if `module.py` itself uses wildcard imports:

package/module.py

```
from somewhere_else import *
```

Now using `from package.module import *` will import all objects that do not start with an underscore declared in the module, but also all the objects imported by it that do not start with an underscore, and also all the objects imported by the modules of the imported objects that do not start with an underscore, etc., recursively. Soon enough, we end up with dozens and dozens of objects exposed in `package`, while just a few of them are useful/meaningful to users.

Not only that, but it also increases the risk of creating cycles in imports. Python can handle some of these cycles, but static analysis tools such as Griffe can have a much harder time trying to resolve them.

In the explicit case, the situation improves, as only the objects listed in `__all__` will be exported to the modules that wildcard imports them. It effectively stops namespace pollution, but it does not remove the risk of cyclic imports, only decreases it.

We have seen code bases where parent modules wildcard imports from submodules, while these submodules also wildcard imports from the parent modules... Python somehow handles this, but it is *hell* to handle statically, and it is just too error prone (cyclic imports, name shadowing, namespaces become dependent on the order of imports, etc.).

For these reasons, we recommend not using wildcard imports. Instead, we recommend declaring your public API explicitly with `__all__`, and combining `__all__` lists together if needed:

```
ðŸ“ package/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  module.py
â””â”€â”€  other_module.py
```

Completely explicit:

package/__init__.py

```
from package.module import only, needed, objects
from package.other_module import some, more

__all__ = [
    "only",
    "needed",
    "some",
    "function",
]

def function(): ...
```

Combining `__all__` lists:

package/__init__.py

```
from package.module import only, needed, objects, __all__ as module_all
from package.other_module import some, more, __all__ as other_module_all

__all__ = [
    *module_all,
    *other_module_all,
    "function",
]

def function(): ...
```

Most Python linting tools allow you to forbid the use of wildcard imports.

## Prefer canonical imports

Within your own code base, we recommend using canonical imports. By canonical, we mean importing objects from the module they are declared in, and not from another module that also imports them.

Given the following tree:

```
ðŸ“ package/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  module_a.py
â””â”€â”€  module_b.py
```

package/module_a.py

```
from package.module_b import thing
```

package/module_b.py

```
thing = True
```

Don't do that:

package/__init__.py

```
from package.module_a import thing  # Indirect import, bad.
```

Instead, do this:

package/__init__.py

```
from package.module_b import thing  # Canonical import, good.
```

______________________________________________________________________

We especially recommend canonical imports over indirect imports from sibling modules passing through the parent:

package/__init__.py

```
from package.module_a import thing  # Canonical import, good.
```

package/module_a.py

```
thing = True
```

package/module_b.py

```
from package import thing  # Indirect import passing through parent, bad.

# Do this instead:
from package.module_a import thing  # Canonical import, good.
```

______________________________________________________________________

Similarly, avoid exposing the API of external packages from your own package and recommending to use this indirect API.

package.py

```
import numpy as np

__all__ = ["np"]  # Bad.

# Recommending users to do `from package import np`
# or `import package; package.np.etc`: bad.
```

Instead, let users import Numpy themselves, with `import numpy as np`. This will help other analysis tools, for example to detect that Numpy is used directly and should therefore be listed as a dependency. To quote [PEP 8](https://peps.python.org/pep-0008/#public-and-internal-interfaces):

> Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing moduleâ€™s API, such as os.path or a packageâ€™s `__init__` module that exposes functionality from submodules.

Emphasis on *exposes functionality from submodules*: PEP 8 does not state *exposing functionality from external packages*.

______________________________________________________________________

Using canonical imports provides several benefits:

- it can reduce the risk of cyclic imports
- it can increase performance by reducing hoops and importing less things (for example by not passing through a parent module that imports many things from siblings modules)
- it makes the code more readable and easier to refactor (less indirections)
- it makes the life of static analysis tools easier (less indirections)

We recommend using the [canonical-imports](https://github.com/15r10nk/canonical-imports) tool to automatically rewrite your imports as canonical.

Note however that we recommend using public imports (importing from the "public" locations rather than the canonical ones) when:

- importing from other packages
- importing from your own package within your tests suite

Apply these recommendations at your discretion: there may be other special cases where it might not make sense to use canonical imports.

## Make your compiled objects tell their true location

Python modules can be written in other languages (C, C++, Rust) and compiled. To extract information from such compiled modules, we have to use dynamic analysis, since sources are not available.

A practice that seems common in projects including compiled modules in their distributions is to make the compiled modules private (prefix their names with an underscore), and to expose their objects from a public module higher-up in the module layout, for example by wildcard importing everything from it.

```
ðŸ“ package/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  module.py
â””â”€â”€  _module.cpython-312-x86_64-linux-gnu.so
```

package/module.py

```
from package._module import *
```

Since the objects are exposed in `package.module` instead of `package._module`, developers sometimes decide to make their compiled objects lie about their location, and make them say that they are defined in `package.module` instead of `package._module`. Example:

```
>>> from package._module import MyObject
>>> MyObject.__module__
'package.module'
```

**Don't do that.**

When using dynamic analysis and inspecting modules, Griffe must distinguish objects that were declared in the inspected module from objects that were imported from other modules. The reason is that if we didn't care where objects come from, we could end up inspecting the same objects and their members again and again, since they can be imported in many places. This could lead to infinite loops, recursivity errors, and would generally decrease performance.

So, when Griffe inspects a member of the compiled `_module`, and this member lies and says it comes from `package.module`, Griffe thinks it was imported. It means that Griffe will record the object as an indirection, or alias, instead of visiting it in-place. But that is wrong: the object was actually declared in the module, and should not have been recorded as an indirection.

Fortunately, we were able to put some guard-rails in place, which means that the case above where the compiled and public modules have the same name, except for the leading underscore, is supported, and will not trigger errors. But other cases where modules have different names will trigger issues, and we have to special case them in Griffe itself, after issues are reported.

Please, use your framework features to correctly set the `__module__` attribute of your objects (functions, classes and their methods too) as their *canonical location*, not their public location or any other location in the final package.

For example with [PyO3](https://github.com/PyO3/pyo3):

```
// Your module is compiled and added as `_module` into `package`,
// but its objects are exposed in `package` or `package.module`.
// Set `module = "package._module"`, not `module = "package"` or `module = "package.module"`!
#[pyclass(name = "MyClass", module = "package._module")]
struct MyClass {
    // ...
}
```

Some modules of the standard library are guilty of this too, and do so inconsistently (`ast` and `_ast`, `io` and `_io`, depending on the Python version...). For this reason, when checking if an object was declared in the currently inspected module, Griffe ultimately considers that any qualified name is equal to itself with each component stripped from leading underscores:

```
a.b.c == _a.b.c
a.b.c == _a._b._c
a.__b._c == __a.b.c
...
```

When the qualified name of the object's parent module and the currently inspected module match like above, the object is inspected in-place (added as a member of the currently inspected module) instead of created as an alias.

## Avoid forward references in base classes

Python's type system will let you use forward references in generic types when they are used as base classes. For example:

```
from typing import TypeVar, Generic

T = TypeVar('T')


class Foo(Generic[T]):
    ...


class FooBar(Foo['Bar']):
    ...


class Bar:
    ...
```

```
class Foo[T]:
    ...


class FooBar(Foo['Bar']):
    ...


class Bar:
    ...
```

While Griffe will load this code without error, the `'Bar'` forward reference won't be resolved to the actual `Bar` class. As a consequence, downstream tools like documentation renderers won't be able to output a link to the `Bar` class. We therefore recommend to avoid using forward references in base classes, if possible.

Instead, you can try one of the following approach:

- declare or import the `Bar` class earlier

- declare a proper type:

  ```
  class Foo[T]:
      ...


  type TBar = Bar


  class FooBar(Foo[TBar]):
      ...


  class Bar:
      ...
  ```

- make `FooBar` generic again but with a default type:

  ```
  class Foo[T]:
      ...


  class FooBar[T=Bar](Foo[T]):
      ...


  class Bar:
      ...
  ```
# How-to

# Using Griffe as a docstring-parsing library

You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You just need to import the Docstring class. Then you can build a `Docstring` instance and call its `parse` method, choosing the parsing-style to use:

```
from griffe import Docstring

text = "Hello I'm a docstring!"
docstring = Docstring(text, lineno=1)
parsed = docstring.parse("google")
```

If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring:

```
from griffe import Docstring, Function, Parameters, Parameter, ParameterKind

function = Function(
    "func",
    parameters=Parameters(
        Parameter("param1", annotation="str", kind=ParameterKind.positional_or_keyword),
        Parameter("param2", annotation="int", kind=ParameterKind.keyword_only),
    ),
)
text = """
Hello I'm a docstring!

Parameters:
    param1: Description.
    param2: Description.
"""
docstring = Docstring(text, lineno=1, parent=function)
parsed = docstring.parse("google")
```

With this the parser will fetch the `str` and `int` annotations from the parent function's parameters.

# Inspecting specific objects

Griffe by default parses and visits your code (static analysis) instead of importing it and inspecting objects in memory (dynamic analysis). There are various reasons why static analysis is generally a better approach, but sometimes it is insufficient to handle particularly dynamic objects. When this happens and Griffe cannot handle specific objects, you have a few solutions:

1. enable dynamic analysis for the whole package
1. write a Griffe extension that dynamically handles just the problematic objects
1. write a Griffe extension that statically handles the objects

This document will help you achieve point 2.

Enabling dynamic analysis for whole packages is not recommended, but it can be useful to do it once and check the results, to see if our dynamic analysis agent is able to handle your code natively. Whether it is or not is not very important, you will be able to move onto creating an extension that will selectively inspect the relevant objects in any case. It could just be a bit more difficult in the latter case, and if you have trouble writing the extension we invite you to create a [Q&A discussion](https://github.com/mkdocstrings/griffe/discussions/categories/q-a) to get guidance.

______________________________________________________________________

Start by creating an extensions module (a simple Python file) somewhere in your repository, if you don't already have one. Within it, create an extension class:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""
```

Make it accept configuration options by declaring an `__init__` method:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects
```

Here we choose to store a list of strings, where each string is an object path, like `module.Class.method`. Feel free to store different values to help you filter objects according to your needs. For example, maybe you want to inspect all functions with a given label, in that case you could accept a single string which is the label name. Or you may want to inspect all functions decorated with a specific decorator, etc.

With this `__init__` method, users (or simply yourself) will be able to configure the extension by passing a list of object paths. You could also hard-code everything in the extension if you don't want or need to configure it.

Now that our extension accepts options, we implement its core functionality. We assume that the static analysis agent is able to see the objects we are interested in, and will actually create instances that represent them (Griffe objects). Therefore we hook onto the `on_instance` event, which runs each time a Griffe object is created.

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        ...
```

Check out the available hooks to see if there more appropriate hooks for your needs.

Lets now use our configuration option to decide whether to do something or skip:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return
```

Now we know that only the objects we're interested in will be handled, so lets handle them.

```
import griffe

logger = griffe.get_logger("griffe_inspect_specific_objects")  # (1)!


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        try:
            runtime_obj = griffe.dynamic_import(obj.path)
        except ImportError as error:
            logger.warning(f"Could not import {obj.path}: {error}")  # (2)!
            return
```

1. We integrate with Griffe's logging (which also ensures integration with MkDocs' logging) by creating a logger. The name should look like a package name, with underscores.
1. We decide to log the exception as a warning (causing MkDocs builds to fail in `--strict` mode), but you could also log an error, or a debug message.

Now that we have a reference to our runtime object, we can use it to alter the Griffe object.

For example, we could use the runtime object's `__doc__` attribute, which could have been declared dynamically, to fix the Griffe object docstring:

```
import griffe

logger = griffe.get_logger("griffe_inspect_specific_objects")


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        try:
            runtime_obj = griffe.dynamic_import(obj.path)
        except ImportError as error:
            logger.warning(f"Could not import {obj.path}: {error}")
            return

        if obj.docstring:
            obj.docstring.value = runtime_obj.__doc__
        else:
            obj.docstring = griffe.Docstring(runtime_obj.__doc__)
```

Or we could alter the Griffe object parameters in case of functions, which could have been modified by a signature-changing decorator:

```
import inspect
import griffe

logger = griffe.get_logger("griffe_inspect_specific_objects")


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        try:
            runtime_obj = griffe.dynamic_import(obj.path)
        except ImportError as error:
            logger.warning(f"Could not import {obj.path}: {error}")
            return

        # Update default values modified by decorator.
        signature = inspect.signature(runtime_obj)
        for param in signature.parameters:
            if param.name in obj.parameters:
                obj.parameters[param.name].default = repr(param.default)
```

We could also entirely replace the Griffe object obtained from static analysis by the same one obtained from dynamic analysis:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        inspected_module = griffe.inspect(obj.module.path, filepath=obj.filepath)
        obj.parent.set_member(obj.name, inspected_module[obj.name])  # (1)!
```

1. This assumes the object we're interested in is declared at the module level.

# Setting the right docstring style for every docstring

Griffe attaches the specified docstring style and parsing options to each object in the tree of the package(s) you load. If your package(s) use several docstring styles, some of these objects will have the wrong style attached to them. This is problematic because other Griffe extensions rely on this attached style to parse docstrings and modify them. We plan to alleviate this limitation in the future (see [issue-340](https://github.com/mkdocstrings/griffe/issues/340)), but the most robust thing you can do is to make sure each object has the *right style* attached, as easly as possible, so that other extensions can work without issue.

There are currently two ways to make sure objects have the right docstring style attached as early as possible:

1. Use the [`auto` docstring style](https://mkdocstrings.github.io/griffe/reference/docstrings/#auto-style). Griffe will use regular expressions to infer the docstring style used. 100% accuracy is impossible to achieve, so it's possible that you get incorrect styles for some objects.
1. Write and use a custom Griffe extension.

This how-to provides a few extension-based solutions to correctly set docstring styles in your packages. **Just make sure to enable these extensions in first position.**

## Markup comment

Depending on the markup you use in docstrings, you can add a comment that tells Griffe which docstring style to use.

```
def function():
    """Summary.

    Body.

    <!-- style: google -->
    """
```

```
def function():
    """Summary.

    Body.

    .. style: google
    """
```

Your Griffe extension can then use regular expressions to search for such comments. For example with Markdown (HTML) comments:

```
import re
import griffe


class ApplyDocstringStyle(griffe.Extension):
    def __init__(self, regex: str = "<!-- style: (google|numpy|sphinx) -->") -> None:
         self.regex = re.compile(regex)

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.docstring:
            if match := self.regex.search(obj.docstring.value):
                obj.docstring.parser = match.group(1)
```

## Python comment

You could also decide to add a trailing comment to your docstrings to indicate which style to use.

```
def function():
    """Summary.

    Body.
    """  # style: google
```

Your extension can then pick up this comment to assign the right style:

```
import re
import griffe


class ApplyDocstringStyle(griffe.Extension):
    def __init__(self, regex: str = ".*# style: (google|numpy|sphinx)$") -> None:
         self.regex = re.compile(regex)

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.docstring:
            if match := self.regex.search(obj.docstring.source):
                obj.docstring.parser = match.group(1)
```

## Explicit configuration

Finally, you could decide to map a list of objects to the docstring style they should use. Your extension can either accept options, or it could hard-code that list:

```
import griffe
from fnmatch import fnmatch

class ApplyDocstringStyle(griffe.Extension):
    def __init__(self, config: dict[str, str]):
        self.instances = {}
        self.globs = {}
        for key, value in config.items():
            if "*" in key:
                self.globs[key] = value
            else:
                self.instances[key] = value

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path in self.instances:
            if obj.docstring:
                obj.docsring.parser = self.instances[obj.path]
         else:
             for pattern, style in self.globs:
                 if fnmatch(obj.path, pattern):
                     if obj.docstring:
                         obj.docstring.parser = style
```

Example configuration in MkDocs:

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - your_griffe_extension.py:
              config:
                path.to.obj1: google
                path.to.obj2: numpy
                path.to.obj3.*: sphinx
                path.to.obj4*: google
```

The benefit of this last solution is that it works for code you don't have control over. An alternative solution is to use the [griffe-autodocstringstyle extension](https://mkdocstrings.github.io/griffe/extensions/official/autodocstringstyle/), which automatically assigns the `auto` style to all objects coming from sources found in a virtual environment.

# Set Git information and source link on objects

Griffe tries to set source information on each package it loads. Sometimes it won't be able to find such information, or to find the correct information. In this case, you can programmatically set the right information with a Griffe extension. This will let you fix or customize the source links for many objects at once or for specific objects.

## Git information on whole packages

In this example we see how to set the Git information for whole packages. This will affect every object in these packages, and therefore the source link for each object.

Start by creating an extensions module (a simple Python file) somewhere in your repository, if you don't already have one. Within it, create an extension class:

```
import griffe


class GitInfo(griffe.Extension):
    """An extension to set the right Git information."""
```

Next we hook onto the `on_package` event to override the `git_info` attribute of the packages we are interested into.

```
from pathlib import Path
from typing import Any

import griffe


class GitInfo(griffe.Extension):
    """An extension to set the right Git information."""

    def on_package(self, *, pkg: griffe.Module, **kwargs: Any) -> None:
        if pkg.name == "my_package_name":
            pkg.git_info = griffe.GitInfo(
                repository=Path("/path/to/this/package/local/repository"),
                service="forgejo",
                remote_url="https://myhostedforge.mydomain.com/myaccount/myproject",
                commit_hash="77f928aeab857cb45564462a4f849c2df2cca99a",
            )
```

Here we hardcode the commit hash, but ideally we would obtain it by running a Git command in a subprocess, or any other way that gives a relevant commit hash.

```
import subprocess

process = subprocess.run(["git", "-C", repo, "rev-parse", "HEAD"], text=True, capture_output=True)
commit_hash = process.stdout.strip()
```

We could also reuse properties that Griffe found:

```
# Here we reuse `repository` and `commit_hash` while overriding only `service` and `remote_url`.
pkg.git_info = griffe.GitInfo(
    repository=pkg.git_info.repository,
    service="forgejo",
    remote_url="https://myhostedforge.mydomain.com/myaccount/myproject",
    commit_hash=pkg.git_info.commit_hash,
)

# We could also mutate the original `GitInfo` object:
pkg.git_info.service = "forgejo"
```

Now, with this extension enabled (see Using extensions), every object source link in our `my_package_name` package will be based on this Git information. For example, the source link for `my_package_name.my_function` would be something like `https://myhostedforge.mydomain.com/myaccount/myproject/src/commit/77f928aeab857cb45564462a4f849c2df2cca99a/src/my_package_name/__init__.py#L35-L48`.

## Source links on specific objects

Let say you expose Python objects in your API that are compiled from other sources (C extension, Pyo3 code, etc.). Let say you also know the filepath and line numbers for each of these compiled objects. With this information, you could fix the source link for these compiled objects so that they point to the actual sources, and not to the final modules, where the line numbers would be incorrect (or to nowhere since we wouldn't have line numbers in the first place).

Start by creating an extensions module (a simple Python file) somewhere in your repository, if you don't already have one. Within it, create an extension class:

```
import griffe


class SourceLinks(griffe.Extension):
    """An extension to set the right source links."""
```

Next we hook onto the `on_object` event to override the `source_link` attribute of the objects we are interested into.

```
from pathlib import Path
from typing import Any

import griffe


class SourceLinks(griffe.Extension):
    """An extension to set the right source links."""

    def on_object(self, *, obj: griffe.Object, **kwargs: Any) -> None:
        if obj.path == "my_package_name.my_function":
            obj.source_link = "https://myhostedforge.mydomain.com/myaccount/myproject/src/commit/77f928aeab857cb45564462a4f849c2df2cca99a/src/lib.rs#L35-L48"
        # Handle any other object you want.
        elif ...:
            ...
```

Here we hardcode the link, but we can also reuse the Git information of the package to just correct the filepath and line numbers:

```
from pathlib import Path
from typing import Any

import griffe


class SourceLinks(griffe.Extension):
    """An extension to set the right source links."""

    def on_object(self, *, obj: griffe.Object, **kwargs: Any) -> None:
        if obj.path == "my_package_name.my_function":
            obj.source_link = obj.git_info.get_source_link(
                filepath="src/lib.rs",
                lineno=35,
                endlineno=48,
            )
        # Handle any other object you want.
        elif ...:
            ...
```

# Supporting custom decorators

Griffe aims to support the Python language itself, as well as its standard library. It means that built-in objects and objects from the standard library that can be used or are often used as decorators, should be supported natively or through official extensions, for example `@property`, `@functools.cache`, `@warnings.deprecated`, etc.

Custom decorators however (the ones you define in your code-base) won't be supported by default, at least statically (dynamic analysis might be able to support them), because Griffe doesn't try to infer anything more than the obvious. Griffe is not a type-checker and so doesn't have the same inference abilities.

Therefore, to support your own decorators (at least statically), you have to write Griffe extensions. Don't worry, extensions that support custom decorators are generally super easy to write.

______________________________________________________________________

Lets assume we have a decorator whose path is `my_package.utils.enhance`. It is used throughout our code base like so:

```
from my_package.utils import enhance

@enhance
def my_function() -> ...:
    ...
```

Start by creating an extensions module (a simple Python file) somewhere in your repository, if you don't already have one. Within it, create an extension class:

```
import griffe


class MyDecorator(griffe.Extension):
    """An extension to suport my decorator."""
```

Now we can declare the on_instance hook, which receives any kind of Griffe object (Module, Class, Function, Attribute, TypeAlias), or we could use a kind-specific hook such as on_module_instance, on_class_instance, on_function_instance, on_attribute_instance and on_type_alias_instance. For example, if you know your decorator is only ever used on class declarations, it would make sense to use `on_class_instance`.

For the example, lets use the `on_function_instance` hook, which receives `Function` instances.

```
import griffe


class MyDecorator(griffe.Extension):
    """An extension to suport my decorator."""

    def on_function_instance(self, *, func: griffe.Function, **kwargs) -> None:
        ...
```

In this hook, we check if our function is decorated with our custom decorator:

```
import griffe


class MyDecorator(griffe.Extension):
    """An extension to suport my decorator."""

    def on_function_instance(self, *, func: griffe.Function, **kwargs) -> None:
        for decorator in func.decorators:
            if decorator.callable_path == "my_package.utils.enhance":
                ...  # Update the function attributes.
```

Now all that is left to do is to actually write the code that updates the function according to what the decorator is doing. We could update the function's docstring, or its return type, or its parameters: it all depends on your decorator and what it does to the objects it decorates. Check out the API reference for function objects to see what data this object stores.
# Reference

# CLI reference

## griffe

> Signatures for entire Python programs.

Global Options:

- `-h`, `--help`: Show this help message and exit. Commands also accept the -h/--help option.
- `-V`, `--version`: show program's version number and exit
- `--debug-info`: Print debug information.

Commands:

### dump

> Load package-signatures and dump them as JSON.

Search Options:

- `-s`, `--search`: Paths to search packages into.
- `-y`, `--sys-path`: Whether to append `sys.path` to search paths specified with `-s`.

Loading Options:

- `-B`, `--find-stubs-packages`: Whether to look for stubs-only packages and merge them with concrete ones.
- `-e`, `--extensions`: A list of extensions to use.
- `-X`, `--no-inspection`: Disallow inspection of builtin/compiled/not found modules. Default: `True`.
- `-x`, `--force-inspection`: Force inspection of everything, even when sources are found.

Dump Options:

- `packages` `PACKAGE`: Packages to find, load and dump.
- `-f`, `--full`: Whether to dump full data in JSON.
- `-o`, `--output`: Output file. Supports templating to output each package in its own file, with `{package}`. Default: `sys.stdout`.
- `-d`, `--docstyle`: The docstring style to parse.
- `-D`, `--docopts`: The options for the docstring parser.
- `-r`, `--resolve-aliases`: Whether to resolve aliases.
- `-I`, `--resolve-implicit`: Whether to resolve implicitly exported aliases as well. Aliases are explicitly exported when defined in `__all__`.
- `-U`, `--resolve-external`: Always resolve aliases pointing to external/unknown modules (not loaded directly).Default is to resolve only from one module to its private sibling (`ast` -> `_ast`).
- `--no-resolve-external`: Never resolve aliases pointing to external/unknown modules (not loaded directly).Default is to resolve only from one module to its private sibling (`ast` -> `_ast`). Default: `True`.
- `-S`, `--stats`: Show statistics at the end.

Debugging Options:

- `-L`, `--log-level` `LEVEL`: Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`. Default: `INFO`.

Common Options:

- `-h`, `--help`: Show this help message and exit.

### check

> Check for API breakages or possible improvements.

Search Options:

- `-s`, `--search`: Paths to search packages into.
- `-y`, `--sys-path`: Whether to append `sys.path` to search paths specified with `-s`.

Loading Options:

- `-B`, `--find-stubs-packages`: Whether to look for stubs-only packages and merge them with concrete ones.
- `-e`, `--extensions`: A list of extensions to use.
- `-X`, `--no-inspection`: Disallow inspection of builtin/compiled/not found modules. Default: `True`.
- `-x`, `--force-inspection`: Force inspection of everything, even when sources are found.

Debugging Options:

- `-L`, `--log-level` `LEVEL`: Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`. Default: `INFO`.

Common Options:

- `-h`, `--help`: Show this help message and exit.

Check Options:

- `package` `PACKAGE`: Package to find, load and check, as path.
- `-a`, `--against` `REF`: Older Git reference (commit, branch, tag) to check against. Default: load latest tag.
- `-b`, `--base-ref` `BASE_REF`: Git reference (commit, branch, tag) to check. Default: load current code.
- `--color`: Force enable colors in the output.
- `--no-color`: Force disable colors in the output.
- `-v`, `--verbose`: Verbose output.
- `-f`, `--format`: Output format.

# Docstrings

Griffe provides different docstring parsers allowing to extract even more structured data from source code.

The available parsers are:

- `google`, to parse Google-style docstrings, see [Napoleon's documentation](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html)
- `numpy`, to parse Numpydoc docstrings, see [Numpydoc's documentation](https://numpydoc.readthedocs.io/en/latest/format.html)
- `sphinx`, to parse Sphinx-style docstrings, see [Sphinx's documentation](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html)
- `auto`, to automatically detect the docstring style, see [Auto-style](#auto-style)

Most of the time, the syntax specified in the aforementioned docs is supported. In some cases, the original syntax is not supported, or is supported but with subtle differences. We will try to document these differences in the following sections.

No assumption is made on the markup used in docstrings: it's retrieved as regular text. Tooling making use of Griffe can then choose to render the text as if it is Markdown, or AsciiDoc, or reStructuredText, etc..

## Google-style

Google-style docstrings, see [Napoleon's documentation](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html).

### Syntax

Sections are written like this:

```
section identifier: optional section title
    section contents
```

All sections identifiers are case-insensitive. All sections support multiple lines in descriptions, as well as blank lines. The first line must not be blank. Each section must be separated from contents above by a blank line.

âŒ This is **invalid** and will be parsed as regular markup:

```
Some text.
Note: # (1)!
    Some information.

    Blank lines allowed.
```

1. Missing blank line above.

âŒ This is **invalid** and will be parsed as regular markup:

```
Some text.

Note: # (1)!

    Some information.

    Blank lines allowed.
```

1. Extraneous blank line below.

âœ… This is **valid** and will parsed as a text section followed by a note admonition:

```
Some text.

Note:
    Some information.

    Blank lines allowed.
```

Find out possibly invalid section syntax by grepping for "reasons" in Griffe debug logs:

```
griffe dump -Ldebug -o/dev/null -fdgoogle your_package 2>&1 | grep reasons
```

Some sections support documenting multiple items (attributes, parameters, etc.). When multiple items are supported, each item description can use multiple lines, and continuation lines must be indented once more so that the parser is able to differentiate items.

```
def foo(a, b):
    """Foo.

    Parameters:
        a: Here's a.
            Continuation line 1.

            Continuation line 2.
        b: Here's b.
    """
```

It's possible to start a description with a newline if you find it less confusing:

```
def foo(a, b):
    """Foo.

    Parameters:
        a:
            Here's a.
            Continuation line 1.

            Continuation line 2.
        b: Here's b.
    """
```

### Admonitions

When a section identifier does not match one of the [supported sections](#google-sections), the section is parsed as an "admonition" (or "callout").

Identifiers are case-insensitive, however singular and plural forms are distinct. For example, `Note:` is not the same as `Notes:`.

In particular, `Examples` is parsed as the [Examples section](#google-section-examples), while `Example` is parsed as an admonition whose kind is `example`.

The kind is obtained by lower-casing the identifier and replacing spaces with dashes. For example, an admonition whose identifier is `See also:` will have a kind equal to `see-also`.

Custom section titles are preserved in admonitions: `Tip: Check this out:` is parsed as a `tip` admonition with `Check this out:` as title.

It is up to any downstream documentation renderer to make use of these kinds and titles.

### Parser options

The parser accepts a few options:

- `ignore_init_summary`: Ignore the first line in `__init__` methods' docstrings. Useful when merging `__init__` docstring into class' docstrings with mkdocstrings-python's [`merge_init_into_class`](https://mkdocstrings.github.io/python/usage/configuration/docstrings/#merge_init_into_class) option. Default: false.
- `returns_multiple_items`: Parse [Returns sections](#google-section-returns) and [Yields sections](#google-section-yields) as if they contain multiple items. It means that continuation lines must be indented. Default: true.
- `returns_named_value`: Whether to parse `thing: Description` in [Returns sections](#google-section-returns) and [Yields sections](#google-section-yields) as a name and description, rather than a type and description. When true, type must be wrapped in parentheses: `(int): Description.`. When false, parentheses are optional but the items cannot be named: `int: Description`. Default: true.
- `receives_multiple_items`: Parse [Receives sections](#google-section-receives) as if they contain multiple items. It means that continuation lines must be indented. Default: true.
- `receives_named_value`: Whether to parse `thing: Description` in [Receives sections](#google-section-receives) as a name and description, rather than a type and description. When true, type must be wrapped in parentheses: `(int): Description.`. When false, parentheses are optional but the items cannot be named: `int: Description`. Default: true.
- `returns_type_in_property_summary`: Whether to parse the return type of properties at the beginning of their summary: `str: Summary of the property`. Default: false.
- `trim_doctest_flags`: Remove the [doctest flags](https://docs.python.org/3/library/doctest.html#option-flags) written as comments in `pycon` snippets within a docstring. These flags are used to alter the behavior of [doctest](https://docs.python.org/3/library/doctest.html#module-doctest) when testing docstrings, and should not be visible in your docs. Default: true.
- `warn_unknown_params`: Warn about parameters documented in docstrings that do not appear in the signature. Default: true.
- `warn_missing_types`: Warn about missing type or annotation for parameters, return values, etc. Default: true.
- `warnings`: Generally enable/disable warnings when parsing docstrings. Default: true.

### Sections

The following sections are supported.

#### Attributes

- Multiple items allowed

Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.

```
"""My module.

Attributes:
    foo: Description for `foo`.
    bar: Description for `bar`.
"""

foo: int = 0
bar: bool = True


class MyClass:
    """My class.

    Attributes:
        foofoo: Description for `foofoo`.
        barbar: Description for `barbar`.
    """

    foofoo: int = 0

    def __init__(self):
        self.barbar: bool = True
```

Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:

```
"""My module.

Attributes:
    foo (Integer): Description for `foo`.
    bar (Boolean): Description for `bar`.
"""
```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting an attribute with `attr_name (attr_type): Attribute description`, `attr_type` will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Functions/Methods

- Multiple items allowed

Functions or Methods sections allow to document functions of a module, or methods of a class. They should be used in modules and classes docstrings only.

```
"""My module.

Functions:
    foo: Description for `foo`.
    bar: Description for `bar`.
"""


def foo():
    return "foo"


def bar(baz: int) -> int:
    return baz * 2


class MyClass:
    """My class.

    Methods:
        foofoo: Description for `foofoo`.
        barbar: Description for `barbar`.
    """

    def foofoo(self):
        return "foofoo"

    @staticmethod
    def barbar():
        return "barbar"
```

It's possible to write the function/method signature as well as its name:

```
"""
Functions:
    foo(): Description for `foo`.
    bar(baz=1): Description for `bar`.
"""
```

The signatures do not have to match the real ones: you can shorten them to only show the important parameters.

#### Classes

- Multiple items allowed

Classes sections allow to document classes of a module or class. They should be used in modules and classes docstrings only.

```
"""My module.

Classes:
    Foo: Description for `foo`.
    Bar: Description for `bar`.
"""


class Foo:
    ...


class Bar:
    def __init__(self, baz: int) -> int:
        return baz * 2


class MyClass:
    """My class.

    Classes:
        FooFoo: Description for `foofoo`.
        BarBar: Description for `barbar`.
    """

    class FooFoo:
        ...

    class BarBar:
        ...
```

It's possible to write the class signature as well as its name:

```
"""
Functions:
    Foo(): Description for `Foo`.
    Bar(baz=1): Description for `Bar`.
"""
```

The signatures do not have to match the real ones: you can shorten them to only show the important initialization parameters.

#### Modules

- Multiple items allowed

Modules sections allow to document submodules of a module. They should be used in modules docstrings only.

```
ðŸ“ my_pkg/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  foo.py
â””â”€â”€  bar.py
```

my_pkg/__init__.py

```
"""My package.

Modules:
    foo: Description for `foo`.
    bar: Description for `bar`.
"""
```

#### Examples

Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.

```
"""My module.

Examples:
    Some explanation of what is possible.

    >>> print("hello!")
    hello!

    Blank lines delimit prose vs. console blocks.

    >>> a = 0
    >>> a += 1
    >>> a
    1
"""
```

Not the same as *Example* sections.

*Example* (singular) sections are parsed as admonitions. Console code blocks will only be understood in *Examples* (plural) sections.

#### Parameters

- Aliases: Args, Arguments, Params
- Multiple items allowed

Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.

```
def foo(a: int, b: str):
    """Foo.

    Parameters:
        a: Here's a.
        b: Here's b.
    """
```

```
from dataclasses import dataclass


@dataclass
class Foo:
    """Foo.

    Parameters:
        a: Here's a.
        b: Here's b.
    """

    foo: int
    bar: str
```

Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:

```
"""My function.

Parameters:
    foo (Integer): Description for `foo`.
    bar (String): Description for `bar`.
"""
```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting a parameter with `param_name (param_type): Parameter description`, `param_type` will be resolved using the scope of the function (or class). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Other Parameters

- Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params
- Multiple items allowed

Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are, but can also be useful in decorators / to document returned callables.

```
def foo(a, b, **kwargs):
    """Foo.

    Parameters:
        a: Here's a.
        b: Here's b.

    Other parameters:
        c (int): Here's c.
        d (bool): Here's d.
    """
```

```
def foo(a, b):
    """Returns a callable.

    Parameters:
        a: Here's a.
        b: Here's b.

    Other parameters: Parameters of the returned callable:
        c (int): Here's c.
        d (bool): Here's d.
    """

    def inner(c, d):
        ...

    return inner
```

Types in docstrings are resolved using the docstrings' parent scope.

See the same tip for parameters.

#### Raises

- Aliases: Exceptions
- Multiple items allowed

Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.

```
def foo(a: int):
    """Foo.

    Parameters:
        a: A value.

    Raises:
        ValueError: When `a` is less than 0.
    """
    if a < 0:
        raise ValueError("message")
```

Exceptions names are resolved using the function's scope.

`ValueError` and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example `my_exceptions.MyCustomException` or `MyCustomException` directly, depending on what you imported/defined in the current module.

#### Warns

- Aliases: Warnings
- Multiple items allowed

Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.

```
import warnings


def foo():
    """Foo.

    Warns:
        UserWarning: To annoy users.
    """
    warnings.warn("Just messing with you.", UserWarning)
```

Warnings names are resolved using the function's scope.

`UserWarning` and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example `my_warnings.MyCustomWarning` or `MyCustomWarning` directly, depending on what you imported/defined in the current module.

#### Yields

- Multiple items allowed

Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Iterator


def foo() -> Iterator[int]:
    """Foo.

    Yields:
        Integers from 0 to 9.
    """
    for i in range(10):
        yield i
```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator` or `typing.Iterator`. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
from datetime import datetime


def foo() -> Iterator[tuple[float, float, datetime]]:
    """Foo.

    Yields:
        x: Absissa.
        y: Ordinate.
        t: Time.

    ...
    """
    ...
```

You have to indent each continuation line when documenting yielded values, even if there's only one value yielded:

```
"""Foo.

Yields:
    partial_result: Some partial result.
        A longer description of details and other information
        for this partial result.
"""
```

If you don't want to indent continuation lines for the only yielded value, use the [`returns_multiple_items=False`](#google-options) parser option.

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Yields:
    x (int): Absissa.
    y (int): Ordinate.
    t (int): Timestamp.
"""
```

If you want to specify the type without a name, you still have to wrap the type in parentheses:

```
"""Foo.

Yields:
    (int): Absissa.
    (int): Ordinate.
    (int): Timestamp.
"""
```

If you don't want to wrap the type in parentheses, use the [`returns_named_value=False`](#google-options) parser option. Setting it to false will disallow specifying a name.

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Receives

- Multiple items allowed

Receives sections allow to document values that can be sent to generators using their `send` method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Generator


def foo() -> Generator[int, str, None]:
    """Foo.

    Receives:
        reverse: Reverse the generator if `"reverse"` is received.

    Yields:
        Integers from 0 to 9.

    Examples:
        >>> gen = foo()
        >>> next(gen)
        0
        >>> next(gen)
        1
        >>> next(gen)
        2
        >>> gen.send("reverse")
        2
        >>> next(gen)
        1
        >>> next(gen)
        0
        >>> next(gen)
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        StopIteration
    """
    for i in range(10):
        received = yield i
        if received == "reverse":
            for j in range(i, -1, -1):
                yield j
            break
```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator`. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> Generator[int, tuple[str, bool], None]:
    """Foo.

    Receives:
        mode: Some mode.
        flag: Some flag.

    ...
    """
    ...
```

You have to indent each continuation line when documenting received values, even if there's only one value received:

```
"""Foo.

Receives:
    data: Input data.
        A longer description of what this data actually is,
        and what it isn't.
"""
```

If you don't want to indent continuation lines for the only received value, use the [`receives_multiple_items=False`](#google-options) parser option.

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Receives:
    mode (ModeEnum): Some mode.
    flag (int): Some flag.
"""
```

If you want to specify the type without a name, you still have to wrap the type in parentheses:

```
"""Foo.

Receives:
    (ModeEnum): Some mode.
    (int): Some flag.
"""
```

If you don't want to wrap the type in parentheses, use the [`receives_named_value=False`](#google-options) parser option. Setting it to false will disallow specifying a name.

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Returns

- Multiple items allowed

Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.

```
import random


def foo() -> int:
    """Foo.

    Returns:
        A random integer.
    """
    return random.randint(0, 100)
```

Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> tuple[bool, float]:
    """Foo.

    Returns:
        success: Whether it succeeded.
        precision: Final precision.

    ...
    """
    ...
```

You have to indent each continuation line when documenting returned values, even if there's only one value returned:

```
"""Foo.

Returns:
    success: Whether it succeeded.
        A longer description of what is considered success,
        and what is considered failure.
"""
```

If you don't want to indent continuation lines for the only returned value, use the [`returns_multiple_items=False`](#google-options) parser option.

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Returns:
    success (int): Whether it succeeded.
    precision (Decimal): Final precision.
"""
```

If you want to specify the type without a name, you still have to wrap the type in parentheses:

```
"""Foo.

Returns:
    (int): Whether it succeeded.
    (Decimal): Final precision.
"""
```

If you don't want to wrap the type in parentheses, use the [`returns_named_value=False`](#google-options) parser option. Setting it to false will disallow specifying a name.

Types in docstrings are resolved using the docstrings' function scope.

See previous tips for types in docstrings.

## Numpydoc-style

Numpydoc docstrings, see [Numpydoc's documentation](https://numpydoc.readthedocs.io/en/latest/format.html)

### Syntax

Sections are written like this:

```
section identifier
------------------
section contents
```

All sections identifiers are case-insensitive. All sections support multiple lines in descriptions.

Some sections support documenting items items. Item descriptions start on a new, indented line. When multiple items are supported, each item description can use multiple lines.

```
def foo(a, b):
    """Foo.

    Parameters
    ----------
    a
        Here's a.
        Continuation line 1.

        Continuation line 2.
    b
        Here's b.
    """
```

For items that have an optional name and type, several syntaxes are supported:

- specifying both the name and type:

  ```
  """
  name : type
      description
  """
  ```

- specifying just the name:

  ```
  """
  name
      description
  """
  ```

  or

  ```
  """
  name :
      description
  """
  ```

- specifying just the type:

  ```
  """
  : type
      description
  """
  ```

- specifying neither the name nor type:

  ```
  """
  :
      description
  """
  ```

### Admonitions

When a section identifier does not match one of the [supported sections](#numpydoc-sections), the section is parsed as an "admonition" (or "callout").

Identifiers are case-insensitive, however singular and plural forms are distinct, except for notes and warnings. In particular, `Examples` is parsed as the [Examples section](#numpydoc-section-examples), while `Example` is parsed as an admonition whose kind is `example`.

The kind is obtained by lower-casing the identifier and replacing spaces with dashes. For example, an admonition whose identifier is `See also` will have a kind equal to `see-also`.

It is up to any downstream documentation renderer to make use of these kinds.

### Parser options

The parser accepts a few options:

- `ignore_init_summary`: Ignore the first line in `__init__` methods' docstrings. Useful when merging `__init__` docstring into class' docstrings with mkdocstrings-python's [`merge_init_into_class`](https://mkdocstrings.github.io/python/usage/configuration/docstrings/#merge_init_into_class) option. Default: false.
- `trim_doctest_flags`: Remove the [doctest flags](https://docs.python.org/3/library/doctest.html#option-flags) written as comments in `pycon` snippets within a docstring. These flags are used to alter the behavior of [doctest](https://docs.python.org/3/library/doctest.html#module-doctest) when testing docstrings, and should not be visible in your docs. Default: true.
- `warn_unknown_params`: Warn about parameters documented in docstrings that do not appear in the signature. Default: true.
- `warn_missing_types`: Warn about missing type or annotation for parameters, return values, etc. Default: true.
- `warnings`: Generally enable/disable warnings when parsing docstrings. Default: true.

### Sections

The following sections are supported.

#### Attributes

- Multiple items allowed

Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.

```
"""My module.

Attributes
----------
foo
    Description for `foo`.
bar
    Description for `bar`.
"""

foo: int = 0
bar: bool = True


class MyClass:
    """My class.

    Attributes
    ----------
    foofoo
        Description for `foofoo`.
    barbar
        Description for `barbar`.
    """

    foofoo: int = 0

    def __init__(self):
        self.barbar: bool = True
```

Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:

```
"""My module.

Attributes
----------
foo : Integer
    Description for `foo`.
bar : Boolean
    Description for `bar`.
"""
```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting an attribute with `attr_name : attr_type`, `attr_type` will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Functions/Methods

- Multiple items allowed

Functions or Methods sections allow to document functions of a module, or methods of a class. They should be used in modules and classes docstrings only.

```
"""My module.

Functions
---------
foo
    Description for `foo`.
bar
    Description for `bar`.
"""


def foo():
    return "foo"


def bar(baz: int) -> int:
    return baz * 2


class MyClass:
    """My class.

    Methods
    -------
    foofoo
        Description for `foofoo`.
    barbar
        Description for `barbar`.
    """

    def foofoo(self):
        return "foofoo"

    @staticmethod
    def barbar():
        return "barbar"
```

It's possible to write the function/method signature as well as its name:

```
"""
Functions
---------
foo()
    Description for `foo`.
bar(baz=1)
    Description for `bar`.
"""
```

The signatures do not have to match the real ones: you can shorten them to only show the important parameters.

#### Classes

- Multiple items allowed

Classes sections allow to document classes of a module or class. They should be used in modules and classes docstrings only.

```
"""My module.

Classes
-------
Foo
    Description for `foo`.
Bar
    Description for `bar`.
"""


class Foo:
    ...


class Bar:
    def __init__(self, baz: int) -> int:
        return baz * 2


class MyClass:
    """My class.

    Classes
    -------
    FooFoo
        Description for `foofoo`.
    BarBar
        Description for `barbar`.
    """

    class FooFoo:
        ...

    class BarBar:
        ...
```

It's possible to write the class signature as well as its name:

```
"""
Functions
---------
Foo()
    Description for `Foo`.
Bar(baz=1)
    Description for `Bar`.
"""
```

The signatures do not have to match the real ones: you can shorten them to only show the important initialization parameters.

#### Modules

- Multiple items allowed

Modules sections allow to document submodules of a module. They should be used in modules docstrings only.

```
ðŸ“ my_pkg/
â”œâ”€â”€  __init__.py
â”œâ”€â”€  foo.py
â””â”€â”€  bar.py
```

my_pkg/__init__.py

```
"""My package.

Modules
-------
foo
    Description for `foo`.
bar
    Description for `bar`.
"""
```

#### Examples

Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.

```
"""My module.

Examples
--------
Some explanation of what is possible.

>>> print("hello!")
hello!

Blank lines delimit prose vs. console blocks.

>>> a = 0
>>> a += 1
>>> a
1
"""
```

#### Parameters

- Aliases: Args, Arguments, Params
- Multiple items allowed

Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.

```
def foo(a: int, b: str):
    """Foo.

    Parameters
    ----------
    a
        Here's a.
    b
        Here's b.
    """
```

```
from dataclasses import dataclass


@dataclass
class Foo:
    """Foo.

    Parameters
    ----------
    a
        Here's a.
    b
        Here's b.
    """

    foo: int
    bar: str
```

Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:

```
"""My function.

Parameters
----------
foo : Integer
    Description for `foo`.
bar : String
    Description for `bar`.
"""
```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting a parameter with `param_name : param_type`, `param_type` will be resolved using the scope of the function (or class). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Other Parameters

- Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params
- Multiple items allowed

Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are.

```
def foo(a, b, **kwargs):
    """Foo.

    Parameters
    ----------
    a
        Here's a.
    b
        Here's b.

    Other parameters
    ----------------
    c : int
        Here's c.
    d : bool
        Here's d.
    """
```

Types in docstrings are resolved using the docstrings' parent scope.

See the same tip for parameters.

#### Raises

- Aliases: Exceptions
- Multiple items allowed

Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.

```
def foo(a: int):
    """Foo.

    Parameters
    ----------
    a
        A value.

    Raises
    ------
    ValueError
        When `a` is less than 0.
    """
    if a < 0:
        raise ValueError("message")
```

Exceptions names are resolved using the function's scope.

`ValueError` and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example `my_exceptions.MyCustomException` or `MyCustomException` directly, depending on what you imported/defined in the current module.

#### Warns

- Multiple items allowed

Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.

```
import warnings


def foo():
    """Foo.

    Warns
    -----
    UserWarning
        To annoy users.
    """
    warnings.warn("Just messing with you.", UserWarning)
```

Warnings names are resolved using the function's scope.

`UserWarning` and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example `my_warnings.MyCustomWarning` or `MyCustomWarning` directly, depending on what you imported/defined in the current module.

#### Yields

- Multiple items allowed

Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Iterator


def foo() -> Iterator[int]:
    """Foo.

    Yields
    ------
    :
        Integers from 0 to 9.
    """
    for i in range(10):
        yield i
```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator` or `typing.Iterator`. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
from datetime import datetime


def foo() -> Iterator[tuple[float, float, datetime]]:
    """Foo.

    Yields
    ------
    x
        Absissa.
    y
        Ordinate.
    t
        Time.
    """
    ...
```

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Yields
------
x : int
    Absissa.
y : int
    Ordinate.
t : int
    Timestamp.
"""
```

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Receives

- Multiple items allowed

Receives sections allow to document values that can be sent to generators using their `send` method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Generator


def foo() -> Generator[int, str, None]:
    """Foo.

    Receives
    --------
    reverse
        Reverse the generator if `"reverse"` is received.

    Yields
    ------
    :
        Integers from 0 to 9.

    Examples
    --------
    >>> gen = foo()
    >>> next(gen)
    0
    >>> next(gen)
    1
    >>> next(gen)
    2
    >>> gen.send("reverse")
    2
    >>> next(gen)
    1
    >>> next(gen)
    0
    >>> next(gen)
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    StopIteration
    """
    for i in range(10):
        received = yield i
        if received == "reverse":
            for j in range(i, -1, -1):
                yield j
            break
```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator`. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> Generator[int, tuple[str, bool], None]:
    """Foo.

    Receives
    --------
    mode
        Some mode.
    flag
        Some flag.
    """
    ...
```

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Receives
--------
mode : ModeEnum
    Some mode.
flag : int
    Some flag.
"""
```

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Returns

- Multiple items allowed

Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.

```
import random


def foo() -> int:
    """Foo.

    Returns
    -------
    :
        A random integer.
    """
    return random.randint(0, 100)
```

Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> tuple[bool, float]:
    """Foo.

    Returns
    -------
    success
        Whether it succeeded.
    precision
        Final precision.
    """
    ...
```

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Returns
-------
success : int
    Whether it succeeded.
precision : Decimal
    Final precision.
"""
```

Types in docstrings are resolved using the docstrings' function scope.

See previous tips for types in docstrings.

## Auto-style

Automatic style detection. This parser will first try to detect the style used in the docstring, and call the corresponding parser on it.

### Parser options

The parser accepts a few options:

- `method`: The method to use to detect the style and infer the parser. Method 'heuristics' will use regular expressions, while method 'max_sections' will parse the docstring with all parsers specified in `style_order` and return the one who parsed the most sections. Default: `"heuristics"`.
- `style_order`: If multiple parsers parsed the same number of sections, `style_order` is used to decide which one to return. Default: `["sphinx", "google", "numpy"]`.
- `default`: If heuristics fail, the `default` parser is returned. The `default` parser is never used with the 'max_sections' method. Default: `None`.
- Any other option is passed down to the detected parser, if any.

## Parsers features

Want to contribute?

Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item.

The sections are easier to deal in that order:

- Raises, Warns (multiple items, no names, single type each)
- Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each)
- Returns (multiple items, optional name and/or type each, annotation to split when multiple names)
- Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names)

"Examples" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function.

You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables).

### Sections

| Section          | Google | Numpy | Sphinx                                                 |
| ---------------- | ------ | ----- | ------------------------------------------------------ |
| Attributes       | âœ…     | âœ…    | âœ…                                                     |
| Functions        | âœ…     | âœ…    | âŒ                                                     |
| Methods          | âœ…     | âœ…    | âŒ                                                     |
| Classes          | âœ…     | âœ…    | âŒ                                                     |
| Modules          | âœ…     | âœ…    | âŒ                                                     |
| Examples         | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/7)  |
| Parameters       | âœ…     | âœ…    | âœ…                                                     |
| Other Parameters | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/27) |
| Raises           | âœ…     | âœ…    | âœ…                                                     |
| Warns            | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/9)  |
| Yields           | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/10) |
| Receives         | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/8)  |
| Returns          | âœ…     | âœ…    | âœ…                                                     |

### Getting annotations/defaults from parent

| Section          | Google | Numpy | Sphinx                                                 |
| ---------------- | ------ | ----- | ------------------------------------------------------ |
| Attributes       | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/33) |
| Functions        | /      | /     | /                                                      |
| Methods          | /      | /     | /                                                      |
| Classes          | /      | /     | /                                                      |
| Modules          | /      | /     | /                                                      |
| Examples         | /      | /     | /                                                      |
| Parameters       | âœ…     | âœ…    | âœ…                                                     |
| Other Parameters | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/34) |
| Raises           | /      | /     | /                                                      |
| Warns            | /      | /     | /                                                      |
| Yields           | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/36) |
| Receives         | âœ…     | âœ…    | [âŒ](https://github.com/mkdocstrings/griffe/issues/35) |
| Returns          | âœ…     | âœ…    | âœ…                                                     |

### Cross-references for annotations in docstrings

| Section          | Google                                                  | Numpy                                                   | Sphinx                                                 |
| ---------------- | ------------------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------ |
| Attributes       | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/19) |
| Functions        | [âŒ](https://github.com/mkdocstrings/griffe/issues/199) | [âŒ](https://github.com/mkdocstrings/griffe/issues/200) | /                                                      |
| Methods          | [âŒ](https://github.com/mkdocstrings/griffe/issues/199) | [âŒ](https://github.com/mkdocstrings/griffe/issues/200) | /                                                      |
| Classes          | [âŒ](https://github.com/mkdocstrings/griffe/issues/199) | [âŒ](https://github.com/mkdocstrings/griffe/issues/200) | /                                                      |
| Modules          | /                                                       | /                                                       | /                                                      |
| Examples         | /                                                       | /                                                       | /                                                      |
| Parameters       | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/21) |
| Other Parameters | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/20) |
| Raises           | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/22) |
| Warns            | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/25) |
| Yields           | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/26) |
| Receives         | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/23) |
| Returns          | âœ…                                                      | âœ…                                                      | [âŒ](https://github.com/mkdocstrings/griffe/issues/24) |

# griffe

Griffe package.

Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.

The entirety of the public API is exposed here, in the top-level `griffe` module.

All messages written to standard output or error are logged using the `logging` module. Our logger's name is set to `"griffe"` and is public (you can rely on it). You can obtain the logger from the standard `logging` module: `logging.getLogger("griffe")`. Actual logging messages are not part of the public API (they might change without notice).

Raised exceptions throughout the package are part of the public API (you can rely on them). Their actual messages are not part of the public API (they might change without notice).

The following paragraphs will help you discover the package's content.

### CLI entrypoints

Griffe provides a command-line interface (CLI) to interact with the package. The CLI entrypoints can be called from Python code.

- griffe.main: Run the main program.
- griffe.check: Check for API breaking changes in two versions of the same package.
- griffe.dump: Load packages data and dump it as JSON.

### Loaders

To load API data, Griffe provides several high-level functions.

- griffe.load: Load and return a Griffe object.
- griffe.load_git: Load and return a module from a specific Git reference.
- griffe.load_pypi: Load and return a module from a specific package version downloaded using pip.

### Models

The data loaded by Griffe is represented by several classes.

- griffe.Module: The class representing a Python module.
- griffe.Class: The class representing a Python class.
- griffe.Function: The class representing a Python function or method.
- griffe.Attribute: The class representing a Python attribute.
- griffe.Alias: This class represents an alias, or indirection, to an object declared in another module.

Additional classes are available to represent other concepts.

- griffe.Decorator: This class represents a decorator.
- griffe.Parameters: This class is a container for parameters.
- griffe.Parameter: This class represent a function parameter.

### Agents

Griffe is able to analyze code both statically and dynamically, using the following "agents". However most of the time you will only need to use the loaders above.

- griffe.visit: Parse and visit a module file.
- griffe.inspect: Inspect a module.

### Serializers

Griffe can serizalize data to dictionary and JSON.

- griffe.Object.as_json
- griffe.Object.from_json
- griffe.JSONEncoder: JSON encoder for Griffe objects.
- griffe.json_decoder: JSON decoder for Griffe objects.

### API checks

Griffe can compare two versions of the same package to find breaking changes.

- griffe.find_breaking_changes: Find breaking changes between two versions of the same API.
- griffe.Breakage: Breakage classes can explain what broke from a version to another.

### Extensions

Griffe supports extensions. You can create your own extension by subclassing the `griffe.Extension` class.

- griffe.load_extensions: Load configured extensions.
- griffe.Extension: Base class for Griffe extensions.

### Docstrings

Griffe can parse docstrings into structured data.

Main class:

- griffe.Docstring: This class represents docstrings.

Docstring section and element classes all start with `Docstring`.

Docstring parsers:

- griffe.parse: Parse the docstring.
- griffe.parse_auto: Parse a docstring by automatically detecting the style it uses.
- griffe.parse_google: Parse a Google-style docstring.
- griffe.parse_numpy: Parse a Numpydoc-style docstring.
- griffe.parse_sphinx: Parse a Sphinx-style docstring.

### Exceptions

Griffe uses several exceptions to signal errors.

- griffe.GriffeError: The base exception for all Griffe errors.
- griffe.LoadingError: Exception for loading errors.
- griffe.NameResolutionError: Exception for names that cannot be resolved in a object scope.
- griffe.UnhandledEditableModuleError: Exception for unhandled editables modules, when searching modules.
- griffe.UnimportableModuleError: Exception for modules that cannot be imported.
- griffe.AliasResolutionError: Exception for aliases that cannot be resolved.
- griffe.CyclicAliasError: Exception raised when a cycle is detected in aliases.
- griffe.LastNodeError: Exception raised when trying to access a next or previous node.
- griffe.RootNodeError: Exception raised when trying to use siblings properties on a root node.
- griffe.BuiltinModuleError: Exception raised when trying to access the filepath of a builtin module.
- griffe.ExtensionError: Base class for errors raised by extensions.
- griffe.ExtensionNotLoadedError: Exception raised when an extension could not be loaded.
- griffe.GitError: Exception raised for errors related to Git.

## Expressions

Griffe stores snippets of code (attribute values, decorators, base class, type annotations) as expressions. Expressions are basically abstract syntax trees (AST) with a few differences compared to the nodes returned by ast. Griffe provides a few helpers to extract expressions from regular AST nodes.

- griffe.get_annotation: Get a type annotation as expression.
- griffe.get_base_class: Get a base class as expression.
- griffe.get_class_keyword: Get a class keyword as expression.
- griffe.get_condition: Get a condition as expression.
- griffe.get_expression: Get an expression from an AST node.
- griffe.safe_get_annotation: Get a type annotation as expression, safely (returns `None` on error).
- griffe.safe_get_base_class: Get a base class as expression, safely (returns `None` on error).
- griffe.safe_get_class_keyword: Get a class keyword as expression, safely (returns `None` on error).
- griffe.safe_get_condition: Get a condition as expression, safely (returns `None` on error).
- griffe.safe_get_expression: Get an expression from an AST node, safely (returns `None` on error).

The base class for expressions.

- griffe.Expr

Expression classes all start with `Expr`.

## Loggers

If you want to log messages from extensions, get a logger with `get_logger`. The `logger` attribute is used by Griffe itself. You can use it to temporarily disable Griffe logging.

- griffe.logger: Our global logger, used throughout the library.
- griffe.get_logger: Create and return a new logger instance.

## Helpers

To test your Griffe extensions, or to load API data from code in memory, Griffe provides the following helpers.

- griffe.temporary_pyfile: Create a Python file containing the given code in a temporary directory.
- griffe.temporary_pypackage: Create a package containing the given modules in a temporary directory.
- griffe.temporary_visited_module: Create and visit a temporary module with the given code.
- griffe.temporary_visited_package: Create and visit a temporary package.
- griffe.temporary_inspected_module: Create and inspect a temporary module with the given code.
- griffe.temporary_inspected_package: Create and inspect a temporary package.

# Agents

Griffe is able to analyze code both statically and dynamically.

## **Main API**

## visit

```
visit(
    module_name: str,
    filepath: Path,
    code: str,
    *,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module
```

Parse and visit a module file.

We provide this function for static analysis. It uses a NodeVisitor-like class, the Visitor, to compile and parse code (using compile) then visit the resulting AST (Abstract Syntax Tree).

Important

This function is generally not used directly. In most cases, users can rely on the GriffeLoader and its accompanying load shortcut and their respective options to load modules using static analysis.

Parameters:

- ### **`module_name`**

  (`str`) â€“ The module name (as when importing [from] it).

- ### **`filepath`**

  (`Path`) â€“ The module file path.

- ### **`code`**

  (`str`) â€“ The module contents.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use when visiting the AST.

- ### **`parent`**

  (`Module | None`, default: `None` ) â€“ The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

Returns:

- `Module` â€“ The module, with its members populated.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit(
    module_name: str,
    filepath: Path,
    code: str,
    *,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module:
    """Parse and visit a module file.

    We provide this function for static analysis. It uses a [`NodeVisitor`][ast.NodeVisitor]-like class,
    the [`Visitor`][griffe.Visitor], to compile and parse code (using [`compile`][])
    then visit the resulting AST (Abstract Syntax Tree).

    Important:
        This function is generally not used directly.
        In most cases, users can rely on the [`GriffeLoader`][griffe.GriffeLoader]
        and its accompanying [`load`][griffe.load] shortcut and their respective options
        to load modules using static analysis.

    Parameters:
        module_name: The module name (as when importing [from] it).
        filepath: The module file path.
        code: The module contents.
        extensions: The extensions to use when visiting the AST.
        parent: The optional parent of this module.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.

    Returns:
        The module, with its members populated.
    """
    return Visitor(
        module_name,
        filepath,
        code,
        extensions or load_extensions(),
        parent,
        docstring_parser=docstring_parser,
        docstring_options=docstring_options,
        lines_collection=lines_collection,
        modules_collection=modules_collection,
    ).get_module()
```

## inspect

```
inspect(
    module_name: str,
    *,
    filepath: Path | None = None,
    import_paths: Sequence[str | Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module
```

Inspect a module.

Sometimes we cannot get the source code of a module or an object, typically built-in modules like `itertools`. The only way to know what they are made of is to actually import them and inspect their contents.

Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our static agent is not powerful enough to infer all these dynamic modifications. In this case, we load the module using introspection.

Griffe therefore provides this function for dynamic analysis. It uses a NodeVisitor-like class, the Inspector, to inspect the module with inspect.getmembers().

The inspection agent works similarly to the regular Visitor agent, in that it maintains a state with the current object being handled, and recursively handle its members.

Important

This function is generally not used directly. In most cases, users can rely on the GriffeLoader and its accompanying load shortcut and their respective options to load modules using dynamic analysis.

Parameters:

- ### **`module_name`**

  (`str`) â€“ The module name (as when importing [from] it).

- ### **`filepath`**

  (`Path | None`, default: `None` ) â€“ The module file path.

- ### **`import_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ Paths to import the module from.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use when inspecting the module.

- ### **`parent`**

  (`Module | None`, default: `None` ) â€“ The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

Returns:

- `Module` â€“ The module, with its members populated.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect(
    module_name: str,
    *,
    filepath: Path | None = None,
    import_paths: Sequence[str | Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module:
    """Inspect a module.

    Sometimes we cannot get the source code of a module or an object,
    typically built-in modules like `itertools`.
    The only way to know what they are made of is to actually import them and inspect their contents.

    Sometimes, even if the source code is available,
    loading the object is desired because it was created or modified dynamically,
    and our static agent is not powerful enough to infer all these dynamic modifications.
    In this case, we load the module using introspection.

    Griffe therefore provides this function for dynamic analysis.
    It uses a [`NodeVisitor`][ast.NodeVisitor]-like class, the [`Inspector`][griffe.Inspector],
    to inspect the module with [`inspect.getmembers()`][inspect.getmembers].

    The inspection agent works similarly to the regular [`Visitor`][griffe.Visitor] agent,
    in that it maintains a state with the current object being handled, and recursively handle its members.

    Important:
        This function is generally not used directly.
        In most cases, users can rely on the [`GriffeLoader`][griffe.GriffeLoader]
        and its accompanying [`load`][griffe.load] shortcut and their respective options
        to load modules using dynamic analysis.

    Parameters:
        module_name: The module name (as when importing [from] it).
        filepath: The module file path.
        import_paths: Paths to import the module from.
        extensions: The extensions to use when inspecting the module.
        parent: The optional parent of this module.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.

    Returns:
        The module, with its members populated.
    """
    return Inspector(
        module_name,
        filepath,
        extensions or load_extensions(),
        parent,
        docstring_parser=docstring_parser,
        docstring_options=docstring_options,
        lines_collection=lines_collection,
        modules_collection=modules_collection,
    ).get_module(import_paths)
```

## **Advanced API**

## Visitor

```
Visitor(
    module_name: str,
    filepath: Path,
    code: str,
    extensions: Extensions,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
)
```

This class is used to instantiate a visitor.

Visitors iterate on AST nodes to extract data from them.

Parameters:

- ### **`module_name`**

  (`str`) â€“ The module name.

- ### **`filepath`**

  (`Path`) â€“ The module filepath.

- ### **`code`**

  (`str`) â€“ The module source code.

- ### **`extensions`**

  (`Extensions`) â€“ The extensions to use when visiting.

- ### **`parent`**

  (`Module | None`, default: `None` ) â€“ An optional parent for the final module object.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

Methods:

- **`decorators_to_labels`** â€“ Build and return a set of labels based on decorators.
- **`generic_visit`** â€“ Extend the base generic visit with extensions.
- **`get_base_property`** â€“ Check decorators to return the base property in case of setters and deleters.
- **`get_module`** â€“ Build and return the object representing the module attached to this visitor.
- **`handle_attribute`** â€“ Handle an attribute (assignment) node.
- **`handle_function`** â€“ Handle a function definition node.
- **`visit`** â€“ Extend the base visit with extensions.
- **`visit_annassign`** â€“ Visit an annotated assignment node.
- **`visit_assign`** â€“ Visit an assignment node.
- **`visit_asyncfunctiondef`** â€“ Visit an async function definition node.
- **`visit_augassign`** â€“ Visit an augmented assignment node.
- **`visit_classdef`** â€“ Visit a class definition node.
- **`visit_functiondef`** â€“ Visit a function definition node.
- **`visit_if`** â€“ Visit an "if" node.
- **`visit_import`** â€“ Visit an import node.
- **`visit_importfrom`** â€“ Visit an "import from" node.
- **`visit_module`** â€“ Visit a module node.
- **`visit_typealias`** â€“ Visit a type alias node.

Attributes:

- **`code`** (`str`) â€“ The module source code.
- **`current`** (`Module | Class`) â€“ The current object being visited.
- **`docstring_options`** (`DocstringOptions`) â€“ The docstring parsing options.
- **`docstring_parser`** (`DocstringStyle | Parser | None`) â€“ The docstring parser to use.
- **`extensions`** (`Extensions`) â€“ The extensions to use when visiting the AST.
- **`filepath`** (`Path`) â€“ The module filepath.
- **`lines_collection`** (`LinesCollection`) â€“ A collection of source code lines.
- **`module_name`** (`str`) â€“ The module name.
- **`modules_collection`** (`ModulesCollection`) â€“ A collection of modules.
- **`parent`** (`Module | None`) â€“ An optional parent for the final module object.
- **`type_guarded`** (`bool`) â€“ Whether the current code branch is type-guarded.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def __init__(
    self,
    module_name: str,
    filepath: Path,
    code: str,
    extensions: Extensions,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> None:
    """Initialize the visitor.

    Parameters:
        module_name: The module name.
        filepath: The module filepath.
        code: The module source code.
        extensions: The extensions to use when visiting.
        parent: An optional parent for the final module object.
        docstring_parser: The docstring parser to use.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
    """
    super().__init__()

    self.module_name: str = module_name
    """The module name."""

    self.filepath: Path = filepath
    """The module filepath."""

    self.code: str = code
    """The module source code."""

    self.extensions: Extensions = extensions
    """The extensions to use when visiting the AST."""

    self.parent: Module | None = parent
    """An optional parent for the final module object."""

    self.current: Module | Class = None  # type: ignore[assignment]
    """The current object being visited."""

    self.docstring_parser: DocstringStyle | Parser | None = docstring_parser
    """The docstring parser to use."""

    self.docstring_options: DocstringOptions = docstring_options or {}
    """The docstring parsing options."""

    self.lines_collection: LinesCollection = lines_collection or LinesCollection()
    """A collection of source code lines."""

    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()
    """A collection of modules."""

    self.type_guarded: bool = False
    """Whether the current code branch is type-guarded."""
```

### code

```
code: str = code
```

The module source code.

### current

```
current: Module | Class = None
```

The current object being visited.

### docstring_options

```
docstring_options: DocstringOptions = (
    docstring_options or {}
)
```

The docstring parsing options.

### docstring_parser

```
docstring_parser: DocstringStyle | Parser | None = (
    docstring_parser
)
```

The docstring parser to use.

### extensions

```
extensions: Extensions = extensions
```

The extensions to use when visiting the AST.

### filepath

```
filepath: Path = filepath
```

The module filepath.

### lines_collection

```
lines_collection: LinesCollection = (
    lines_collection or LinesCollection()
)
```

A collection of source code lines.

### module_name

```
module_name: str = module_name
```

The module name.

### modules_collection

```
modules_collection: ModulesCollection = (
    modules_collection or ModulesCollection()
)
```

A collection of modules.

### parent

```
parent: Module | None = parent
```

An optional parent for the final module object.

### type_guarded

```
type_guarded: bool = False
```

Whether the current code branch is type-guarded.

### decorators_to_labels

```
decorators_to_labels(
    decorators: list[Decorator],
) -> set[str]
```

Build and return a set of labels based on decorators.

Parameters:

- #### **`decorators`**

  (`list[Decorator]`) â€“ The decorators to check.

Returns:

- `set[str]` â€“ A set of labels.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def decorators_to_labels(self, decorators: list[Decorator]) -> set[str]:
    """Build and return a set of labels based on decorators.

    Parameters:
        decorators: The decorators to check.

    Returns:
        A set of labels.
    """
    labels = set()
    for decorator in decorators:
        callable_path = decorator.callable_path
        if callable_path in builtin_decorators:
            labels.add(builtin_decorators[callable_path])
        elif callable_path in stdlib_decorators:
            labels |= stdlib_decorators[callable_path]
    return labels
```

### generic_visit

```
generic_visit(node: AST) -> None
```

Extend the base generic visit with extensions.

Parameters:

- #### **`node`**

  (`AST`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def generic_visit(self, node: ast.AST) -> None:
    """Extend the base generic visit with extensions.

    Parameters:
        node: The node to visit.
    """
    for child in ast_children(node):
        self.visit(child)
```

### get_base_property

```
get_base_property(
    decorators: list[Decorator], function: Function
) -> str | None
```

Check decorators to return the base property in case of setters and deleters.

Parameters:

- #### **`decorators`**

  (`list[Decorator]`) â€“ The decorators to check.

Returns:

- **`base_property`** ( `str | None` ) â€“ The property for which the setter/deleted is set.
- **`property_function`** ( `str | None` ) â€“ Either "setter" or "deleter".

Source code in `src/griffe/_internal/agents/visitor.py`

```
def get_base_property(self, decorators: list[Decorator], function: Function) -> str | None:
    """Check decorators to return the base property in case of setters and deleters.

    Parameters:
        decorators: The decorators to check.

    Returns:
        base_property: The property for which the setter/deleted is set.
        property_function: Either `"setter"` or `"deleter"`.
    """
    for decorator in decorators:
        try:
            path, prop_function = decorator.callable_path.rsplit(".", 1)
        except ValueError:
            continue
        property_setter_or_deleter = (
            prop_function in {"setter", "deleter"}
            and path == function.path
            and self.current.get_member(function.name).has_labels("property")
        )
        if property_setter_or_deleter:
            return prop_function
    return None
```

### get_module

```
get_module() -> Module
```

Build and return the object representing the module attached to this visitor.

This method triggers a complete visit of the module nodes.

Returns:

- `Module` â€“ A module instance.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def get_module(self) -> Module:
    """Build and return the object representing the module attached to this visitor.

    This method triggers a complete visit of the module nodes.

    Returns:
        A module instance.
    """
    # Optimization: equivalent to `ast.parse`, but with `optimize=1` to remove assert statements.
    # TODO: With options, could use `optimize=2` to remove docstrings.
    top_node = compile(self.code, mode="exec", filename=str(self.filepath), flags=ast.PyCF_ONLY_AST, optimize=1)
    self.visit(top_node)
    return self.current.module
```

### handle_attribute

```
handle_attribute(
    node: Assign | AnnAssign,
    annotation: str | Expr | None = None,
) -> None
```

Handle an attribute (assignment) node.

Parameters:

- #### **`node`**

  (`Assign | AnnAssign`) â€“ The node to visit.

- #### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ A potential annotation.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def handle_attribute(
    self,
    node: ast.Assign | ast.AnnAssign,
    annotation: str | Expr | None = None,
) -> None:
    """Handle an attribute (assignment) node.

    Parameters:
        node: The node to visit.
        annotation: A potential annotation.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_attribute_node", node=node, agent=self)
    parent = self.current
    labels = set()
    names = None

    if parent.kind is Kind.MODULE:
        try:
            names = get_names(node)
        except KeyError:  # Unsupported nodes, like subscript.
            return
        labels.add("module-attribute")
    elif parent.kind is Kind.CLASS:
        try:
            names = get_names(node)
        except KeyError:  # Unsupported nodes, like subscript.
            return

        if isinstance(annotation, Expr) and annotation.is_classvar:
            # Explicit `ClassVar`: class attribute only.
            annotation = annotation.slice  # type: ignore[attr-defined]
            labels.add("class-attribute")
        elif node.value:
            # Attribute assigned at class-level: available in instances as well.
            labels.add("class-attribute")
            labels.add("instance-attribute")
        else:
            # Annotated attribute only: not available at class-level.
            labels.add("instance-attribute")

    elif parent.kind is Kind.FUNCTION:
        if parent.name != "__init__":
            return
        try:
            names = get_instance_names(node)
        except KeyError:  # Unsupported nodes, like subscript.
            return
        parent = parent.parent  # type: ignore[assignment]
        if parent is None:
            return
        labels.add("instance-attribute")

    if not names:
        return

    value = safe_get_expression(node.value, parent=self.current, parse_strings=False)

    try:
        docstring = self._get_docstring(ast_next(node), strict=True)
    except (LastNodeError, AttributeError):
        docstring = None

    for name in names:
        # TODO: Handle assigns like `x.y = z`.
        # We need to resolve `x.y` and add `z` in its members.
        if "." in name:
            continue

        if name in parent.members:
            # Assigning multiple times.
            # TODO: Might be better to inspect.
            if isinstance(node.parent, (ast.If, ast.ExceptHandler)):  # type: ignore[union-attr]
                continue  # Prefer "no-exception" case.

            existing_member = parent.members[name]
            with suppress(AliasResolutionError, CyclicAliasError):
                labels |= existing_member.labels
                # Forward previous docstring and annotation instead of erasing them.
                if existing_member.docstring and not docstring:
                    docstring = existing_member.docstring
                with suppress(AttributeError):
                    if existing_member.annotation and not annotation:  # type: ignore[union-attr]
                        annotation = existing_member.annotation  # type: ignore[union-attr]

        attribute = Attribute(
            name=name,
            value=value,
            annotation=annotation,
            lineno=node.lineno,
            endlineno=node.end_lineno,
            docstring=docstring,
            runtime=not self.type_guarded,
            analysis="static",
        )
        attribute.labels |= labels
        parent.set_member(name, attribute)

        if name == "__all__":
            with suppress(AttributeError):
                parent.exports = [
                    name if isinstance(name, str) else ExprName(name.name, parent=name.parent)
                    for name in safe_get__all__(node, self.current)  # type: ignore[arg-type]
                ]
        self.extensions.call("on_instance", node=node, obj=attribute, agent=self)
        self.extensions.call("on_attribute_instance", node=node, attr=attribute, agent=self)
```

### handle_function

```
handle_function(
    node: AsyncFunctionDef | FunctionDef,
    labels: set | None = None,
) -> None
```

Handle a function definition node.

Parameters:

- #### **`node`**

  (`AsyncFunctionDef | FunctionDef`) â€“ The node to visit.

- #### **`labels`**

  (`set | None`, default: `None` ) â€“ Labels to add to the data object.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def handle_function(self, node: ast.AsyncFunctionDef | ast.FunctionDef, labels: set | None = None) -> None:
    """Handle a function definition node.

    Parameters:
        node: The node to visit.
        labels: Labels to add to the data object.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_function_node", node=node, agent=self)

    labels = labels or set()

    # Handle decorators.
    decorators = []
    overload = False
    if node.decorator_list:
        lineno = node.decorator_list[0].lineno
        for decorator_node in node.decorator_list:
            decorator_value = safe_get_expression(decorator_node, parent=self.current, parse_strings=False)
            if decorator_value is None:
                continue
            decorator = Decorator(
                decorator_value,
                lineno=decorator_node.lineno,
                endlineno=decorator_node.end_lineno,
            )
            decorators.append(decorator)
            overload |= decorator.callable_path in typing_overload
    else:
        lineno = node.lineno

    labels |= self.decorators_to_labels(decorators)

    if "property" in labels:
        attribute = Attribute(
            name=node.name,
            value=None,
            annotation=safe_get_annotation(node.returns, parent=self.current, member=node.name),
            lineno=node.lineno,
            endlineno=node.end_lineno,
            docstring=self._get_docstring(node),
            runtime=not self.type_guarded,
            analysis="static",
        )
        attribute.labels |= labels
        self.current.set_member(node.name, attribute)
        self.extensions.call("on_instance", node=node, obj=attribute, agent=self)
        self.extensions.call("on_attribute_instance", node=node, attr=attribute, agent=self)
        return

    # Handle parameters.
    parameters = Parameters(
        *[
            Parameter(
                name,
                kind=kind,
                annotation=safe_get_annotation(annotation, parent=self.current, member=node.name),
                default=default
                if isinstance(default, str)
                else safe_get_expression(default, parent=self.current, parse_strings=False),
            )
            for name, annotation, kind, default in get_parameters(node.args)
        ],
    )

    function = Function(
        name=node.name,
        lineno=lineno,
        endlineno=node.end_lineno,
        parameters=parameters,
        returns=safe_get_annotation(node.returns, parent=self.current, member=node.name),
        decorators=decorators,
        type_parameters=TypeParameters(*self._get_type_parameters(node, scope=node.name)),
        docstring=self._get_docstring(node),
        runtime=not self.type_guarded,
        parent=self.current,
        analysis="static",
    )

    property_function = self.get_base_property(decorators, function)

    if overload:
        self.current.overloads[function.name].append(function)
    elif property_function:
        base_property: Attribute = self.current.members[node.name]  # type: ignore[assignment]
        if property_function == "setter":
            base_property.setter = function
            base_property.labels.add("writable")
        elif property_function == "deleter":
            base_property.deleter = function
            base_property.labels.add("deletable")
    else:
        self.current.set_member(node.name, function)
        if self.current.kind in {Kind.MODULE, Kind.CLASS} and self.current.overloads[function.name]:
            function.overloads = self.current.overloads[function.name]
            del self.current.overloads[function.name]

    function.labels |= labels

    self.extensions.call("on_instance", node=node, obj=function, agent=self)
    self.extensions.call("on_function_instance", node=node, func=function, agent=self)
    if self.current.kind is Kind.CLASS and function.name == "__init__":
        self.current = function  # type: ignore[assignment]
        self.generic_visit(node)
        self.current = self.current.parent  # type: ignore[assignment]
```

### visit

```
visit(node: AST) -> None
```

Extend the base visit with extensions.

Parameters:

- #### **`node`**

  (`AST`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit(self, node: ast.AST) -> None:
    """Extend the base visit with extensions.

    Parameters:
        node: The node to visit.
    """
    getattr(self, f"visit_{ast_kind(node)}", self.generic_visit)(node)
```

### visit_annassign

```
visit_annassign(node: AnnAssign) -> None
```

Visit an annotated assignment node.

Parameters:

- #### **`node`**

  (`AnnAssign`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_annassign(self, node: ast.AnnAssign) -> None:
    """Visit an annotated assignment node.

    Parameters:
        node: The node to visit.
    """
    self.handle_attribute(node, safe_get_annotation(node.annotation, parent=self.current))
```

### visit_assign

```
visit_assign(node: Assign) -> None
```

Visit an assignment node.

Parameters:

- #### **`node`**

  (`Assign`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_assign(self, node: ast.Assign) -> None:
    """Visit an assignment node.

    Parameters:
        node: The node to visit.
    """
    self.handle_attribute(node)
```

### visit_asyncfunctiondef

```
visit_asyncfunctiondef(node: AsyncFunctionDef) -> None
```

Visit an async function definition node.

Parameters:

- #### **`node`**

  (`AsyncFunctionDef`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_asyncfunctiondef(self, node: ast.AsyncFunctionDef) -> None:
    """Visit an async function definition node.

    Parameters:
        node: The node to visit.
    """
    self.handle_function(node, labels={"async"})
```

### visit_augassign

```
visit_augassign(node: AugAssign) -> None
```

Visit an augmented assignment node.

Parameters:

- #### **`node`**

  (`AugAssign`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_augassign(self, node: ast.AugAssign) -> None:
    """Visit an augmented assignment node.

    Parameters:
        node: The node to visit.
    """
    with suppress(AttributeError):
        all_augment = (
            node.target.id == "__all__"  # type: ignore[union-attr]
            and self.current.is_module
            and isinstance(node.op, ast.Add)
        )
        if all_augment:
            # We assume `exports` is not `None` at this point.
            self.current.exports.extend(  # type: ignore[union-attr]
                [
                    name if isinstance(name, str) else ExprName(name.name, parent=name.parent)
                    for name in safe_get__all__(node, self.current)  # type: ignore[arg-type]
                ],
            )
```

### visit_classdef

```
visit_classdef(node: ClassDef) -> None
```

Visit a class definition node.

Parameters:

- #### **`node`**

  (`ClassDef`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_classdef(self, node: ast.ClassDef) -> None:
    """Visit a class definition node.

    Parameters:
        node: The node to visit.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_class_node", node=node, agent=self)

    # Handle decorators.
    decorators: list[Decorator] = []
    if node.decorator_list:
        lineno = node.decorator_list[0].lineno
        decorators.extend(
            Decorator(
                safe_get_expression(decorator_node, parent=self.current, parse_strings=False),  # type: ignore[arg-type]
                lineno=decorator_node.lineno,
                endlineno=decorator_node.end_lineno,
            )
            for decorator_node in node.decorator_list
        )
    else:
        lineno = node.lineno

    # Handle base classes and keywords.
    bases = [safe_get_base_class(base, parent=self.current, member=node.name) for base in node.bases]
    keywords = {
        kw.arg: safe_get_class_keyword(kw.value, parent=self.current) for kw in node.keywords if kw.arg is not None
    }

    class_ = Class(
        name=node.name,
        lineno=lineno,
        endlineno=node.end_lineno,
        docstring=self._get_docstring(node),
        decorators=decorators,
        type_parameters=TypeParameters(*self._get_type_parameters(node, scope=node.name)),
        bases=bases,  # type: ignore[arg-type]
        keywords=keywords,
        runtime=not self.type_guarded,
        analysis="static",
    )
    class_.labels |= self.decorators_to_labels(decorators)

    self.current.set_member(node.name, class_)
    self.current = class_
    self.extensions.call("on_instance", node=node, obj=class_, agent=self)
    self.extensions.call("on_class_instance", node=node, cls=class_, agent=self)
    self.generic_visit(node)
    self.extensions.call("on_members", node=node, obj=class_, agent=self)
    self.extensions.call("on_class_members", node=node, cls=class_, agent=self)
    self.current = self.current.parent  # type: ignore[assignment]
```

### visit_functiondef

```
visit_functiondef(node: FunctionDef) -> None
```

Visit a function definition node.

Parameters:

- #### **`node`**

  (`FunctionDef`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_functiondef(self, node: ast.FunctionDef) -> None:
    """Visit a function definition node.

    Parameters:
        node: The node to visit.
    """
    self.handle_function(node)
```

### visit_if

```
visit_if(node: If) -> None
```

Visit an "if" node.

Parameters:

- #### **`node`**

  (`If`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_if(self, node: ast.If) -> None:
    """Visit an "if" node.

    Parameters:
        node: The node to visit.
    """
    if isinstance(node.parent, (ast.Module, ast.ClassDef)):  # type: ignore[attr-defined]
        condition = safe_get_condition(node.test, parent=self.current, log_level=None)
        if str(condition) in {"typing.TYPE_CHECKING", "TYPE_CHECKING"}:
            self.type_guarded = True
    self.generic_visit(node)
    self.type_guarded = False
```

### visit_import

```
visit_import(node: Import) -> None
```

Visit an import node.

Parameters:

- #### **`node`**

  (`Import`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_import(self, node: ast.Import) -> None:
    """Visit an import node.

    Parameters:
        node: The node to visit.
    """
    for name in node.names:
        alias_path = name.name if name.asname else name.name.split(".", 1)[0]
        alias_name = name.asname or alias_path.split(".", 1)[0]
        self.current.imports[alias_name] = alias_path
        alias = Alias(
            alias_name,
            alias_path,
            lineno=node.lineno,
            endlineno=node.end_lineno,
            runtime=not self.type_guarded,
            analysis="static",
        )
        self.current.set_member(alias_name, alias)
        self.extensions.call("on_alias_instance", alias=alias, node=node, agent=self)
```

### visit_importfrom

```
visit_importfrom(node: ImportFrom) -> None
```

Visit an "import from" node.

Parameters:

- #### **`node`**

  (`ImportFrom`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_importfrom(self, node: ast.ImportFrom) -> None:
    """Visit an "import from" node.

    Parameters:
        node: The node to visit.
    """
    for name in node.names:
        if not node.module and node.level == 1 and not name.asname and self.current.module.is_init_module:
            # Special case: when being in `a/__init__.py` and doing `from . import b`,
            # we are effectively creating a member `b` in `a` that is pointing to `a.b`
            # -> cyclic alias! In that case, we just skip it, as both the member and module
            # have the same name and can be accessed the same way.
            continue

        alias_path = relative_to_absolute(node, name, self.current.module)
        if name.name == "*":
            alias_name = alias_path.replace(".", "/")
            alias_path = alias_path.replace(".*", "")
        else:
            alias_name = name.asname or name.name
            self.current.imports[alias_name] = alias_path
        # Do not create aliases pointing to themselves (it happens with
        # `from package.current_module import Thing as Thing` or
        # `from . import thing as thing`).
        if alias_path != f"{self.current.path}.{alias_name}":
            alias = Alias(
                alias_name,
                alias_path,
                lineno=node.lineno,
                endlineno=node.end_lineno,
                runtime=not self.type_guarded,
                analysis="static",
            )
            self.current.set_member(alias_name, alias)
            self.extensions.call("on_alias_instance", alias=alias, node=node, agent=self)
```

### visit_module

```
visit_module(node: Module) -> None
```

Visit a module node.

Parameters:

- #### **`node`**

  (`Module`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_module(self, node: ast.Module) -> None:
    """Visit a module node.

    Parameters:
        node: The node to visit.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_module_node", node=node, agent=self)
    self.current = module = Module(
        name=self.module_name,
        filepath=self.filepath,
        parent=self.parent,
        docstring=self._get_docstring(node),
        lines_collection=self.lines_collection,
        modules_collection=self.modules_collection,
        analysis="static",
    )
    self.extensions.call("on_instance", node=node, obj=module, agent=self)
    self.extensions.call("on_module_instance", node=node, mod=module, agent=self)
    self.generic_visit(node)
    self.extensions.call("on_members", node=node, obj=module, agent=self)
    self.extensions.call("on_module_members", node=node, mod=module, agent=self)
```

### visit_typealias

```
visit_typealias(node: TypeAlias) -> None
```

Visit a type alias node.

Parameters:

- #### **`node`**

  (`TypeAlias`) â€“ The node to visit.

Source code in `src/griffe/_internal/agents/visitor.py`

```
def visit_typealias(self, node: ast.TypeAlias) -> None:
    """Visit a type alias node.

    Parameters:
        node: The node to visit.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_type_alias_node", node=node, agent=self)

    # A type alias's name attribute is syntactically a single NAME,
    # but represented as an expression in the AST.
    # https://jellezijlstra.github.io/pep695#ast

    name = node.name.id

    value = safe_get_expression(node.value, parent=self.current, member=name)

    try:
        docstring = self._get_docstring(ast_next(node), strict=True)
    except (LastNodeError, AttributeError):
        docstring = None

    type_alias = TypeAlias(
        name=name,
        value=value,
        lineno=node.lineno,
        endlineno=node.end_lineno,
        type_parameters=TypeParameters(*self._get_type_parameters(node, scope=name)),
        docstring=docstring,
        parent=self.current,
        analysis="static",
    )
    self.current.set_member(name, type_alias)
    self.extensions.call("on_instance", node=node, obj=type_alias, agent=self)
    self.extensions.call("on_type_alias_instance", node=node, type_alias=type_alias, agent=self)
```

## Inspector

```
Inspector(
    module_name: str,
    filepath: Path | None,
    extensions: Extensions,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
)
```

This class is used to instantiate an inspector.

Inspectors iterate on objects members to extract data from them.

Parameters:

- ### **`module_name`**

  (`str`) â€“ The module name.

- ### **`filepath`**

  (`Path | None`) â€“ The optional filepath.

- ### **`extensions`**

  (`Extensions`) â€“ Extensions to use when inspecting.

- ### **`parent`**

  (`Module | None`, default: `None` ) â€“ The module parent.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

Methods:

- **`generic_inspect`** â€“ Extend the base generic inspection with extensions.
- **`get_module`** â€“ Build and return the object representing the module attached to this inspector.
- **`handle_attribute`** â€“ Handle an attribute.
- **`handle_function`** â€“ Handle a function.
- **`inspect`** â€“ Extend the base inspection with extensions.
- **`inspect_attribute`** â€“ Inspect an attribute.
- **`inspect_builtin_function`** â€“ Inspect a builtin function.
- **`inspect_builtin_method`** â€“ Inspect a builtin method.
- **`inspect_cached_property`** â€“ Inspect a cached property.
- **`inspect_class`** â€“ Inspect a class.
- **`inspect_classmethod`** â€“ Inspect a class method.
- **`inspect_coroutine`** â€“ Inspect a coroutine.
- **`inspect_function`** â€“ Inspect a function.
- **`inspect_getset_descriptor`** â€“ Inspect a get/set descriptor.
- **`inspect_method`** â€“ Inspect a method.
- **`inspect_method_descriptor`** â€“ Inspect a method descriptor.
- **`inspect_module`** â€“ Inspect a module.
- **`inspect_property`** â€“ Inspect a property.
- **`inspect_staticmethod`** â€“ Inspect a static method.
- **`inspect_type_alias`** â€“ Inspect a type alias.

Attributes:

- **`current`** (`Module | Class`) â€“ The current object being inspected.
- **`docstring_options`** (`DocstringOptions`) â€“ The docstring parsing options.
- **`docstring_parser`** (`DocstringStyle | Parser | None`) â€“ The docstring parser to use.
- **`extensions`** (`Extensions`) â€“ The extensions to use when inspecting.
- **`filepath`** (`Path | None`) â€“ The module file path.
- **`lines_collection`** (`LinesCollection`) â€“ A collection of source code lines.
- **`module_name`** (`str`) â€“ The module name.
- **`modules_collection`** (`ModulesCollection`) â€“ A collection of modules.
- **`parent`** (`Module | None`) â€“ An optional parent for the final module object.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def __init__(
    self,
    module_name: str,
    filepath: Path | None,
    extensions: Extensions,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> None:
    """Initialize the inspector.

    Parameters:
        module_name: The module name.
        filepath: The optional filepath.
        extensions: Extensions to use when inspecting.
        parent: The module parent.
        docstring_parser: The docstring parser to use.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
    """
    super().__init__()

    self.module_name: str = module_name
    """The module name."""

    self.filepath: Path | None = filepath
    """The module file path."""

    self.extensions: Extensions = extensions
    """The extensions to use when inspecting."""

    self.parent: Module | None = parent
    """An optional parent for the final module object."""

    self.current: Module | Class = None  # type: ignore[assignment]
    """The current object being inspected."""

    self.docstring_parser: DocstringStyle | Parser | None = docstring_parser
    """The docstring parser to use."""

    self.docstring_options: DocstringOptions = docstring_options or {}
    """The docstring parsing options."""

    self.lines_collection: LinesCollection = lines_collection or LinesCollection()
    """A collection of source code lines."""

    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()
    """A collection of modules."""
```

### current

```
current: Module | Class = None
```

The current object being inspected.

### docstring_options

```
docstring_options: DocstringOptions = (
    docstring_options or {}
)
```

The docstring parsing options.

### docstring_parser

```
docstring_parser: DocstringStyle | Parser | None = (
    docstring_parser
)
```

The docstring parser to use.

### extensions

```
extensions: Extensions = extensions
```

The extensions to use when inspecting.

### filepath

```
filepath: Path | None = filepath
```

The module file path.

### lines_collection

```
lines_collection: LinesCollection = (
    lines_collection or LinesCollection()
)
```

A collection of source code lines.

### module_name

```
module_name: str = module_name
```

The module name.

### modules_collection

```
modules_collection: ModulesCollection = (
    modules_collection or ModulesCollection()
)
```

A collection of modules.

### parent

```
parent: Module | None = parent
```

An optional parent for the final module object.

### generic_inspect

```
generic_inspect(node: ObjectNode) -> None
```

Extend the base generic inspection with extensions.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def generic_inspect(self, node: ObjectNode) -> None:
    """Extend the base generic inspection with extensions.

    Parameters:
        node: The node to inspect.
    """
    for child in node.children:
        if target_path := child.alias_target_path:
            # If the child is an actual submodule of the current module,
            # and has no `__file__` set, we won't find it on the disk so we must inspect it now.
            # For that we instantiate a new inspector and use it to inspect the submodule,
            # then assign the submodule as member of the current module.
            # If the submodule has a `__file__` set, the loader should find it on the disk,
            # so we skip it here (no member, no alias, just skip it).
            if child.is_module and target_path == f"{self.current.path}.{child.name}":
                if not hasattr(child.obj, "__file__"):
                    logger.debug("Module %s is not discoverable on disk, inspecting right now", target_path)
                    inspector = Inspector(
                        child.name,
                        filepath=None,
                        parent=self.current.module,
                        extensions=self.extensions,
                        docstring_parser=self.docstring_parser,
                        docstring_options=self.docstring_options,
                        lines_collection=self.lines_collection,
                        modules_collection=self.modules_collection,
                    )
                    inspector.inspect_module(child)
                    self.current.set_member(child.name, inspector.current.module)
            # Otherwise, alias the object.
            else:
                alias = Alias(child.name, target_path, analysis="dynamic")
                self.current.set_member(child.name, alias)
                self.extensions.call("on_alias_instance", alias=alias, node=node, agent=self)
        else:
            self.inspect(child)
```

### get_module

```
get_module(
    import_paths: Sequence[str | Path] | None = None,
) -> Module
```

Build and return the object representing the module attached to this inspector.

This method triggers a complete inspection of the module members.

Parameters:

- #### **`import_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ Paths replacing sys.path to import the module.

Returns:

- `Module` â€“ A module instance.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def get_module(self, import_paths: Sequence[str | Path] | None = None) -> Module:
    """Build and return the object representing the module attached to this inspector.

    This method triggers a complete inspection of the module members.

    Parameters:
        import_paths: Paths replacing `sys.path` to import the module.

    Returns:
        A module instance.
    """
    import_path = self.module_name
    if self.parent is not None:
        import_path = f"{self.parent.path}.{import_path}"

    # Make sure `import_paths` is a list, in case we want to `insert` into it.
    import_paths = list(import_paths or ())

    # If the thing we want to import has a filepath,
    # we make sure to insert the right parent directory
    # at the front of our list of import paths.
    # We do this by counting the number of dots `.` in the import path,
    # corresponding to slashes `/` in the filesystem,
    # and go up in the file tree the same number of times.
    if self.filepath:
        parent_path = self.filepath.parent
        for _ in range(import_path.count(".")):
            parent_path = parent_path.parent
        # Climb up one more time for `__init__` modules.
        if self.filepath.stem == "__init__":
            parent_path = parent_path.parent
        if parent_path not in import_paths:
            import_paths.insert(0, parent_path)

    value = dynamic_import(import_path, import_paths)

    # We successfully imported the given object,
    # and we now create the object tree with all the necessary nodes,
    # from the root of the package to this leaf object.
    parent_node = None
    if self.parent is not None:
        for part in self.parent.path.split("."):
            parent_node = ObjectNode(None, name=part, parent=parent_node)
    module_node = ObjectNode(value, self.module_name, parent=parent_node)

    self.inspect(module_node)
    return self.current.module
```

### handle_attribute

```
handle_attribute(
    node: ObjectNode, annotation: str | Expr | None = None
) -> None
```

Handle an attribute.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

- #### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ A potential annotation.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def handle_attribute(self, node: ObjectNode, annotation: str | Expr | None = None) -> None:
    """Handle an attribute.

    Parameters:
        node: The node to inspect.
        annotation: A potential annotation.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_attribute_node", node=node, agent=self)

    # TODO: To improve.
    parent = self.current
    labels: set[str] = set()

    if parent.kind is Kind.MODULE:
        labels.add("module-attribute")
    elif parent.kind is Kind.CLASS:
        labels.add("class-attribute")
    elif parent.kind is Kind.FUNCTION:
        if parent.name != "__init__":
            return
        parent = parent.parent  # type: ignore[assignment]
        labels.add("instance-attribute")

    try:
        value = repr(node.obj)
    except Exception:  # noqa: BLE001
        value = None
    try:
        docstring = self._get_docstring(node)
    except Exception:  # noqa: BLE001
        docstring = None

    attribute = Attribute(
        name=node.name,
        value=value,
        annotation=annotation,
        docstring=docstring,
        analysis="dynamic",
    )
    attribute.labels |= labels
    parent.set_member(node.name, attribute)

    if node.name == "__all__":
        parent.exports = list(node.obj)
    self.extensions.call("on_instance", node=node, obj=attribute, agent=self)
    self.extensions.call("on_attribute_instance", node=node, attr=attribute, agent=self)
```

### handle_function

```
handle_function(
    node: ObjectNode, labels: set | None = None
) -> None
```

Handle a function.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

- #### **`labels`**

  (`set | None`, default: `None` ) â€“ Labels to add to the data object.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def handle_function(self, node: ObjectNode, labels: set | None = None) -> None:
    """Handle a function.

    Parameters:
        node: The node to inspect.
        labels: Labels to add to the data object.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_function_node", node=node, agent=self)

    try:
        signature = getsignature(node.obj)
    except Exception:  # noqa: BLE001
        # So many exceptions can be raised here:
        # AttributeError, NameError, RuntimeError, ValueError, TokenError, TypeError...
        parameters = None
        returns = None
    else:
        parameters = Parameters(
            *[
                _convert_parameter(parameter, parent=self.current, member=node.name)
                for parameter in signature.parameters.values()
            ],
        )
        return_annotation = signature.return_annotation
        returns = (
            None
            if return_annotation is _empty
            else _convert_object_to_annotation(return_annotation, parent=self.current, member=node.name)
        )

    lineno, endlineno = self._get_linenos(node)

    obj: Attribute | Function
    labels = labels or set()
    if "property" in labels:
        obj = Attribute(
            name=node.name,
            value=None,
            annotation=returns,
            docstring=self._get_docstring(node),
            lineno=lineno,
            endlineno=endlineno,
            analysis="dynamic",
        )
    else:
        obj = Function(
            name=node.name,
            parameters=parameters,
            returns=returns,
            type_parameters=TypeParameters(
                *_convert_type_parameters(node.obj, parent=self.current, member=node.name),
            ),
            docstring=self._get_docstring(node),
            lineno=lineno,
            endlineno=endlineno,
            analysis="dynamic",
        )
    obj.labels |= labels
    self.current.set_member(node.name, obj)
    self.extensions.call("on_instance", node=node, obj=obj, agent=self)
    if obj.is_attribute:
        self.extensions.call("on_attribute_instance", node=node, attr=obj, agent=self)
    else:
        self.extensions.call("on_function_instance", node=node, func=obj, agent=self)
```

### inspect

```
inspect(node: ObjectNode) -> None
```

Extend the base inspection with extensions.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect(self, node: ObjectNode) -> None:
    """Extend the base inspection with extensions.

    Parameters:
        node: The node to inspect.
    """
    getattr(self, f"inspect_{node.kind}", self.generic_inspect)(node)
```

### inspect_attribute

```
inspect_attribute(node: ObjectNode) -> None
```

Inspect an attribute.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_attribute(self, node: ObjectNode) -> None:
    """Inspect an attribute.

    Parameters:
        node: The node to inspect.
    """
    self.handle_attribute(node)
```

### inspect_builtin_function

```
inspect_builtin_function(node: ObjectNode) -> None
```

Inspect a builtin function.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_builtin_function(self, node: ObjectNode) -> None:
    """Inspect a builtin function.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"builtin"})
```

### inspect_builtin_method

```
inspect_builtin_method(node: ObjectNode) -> None
```

Inspect a builtin method.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_builtin_method(self, node: ObjectNode) -> None:
    """Inspect a builtin method.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"builtin"})
```

### inspect_cached_property

```
inspect_cached_property(node: ObjectNode) -> None
```

Inspect a cached property.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_cached_property(self, node: ObjectNode) -> None:
    """Inspect a cached property.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"cached", "property"})
```

### inspect_class

```
inspect_class(node: ObjectNode) -> None
```

Inspect a class.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_class(self, node: ObjectNode) -> None:
    """Inspect a class.

    Parameters:
        node: The node to inspect.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_class_node", node=node, agent=self)

    bases = []
    for base in node.obj.__bases__:
        if base is object:
            continue
        bases.append(f"{base.__module__}.{base.__qualname__}")

    lineno, endlineno = self._get_linenos(node)
    class_ = Class(
        name=node.name,
        docstring=self._get_docstring(node),
        bases=bases,
        type_parameters=TypeParameters(*_convert_type_parameters(node.obj, parent=self.current, member=node.name)),
        lineno=lineno,
        endlineno=endlineno,
        analysis="dynamic",
    )
    self.current.set_member(node.name, class_)
    self.current = class_
    self.extensions.call("on_instance", node=node, obj=class_, agent=self)
    self.extensions.call("on_class_instance", node=node, cls=class_, agent=self)
    self.generic_inspect(node)
    self.extensions.call("on_members", node=node, obj=class_, agent=self)
    self.extensions.call("on_class_members", node=node, cls=class_, agent=self)
    self.current = self.current.parent  # type: ignore[assignment]
```

### inspect_classmethod

```
inspect_classmethod(node: ObjectNode) -> None
```

Inspect a class method.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_classmethod(self, node: ObjectNode) -> None:
    """Inspect a class method.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"classmethod"})
```

### inspect_coroutine

```
inspect_coroutine(node: ObjectNode) -> None
```

Inspect a coroutine.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_coroutine(self, node: ObjectNode) -> None:
    """Inspect a coroutine.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"async"})
```

### inspect_function

```
inspect_function(node: ObjectNode) -> None
```

Inspect a function.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_function(self, node: ObjectNode) -> None:
    """Inspect a function.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node)
```

### inspect_getset_descriptor

```
inspect_getset_descriptor(node: ObjectNode) -> None
```

Inspect a get/set descriptor.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_getset_descriptor(self, node: ObjectNode) -> None:
    """Inspect a get/set descriptor.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"property"})
```

### inspect_method

```
inspect_method(node: ObjectNode) -> None
```

Inspect a method.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_method(self, node: ObjectNode) -> None:
    """Inspect a method.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node)
```

### inspect_method_descriptor

```
inspect_method_descriptor(node: ObjectNode) -> None
```

Inspect a method descriptor.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_method_descriptor(self, node: ObjectNode) -> None:
    """Inspect a method descriptor.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"method descriptor"})
```

### inspect_module

```
inspect_module(node: ObjectNode) -> None
```

Inspect a module.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_module(self, node: ObjectNode) -> None:
    """Inspect a module.

    Parameters:
        node: The node to inspect.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_module_node", node=node, agent=self)
    self.current = module = Module(
        name=self.module_name,
        filepath=self.filepath,
        parent=self.parent,
        docstring=self._get_docstring(node),
        lines_collection=self.lines_collection,
        modules_collection=self.modules_collection,
        analysis="dynamic",
    )
    self.extensions.call("on_instance", node=node, obj=module, agent=self)
    self.extensions.call("on_module_instance", node=node, mod=module, agent=self)
    self.generic_inspect(node)
    self.extensions.call("on_members", node=node, obj=module, agent=self)
    self.extensions.call("on_module_members", node=node, mod=module, agent=self)
```

### inspect_property

```
inspect_property(node: ObjectNode) -> None
```

Inspect a property.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_property(self, node: ObjectNode) -> None:
    """Inspect a property.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"property"})
```

### inspect_staticmethod

```
inspect_staticmethod(node: ObjectNode) -> None
```

Inspect a static method.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_staticmethod(self, node: ObjectNode) -> None:
    """Inspect a static method.

    Parameters:
        node: The node to inspect.
    """
    self.handle_function(node, {"staticmethod"})
```

### inspect_type_alias

```
inspect_type_alias(node: ObjectNode) -> None
```

Inspect a type alias.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/agents/inspector.py`

```
def inspect_type_alias(self, node: ObjectNode) -> None:
    """Inspect a type alias.

    Parameters:
        node: The node to inspect.
    """
    self.extensions.call("on_node", node=node, agent=self)
    self.extensions.call("on_type_alias_node", node=node, agent=self)

    lineno, endlineno = self._get_linenos(node)

    type_alias = TypeAlias(
        name=node.name,
        value=_convert_type_to_annotation(node.obj.__value__, parent=self.current, member=node.name),
        lineno=lineno,
        endlineno=endlineno,
        type_parameters=TypeParameters(*_convert_type_parameters(node.obj, parent=self.current, member=node.name)),
        docstring=self._get_docstring(node),
        parent=self.current,
        analysis="dynamic",
    )
    self.current.set_member(node.name, type_alias)
    self.extensions.call("on_instance", node=node, obj=type_alias, agent=self)
    self.extensions.call("on_type_alias_instance", node=node, type_alias=type_alias, agent=self)
```

## **Dynamic analysis helpers**

## sys_path

```
sys_path(*paths: str | Path) -> Iterator[None]
```

Redefine `sys.path` temporarily.

Parameters:

- ### **`*paths`**

  (`str | Path`, default: `()` ) â€“ The paths to use when importing modules. If no paths are given, keep sys.path untouched.

Yields:

- `None` â€“ Nothing.

Source code in `src/griffe/_internal/importer.py`

```
@contextmanager
def sys_path(*paths: str | Path) -> Iterator[None]:
    """Redefine `sys.path` temporarily.

    Parameters:
        *paths: The paths to use when importing modules.
            If no paths are given, keep `sys.path` untouched.

    Yields:
        Nothing.
    """
    if not paths:
        yield
        return
    old_path = sys.path
    sys.path = [str(path) for path in paths]
    try:
        yield
    finally:
        sys.path = old_path
```

## dynamic_import

```
dynamic_import(
    import_path: str,
    import_paths: Sequence[str | Path] | None = None,
) -> Any
```

Dynamically import the specified object.

It can be a module, class, method, function, attribute, type alias, nested arbitrarily.

It works like this:

- for a given object path `a.b.x.y`
- it tries to import `a.b.x.y` as a module (with `importlib.import_module`)
- if it fails, it tries again with `a.b.x`, storing `y`
- then `a.b`, storing `x.y`
- then `a`, storing `b.x.y`
- if nothing worked, it raises an error
- if one of the iteration worked, it moves on, and...
- it tries to get the remaining (stored) parts with `getattr`
- for example it gets `b` from `a`, then `x` from `b`, etc.
- if a single attribute access fails, it raises an error
- if everything worked, it returns the last obtained attribute

Since the function potentially tries multiple things before succeeding, all errors happening along the way are recorded, and re-emitted with an `ImportError` when it fails, to let users know what was tried.

Important

The paths given through the `import_paths` parameter are used to temporarily patch `sys.path`: this function is therefore not thread-safe.

Important

The paths given as `import_paths` must be *correct*. The contents of `sys.path` must be consistent to what a user of the imported code would expect. Given a set of paths, if the import fails for a user, it will fail here too, with potentially unintuitive errors. If we wanted to make this function more robust, we could add a loop to "roll the window" of given paths, shifting them to the left (for example: `("/a/a", "/a/b", "/a/c/")`, then `("/a/b", "/a/c", "/a/a/")`, then `("/a/c", "/a/a", "/a/b/")`), to make sure each entry is given highest priority at least once, maintaining relative order, but we deem this unnecessary for now.

Parameters:

- ### **`import_path`**

  (`str`) â€“ The path of the object to import.

- ### **`import_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The (sys) paths to import the object from.

Raises:

- `ModuleNotFoundError` â€“ When the object's module could not be found.
- `ImportError` â€“ When there was an import error or when couldn't get the attribute.

Returns:

- `Any` â€“ The imported object.

Source code in `src/griffe/_internal/importer.py`

```
def dynamic_import(import_path: str, import_paths: Sequence[str | Path] | None = None) -> Any:
    """Dynamically import the specified object.

    It can be a module, class, method, function, attribute, type alias,
    nested arbitrarily.

    It works like this:

    - for a given object path `a.b.x.y`
    - it tries to import `a.b.x.y` as a module (with `importlib.import_module`)
    - if it fails, it tries again with `a.b.x`, storing `y`
    - then `a.b`, storing `x.y`
    - then `a`, storing `b.x.y`
    - if nothing worked, it raises an error
    - if one of the iteration worked, it moves on, and...
    - it tries to get the remaining (stored) parts with `getattr`
    - for example it gets `b` from `a`, then `x` from `b`, etc.
    - if a single attribute access fails, it raises an error
    - if everything worked, it returns the last obtained attribute

    Since the function potentially tries multiple things before succeeding,
    all errors happening along the way are recorded, and re-emitted with
    an `ImportError` when it fails, to let users know what was tried.

    IMPORTANT: The paths given through the `import_paths` parameter are used
    to temporarily patch `sys.path`: this function is therefore not thread-safe.

    IMPORTANT: The paths given as `import_paths` must be *correct*.
    The contents of `sys.path` must be consistent to what a user of the imported code
    would expect. Given a set of paths, if the import fails for a user, it will fail here too,
    with potentially unintuitive errors. If we wanted to make this function more robust,
    we could add a loop to "roll the window" of given paths, shifting them to the left
    (for example: `("/a/a", "/a/b", "/a/c/")`, then `("/a/b", "/a/c", "/a/a/")`,
    then `("/a/c", "/a/a", "/a/b/")`), to make sure each entry is given highest priority
    at least once, maintaining relative order, but we deem this unnecessary for now.

    Parameters:
        import_path: The path of the object to import.
        import_paths: The (sys) paths to import the object from.

    Raises:
        ModuleNotFoundError: When the object's module could not be found.
        ImportError: When there was an import error or when couldn't get the attribute.

    Returns:
        The imported object.
    """
    module_parts: list[str] = import_path.split(".")
    object_parts: list[str] = []
    errors = []

    with sys_path(*(import_paths or ())):
        while module_parts:
            module_path = ".".join(module_parts)
            try:
                module = import_module(module_path)
            except BaseException as error:  # noqa: BLE001
                # pyo3's PanicException can only be caught with BaseException.
                # We do want to catch base exceptions anyway (exit, interrupt, etc.).
                errors.append(_error_details(error, module_path))
                object_parts.insert(0, module_parts.pop(-1))
            else:
                break
        else:
            raise ImportError("; ".join(errors))

        # Sometimes extra dependencies are not installed,
        # so importing the leaf module fails with a ModuleNotFoundError,
        # or later `getattr` triggers additional code that fails.
        # In these cases, and for consistency, we always re-raise an ImportError
        # instead of an any other exception (it's called "dynamic import" after all).
        # See https://github.com/mkdocstrings/mkdocstrings/issues/380.
        value = module
        for part in object_parts:
            try:
                value = getattr(value, part)
            except BaseException as error:  # noqa: BLE001
                errors.append(_error_details(error, module_path + ":" + ".".join(object_parts)))
                raise ImportError("; ".join(errors))  # noqa: B904

    return value
```

## ObjectNode

```
ObjectNode(
    obj: Any, name: str, parent: ObjectNode | None = None
)
```

Helper class to represent an object tree.

It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).

Each node stores an object, its name, and a reference to its parent node.

Parameters:

- ### **`obj`**

  (`Any`) â€“ A Python object.

- ### **`name`**

  (`str`) â€“ The object's name.

- ### **`parent`**

  (`ObjectNode | None`, default: `None` ) â€“ The object's parent node.

Attributes:

- **`alias_target_path`** (`str | None`) â€“ Alias target path of this node, if the node should be an alias.
- **`children`** (`Sequence[ObjectNode]`) â€“ The children of this node.
- **`exclude_specials`** (`set[str]`) â€“ Low level attributes known to cause issues when resolving aliases.
- **`is_attribute`** (`bool`) â€“ Whether this node's object is an attribute.
- **`is_builtin_function`** (`bool`) â€“ Whether this node's object is a builtin function.
- **`is_builtin_method`** (`bool`) â€“ Whether this node's object is a builtin method.
- **`is_cached_property`** (`bool`) â€“ Whether this node's object is a cached property.
- **`is_class`** (`bool`) â€“ Whether this node's object is a class.
- **`is_classmethod`** (`bool`) â€“ Whether this node's object is a classmethod.
- **`is_coroutine`** (`bool`) â€“ Whether this node's object is a coroutine.
- **`is_function`** (`bool`) â€“ Whether this node's object is a function.
- **`is_getset_descriptor`** (`bool`) â€“ Whether this node's object is a get/set descriptor.
- **`is_method`** (`bool`) â€“ Whether this node's object is a method.
- **`is_method_descriptor`** (`bool`) â€“ Whether this node's object is a method descriptor.
- **`is_module`** (`bool`) â€“ Whether this node's object is a module.
- **`is_property`** (`bool`) â€“ Whether this node's object is a property.
- **`is_staticmethod`** (`bool`) â€“ Whether this node's object is a staticmethod.
- **`is_type_alias`** (`bool`) â€“ Whether this node's object is a type alias.
- **`kind`** (`ObjectKind`) â€“ The kind of this node.
- **`module`** (`ObjectNode`) â€“ The object's module, fetched from the node tree.
- **`module_path`** (`str | None`) â€“ The object's module path.
- **`name`** (`str`) â€“ The Python object's name.
- **`obj`** (`Any`) â€“ The actual Python object.
- **`parent`** (`ObjectNode | None`) â€“ The parent node.
- **`parent_is_class`** (`bool`) â€“ Whether the object of this node's parent is a class.
- **`path`** (`str`) â€“ The object's (Python) path.

Source code in `src/griffe/_internal/agents/nodes/runtime.py`

```
def __init__(self, obj: Any, name: str, parent: ObjectNode | None = None) -> None:
    """Initialize the object.

    Parameters:
        obj: A Python object.
        name: The object's name.
        parent: The object's parent node.
    """
    # Unwrap object.
    try:
        obj = inspect.unwrap(obj)
    except Exception as error:  # noqa: BLE001
        # `inspect.unwrap` at some point runs `hasattr(obj, "__wrapped__")`,
        # which triggers the `__getattr__` method of the object, which in
        # turn can raise various exceptions. Probably not just `__getattr__`.
        # See https://github.com/pawamoy/pytkdocs/issues/45.
        logger.debug("Could not unwrap %s: %r", name, error)

    # Unwrap cached properties (`inspect.unwrap` doesn't do that).
    if isinstance(obj, cached_property):
        is_cached_property = True
        obj = obj.func
    else:
        is_cached_property = False

    self.obj: Any = obj
    """The actual Python object."""
    self.name: str = name
    """The Python object's name."""
    self.parent: ObjectNode | None = parent
    """The parent node."""
    self.is_cached_property: bool = is_cached_property
    """Whether this node's object is a cached property."""
```

### alias_target_path

```
alias_target_path: str | None
```

Alias target path of this node, if the node should be an alias.

### children

```
children: Sequence[ObjectNode]
```

The children of this node.

### exclude_specials

```
exclude_specials: set[str] = {
    "__builtins__",
    "__loader__",
    "__spec__",
}
```

Low level attributes known to cause issues when resolving aliases.

### is_attribute

```
is_attribute: bool
```

Whether this node's object is an attribute.

### is_builtin_function

```
is_builtin_function: bool
```

Whether this node's object is a builtin function.

### is_builtin_method

```
is_builtin_method: bool
```

Whether this node's object is a builtin method.

### is_cached_property

```
is_cached_property: bool = is_cached_property
```

Whether this node's object is a cached property.

### is_class

```
is_class: bool
```

Whether this node's object is a class.

### is_classmethod

```
is_classmethod: bool
```

Whether this node's object is a classmethod.

### is_coroutine

```
is_coroutine: bool
```

Whether this node's object is a coroutine.

### is_function

```
is_function: bool
```

Whether this node's object is a function.

### is_getset_descriptor

```
is_getset_descriptor: bool
```

Whether this node's object is a get/set descriptor.

### is_method

```
is_method: bool
```

Whether this node's object is a method.

### is_method_descriptor

```
is_method_descriptor: bool
```

Whether this node's object is a method descriptor.

Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods.

### is_module

```
is_module: bool
```

Whether this node's object is a module.

### is_property

```
is_property: bool
```

Whether this node's object is a property.

### is_staticmethod

```
is_staticmethod: bool
```

Whether this node's object is a staticmethod.

### is_type_alias

```
is_type_alias: bool
```

Whether this node's object is a type alias.

### kind

```
kind: ObjectKind
```

The kind of this node.

### module

```
module: ObjectNode
```

The object's module, fetched from the node tree.

### module_path

```
module_path: str | None
```

The object's module path.

### name

```
name: str = name
```

The Python object's name.

### obj

```
obj: Any = obj
```

The actual Python object.

### parent

```
parent: ObjectNode | None = parent
```

The parent node.

### parent_is_class

```
parent_is_class: bool
```

Whether the object of this node's parent is a class.

### path

```
path: str
```

The object's (Python) path.

## ObjectKind

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.ObjectKind[ObjectKind]

              

              click griffe.ObjectKind href "" "griffe.ObjectKind"
```

Enumeration of the different runtime object kinds.

Attributes:

- **`ATTRIBUTE`** â€“ Attributes.
- **`BUILTIN_FUNCTION`** â€“ Built-in functions.
- **`BUILTIN_METHOD`** â€“ Built-in methods.
- **`CACHED_PROPERTY`** â€“ Cached properties.
- **`CLASS`** â€“ Classes.
- **`CLASSMETHOD`** â€“ Class methods.
- **`COROUTINE`** â€“ Coroutines
- **`FUNCTION`** â€“ Functions.
- **`GETSET_DESCRIPTOR`** â€“ Get/set descriptors.
- **`METHOD`** â€“ Methods.
- **`METHOD_DESCRIPTOR`** â€“ Method descriptors.
- **`MODULE`** â€“ Modules.
- **`PROPERTY`** â€“ Properties.
- **`STATICMETHOD`** â€“ Static methods.
- **`TYPE_ALIAS`** â€“ Type aliases.

### ATTRIBUTE

```
ATTRIBUTE = 'attribute'
```

Attributes.

### BUILTIN_FUNCTION

```
BUILTIN_FUNCTION = 'builtin_function'
```

Built-in functions.

### BUILTIN_METHOD

```
BUILTIN_METHOD = 'builtin_method'
```

Built-in methods.

### CACHED_PROPERTY

```
CACHED_PROPERTY = 'cached_property'
```

Cached properties.

### CLASS

```
CLASS = 'class'
```

Classes.

### CLASSMETHOD

```
CLASSMETHOD = 'classmethod'
```

Class methods.

### COROUTINE

```
COROUTINE = 'coroutine'
```

Coroutines

### FUNCTION

```
FUNCTION = 'function'
```

Functions.

### GETSET_DESCRIPTOR

```
GETSET_DESCRIPTOR = 'getset_descriptor'
```

Get/set descriptors.

### METHOD

```
METHOD = 'method'
```

Methods.

### METHOD_DESCRIPTOR

```
METHOD_DESCRIPTOR = 'method_descriptor'
```

Method descriptors.

### MODULE

```
MODULE = 'module'
```

Modules.

### PROPERTY

```
PROPERTY = 'property'
```

Properties.

### STATICMETHOD

```
STATICMETHOD = 'staticmethod'
```

Static methods.

### TYPE_ALIAS

```
TYPE_ALIAS = 'type_alias'
```

Type aliases.

## **Static analysis helpers**

## builtin_decorators

```
builtin_decorators = {
    "property": "property",
    "staticmethod": "staticmethod",
    "classmethod": "classmethod",
}
```

Mapping of builtin decorators to labels.

## stdlib_decorators

```
stdlib_decorators = {
    "abc.abstractmethod": {"abstractmethod"},
    "functools.cache": {"cached"},
    "functools.cached_property": {"cached", "property"},
    "cached_property.cached_property": {
        "cached",
        "property",
    },
    "functools.lru_cache": {"cached"},
    "dataclasses.dataclass": {"dataclass"},
}
```

Mapping of standard library decorators to labels.

## typing_overload

```
typing_overload = {
    "typing.overload",
    "typing_extensions.overload",
}
```

Set of recognized typing overload decorators.

When such a decorator is found, the decorated function becomes an overload.

## ast_kind

```
ast_kind(node: AST) -> str
```

Return the kind of an AST node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Returns:

- `str` â€“ The node kind.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_kind(node: AST) -> str:
    """Return the kind of an AST node.

    Parameters:
        node: The AST node.

    Returns:
        The node kind.
    """
    return node.__class__.__name__.lower()
```

## ast_children

```
ast_children(node: AST) -> Iterator[AST]
```

Return the children of an AST node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Yields:

- `AST` â€“ The node children.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_children(node: AST) -> Iterator[AST]:
    """Return the children of an AST node.

    Parameters:
        node: The AST node.

    Yields:
        The node children.
    """
    for field_name in node._fields:
        try:
            field = getattr(node, field_name)
        except AttributeError:
            continue
        if isinstance(field, AST):
            field.parent = node  # type: ignore[attr-defined]
            yield field
        elif isinstance(field, list):
            for child in field:
                if isinstance(child, AST):
                    child.parent = node  # type: ignore[attr-defined]
                    yield child
```

## ast_previous_siblings

```
ast_previous_siblings(node: AST) -> Iterator[AST]
```

Return the previous siblings of this node, starting from the closest.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Yields:

- `AST` â€“ The previous siblings.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_previous_siblings(node: AST) -> Iterator[AST]:
    """Return the previous siblings of this node, starting from the closest.

    Parameters:
        node: The AST node.

    Yields:
        The previous siblings.
    """
    for sibling in ast_children(node.parent):  # type: ignore[attr-defined]
        if sibling is not node:
            yield sibling
        else:
            return
```

## ast_next_siblings

```
ast_next_siblings(node: AST) -> Iterator[AST]
```

Return the next siblings of this node, starting from the closest.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Yields:

- `AST` â€“ The next siblings.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_next_siblings(node: AST) -> Iterator[AST]:
    """Return the next siblings of this node, starting from the closest.

    Parameters:
        node: The AST node.

    Yields:
        The next siblings.
    """
    siblings = ast_children(node.parent)  # type: ignore[attr-defined]
    for sibling in siblings:
        if sibling is node:
            break
    yield from siblings
```

## ast_siblings

```
ast_siblings(node: AST) -> Iterator[AST]
```

Return the siblings of this node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Yields:

- `AST` â€“ The siblings.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_siblings(node: AST) -> Iterator[AST]:
    """Return the siblings of this node.

    Parameters:
        node: The AST node.

    Yields:
        The siblings.
    """
    siblings = ast_children(node.parent)  # type: ignore[attr-defined]
    for sibling in siblings:
        if sibling is not node:
            yield sibling
        else:
            break
    yield from siblings
```

## ast_previous

```
ast_previous(node: AST) -> AST
```

Return the previous sibling of this node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Raises:

- `LastNodeError` â€“ When the node does not have previous siblings.

Returns:

- `AST` â€“ The sibling.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_previous(node: AST) -> AST:
    """Return the previous sibling of this node.

    Parameters:
        node: The AST node.

    Raises:
        LastNodeError: When the node does not have previous siblings.

    Returns:
        The sibling.
    """
    try:
        *_, last = ast_previous_siblings(node)
    except ValueError:
        raise LastNodeError("there is no previous node") from None
    return last
```

## ast_next

```
ast_next(node: AST) -> AST
```

Return the next sibling of this node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Raises:

- `LastNodeError` â€“ When the node does not have next siblings.

Returns:

- `AST` â€“ The sibling.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_next(node: AST) -> AST:
    """Return the next sibling of this node.

    Parameters:
        node: The AST node.

    Raises:
        LastNodeError: When the node does not have next siblings.

    Returns:
        The sibling.
    """
    try:
        return next(ast_next_siblings(node))
    except StopIteration:
        raise LastNodeError("there is no next node") from None
```

## ast_first_child

```
ast_first_child(node: AST) -> AST
```

Return the first child of this node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Raises:

- `LastNodeError` â€“ When the node does not have children.

Returns:

- `AST` â€“ The child.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_first_child(node: AST) -> AST:
    """Return the first child of this node.

    Parameters:
        node: The AST node.

    Raises:
        LastNodeError: When the node does not have children.

    Returns:
        The child.
    """
    try:
        return next(ast_children(node))
    except StopIteration as error:
        raise LastNodeError("there are no children node") from error
```

## ast_last_child

```
ast_last_child(node: AST) -> AST
```

Return the lasts child of this node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The AST node.

Raises:

- `LastNodeError` â€“ When the node does not have children.

Returns:

- `AST` â€“ The child.

Source code in `src/griffe/_internal/agents/nodes/ast.py`

```
def ast_last_child(node: AST) -> AST:
    """Return the lasts child of this node.

    Parameters:
        node: The AST node.

    Raises:
        LastNodeError: When the node does not have children.

    Returns:
        The child.
    """
    try:
        *_, last = ast_children(node)
    except ValueError as error:
        raise LastNodeError("there are no children node") from error
    return last
```

## get_docstring

```
get_docstring(
    node: AST, *, strict: bool = False
) -> tuple[str | None, int | None, int | None]
```

Extract a docstring.

Parameters:

- ### **`node`**

  (`AST`) â€“ The node to extract the docstring from.

- ### **`strict`**

  (`bool`, default: `False` ) â€“ Whether to skip searching the body (functions).

Returns:

- `tuple[str | None, int | None, int | None]` â€“ A tuple with the value and line numbers of the docstring.

Source code in `src/griffe/_internal/agents/nodes/docstrings.py`

```
def get_docstring(
    node: ast.AST,
    *,
    strict: bool = False,
) -> tuple[str | None, int | None, int | None]:
    """Extract a docstring.

    Parameters:
        node: The node to extract the docstring from.
        strict: Whether to skip searching the body (functions).

    Returns:
        A tuple with the value and line numbers of the docstring.
    """
    # TODO: Possible optimization using a type map.
    if isinstance(node, ast.Expr):
        doc = node.value
    elif not strict and node.body and isinstance(node.body, list) and isinstance(node.body[0], ast.Expr):  # type: ignore[attr-defined]
        doc = node.body[0].value  # type: ignore[attr-defined]
    else:
        return None, None, None
    if isinstance(doc, ast.Constant) and isinstance(doc.value, str):
        return doc.value, doc.lineno, doc.end_lineno
    return None, None, None
```

## get_name

```
get_name(node: AST) -> str
```

Extract name from an assignment node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The node to extract names from.

Returns:

- `str` â€“ A list of names.

Source code in `src/griffe/_internal/agents/nodes/assignments.py`

```
def get_name(node: ast.AST) -> str:
    """Extract name from an assignment node.

    Parameters:
        node: The node to extract names from.

    Returns:
        A list of names.
    """
    return _node_name_map[type(node)](node)
```

## get_names

```
get_names(node: AST) -> list[str]
```

Extract names from an assignment node.

Parameters:

- ### **`node`**

  (`AST`) â€“ The node to extract names from.

Returns:

- `list[str]` â€“ A list of names.

Source code in `src/griffe/_internal/agents/nodes/assignments.py`

```
def get_names(node: ast.AST) -> list[str]:
    """Extract names from an assignment node.

    Parameters:
        node: The node to extract names from.

    Returns:
        A list of names.
    """
    return _node_names_map[type(node)](node)
```

## get_instance_names

```
get_instance_names(node: AST) -> list[str]
```

Extract names from an assignment node, only for instance attributes.

Parameters:

- ### **`node`**

  (`AST`) â€“ The node to extract names from.

Returns:

- `list[str]` â€“ A list of names.

Source code in `src/griffe/_internal/agents/nodes/assignments.py`

```
def get_instance_names(node: ast.AST) -> list[str]:
    """Extract names from an assignment node, only for instance attributes.

    Parameters:
        node: The node to extract names from.

    Returns:
        A list of names.
    """
    return [name.split(".", 1)[1] for name in get_names(node) if name.startswith("self.")]
```

## get\_\_all\_\_

```
get__all__(
    node: Assign | AnnAssign | AugAssign, parent: Module
) -> list[str | ExprName]
```

Get the values declared in `__all__`.

Parameters:

- ### **`node`**

  (`Assign | AnnAssign | AugAssign`) â€“ The assignment node.

- ### **`parent`**

  (`Module`) â€“ The parent module.

Returns:

- `list[str | ExprName]` â€“ A set of names.

Source code in `src/griffe/_internal/agents/nodes/exports.py`

```
def get__all__(node: ast.Assign | ast.AnnAssign | ast.AugAssign, parent: Module) -> list[str | ExprName]:
    """Get the values declared in `__all__`.

    Parameters:
        node: The assignment node.
        parent: The parent module.

    Returns:
        A set of names.
    """
    if node.value is None:
        return []
    return _extract(node.value, parent)
```

## safe_get\_\_all\_\_

```
safe_get__all__(
    node: Assign | AnnAssign | AugAssign,
    parent: Module,
    log_level: LogLevel = debug,
) -> list[str | ExprName]
```

Safely (no exception) extract values in `__all__`.

Parameters:

- ### **`node`**

  (`Assign | AnnAssign | AugAssign`) â€“ The __all__ assignment node.

- ### **`parent`**

  (`Module`) â€“ The parent used to resolve the names.

- ### **`log_level`**

  (`LogLevel`, default: `debug` ) â€“ Log level to use to log a message.

Returns:

- `list[str | ExprName]` â€“ A list of strings or resolvable names.

Source code in `src/griffe/_internal/agents/nodes/exports.py`

```
def safe_get__all__(
    node: ast.Assign | ast.AnnAssign | ast.AugAssign,
    parent: Module,
    log_level: LogLevel = LogLevel.debug,  # TODO: Set to error when we handle more things?
) -> list[str | ExprName]:
    """Safely (no exception) extract values in `__all__`.

    Parameters:
        node: The `__all__` assignment node.
        parent: The parent used to resolve the names.
        log_level: Log level to use to log a message.

    Returns:
        A list of strings or resolvable names.
    """
    try:
        return get__all__(node, parent)
    except Exception as error:  # noqa: BLE001
        message = f"Failed to extract `__all__` value: {get_value(node.value)}"
        with suppress(Exception):
            message += f" at {parent.relative_filepath}:{node.lineno}"
        if isinstance(error, KeyError):
            message += f": unsupported node {error}"
        else:
            message += f": {error}"
        getattr(logger, log_level.value)(message)
        return []
```

## relative_to_absolute

```
relative_to_absolute(
    node: ImportFrom, name: alias, current_module: Module
) -> str
```

Convert a relative import path to an absolute one.

Parameters:

- ### **`node`**

  (`ImportFrom`) â€“ The "from ... import ..." AST node.

- ### **`name`**

  (`alias`) â€“ The imported name.

- ### **`current_module`**

  (`Module`) â€“ The module in which the import happens.

Returns:

- `str` â€“ The absolute import path.

Source code in `src/griffe/_internal/agents/nodes/imports.py`

```
def relative_to_absolute(node: ast.ImportFrom, name: ast.alias, current_module: Module) -> str:
    """Convert a relative import path to an absolute one.

    Parameters:
        node: The "from ... import ..." AST node.
        name: The imported name.
        current_module: The module in which the import happens.

    Returns:
        The absolute import path.
    """
    level = node.level
    if (level > 0 and current_module.is_package) or current_module.is_subpackage:
        level -= 1
    while level > 0 and current_module.parent is not None:
        current_module = current_module.parent  # type: ignore[assignment]
        level -= 1
    base = current_module.path + "." if node.level > 0 else ""
    node_module = node.module + "." if node.module else ""
    return base + node_module + name.name
```

## get_parameters

```
get_parameters(node: arguments) -> ParametersType
```

Source code in `src/griffe/_internal/agents/nodes/parameters.py`

```
def get_parameters(node: ast.arguments) -> ParametersType:
    parameters: ParametersType = []

    # TODO: Probably some optimizations to do here.
    args_kinds_defaults: Iterable = reversed(
        (
            *zip_longest(
                reversed(
                    (
                        *zip_longest(
                            node.posonlyargs,
                            [],
                            fillvalue=ParameterKind.positional_only,
                        ),
                        *zip_longest(node.args, [], fillvalue=ParameterKind.positional_or_keyword),
                    ),
                ),
                reversed(node.defaults),
                fillvalue=None,
            ),
        ),
    )
    arg: ast.arg
    kind: ParameterKind
    arg_default: ast.AST | None
    for (arg, kind), arg_default in args_kinds_defaults:
        parameters.append((arg.arg, arg.annotation, kind, arg_default))

    if node.vararg:
        parameters.append(
            (
                node.vararg.arg,
                node.vararg.annotation,
                ParameterKind.var_positional,
                "()",
            ),
        )

    # TODO: Probably some optimizations to do here.
    kwargs_defaults: Iterable = reversed(
        (
            *zip_longest(
                reversed(node.kwonlyargs),
                reversed(node.kw_defaults),
                fillvalue=None,
            ),
        ),
    )
    kwarg: ast.arg
    kwarg_default: ast.AST | None
    for kwarg, kwarg_default in kwargs_defaults:
        parameters.append(
            (kwarg.arg, kwarg.annotation, ParameterKind.keyword_only, kwarg_default),
        )

    if node.kwarg:
        parameters.append(
            (
                node.kwarg.arg,
                node.kwarg.annotation,
                ParameterKind.var_keyword,
                "{}",
            ),
        )

    return parameters
```

## get_value

```
get_value(node: AST | None) -> str | None
```

Get the string representation of a node.

Parameters:

- ### **`node`**

  (`AST | None`) â€“ The node to represent.

Returns:

- `str | None` â€“ The representing code for the node.

Source code in `src/griffe/_internal/agents/nodes/values.py`

```
def get_value(node: ast.AST | None) -> str | None:
    """Get the string representation of a node.

    Parameters:
        node: The node to represent.

    Returns:
        The representing code for the node.
    """
    if node is None:
        return None
    return unparse(node)
```

## safe_get_value

```
safe_get_value(
    node: AST | None, filepath: str | Path | None = None
) -> str | None
```

Safely (no exception) get the string representation of a node.

Parameters:

- ### **`node`**

  (`AST | None`) â€“ The node to represent.

- ### **`filepath`**

  (`str | Path | None`, default: `None` ) â€“ An optional filepath from where the node comes.

Returns:

- `str | None` â€“ The representing code for the node.

Source code in `src/griffe/_internal/agents/nodes/values.py`

```
def safe_get_value(node: ast.AST | None, filepath: str | Path | None = None) -> str | None:
    """Safely (no exception) get the string representation of a node.

    Parameters:
        node: The node to represent.
        filepath: An optional filepath from where the node comes.

    Returns:
        The representing code for the node.
    """
    try:
        return get_value(node)
    except Exception as error:  # noqa: BLE001
        message = f"Failed to represent node {node}"
        if filepath:
            message += f" at {filepath}:{node.lineno}"  # type: ignore[union-attr]
        message += f": {error}"
        logger.exception(message)
        return None
```

## **Deprecated API**

## ExportedName

```
ExportedName(name: str, parent: Module)
```

Deprecated. An intermediate class to store names.

The get\_\_all\_\_ function now returns instances of ExprName instead.

Attributes:

- **`name`** (`str`) â€“ The exported name.
- **`parent`** (`Module`) â€“ The parent module.

### name

```
name: str
```

The exported name.

### parent

```
parent: Module
```

The parent module.

# API checks

## find_breaking_changes

```
find_breaking_changes(
    old_obj: Object | Alias, new_obj: Object | Alias
) -> Iterator[Breakage]
```

Find breaking changes between two versions of the same API.

The function will iterate recursively on all objects and yield breaking changes with detailed information.

Parameters:

- ### **`old_obj`**

  (`Object | Alias`) â€“ The old version of an object.

- ### **`new_obj`**

  (`Object | Alias`) â€“ The new version of an object.

Yields:

- `Breakage` â€“ Breaking changes.

Examples:

```
>>> import sys, griffe
>>> new = griffe.load("pkg")
>>> old = griffe.load_git("pkg", "1.2.3")
>>> for breakage in griffe.find_breaking_changes(old, new)
...     print(breakage.explain(style=style), file=sys.stderr)
```

Source code in `src/griffe/_internal/diff.py`

```
def find_breaking_changes(
    old_obj: Object | Alias,
    new_obj: Object | Alias,
) -> Iterator[Breakage]:
    """Find breaking changes between two versions of the same API.

    The function will iterate recursively on all objects
    and yield breaking changes with detailed information.

    Parameters:
        old_obj: The old version of an object.
        new_obj: The new version of an object.

    Yields:
        Breaking changes.

    Examples:
        >>> import sys, griffe
        >>> new = griffe.load("pkg")
        >>> old = griffe.load_git("pkg", "1.2.3")
        >>> for breakage in griffe.find_breaking_changes(old, new)
        ...     print(breakage.explain(style=style), file=sys.stderr)
    """
    yield from _member_incompatibilities(old_obj, new_obj)
```

## ExplanationStyle

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.ExplanationStyle[ExplanationStyle]

              

              click griffe.ExplanationStyle href "" "griffe.ExplanationStyle"
```

Enumeration of the possible styles for explanations.

Attributes:

- **`GITHUB`** â€“ Explanation as GitHub workflow commands warnings, adapted to CI.
- **`MARKDOWN`** â€“ Explanations in Markdown, adapted to changelogs.
- **`ONE_LINE`** â€“ Explanations on one-line.
- **`VERBOSE`** â€“ Explanations on multiple lines.

### GITHUB

```
GITHUB = 'github'
```

Explanation as GitHub workflow commands warnings, adapted to CI.

### MARKDOWN

```
MARKDOWN = 'markdown'
```

Explanations in Markdown, adapted to changelogs.

### ONE_LINE

```
ONE_LINE = 'oneline'
```

Explanations on one-line.

### VERBOSE

```
VERBOSE = 'verbose'
```

Explanations on multiple lines.

## Breakage

```
Breakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Breakages can explain what broke from a version to another.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## BreakageKind

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.BreakageKind[BreakageKind]

              

              click griffe.BreakageKind href "" "griffe.BreakageKind"
```

Enumeration of the possible API breakages.

Attributes:

- **`ATTRIBUTE_CHANGED_TYPE`** â€“ Attribute types are incompatible
- **`ATTRIBUTE_CHANGED_VALUE`** â€“ Attribute value was changed
- **`CLASS_REMOVED_BASE`** â€“ Base class was removed
- **`OBJECT_CHANGED_KIND`** â€“ Public object points to a different kind of object
- **`OBJECT_REMOVED`** â€“ Public object was removed
- **`PARAMETER_ADDED_REQUIRED`** â€“ Parameter was added as required
- **`PARAMETER_CHANGED_DEFAULT`** â€“ Parameter default was changed
- **`PARAMETER_CHANGED_KIND`** â€“ Parameter kind was changed
- **`PARAMETER_CHANGED_REQUIRED`** â€“ Parameter is now required
- **`PARAMETER_MOVED`** â€“ Positional parameter was moved
- **`PARAMETER_REMOVED`** â€“ Parameter was removed
- **`RETURN_CHANGED_TYPE`** â€“ Return types are incompatible

### ATTRIBUTE_CHANGED_TYPE

```
ATTRIBUTE_CHANGED_TYPE = 'Attribute types are incompatible'
```

Attribute types are incompatible

### ATTRIBUTE_CHANGED_VALUE

```
ATTRIBUTE_CHANGED_VALUE = 'Attribute value was changed'
```

Attribute value was changed

### CLASS_REMOVED_BASE

```
CLASS_REMOVED_BASE = 'Base class was removed'
```

Base class was removed

### OBJECT_CHANGED_KIND

```
OBJECT_CHANGED_KIND = (
    "Public object points to a different kind of object"
)
```

Public object points to a different kind of object

### OBJECT_REMOVED

```
OBJECT_REMOVED = 'Public object was removed'
```

Public object was removed

### PARAMETER_ADDED_REQUIRED

```
PARAMETER_ADDED_REQUIRED = "Parameter was added as required"
```

Parameter was added as required

### PARAMETER_CHANGED_DEFAULT

```
PARAMETER_CHANGED_DEFAULT = 'Parameter default was changed'
```

Parameter default was changed

### PARAMETER_CHANGED_KIND

```
PARAMETER_CHANGED_KIND = 'Parameter kind was changed'
```

Parameter kind was changed

### PARAMETER_CHANGED_REQUIRED

```
PARAMETER_CHANGED_REQUIRED = 'Parameter is now required'
```

Parameter is now required

### PARAMETER_MOVED

```
PARAMETER_MOVED = 'Positional parameter was moved'
```

Positional parameter was moved

### PARAMETER_REMOVED

```
PARAMETER_REMOVED = 'Parameter was removed'
```

Parameter was removed

### RETURN_CHANGED_TYPE

```
RETURN_CHANGED_TYPE = 'Return types are incompatible'
```

Return types are incompatible

## AttributeChangedTypeBreakage

```
AttributeChangedTypeBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.AttributeChangedTypeBreakage[AttributeChangedTypeBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.AttributeChangedTypeBreakage
                


              click griffe.AttributeChangedTypeBreakage href "" "griffe.AttributeChangedTypeBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for attributes whose type changed.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = ATTRIBUTE_CHANGED_TYPE
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## AttributeChangedValueBreakage

```
AttributeChangedValueBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.AttributeChangedValueBreakage[AttributeChangedValueBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.AttributeChangedValueBreakage
                


              click griffe.AttributeChangedValueBreakage href "" "griffe.AttributeChangedValueBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for attributes whose value changed.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = ATTRIBUTE_CHANGED_VALUE
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ClassRemovedBaseBreakage

```
ClassRemovedBaseBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ClassRemovedBaseBreakage[ClassRemovedBaseBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ClassRemovedBaseBreakage
                


              click griffe.ClassRemovedBaseBreakage href "" "griffe.ClassRemovedBaseBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for removed base classes.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = CLASS_REMOVED_BASE
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ObjectChangedKindBreakage

```
ObjectChangedKindBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ObjectChangedKindBreakage[ObjectChangedKindBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ObjectChangedKindBreakage
                


              click griffe.ObjectChangedKindBreakage href "" "griffe.ObjectChangedKindBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for objects whose kind changed.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = OBJECT_CHANGED_KIND
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ObjectRemovedBreakage

```
ObjectRemovedBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ObjectRemovedBreakage[ObjectRemovedBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ObjectRemovedBreakage
                


              click griffe.ObjectRemovedBreakage href "" "griffe.ObjectRemovedBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for removed objects.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = OBJECT_REMOVED
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ParameterAddedRequiredBreakage

```
ParameterAddedRequiredBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ParameterAddedRequiredBreakage[ParameterAddedRequiredBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterAddedRequiredBreakage
                


              click griffe.ParameterAddedRequiredBreakage href "" "griffe.ParameterAddedRequiredBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for new parameters added as required.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_ADDED_REQUIRED
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ParameterChangedDefaultBreakage

```
ParameterChangedDefaultBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ParameterChangedDefaultBreakage[ParameterChangedDefaultBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterChangedDefaultBreakage
                


              click griffe.ParameterChangedDefaultBreakage href "" "griffe.ParameterChangedDefaultBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for parameters whose default value changed.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_CHANGED_DEFAULT
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ParameterChangedKindBreakage

```
ParameterChangedKindBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ParameterChangedKindBreakage[ParameterChangedKindBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterChangedKindBreakage
                


              click griffe.ParameterChangedKindBreakage href "" "griffe.ParameterChangedKindBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for parameters whose kind changed.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_CHANGED_KIND
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ParameterChangedRequiredBreakage

```
ParameterChangedRequiredBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ParameterChangedRequiredBreakage[ParameterChangedRequiredBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterChangedRequiredBreakage
                


              click griffe.ParameterChangedRequiredBreakage href "" "griffe.ParameterChangedRequiredBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for parameters which became required.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_CHANGED_REQUIRED
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ParameterMovedBreakage

```
ParameterMovedBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ParameterMovedBreakage[ParameterMovedBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterMovedBreakage
                


              click griffe.ParameterMovedBreakage href "" "griffe.ParameterMovedBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for moved parameters.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_MOVED
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ParameterRemovedBreakage

```
ParameterRemovedBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ParameterRemovedBreakage[ParameterRemovedBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterRemovedBreakage
                


              click griffe.ParameterRemovedBreakage href "" "griffe.ParameterRemovedBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for removed parameters.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_REMOVED
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

## ReturnChangedTypeBreakage

```
ReturnChangedTypeBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)
```

Bases: `Breakage`

```
              flowchart TD
              griffe.ReturnChangedTypeBreakage[ReturnChangedTypeBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ReturnChangedTypeBreakage
                


              click griffe.ReturnChangedTypeBreakage href "" "griffe.ReturnChangedTypeBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
```

Specific breakage class for return values which changed type.

Parameters:

- ### **`obj`**

  (`Object`) â€“ The object related to the breakage.

- ### **`old_value`**

  (`Any`) â€“ The old value.

- ### **`new_value`**

  (`Any`) â€“ The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) â€“ Some details about the breakage.

Methods:

- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`explain`** â€“ Explain the breakage by showing old and new value.

Attributes:

- **`details`** â€“ Some details about the breakage.
- **`kind`** (`BreakageKind`) â€“ The kind of breakage.
- **`new_value`** â€“ The new, incompatible value.
- **`obj`** â€“ The object related to the breakage.
- **`old_value`** â€“ The old value.

Source code in `src/griffe/_internal/diff.py`

```
def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = "") -> None:
    """Initialize the breakage.

    Parameters:
        obj: The object related to the breakage.
        old_value: The old value.
        new_value: The new, incompatible value.
        details: Some details about the breakage.
    """
    self.obj = obj
    """The object related to the breakage."""
    self.old_value = old_value
    """The old value."""
    self.new_value = new_value
    """The new, incompatible value."""
    self.details = details
    """Some details about the breakage."""
```

### details

```
details = details
```

Some details about the breakage.

### kind

```
kind: BreakageKind = RETURN_CHANGED_TYPE
```

The kind of breakage.

### new_value

```
new_value = new_value
```

The new, incompatible value.

### obj

```
obj = obj
```

The object related to the breakage.

### old_value

```
old_value = old_value
```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/diff.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this object's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "kind": self.kind,
        "object_path": self.obj.path,
        "old_value": self.old_value,
        "new_value": self.new_value,
    }
```

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str
```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) â€“ The explanation style to use.

Returns:

- `str` â€“ An explanation.

Source code in `src/griffe/_internal/diff.py`

```
def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -> str:
    """Explain the breakage by showing old and new value.

    Parameters:
        style: The explanation style to use.

    Returns:
        An explanation.
    """
    return getattr(self, f"_explain_{style.value}")()
```

# CLI entrypoints

## **Main API**

## main

```
main(args: list[str] | None = None) -> int
```

Run the main program.

This function is executed when you type `griffe` or `python -m griffe`.

Parameters:

- ### **`args`**

  (`list[str] | None`, default: `None` ) â€“ Arguments passed from the command line.

Returns:

- `int` â€“ An exit code.

Source code in `src/griffe/_internal/cli.py`

```
def main(args: list[str] | None = None) -> int:
    """Run the main program.

    This function is executed when you type `griffe` or `python -m griffe`.

    Parameters:
        args: Arguments passed from the command line.

    Returns:
        An exit code.
    """
    # Parse arguments.
    parser = get_parser()
    opts: argparse.Namespace = parser.parse_args(args)
    opts_dict = opts.__dict__
    opts_dict.pop("debug_info")
    subcommand = opts_dict.pop("subcommand")

    # Initialize logging.
    log_level = opts_dict.pop("log_level", DEFAULT_LOG_LEVEL)
    try:
        level = getattr(logging, log_level)
    except AttributeError:
        choices = "', '".join(_level_choices)
        print(
            f"griffe: error: invalid log level '{log_level}' (choose from '{choices}')",
            file=sys.stderr,
        )
        return 1
    else:
        logging.basicConfig(format="%(levelname)-10s %(message)s", level=level)

    # Increase maximum recursion limit to 2000.
    sys.setrecursionlimit(max(2000, sys.getrecursionlimit()))

    # Run subcommand.
    commands: dict[str, Callable[..., int]] = {"check": check, "dump": dump}
    return commands[subcommand](**opts_dict)
```

## check

```
check(
    package: str | Path,
    against: str | None = None,
    against_path: str | Path | None = None,
    *,
    base_ref: str | None = None,
    extensions: Sequence[
        str | dict[str, Any] | Extension | type[Extension]
    ]
    | None = None,
    search_paths: Sequence[str | Path] | None = None,
    append_sys_path: bool = False,
    find_stubs_package: bool = False,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    verbose: bool = False,
    color: bool | None = None,
    style: str | ExplanationStyle | None = None,
) -> int
```

Check for API breaking changes in two versions of the same package.

Parameters:

- ### **`package`**

  (`str | Path`) â€“ The package to load and check.

- ### **`against`**

  (`str | None`, default: `None` ) â€“ Older Git reference (commit, branch, tag) to check against.

- ### **`against_path`**

  (`str | Path | None`, default: `None` ) â€“ Path when the "against" reference is checked out.

- ### **`base_ref`**

  (`str | None`, default: `None` ) â€“ Git reference (commit, branch, tag) to check.

- ### **`extensions`**

  (`Sequence[str | dict[str, Any] | Extension | type[Extension]] | None`, default: `None` ) â€“ The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The paths to search into.

- ### **`append_sys_path`**

  (`bool`, default: `False` ) â€“ Whether to append the contents of sys.path to the search paths.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) â€“ Whether to force using dynamic analysis when loading data.

- ### **`verbose`**

  (`bool`, default: `False` ) â€“ Use a verbose output.

Returns:

- `int` â€“ 0 for success, 1 for failure.

Source code in `src/griffe/_internal/cli.py`

```
def check(
    package: str | Path,
    against: str | None = None,
    against_path: str | Path | None = None,
    *,
    base_ref: str | None = None,
    extensions: Sequence[str | dict[str, Any] | Extension | type[Extension]] | None = None,
    search_paths: Sequence[str | Path] | None = None,
    append_sys_path: bool = False,
    find_stubs_package: bool = False,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    verbose: bool = False,
    color: bool | None = None,
    style: str | ExplanationStyle | None = None,
) -> int:
    """Check for API breaking changes in two versions of the same package.

    Parameters:
        package: The package to load and check.
        against: Older Git reference (commit, branch, tag) to check against.
        against_path: Path when the "against" reference is checked out.
        base_ref: Git reference (commit, branch, tag) to check.
        extensions: The extensions to use.
        search_paths: The paths to search into.
        append_sys_path: Whether to append the contents of `sys.path` to the search paths.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        force_inspection: Whether to force using dynamic analysis when loading data.
        verbose: Use a verbose output.

    Returns:
        `0` for success, `1` for failure.
    """
    # Prepare options.
    search_paths = list(search_paths) if search_paths else []
    if append_sys_path:
        search_paths.extend(sys.path)

    against_path = against_path or package
    try:
        loaded_extensions = load_extensions(*(extensions or ()))
    except ExtensionError:
        logger.exception("Could not load extensions")
        return 1

    if match_against := re.match(r"([\w.-]+)?((==|<=|<|>=|>|!=).+)", against or ""):
        against_dist = (match_against.group(1) or str(package)).lower().replace("-", "_")
        against_version = match_against.group(2)
        old_package = load_pypi(
            str(package),
            against_dist,
            against_version,
            extensions=loaded_extensions,
            search_paths=search_paths,
            allow_inspection=allow_inspection,
            force_inspection=force_inspection,
            find_stubs_package=find_stubs_package,
            resolve_aliases=True,
            resolve_external=None,
        )

        if base_ref:
            if not (match_base := re.match(r"([\w.-]+)?((==|<=|<|>=|>|!=).+)", base_ref)):
                raise ValueError(f"Base {base_ref} is not a valid dependency specifier.")
            base_dist = (match_base.group(1) or str(package)).lower().replace("-", "_")
            base_version = match_base.group(2)
        else:
            base_dist = against_dist
            base_version = ""
        new_package = load_pypi(
            str(package),
            base_dist,
            base_version,
            extensions=loaded_extensions,
            search_paths=search_paths,
            allow_inspection=allow_inspection,
            force_inspection=force_inspection,
            find_stubs_package=find_stubs_package,
            resolve_aliases=True,
            resolve_external=None,
        )

    else:
        against_path = against_path or package
        try:
            against = against or _get_latest_tag(package)
            repository = _get_repo_root(against_path)
        except GitError as error:
            print(f"griffe: error: {error}", file=sys.stderr)
            return 2

        # Load old and new version of the package.
        old_package = load_git(
            against_path,
            ref=against,
            repo=repository,
            extensions=loaded_extensions,
            search_paths=search_paths,
            allow_inspection=allow_inspection,
            force_inspection=force_inspection,
            find_stubs_package=find_stubs_package,
            resolve_aliases=True,
            resolve_external=None,
        )

        if base_ref:
            new_package = load_git(
                package,
                ref=base_ref,
                repo=repository,
                extensions=loaded_extensions,
                search_paths=search_paths,
                allow_inspection=allow_inspection,
                force_inspection=force_inspection,
                find_stubs_package=find_stubs_package,
                resolve_aliases=True,
                resolve_external=None,
            )
        else:
            new_package = load(
                package,
                try_relative_path=True,
                extensions=loaded_extensions,
                search_paths=search_paths,
                allow_inspection=allow_inspection,
                force_inspection=force_inspection,
                find_stubs_package=find_stubs_package,
                resolve_aliases=True,
                resolve_external=None,
            )

    # Find and display API breakages.
    breakages = list(find_breaking_changes(old_package, new_package))

    if color is None and (force_color := os.getenv("FORCE_COLOR", None)) is not None:
        color = force_color.lower() in {"1", "true", "y", "yes", "on"}
    colorama.deinit()
    colorama.init(strip=color if color is None else not color)

    if style is None:
        style = ExplanationStyle.VERBOSE if verbose else ExplanationStyle.ONE_LINE
    else:
        style = ExplanationStyle(style)
    for breakage in breakages:
        print(breakage.explain(style=style), file=sys.stderr)

    if breakages:
        return 1
    return 0
```

## dump

```
dump(
    packages: Sequence[str],
    *,
    output: str | IO | None = None,
    full: bool = False,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    extensions: Sequence[
        str | dict[str, Any] | Extension | type[Extension]
    ]
    | None = None,
    resolve_aliases: bool = False,
    resolve_implicit: bool = False,
    resolve_external: bool | None = None,
    search_paths: Sequence[str | Path] | None = None,
    find_stubs_package: bool = False,
    append_sys_path: bool = False,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    stats: bool = False,
) -> int
```

Load packages data and dump it as JSON.

Parameters:

- ### **`packages`**

  (`Sequence[str]`) â€“ The packages to load and dump.

- ### **`output`**

  (`str | IO | None`, default: `None` ) â€“ Where to output the JSON-serialized data.

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to output full or minimal data.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) â€“ Whether to resolve aliases (indirect objects references).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) â€“ Whether to resolve every alias or only the explicitly exported ones.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) â€“ Whether to load additional, unspecified modules to resolve aliases. Default is to resolve only from one module to its private sibling (ast -> \_ast).

- ### **`extensions`**

  (`Sequence[str | dict[str, Any] | Extension | type[Extension]] | None`, default: `None` ) â€“ The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The paths to search into.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) â€“ Whether to search for stubs-only packages. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`append_sys_path`**

  (`bool`, default: `False` ) â€“ Whether to append the contents of sys.path to the search paths.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) â€“ Whether to force using dynamic analysis when loading data.

- ### **`stats`**

  (`bool`, default: `False` ) â€“ Whether to compute and log stats about loading.

Returns:

- `int` â€“ 0 for success, 1 for failure.

Source code in `src/griffe/_internal/cli.py`

```
def dump(
    packages: Sequence[str],
    *,
    output: str | IO | None = None,
    full: bool = False,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    extensions: Sequence[str | dict[str, Any] | Extension | type[Extension]] | None = None,
    resolve_aliases: bool = False,
    resolve_implicit: bool = False,
    resolve_external: bool | None = None,
    search_paths: Sequence[str | Path] | None = None,
    find_stubs_package: bool = False,
    append_sys_path: bool = False,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    stats: bool = False,
) -> int:
    """Load packages data and dump it as JSON.

    Parameters:
        packages: The packages to load and dump.
        output: Where to output the JSON-serialized data.
        full: Whether to output full or minimal data.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        resolve_aliases: Whether to resolve aliases (indirect objects references).
        resolve_implicit: Whether to resolve every alias or only the explicitly exported ones.
        resolve_external: Whether to load additional, unspecified modules to resolve aliases.
            Default is to resolve only from one module to its private sibling (`ast` -> `_ast`).
        extensions: The extensions to use.
        search_paths: The paths to search into.
        find_stubs_package: Whether to search for stubs-only packages.
            If both the package and its stubs are found, they'll be merged together.
            If only the stubs are found, they'll be used as the package itself.
        append_sys_path: Whether to append the contents of `sys.path` to the search paths.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        force_inspection: Whether to force using dynamic analysis when loading data.
        stats: Whether to compute and log stats about loading.

    Returns:
        `0` for success, `1` for failure.
    """
    # Prepare options.
    per_package_output = False
    if isinstance(output, str) and output.format(package="package") != output:
        per_package_output = True

    search_paths = list(search_paths) if search_paths else []
    if append_sys_path:
        search_paths.extend(sys.path)

    try:
        loaded_extensions = load_extensions(*(extensions or ()))
    except ExtensionError:
        logger.exception("Could not load extensions")
        return 1

    # Load packages.
    loader = _load_packages(
        packages,
        extensions=loaded_extensions,
        search_paths=search_paths,
        docstring_parser=docstring_parser,
        docstring_options=docstring_options,
        resolve_aliases=resolve_aliases,
        resolve_implicit=resolve_implicit,
        resolve_external=resolve_external,
        allow_inspection=allow_inspection,
        force_inspection=force_inspection,
        store_source=False,
        find_stubs_package=find_stubs_package,
    )
    data_packages = loader.modules_collection.members

    # Serialize and dump packages.
    started = datetime.now(tz=timezone.utc)
    if per_package_output:
        for package_name, data in data_packages.items():
            serialized = data.as_json(indent=2, full=full, sort_keys=True)
            _print_data(serialized, output.format(package=package_name))  # type: ignore[union-attr]
    else:
        serialized = json.dumps(data_packages, cls=JSONEncoder, indent=2, full=full, sort_keys=True)
        _print_data(serialized, output)
    elapsed = datetime.now(tz=timezone.utc) - started

    if stats:
        loader_stats = loader.stats()
        loader_stats.time_spent_serializing = elapsed.microseconds
        logger.info(loader_stats.as_text())

    return 0 if len(data_packages) == len(packages) else 1
```

## **Advanced API**

## get_parser

```
get_parser() -> ArgumentParser
```

Return the CLI argument parser.

Returns:

- `ArgumentParser` â€“ An argparse parser.

Source code in `src/griffe/_internal/cli.py`

```
def get_parser() -> argparse.ArgumentParser:
    """Return the CLI argument parser.

    Returns:
        An argparse parser.
    """
    usage = "%(prog)s [GLOBAL_OPTS...] COMMAND [COMMAND_OPTS...]"
    description = "Signatures for entire Python programs. "
    "Extract the structure, the frame, the skeleton of your project, "
    "to generate API documentation or find breaking changes in your API."
    parser = argparse.ArgumentParser(add_help=False, usage=usage, description=description, prog="griffe")

    main_help = "Show this help message and exit. Commands also accept the -h/--help option."
    subcommand_help = "Show this help message and exit."

    global_options = parser.add_argument_group(title="Global options")
    global_options.add_argument("-h", "--help", action="help", help=main_help)
    global_options.add_argument("-V", "--version", action="version", version=f"%(prog)s {debug._get_version()}")
    global_options.add_argument("--debug-info", action=_DebugInfo, help="Print debug information.")

    def add_common_options(subparser: argparse.ArgumentParser) -> None:
        common_options = subparser.add_argument_group(title="Common options")
        common_options.add_argument("-h", "--help", action="help", help=subcommand_help)
        search_options = subparser.add_argument_group(title="Search options")
        search_options.add_argument(
            "-s",
            "--search",
            dest="search_paths",
            action="append",
            type=Path,
            help="Paths to search packages into.",
        )
        search_options.add_argument(
            "-y",
            "--sys-path",
            dest="append_sys_path",
            action="store_true",
            help="Whether to append `sys.path` to search paths specified with `-s`.",
        )
        loading_options = subparser.add_argument_group(title="Loading options")
        loading_options.add_argument(
            "-B",
            "--find-stubs-packages",
            dest="find_stubs_package",
            action="store_true",
            default=False,
            help="Whether to look for stubs-only packages and merge them with concrete ones.",
        )
        loading_options.add_argument(
            "-e",
            "--extensions",
            default={},
            type=_extensions_type,
            help="A list of extensions to use.",
        )
        loading_options.add_argument(
            "-X",
            "--no-inspection",
            dest="allow_inspection",
            action="store_false",
            default=True,
            help="Disallow inspection of builtin/compiled/not found modules.",
        )
        loading_options.add_argument(
            "-x",
            "--force-inspection",
            dest="force_inspection",
            action="store_true",
            default=False,
            help="Force inspection of everything, even when sources are found.",
        )
        debug_options = subparser.add_argument_group(title="Debugging options")
        debug_options.add_argument(
            "-L",
            "--log-level",
            metavar="LEVEL",
            default=DEFAULT_LOG_LEVEL,
            choices=_level_choices,
            type=str.upper,
            help="Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.",
        )

    # ========= SUBPARSERS ========= #
    subparsers = parser.add_subparsers(
        dest="subcommand",
        title="Commands",
        metavar="COMMAND",
        prog="griffe",
        required=True,
    )

    def add_subparser(command: str, text: str, **kwargs: Any) -> argparse.ArgumentParser:
        return subparsers.add_parser(command, add_help=False, help=text, description=text, **kwargs)

    # ========= DUMP PARSER ========= #
    dump_parser = add_subparser("dump", "Load package-signatures and dump them as JSON.")
    dump_options = dump_parser.add_argument_group(title="Dump options")
    dump_options.add_argument("packages", metavar="PACKAGE", nargs="+", help="Packages to find, load and dump.")
    dump_options.add_argument(
        "-f",
        "--full",
        action="store_true",
        default=False,
        help="Whether to dump full data in JSON.",
    )
    dump_options.add_argument(
        "-o",
        "--output",
        default=sys.stdout,
        help="Output file. Supports templating to output each package in its own file, with `{package}`.",
    )
    dump_options.add_argument(
        "-d",
        "--docstyle",
        dest="docstring_parser",
        default=None,
        type=Parser,
        help="The docstring style to parse.",
    )
    dump_options.add_argument(
        "-D",
        "--docopts",
        dest="docstring_options",
        default={},
        type=json.loads,
        help="The options for the docstring parser.",
    )
    dump_options.add_argument(
        "-r",
        "--resolve-aliases",
        action="store_true",
        help="Whether to resolve aliases.",
    )
    dump_options.add_argument(
        "-I",
        "--resolve-implicit",
        action="store_true",
        help="Whether to resolve implicitly exported aliases as well. "
        "Aliases are explicitly exported when defined in `__all__`.",
    )
    dump_options.add_argument(
        "-U",
        "--resolve-external",
        dest="resolve_external",
        action="store_true",
        help="Always resolve aliases pointing to external/unknown modules (not loaded directly)."
        "Default is to resolve only from one module to its private sibling (`ast` -> `_ast`).",
    )
    dump_options.add_argument(
        "--no-resolve-external",
        dest="resolve_external",
        action="store_false",
        help="Never resolve aliases pointing to external/unknown modules (not loaded directly)."
        "Default is to resolve only from one module to its private sibling (`ast` -> `_ast`).",
    )
    dump_options.add_argument(
        "-S",
        "--stats",
        action="store_true",
        help="Show statistics at the end.",
    )
    add_common_options(dump_parser)

    # ========= CHECK PARSER ========= #
    check_parser = add_subparser("check", "Check for API breakages or possible improvements.")
    check_options = check_parser.add_argument_group(title="Check options")
    check_options.add_argument("package", metavar="PACKAGE", help="Package to find, load and check, as path.")
    check_options.add_argument(
        "-a",
        "--against",
        metavar="REF",
        help="Older Git reference (commit, branch, tag) to check against. Default: load latest tag.",
    )
    check_options.add_argument(
        "-b",
        "--base-ref",
        metavar="BASE_REF",
        help="Git reference (commit, branch, tag) to check. Default: load current code.",
    )
    check_options.add_argument(
        "--color",
        dest="color",
        action="store_true",
        default=None,
        help="Force enable colors in the output.",
    )
    check_options.add_argument(
        "--no-color",
        dest="color",
        action="store_false",
        default=None,
        help="Force disable colors in the output.",
    )
    check_options.add_argument("-v", "--verbose", action="store_true", help="Verbose output.")
    formats = [fmt.value for fmt in ExplanationStyle]
    check_options.add_argument("-f", "--format", dest="style", choices=formats, default=None, help="Output format.")
    add_common_options(check_parser)

    return parser
```

# Docstrings

Docstrings are [parsed](parsers/) and the extracted information is structured in [models](models/).

# Exceptions

## GriffeError

Bases: `Exception`

```
              flowchart TD
              griffe.GriffeError[GriffeError]

              

              click griffe.GriffeError href "" "griffe.GriffeError"
```

The base exception for all Griffe errors.

## LoadingError

Bases: `GriffeError`

```
              flowchart TD
              griffe.LoadingError[LoadingError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.LoadingError
                


              click griffe.LoadingError href "" "griffe.LoadingError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

The base exception for all Griffe errors.

## NameResolutionError

Bases: `GriffeError`

```
              flowchart TD
              griffe.NameResolutionError[NameResolutionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.NameResolutionError
                


              click griffe.NameResolutionError href "" "griffe.NameResolutionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception for names that cannot be resolved in a object scope.

## UnhandledEditableModuleError

Bases: `GriffeError`

```
              flowchart TD
              griffe.UnhandledEditableModuleError[UnhandledEditableModuleError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.UnhandledEditableModuleError
                


              click griffe.UnhandledEditableModuleError href "" "griffe.UnhandledEditableModuleError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception for unhandled editables modules, when searching modules.

## UnimportableModuleError

Bases: `GriffeError`

```
              flowchart TD
              griffe.UnimportableModuleError[UnimportableModuleError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.UnimportableModuleError
                


              click griffe.UnimportableModuleError href "" "griffe.UnimportableModuleError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception for modules that cannot be imported.

## AliasResolutionError

```
AliasResolutionError(alias: Alias)
```

Bases: `GriffeError`

```
              flowchart TD
              griffe.AliasResolutionError[AliasResolutionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.AliasResolutionError
                


              click griffe.AliasResolutionError href "" "griffe.AliasResolutionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception for alias that cannot be resolved.

Parameters:

- ### **`alias`**

  (`Alias`) â€“ The alias that could not be resolved.

Attributes:

- **`alias`** (`Alias`) â€“ The alias that triggered the error.

Source code in `src/griffe/_internal/exceptions.py`

```
def __init__(self, alias: Alias) -> None:
    """Initialize the exception.

    Parameters:
        alias: The alias that could not be resolved.
    """
    self.alias: Alias = alias
    """The alias that triggered the error."""

    message = f"Could not resolve alias {alias.path} pointing at {alias.target_path}"
    try:
        filepath = alias.parent.relative_filepath  # type: ignore[union-attr]
    except BuiltinModuleError:
        pass
    else:
        message += f" (in {filepath}:{alias.alias_lineno})"
    super().__init__(message)
```

### alias

```
alias: Alias = alias
```

The alias that triggered the error.

## CyclicAliasError

```
CyclicAliasError(chain: list[str])
```

Bases: `GriffeError`

```
              flowchart TD
              griffe.CyclicAliasError[CyclicAliasError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.CyclicAliasError
                


              click griffe.CyclicAliasError href "" "griffe.CyclicAliasError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception raised when a cycle is detected in aliases.

Parameters:

- ### **`chain`**

  (`list[str]`) â€“ The cyclic chain of items (such as target path).

Attributes:

- **`chain`** (`list[str]`) â€“ The chain of aliases that created the cycle.

Source code in `src/griffe/_internal/exceptions.py`

```
def __init__(self, chain: list[str]) -> None:
    """Initialize the exception.

    Parameters:
        chain: The cyclic chain of items (such as target path).
    """
    self.chain: list[str] = chain
    """The chain of aliases that created the cycle."""

    super().__init__("Cyclic aliases detected:\n  " + "\n  ".join(self.chain))
```

### chain

```
chain: list[str] = chain
```

The chain of aliases that created the cycle.

## LastNodeError

Bases: `GriffeError`

```
              flowchart TD
              griffe.LastNodeError[LastNodeError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.LastNodeError
                


              click griffe.LastNodeError href "" "griffe.LastNodeError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception raised when trying to access a next or previous node.

## RootNodeError

Bases: `GriffeError`

```
              flowchart TD
              griffe.RootNodeError[RootNodeError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.RootNodeError
                


              click griffe.RootNodeError href "" "griffe.RootNodeError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception raised when trying to use siblings properties on a root node.

## BuiltinModuleError

Bases: `GriffeError`

```
              flowchart TD
              griffe.BuiltinModuleError[BuiltinModuleError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.BuiltinModuleError
                


              click griffe.BuiltinModuleError href "" "griffe.BuiltinModuleError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception raised when trying to access the filepath of a builtin module.

## ExtensionError

Bases: `GriffeError`

```
              flowchart TD
              griffe.ExtensionError[ExtensionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.ExtensionError
                


              click griffe.ExtensionError href "" "griffe.ExtensionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Base class for errors raised by extensions.

## ExtensionNotLoadedError

Bases: `ExtensionError`

```
              flowchart TD
              griffe.ExtensionNotLoadedError[ExtensionNotLoadedError]
              griffe._internal.exceptions.ExtensionError[ExtensionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.ExtensionError --> griffe.ExtensionNotLoadedError
                                griffe._internal.exceptions.GriffeError --> griffe._internal.exceptions.ExtensionError
                



              click griffe.ExtensionNotLoadedError href "" "griffe.ExtensionNotLoadedError"
              click griffe._internal.exceptions.ExtensionError href "" "griffe._internal.exceptions.ExtensionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception raised when an extension could not be loaded.

## GitError

Bases: `GriffeError`

```
              flowchart TD
              griffe.GitError[GitError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.GitError
                


              click griffe.GitError href "" "griffe.GitError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
```

Exception raised for errors related to Git.

# Expressions

## **Helpers**

## get_annotation

```
get_annotation = partial(get_expression, parse_strings=None)
```

## get_base_class

```
get_base_class = partial(
    get_expression, parse_strings=False
)
```

## get_class_keyword

```
get_class_keyword = partial(
    get_expression, parse_strings=False
)
```

## get_condition

```
get_condition = partial(get_expression, parse_strings=False)
```

## get_expression

```
get_expression(
    node: AST | None,
    parent: Module | Class,
    *,
    member: str | None = None,
    parse_strings: bool | None = None,
) -> Expr | None
```

Build an expression from an AST.

Parameters:

- ### **`node`**

  (`AST | None`) â€“ The annotation node.

- ### **`parent`**

  (`Module | Class`) â€“ The parent used to resolve the name.

- ### **`member`**

  (`str | None`, default: `None` ) â€“ The member name (for resolution in its scope).

- ### **`parse_strings`**

  (`bool | None`, default: `None` ) â€“ Whether to try and parse strings as type annotations.

Returns:

- `Expr | None` â€“ A string or resovable name or expression.

Source code in `src/griffe/_internal/expressions.py`

```
def get_expression(
    node: ast.AST | None,
    parent: Module | Class,
    *,
    member: str | None = None,
    parse_strings: bool | None = None,
) -> Expr | None:
    """Build an expression from an AST.

    Parameters:
        node: The annotation node.
        parent: The parent used to resolve the name.
        member: The member name (for resolution in its scope).
        parse_strings: Whether to try and parse strings as type annotations.

    Returns:
        A string or resovable name or expression.
    """
    if node is None:
        return None
    if parse_strings is None:
        try:
            module = parent.module
        except ValueError:
            parse_strings = False
        else:
            parse_strings = not module.imports_future_annotations
    return _build(node, parent, member=member, parse_strings=parse_strings)
```

## safe_get_annotation

```
safe_get_annotation = partial(
    safe_get_expression,
    parse_strings=None,
    msg_format=_msg_format % "annotation",
)
```

## safe_get_base_class

```
safe_get_base_class = partial(
    safe_get_expression,
    parse_strings=False,
    msg_format=_msg_format % "base class",
)
```

## safe_get_class_keyword

```
safe_get_class_keyword = partial(
    safe_get_expression,
    parse_strings=False,
    msg_format=_msg_format % "class keyword",
)
```

## safe_get_condition

```
safe_get_condition = partial(
    safe_get_expression,
    parse_strings=False,
    msg_format=_msg_format % "condition",
)
```

## safe_get_expression

```
safe_get_expression(
    node: AST | None,
    parent: Module | Class,
    *,
    member: str | None = None,
    parse_strings: bool | None = None,
    log_level: LogLevel | None = error,
    msg_format: str = "{path}:{lineno}: Failed to get expression from {node_class}: {error}",
) -> Expr | None
```

Safely (no exception) build a resolvable annotation.

Parameters:

- ### **`node`**

  (`AST | None`) â€“ The annotation node.

- ### **`parent`**

  (`Module | Class`) â€“ The parent used to resolve the name.

- ### **`member`**

  (`str | None`, default: `None` ) â€“ The member name (for resolution in its scope).

- ### **`parse_strings`**

  (`bool | None`, default: `None` ) â€“ Whether to try and parse strings as type annotations.

- ### **`log_level`**

  (`LogLevel | None`, default: `error` ) â€“ Log level to use to log a message. None to disable logging.

- ### **`msg_format`**

  (`str`, default: `'{path}:{lineno}: Failed to get expression from {node_class}: {error}'` ) â€“ A format string for the log message. Available placeholders: path, lineno, node, error.

Returns:

- `Expr | None` â€“ A string or resovable name or expression.

Source code in `src/griffe/_internal/expressions.py`

```
def safe_get_expression(
    node: ast.AST | None,
    parent: Module | Class,
    *,
    member: str | None = None,
    parse_strings: bool | None = None,
    log_level: LogLevel | None = LogLevel.error,
    msg_format: str = "{path}:{lineno}: Failed to get expression from {node_class}: {error}",
) -> Expr | None:
    """Safely (no exception) build a resolvable annotation.

    Parameters:
        node: The annotation node.
        parent: The parent used to resolve the name.
        member: The member name (for resolution in its scope).
        parse_strings: Whether to try and parse strings as type annotations.
        log_level: Log level to use to log a message. None to disable logging.
        msg_format: A format string for the log message. Available placeholders:
            path, lineno, node, error.

    Returns:
        A string or resovable name or expression.
    """
    try:
        return get_expression(node, parent, member=member, parse_strings=parse_strings)
    except Exception as error:  # noqa: BLE001
        if log_level is None:
            return None
        node_class = node.__class__.__name__
        try:
            path: Path | str = parent.relative_filepath
        except ValueError:
            path = "<in-memory>"
        lineno = node.lineno  # type: ignore[union-attr]
        error_str = f"{error.__class__.__name__}: {error}"
        message = msg_format.format(path=path, lineno=lineno, node_class=node_class, error=error_str)
        getattr(logger, log_level.value)(message)
    return None
```

## **Expression nodes**

## Expr

```
Expr()
```

Base class for expressions.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:  # noqa: ARG002
    """Iterate on the expression elements.

    Parameters:
        flat: Expressions are trees.

            When flat is false, this method iterates only on the first layer of the tree.
            To iterate on all the subparts of the expression, you have to do so recursively.
            It allows to handle each subpart specifically (for example subscripts, attribute, etc.),
            without them getting rendered as strings.

            On the contrary, when flat is true, the whole tree is flattened as a sequence
            of strings and instances of [Names][griffe.ExprName].

    Yields:
        Strings and names when flat, strings and expressions otherwise.
    """
    yield from ()
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprAttribute

```
ExprAttribute(values: list[str | Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprAttribute[ExprAttribute]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprAttribute
                


              click griffe.ExprAttribute href "" "griffe.ExprAttribute"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Attributes like `a.b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`append`** â€“ Append a name to this attribute.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ The canonical path of this attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`first`** (`str | Expr`) â€“ The first part of this attribute (on the left).
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`last`** (`ExprName`) â€“ The last part of this attribute (on the right).
- **`path`** (`str`) â€“ The path of this attribute.
- **`values`** (`list[str | Expr]`) â€“ The different parts of the dotted chain.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

The canonical path of this attribute.

### classname

```
classname: str
```

The expression class name.

### first

```
first: str | Expr
```

The first part of this attribute (on the left).

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### last

```
last: ExprName
```

The last part of this attribute (on the right).

### path

```
path: str
```

The path of this attribute.

### values

```
values: list[str | Expr]
```

The different parts of the dotted chain.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### append

```
append(value: ExprName) -> None
```

Append a name to this attribute.

Parameters:

- #### **`value`**

  (`ExprName`) â€“ The expression name to append.

Source code in `src/griffe/_internal/expressions.py`

```
def append(self, value: ExprName) -> None:
    """Append a name to this attribute.

    Parameters:
        value: The expression name to append.
    """
    if value.parent is None:
        value.parent = self.last
    self.values.append(value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    precedence = _get_precedence(self)
    yield from _yield(self.values[0], flat=flat, outer_precedence=precedence, is_left=True)
    for value in self.values[1:]:
        yield "."
        yield from _yield(value, flat=flat, outer_precedence=precedence)
```

### modernize

```
modernize() -> ExprName | ExprAttribute
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> ExprName | ExprAttribute:
    if modern := _modern_types.get(self.canonical_path):
        return ExprName(modern, parent=self.last.parent)
    return self
```

## ExprBinOp

```
ExprBinOp(
    left: str | Expr, operator: str, right: str | Expr
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprBinOp[ExprBinOp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprBinOp
                


              click griffe.ExprBinOp href "" "griffe.ExprBinOp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Binary operations like `a + b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`left`** (`str | Expr`) â€“ Left part.
- **`operator`** (`str`) â€“ Binary operator.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`right`** (`str | Expr`) â€“ Right part.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### left

```
left: str | Expr
```

Left part.

### operator

```
operator: str
```

Binary operator.

### path

```
path: str
```

Path of the expressed name/attribute.

### right

```
right: str | Expr
```

Right part.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    precedence = _get_precedence(self)
    right_precedence = precedence
    if self.operator == "**" and isinstance(self.right, ExprUnaryOp):
        # Unary operators on the right have higher precedence, e.g. `a ** -b`.
        right_precedence = _OperatorPrecedence(precedence - 1)
    yield from _yield(self.left, flat=flat, outer_precedence=precedence, is_left=True)
    yield f" {self.operator} "
    yield from _yield(self.right, flat=flat, outer_precedence=right_precedence, is_left=False)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprBoolOp

```
ExprBoolOp(operator: str, values: Sequence[str | Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprBoolOp[ExprBoolOp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprBoolOp
                


              click griffe.ExprBoolOp href "" "griffe.ExprBoolOp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Boolean operations like `a or b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`operator`** (`str`) â€“ Boolean operator.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`values`** (`Sequence[str | Expr]`) â€“ Operands.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### operator

```
operator: str
```

Boolean operator.

### path

```
path: str
```

Path of the expressed name/attribute.

### values

```
values: Sequence[str | Expr]
```

Operands.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    precedence = _get_precedence(self)
    it = iter(self.values)
    yield from _yield(next(it), flat=flat, outer_precedence=precedence, is_left=True)
    for value in it:
        yield f" {self.operator} "
        yield from _yield(value, flat=flat, outer_precedence=precedence, is_left=False)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprCall

```
ExprCall(function: Expr, arguments: Sequence[str | Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprCall[ExprCall]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprCall
                


              click griffe.ExprCall href "" "griffe.ExprCall"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Calls like `f()`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`arguments`** (`Sequence[str | Expr]`) â€“ Passed arguments.
- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ The canonical path of this subscript's left part.
- **`classname`** (`str`) â€“ The expression class name.
- **`function`** (`Expr`) â€“ Function called.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### arguments

```
arguments: Sequence[str | Expr]
```

Passed arguments.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

The canonical path of this subscript's left part.

### classname

```
classname: str
```

The expression class name.

### function

```
function: Expr
```

Function called.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield from _yield(self.function, flat=flat, outer_precedence=_get_precedence(self))
    yield "("
    yield from _join(self.arguments, ", ", flat=flat)
    yield ")"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprCompare

```
ExprCompare(
    left: str | Expr,
    operators: Sequence[str],
    comparators: Sequence[str | Expr],
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprCompare[ExprCompare]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprCompare
                


              click griffe.ExprCompare href "" "griffe.ExprCompare"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Comparisons like `a > b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`comparators`** (`Sequence[str | Expr]`) â€“ Things compared.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`left`** (`str | Expr`) â€“ Left part.
- **`operators`** (`Sequence[str]`) â€“ Comparison operators.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### comparators

```
comparators: Sequence[str | Expr]
```

Things compared.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### left

```
left: str | Expr
```

Left part.

### operators

```
operators: Sequence[str]
```

Comparison operators.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    precedence = _get_precedence(self)
    yield from _yield(self.left, flat=flat, outer_precedence=precedence, is_left=True)
    for op, comp in zip(self.operators, self.comparators):
        yield f" {op} "
        yield from _yield(comp, flat=flat, outer_precedence=precedence)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprComprehension

```
ExprComprehension(
    target: str | Expr,
    iterable: str | Expr,
    conditions: Sequence[str | Expr],
    is_async: bool = False,
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprComprehension[ExprComprehension]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprComprehension
                


              click griffe.ExprComprehension href "" "griffe.ExprComprehension"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Comprehensions like `a for b in c if d`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`conditions`** (`Sequence[str | Expr]`) â€“ Conditions to include the target in the result.
- **`is_async`** (`bool`) â€“ Async comprehension or not.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`iterable`** (`str | Expr`) â€“ Value iterated on.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`target`** (`str | Expr`) â€“ Comprehension target (value added to the result).

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### conditions

```
conditions: Sequence[str | Expr]
```

Conditions to include the target in the result.

### is_async

```
is_async: bool = False
```

Async comprehension or not.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### iterable

```
iterable: str | Expr
```

Value iterated on.

### path

```
path: str
```

Path of the expressed name/attribute.

### target

```
target: str | Expr
```

Comprehension target (value added to the result).

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    if self.is_async:
        yield "async "
    yield "for "
    yield from _yield(self.target, flat=flat)
    yield " in "
    yield from _yield(self.iterable, flat=flat)
    if self.conditions:
        yield " if "
        yield from _join(self.conditions, " if ", flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprConstant

```
ExprConstant(value: str)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprConstant[ExprConstant]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprConstant
                


              click griffe.ExprConstant href "" "griffe.ExprConstant"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Constants like `"a"` or `1`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str`) â€“ Constant value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str
```

Constant value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:  # noqa: ARG002
    yield self.value
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprDict

```
ExprDict(
    keys: Sequence[str | Expr | None],
    values: Sequence[str | Expr],
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprDict[ExprDict]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprDict
                


              click griffe.ExprDict href "" "griffe.ExprDict"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Dictionaries like `{"a": 0}`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`keys`** (`Sequence[str | Expr | None]`) â€“ Dict keys.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`values`** (`Sequence[str | Expr]`) â€“ Dict values.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### keys

```
keys: Sequence[str | Expr | None]
```

Dict keys.

### path

```
path: str
```

Path of the expressed name/attribute.

### values

```
values: Sequence[str | Expr]
```

Dict values.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "{"
    yield from _join(
        (("None" if key is None else key, ": ", value) for key, value in zip(self.keys, self.values)),
        ", ",
        flat=flat,
    )
    yield "}"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprDictComp

```
ExprDictComp(
    key: str | Expr,
    value: str | Expr,
    generators: Sequence[Expr],
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprDictComp[ExprDictComp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprDictComp
                


              click griffe.ExprDictComp href "" "griffe.ExprDictComp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Dict comprehensions like `{k: v for k, v in a}`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`generators`** (`Sequence[Expr]`) â€“ Generators iterated on.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`key`** (`str | Expr`) â€“ Target key.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str | Expr`) â€“ Target value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### generators

```
generators: Sequence[Expr]
```

Generators iterated on.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### key

```
key: str | Expr
```

Target key.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str | Expr
```

Target value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "{"
    yield from _yield(self.key, flat=flat)
    yield ": "
    yield from _yield(self.value, flat=flat)
    yield " "
    yield from _join(self.generators, " ", flat=flat)
    yield "}"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprExtSlice

```
ExprExtSlice(dims: Sequence[str | Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprExtSlice[ExprExtSlice]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprExtSlice
                


              click griffe.ExprExtSlice href "" "griffe.ExprExtSlice"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Extended slice like `a[x:y, z]`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`dims`** (`Sequence[str | Expr]`) â€“ Dims.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### dims

```
dims: Sequence[str | Expr]
```

Dims.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield from _join(self.dims, ", ", flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprFormatted

```
ExprFormatted(value: str | Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprFormatted[ExprFormatted]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprFormatted
                


              click griffe.ExprFormatted href "" "griffe.ExprFormatted"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Formatted string like `{1 + 1}`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str | Expr`) â€“ Formatted value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str | Expr
```

Formatted value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "{"
    # Prevent parentheses from being added, avoiding `{(1 + 1)}`
    yield from _yield(self.value, flat=flat, outer_precedence=_OperatorPrecedence.NONE)
    yield "}"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprGeneratorExp

```
ExprGeneratorExp(
    element: str | Expr, generators: Sequence[Expr]
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprGeneratorExp[ExprGeneratorExp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprGeneratorExp
                


              click griffe.ExprGeneratorExp href "" "griffe.ExprGeneratorExp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Generator expressions like `a for b in c for d in e`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`element`** (`str | Expr`) â€“ Yielded element.
- **`generators`** (`Sequence[Expr]`) â€“ Generators iterated on.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### element

```
element: str | Expr
```

Yielded element.

### generators

```
generators: Sequence[Expr]
```

Generators iterated on.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield from _yield(self.element, flat=flat)
    yield " "
    yield from _join(self.generators, " ", flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprIfExp

```
ExprIfExp(
    body: str | Expr, test: str | Expr, orelse: str | Expr
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprIfExp[ExprIfExp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprIfExp
                


              click griffe.ExprIfExp href "" "griffe.ExprIfExp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Conditions like `a if b else c`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`body`** (`str | Expr`) â€“ Value if test.
- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`orelse`** (`str | Expr`) â€“ Other expression.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`test`** (`str | Expr`) â€“ Condition.

### body

```
body: str | Expr
```

Value if test.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### orelse

```
orelse: str | Expr
```

Other expression.

### path

```
path: str
```

Path of the expressed name/attribute.

### test

```
test: str | Expr
```

Condition.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    precedence = _get_precedence(self)
    yield from _yield(self.body, flat=flat, outer_precedence=precedence, is_left=True)
    yield " if "
    # If the test itself is another if/else, its precedence is the same, which will not give
    # a parenthesis: force it.
    test_outer_precedence = _OperatorPrecedence(precedence + 1)
    yield from _yield(self.test, flat=flat, outer_precedence=test_outer_precedence)
    yield " else "
    # If/else is right associative. For example, a nested if/else
    # `a if b else c if d else e` is effectively `a if b else (c if d else e)`, so produce a
    # flattened version without parentheses.
    if isinstance(self.orelse, ExprIfExp):
        yield from self.orelse.iterate(flat=flat)
    else:
        yield from _yield(self.orelse, flat=flat, outer_precedence=precedence, is_left=False)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprJoinedStr

```
ExprJoinedStr(values: Sequence[str | Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprJoinedStr[ExprJoinedStr]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprJoinedStr
                


              click griffe.ExprJoinedStr href "" "griffe.ExprJoinedStr"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Joined strings like `f"a {b} c"`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`values`** (`Sequence[str | Expr]`) â€“ Joined values.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### values

```
values: Sequence[str | Expr]
```

Joined values.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "f'"
    yield from _join(self.values, "", flat=flat)
    yield "'"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprKeyword

```
ExprKeyword(
    name: str,
    value: str | Expr,
    function: Expr | None = None,
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprKeyword[ExprKeyword]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprKeyword
                


              click griffe.ExprKeyword href "" "griffe.ExprKeyword"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Keyword arguments like `a=b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed keyword.
- **`classname`** (`str`) â€“ The expression class name.
- **`function`** (`Expr | None`) â€“ Expression referencing the function called with this parameter.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`name`** (`str`) â€“ Name.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str | Expr`) â€“ Value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed keyword.

### classname

```
classname: str
```

The expression class name.

### function

```
function: Expr | None = None
```

Expression referencing the function called with this parameter.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### name

```
name: str
```

Name.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str | Expr
```

Value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield self.name
    yield "="
    yield from _yield(self.value, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprVarPositional

```
ExprVarPositional(value: Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprVarPositional[ExprVarPositional]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprVarPositional
                


              click griffe.ExprVarPositional href "" "griffe.ExprVarPositional"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Variadic positional parameters like `*args`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`Expr`) â€“ Starred value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: Expr
```

Starred value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "*"
    yield from _yield(self.value, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprVarKeyword

```
ExprVarKeyword(value: Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprVarKeyword[ExprVarKeyword]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprVarKeyword
                


              click griffe.ExprVarKeyword href "" "griffe.ExprVarKeyword"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Variadic keyword parameters like `**kwargs`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`Expr`) â€“ Double-starred value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: Expr
```

Double-starred value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "**"
    yield from _yield(self.value, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprLambda

```
ExprLambda(
    parameters: Sequence[ExprParameter], body: str | Expr
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprLambda[ExprLambda]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprLambda
                


              click griffe.ExprLambda href "" "griffe.ExprLambda"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Lambda expressions like `lambda a: a.b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`body`** (`str | Expr`) â€“ Lambda's body.
- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`parameters`** (`Sequence[ExprParameter]`) â€“ Lambda's parameters.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### body

```
body: str | Expr
```

Lambda's body.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### parameters

```
parameters: Sequence[ExprParameter]
```

Lambda's parameters.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    pos_only = False
    pos_or_kw = False
    kw_only = False
    length = len(self.parameters)
    yield "lambda"
    if length:
        yield " "
    for index, parameter in enumerate(self.parameters, 1):
        if parameter.kind is ParameterKind.positional_only:
            pos_only = True
        elif parameter.kind is ParameterKind.var_positional:
            yield "*"
        elif parameter.kind is ParameterKind.var_keyword:
            yield "**"
        elif parameter.kind is ParameterKind.positional_or_keyword and not pos_or_kw:
            pos_or_kw = True
        elif parameter.kind is ParameterKind.keyword_only and not kw_only:
            kw_only = True
            yield "*, "
        if parameter.kind is not ParameterKind.positional_only and pos_only:
            pos_only = False
            yield "/, "
        yield parameter.name
        if parameter.default and parameter.kind not in (ParameterKind.var_positional, ParameterKind.var_keyword):
            yield "="
            yield from _yield(parameter.default, flat=flat)
        if index < length:
            yield ", "
    yield ": "
    # Body of lambda should not have parentheses, avoiding `lambda: a.b`
    yield from _yield(self.body, flat=flat, outer_precedence=_OperatorPrecedence.NONE)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprList

```
ExprList(elements: Sequence[Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprList[ExprList]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprList
                


              click griffe.ExprList href "" "griffe.ExprList"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Lists like `[0, 1, 2]`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`elements`** (`Sequence[Expr]`) â€“ List elements.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### elements

```
elements: Sequence[Expr]
```

List elements.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "["
    yield from _join(self.elements, ", ", flat=flat)
    yield "]"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprListComp

```
ExprListComp(
    element: str | Expr, generators: Sequence[Expr]
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprListComp[ExprListComp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprListComp
                


              click griffe.ExprListComp href "" "griffe.ExprListComp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

List comprehensions like `[a for b in c]`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`element`** (`str | Expr`) â€“ Target value.
- **`generators`** (`Sequence[Expr]`) â€“ Generators iterated on.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### element

```
element: str | Expr
```

Target value.

### generators

```
generators: Sequence[Expr]
```

Generators iterated on.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "["
    yield from _yield(self.element, flat=flat)
    yield " "
    yield from _join(self.generators, " ", flat=flat)
    yield "]"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprName

```
ExprName(
    name: str,
    parent: str
    | ExprName
    | Module
    | Class
    | Function
    | None = None,
    member: str | None = None,
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprName[ExprName]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprName
                


              click griffe.ExprName href "" "griffe.ExprName"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

This class represents a Python object identified by a name in a given scope.

Methods:

- **`__eq__`** â€“ Two name expressions are equal if they have the same name value (parent is ignored).
- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ The canonical name (resolved one, not alias name).
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_enum_class`** (`bool`) â€“ Whether this name resolves to an enumeration class.
- **`is_enum_instance`** (`bool`) â€“ Whether this name resolves to an enumeration instance.
- **`is_enum_value`** (`bool`) â€“ Whether this name resolves to an enumeration value.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`is_type_parameter`** (`bool`) â€“ Whether this name resolves to a type parameter.
- **`member`** (`str | None`) â€“ Member name (for resolution in its scope).
- **`name`** (`str`) â€“ Actual name.
- **`parent`** (`str | ExprName | Module | Class | Function | None`) â€“ Parent (for resolution in its scope).
- **`path`** (`str`) â€“ The full, resolved name.
- **`resolved`** (`Module | Class | None`) â€“ The resolved object this name refers to.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

The canonical name (resolved one, not alias name).

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_enum_class

```
is_enum_class: bool
```

Whether this name resolves to an enumeration class.

### is_enum_instance

```
is_enum_instance: bool
```

Whether this name resolves to an enumeration instance.

### is_enum_value

```
is_enum_value: bool
```

Whether this name resolves to an enumeration value.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### is_type_parameter

```
is_type_parameter: bool
```

Whether this name resolves to a type parameter.

### member

```
member: str | None = None
```

Member name (for resolution in its scope).

### name

```
name: str
```

Actual name.

### parent

```
parent: (
    str | ExprName | Module | Class | Function | None
) = None
```

Parent (for resolution in its scope).

### path

```
path: str
```

The full, resolved name.

If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source.

### resolved

```
resolved: Module | Class | None
```

The resolved object this name refers to.

### __eq__

```
__eq__(other: object) -> bool
```

Two name expressions are equal if they have the same `name` value (`parent` is ignored).

Source code in `src/griffe/_internal/expressions.py`

```
def __eq__(self, other: object) -> bool:
    """Two name expressions are equal if they have the same `name` value (`parent` is ignored)."""
    if isinstance(other, ExprName):
        return self.name == other.name
    return NotImplemented
```

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[ExprName]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[ExprName]:  # noqa: ARG002
    yield self
```

### modernize

```
modernize() -> ExprName
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> ExprName:
    if modern := _modern_types.get(self.canonical_path):
        return ExprName(modern, parent=self.parent)
    return self
```

## ExprNamedExpr

```
ExprNamedExpr(target: Expr, value: str | Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprNamedExpr[ExprNamedExpr]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprNamedExpr
                


              click griffe.ExprNamedExpr href "" "griffe.ExprNamedExpr"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Named/assignment expressions like `a := b`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`target`** (`Expr`) â€“ Target name.
- **`value`** (`str | Expr`) â€“ Value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### target

```
target: Expr
```

Target name.

### value

```
value: str | Expr
```

Value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield from _yield(self.target, flat=flat)
    yield " := "
    yield from _yield(self.value, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprParameter

```
ExprParameter(
    name: str,
    kind: ParameterKind = positional_or_keyword,
    annotation: Expr | None = None,
    default: str | Expr | None = None,
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprParameter[ExprParameter]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprParameter
                


              click griffe.ExprParameter href "" "griffe.ExprParameter"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Parameters in function signatures like `a: int = 0`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`annotation`** (`Expr | None`) â€“ Parameter type.
- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`default`** (`str | Expr | None`) â€“ Parameter default.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`kind`** (`ParameterKind`) â€“ Parameter kind.
- **`name`** (`str`) â€“ Parameter name.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### annotation

```
annotation: Expr | None = None
```

Parameter type.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### default

```
default: str | Expr | None = None
```

Parameter default.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### kind

```
kind: ParameterKind = positional_or_keyword
```

Parameter kind.

### name

```
name: str
```

Parameter name.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:  # noqa: ARG002
    """Iterate on the expression elements.

    Parameters:
        flat: Expressions are trees.

            When flat is false, this method iterates only on the first layer of the tree.
            To iterate on all the subparts of the expression, you have to do so recursively.
            It allows to handle each subpart specifically (for example subscripts, attribute, etc.),
            without them getting rendered as strings.

            On the contrary, when flat is true, the whole tree is flattened as a sequence
            of strings and instances of [Names][griffe.ExprName].

    Yields:
        Strings and names when flat, strings and expressions otherwise.
    """
    yield from ()
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprSet

```
ExprSet(elements: Sequence[str | Expr])
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprSet[ExprSet]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSet
                


              click griffe.ExprSet href "" "griffe.ExprSet"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Sets like `{0, 1, 2}`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`elements`** (`Sequence[str | Expr]`) â€“ Set elements.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### elements

```
elements: Sequence[str | Expr]
```

Set elements.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "{"
    yield from _join(self.elements, ", ", flat=flat)
    yield "}"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprSetComp

```
ExprSetComp(
    element: str | Expr, generators: Sequence[Expr]
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprSetComp[ExprSetComp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSetComp
                


              click griffe.ExprSetComp href "" "griffe.ExprSetComp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Set comprehensions like `{a for b in c}`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`element`** (`str | Expr`) â€“ Target value.
- **`generators`** (`Sequence[Expr]`) â€“ Generators iterated on.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### element

```
element: str | Expr
```

Target value.

### generators

```
generators: Sequence[Expr]
```

Generators iterated on.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "{"
    yield from _yield(self.element, flat=flat)
    yield " "
    yield from _join(self.generators, " ", flat=flat)
    yield "}"
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprSlice

```
ExprSlice(
    lower: str | Expr | None = None,
    upper: str | Expr | None = None,
    step: str | Expr | None = None,
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprSlice[ExprSlice]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSlice
                


              click griffe.ExprSlice href "" "griffe.ExprSlice"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Slices like `[a:b:c]`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`lower`** (`str | Expr | None`) â€“ Lower bound.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`step`** (`str | Expr | None`) â€“ Iteration step.
- **`upper`** (`str | Expr | None`) â€“ Upper bound.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### lower

```
lower: str | Expr | None = None
```

Lower bound.

### path

```
path: str
```

Path of the expressed name/attribute.

### step

```
step: str | Expr | None = None
```

Iteration step.

### upper

```
upper: str | Expr | None = None
```

Upper bound.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    if self.lower is not None:
        yield from _yield(self.lower, flat=flat)
    yield ":"
    if self.upper is not None:
        yield from _yield(self.upper, flat=flat)
    if self.step is not None:
        yield ":"
        yield from _yield(self.step, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprSubscript

```
ExprSubscript(left: str | Expr, slice: str | Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprSubscript[ExprSubscript]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSubscript
                


              click griffe.ExprSubscript href "" "griffe.ExprSubscript"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Subscripts like `a[b]`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ The canonical path of this subscript's left part.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`left`** (`str | Expr`) â€“ Left part.
- **`path`** (`str`) â€“ The path of this subscript's left part.
- **`slice`** (`str | Expr`) â€“ Slice part.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

The canonical path of this subscript's left part.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### left

```
left: str | Expr
```

Left part.

### path

```
path: str
```

The path of this subscript's left part.

### slice

```
slice: str | Expr
```

Slice part.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield from _yield(self.left, flat=flat, outer_precedence=_get_precedence(self))
    yield "["
    # Prevent parentheses from being added, avoiding `a[(b)]`
    yield from _yield(self.slice, flat=flat, outer_precedence=_OperatorPrecedence.NONE)
    yield "]"
```

### modernize

```
modernize() -> ExprBinOp | ExprSubscript
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> ExprBinOp | ExprSubscript:
    if self.canonical_path == "typing.Union":
        return self._to_binop(self.slice.elements, op="|")  # type: ignore[union-attr]
    if self.canonical_path == "typing.Optional":
        left = self.slice if isinstance(self.slice, str) else self.slice.modernize()
        return ExprBinOp(left=left, operator="|", right="None")
    return ExprSubscript(
        left=self.left if isinstance(self.left, str) else self.left.modernize(),
        slice=self.slice if isinstance(self.slice, str) else self.slice.modernize(),
    )
```

## ExprTuple

```
ExprTuple(
    elements: Sequence[str | Expr], implicit: bool = False
)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprTuple[ExprTuple]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprTuple
                


              click griffe.ExprTuple href "" "griffe.ExprTuple"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Tuples like `(0, 1, 2)`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`elements`** (`Sequence[str | Expr]`) â€“ Tuple elements.
- **`implicit`** (`bool`) â€“ Whether the tuple is implicit (e.g. without parentheses in a subscript's slice).
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### elements

```
elements: Sequence[str | Expr]
```

Tuple elements.

### implicit

```
implicit: bool = False
```

Whether the tuple is implicit (e.g. without parentheses in a subscript's slice).

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    if not self.implicit:
        yield "("
    yield from _join(self.elements, ", ", flat=flat)
    if len(self.elements) == 1:
        yield ","
    if not self.implicit:
        yield ")"
```

### modernize

```
modernize() -> ExprTuple
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> ExprTuple:
    return ExprTuple(
        elements=[el if isinstance(el, str) else el.modernize() for el in self.elements],
        implicit=self.implicit,
    )
```

## ExprUnaryOp

```
ExprUnaryOp(operator: str, value: str | Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprUnaryOp[ExprUnaryOp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprUnaryOp
                


              click griffe.ExprUnaryOp href "" "griffe.ExprUnaryOp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Unary operations like `-1`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`operator`** (`str`) â€“ Unary operator.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str | Expr`) â€“ Value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### operator

```
operator: str
```

Unary operator.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str | Expr
```

Value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield self.operator
    if self.operator == "not":
        yield " "
    yield from _yield(self.value, flat=flat, outer_precedence=_get_precedence(self))
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprYield

```
ExprYield(value: str | Expr | None = None)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprYield[ExprYield]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprYield
                


              click griffe.ExprYield href "" "griffe.ExprYield"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Yield statements like `yield a`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str | Expr | None`) â€“ Yielded value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str | Expr | None = None
```

Yielded value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "yield"
    if self.value is not None:
        yield " "
        yield from _yield(self.value, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

## ExprYieldFrom

```
ExprYieldFrom(value: str | Expr)
```

Bases: `Expr`

```
              flowchart TD
              griffe.ExprYieldFrom[ExprYieldFrom]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprYieldFrom
                


              click griffe.ExprYieldFrom href "" "griffe.ExprYieldFrom"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
```

Yield statements like `yield from a`.

Methods:

- **`__iter__`** â€“ Iterate on the expression syntax and elements.
- **`as_dict`** â€“ Return the expression as a dictionary.
- **`iterate`** â€“ Iterate on the expression elements.
- **`modernize`** â€“ Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) â€“ Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) â€“ Path of the expressed name/attribute.
- **`classname`** (`str`) â€“ The expression class name.
- **`is_classvar`** (`bool`) â€“ Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) â€“ Whether this expression is a generator.
- **`is_iterator`** (`bool`) â€“ Whether this expression is an iterator.
- **`is_tuple`** (`bool`) â€“ Whether this expression is a tuple.
- **`path`** (`str`) â€“ Path of the expressed name/attribute.
- **`value`** (`str | Expr`) â€“ Yielded-from value.

### canonical_name

```
canonical_name: str
```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str
```

Path of the expressed name/attribute.

### classname

```
classname: str
```

The expression class name.

### is_classvar

```
is_classvar: bool
```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool
```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool
```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool
```

Whether this expression is a tuple.

### path

```
path: str
```

Path of the expressed name/attribute.

### value

```
value: str | Expr
```

Yielded-from value.

### __iter__

```
__iter__() -> Iterator[str | Expr]
```

Iterate on the expression syntax and elements.

Source code in `src/griffe/_internal/expressions.py`

```
def __iter__(self) -> Iterator[str | Expr]:
    """Iterate on the expression syntax and elements."""
    yield from self.iterate(flat=False)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Configuration options (none available yet).

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/expressions.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return the expression as a dictionary.

    Parameters:
        **kwargs: Configuration options (none available yet).


    Returns:
        A dictionary.
    """
    return _expr_as_dict(self, **kwargs)
```

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]
```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) â€“ Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` â€“ Strings and names when flat, strings and expressions otherwise.

Source code in `src/griffe/_internal/expressions.py`

```
def iterate(self, *, flat: bool = True) -> Iterator[str | Expr]:
    yield "yield from "
    yield from _yield(self.value, flat=flat)
```

### modernize

```
modernize() -> Expr
```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` â€“ A modernized expression.

Source code in `src/griffe/_internal/expressions.py`

```
def modernize(self) -> Expr:
    """Modernize the expression.

    For example, use PEP 604 type unions `|` instead of `typing.Union`.

    Returns:
        A modernized expression.
    """
    return self
```

# Extensions

## **Main API**

## load_extensions

```
load_extensions(*exts: LoadableExtensionType) -> Extensions
```

Load configured extensions.

Parameters:

- ### **`exts`**

  (`LoadableExtensionType`, default: `()` ) â€“ Extensions with potential configuration options.

Returns:

- `Extensions` â€“ An extensions container.

Source code in `src/griffe/_internal/extensions/base.py`

```
def load_extensions(*exts: LoadableExtensionType) -> Extensions:
    """Load configured extensions.

    Parameters:
        exts: Extensions with potential configuration options.

    Returns:
        An extensions container.
    """
    extensions = Extensions()

    for extension in exts:
        ext = _load_extension(extension)
        if isinstance(ext, list):
            extensions.add(*ext)
        else:
            extensions.add(ext)

    # TODO: Deprecate and remove at some point?
    # Always add our built-in dataclasses extension.
    from griffe._internal.extensions.dataclasses import DataclassesExtension  # noqa: PLC0415

    for ext in extensions._extensions:
        if type(ext) is DataclassesExtension:
            break
    else:
        extensions.add(*_load_extension("dataclasses"))  # type: ignore[misc]

    return extensions
```

## Extension

Base class for Griffe extensions.

Methods:

- **`generic_inspect`** â€“ Extend the base generic inspection with extensions.
- **`generic_visit`** â€“ Visit children nodes.
- **`inspect`** â€“ Inspect a node.
- **`on_alias`** â€“ Run on aliases once the object tree has been fully constructed.
- **`on_alias_instance`** â€“ Run when an Alias has been created.
- **`on_attribute`** â€“ Run on attributes once the object tree has been fully constructed.
- **`on_attribute_instance`** â€“ Run when an Attribute has been created.
- **`on_attribute_node`** â€“ Run when visiting a new attribute node during static/dynamic analysis.
- **`on_class`** â€“ Run on classes once the object tree has been fully constructed.
- **`on_class_instance`** â€“ Run when a Class has been created.
- **`on_class_members`** â€“ Run when members of a Class have been loaded.
- **`on_class_node`** â€“ Run when visiting a new class node during static/dynamic analysis.
- **`on_function`** â€“ Run on functions once the object tree has been fully constructed.
- **`on_function_instance`** â€“ Run when a Function has been created.
- **`on_function_node`** â€“ Run when visiting a new function node during static/dynamic analysis.
- **`on_instance`** â€“ Run when an Object has been created.
- **`on_members`** â€“ Run when members of an Object have been loaded.
- **`on_module`** â€“ Run on modules once the object tree has been fully constructed.
- **`on_module_instance`** â€“ Run when a Module has been created.
- **`on_module_members`** â€“ Run when members of a Module have been loaded.
- **`on_module_node`** â€“ Run when visiting a new module node during static/dynamic analysis.
- **`on_node`** â€“ Run when visiting a new node during static/dynamic analysis.
- **`on_object`** â€“ Run on objects (every kind) once the object tree has been fully constructed.
- **`on_package`** â€“ Run when a package has been completely loaded.
- **`on_type_alias`** â€“ Run on type aliases once the object tree has been fully constructed.
- **`on_type_alias_instance`** â€“ Run when a TypeAlias has been created.
- **`on_type_alias_node`** â€“ Run when visiting a new type alias node during static/dynamic analysis.
- **`visit`** â€“ Visit a node.

### generic_inspect

```
generic_inspect(node: ObjectNode) -> None
```

Extend the base generic inspection with extensions.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/extensions/base.py`

```
def generic_inspect(self, node: ObjectNode) -> None:
    """Extend the base generic inspection with extensions.

    Parameters:
        node: The node to inspect.
    """
    for child in node.children:
        if not child.alias_target_path:
            self.inspect(child)
```

### generic_visit

```
generic_visit(node: AST) -> None
```

Visit children nodes.

Parameters:

- #### **`node`**

  (`AST`) â€“ The node to visit the children of.

Source code in `src/griffe/_internal/extensions/base.py`

```
def generic_visit(self, node: ast.AST) -> None:
    """Visit children nodes.

    Parameters:
        node: The node to visit the children of.
    """
    for child in ast_children(node):
        self.visit(child)
```

### inspect

```
inspect(node: ObjectNode) -> None
```

Inspect a node.

Parameters:

- #### **`node`**

  (`ObjectNode`) â€“ The node to inspect.

Source code in `src/griffe/_internal/extensions/base.py`

```
def inspect(self, node: ObjectNode) -> None:
    """Inspect a node.

    Parameters:
        node: The node to inspect.
    """
    getattr(self, f"inspect_{node.kind}", lambda _: None)(node)
```

### on_alias

```
on_alias(
    *, alias: Alias, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run on aliases once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`alias`**

  (`Alias`) â€“ The alias instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_alias(self, *, alias: Alias, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on aliases once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        alias: The alias instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_alias_instance

```
on_alias_instance(
    *,
    node: AST | ObjectNode,
    alias: Alias,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when an Alias has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`alias`**

  (`Alias`) â€“ The alias instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_alias_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    alias: Alias,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when an Alias has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        alias: The alias instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
    if getattr(self, "__old_on_alias", False):
        self.on_alias(node=node, alias=alias, agent=agent, **kwargs)
```

### on_attribute

```
on_attribute(
    *, attr: Attribute, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run on attributes once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`attr`**

  (`Attribute`) â€“ The attribute instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_attribute(self, *, attr: Attribute, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on attributes once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        attr: The attribute instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_attribute_instance

```
on_attribute_instance(
    *,
    node: AST | ObjectNode,
    attr: Attribute,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when an Attribute has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`attr`**

  (`Attribute`) â€“ The attribute instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_attribute_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    attr: Attribute,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when an Attribute has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        attr: The attribute instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_attribute_node

```
on_attribute_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when visiting a new attribute node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_attribute_node(self, *, node: ast.AST | ObjectNode, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when visiting a new attribute node during static/dynamic analysis.

    Parameters:
        node: The currently visited node.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_class

```
on_class(
    *, cls: Class, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run on classes once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`cls`**

  (`Class`) â€“ The class instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_class(self, *, cls: Class, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on classes once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        cls: The class instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_class_instance

```
on_class_instance(
    *,
    node: AST | ObjectNode,
    cls: Class,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when a Class has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`cls`**

  (`Class`) â€“ The class instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_class_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    cls: Class,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when a Class has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        cls: The class instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_class_members

```
on_class_members(
    *,
    node: AST | ObjectNode,
    cls: Class,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when members of a Class have been loaded.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`cls`**

  (`Class`) â€“ The class instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_class_members(
    self,
    *,
    node: ast.AST | ObjectNode,
    cls: Class,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when members of a Class have been loaded.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        cls: The class instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_class_node

```
on_class_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when visiting a new class node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_class_node(self, *, node: ast.AST | ObjectNode, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when visiting a new class node during static/dynamic analysis.

    Parameters:
        node: The currently visited node.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_function

```
on_function(
    *, func: Function, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run on functions once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`func`**

  (`Function`) â€“ The function instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_function(self, *, func: Function, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on functions once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        func: The function instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_function_instance

```
on_function_instance(
    *,
    node: AST | ObjectNode,
    func: Function,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when a Function has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`func`**

  (`Function`) â€“ The function instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_function_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    func: Function,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when a Function has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        func: The function instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_function_node

```
on_function_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when visiting a new function node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_function_node(self, *, node: ast.AST | ObjectNode, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when visiting a new function node during static/dynamic analysis.

    Parameters:
        node: The currently visited node.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_instance

```
on_instance(
    *,
    node: AST | ObjectNode,
    obj: Object,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when an Object has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`obj`**

  (`Object`) â€“ The object instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    obj: Object,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when an Object has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        obj: The object instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_members

```
on_members(
    *,
    node: AST | ObjectNode,
    obj: Object,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when members of an Object have been loaded.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`obj`**

  (`Object`) â€“ The object instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_members(self, *, node: ast.AST | ObjectNode, obj: Object, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when members of an Object have been loaded.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        obj: The object instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_module

```
on_module(
    *, mod: Module, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run on modules once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`mod`**

  (`Module`) â€“ The module instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_module(self, *, mod: Module, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on modules once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        mod: The module instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_module_instance

```
on_module_instance(
    *,
    node: AST | ObjectNode,
    mod: Module,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when a Module has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`mod`**

  (`Module`) â€“ The module instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_module_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    mod: Module,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when a Module has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        mod: The module instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_module_members

```
on_module_members(
    *,
    node: AST | ObjectNode,
    mod: Module,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when members of a Module have been loaded.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`mod`**

  (`Module`) â€“ The module instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_module_members(
    self,
    *,
    node: ast.AST | ObjectNode,
    mod: Module,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when members of a Module have been loaded.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        mod: The module instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_module_node

```
on_module_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when visiting a new module node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_module_node(self, *, node: ast.AST | ObjectNode, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when visiting a new module node during static/dynamic analysis.

    Parameters:
        node: The currently visited node.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_node

```
on_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when visiting a new node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_node(self, *, node: ast.AST | ObjectNode, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when visiting a new node during static/dynamic analysis.

    Parameters:
        node: The currently visited node.
    """
```

### on_object

```
on_object(
    *, obj: Object, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run on objects (every kind) once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`obj`**

  (`Object`) â€“ The object instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_object(self, *, obj: Object, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on objects (every kind) once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        obj: The object instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_package

```
on_package(
    *, pkg: Module, loader: GriffeLoader, **kwargs: Any
) -> None
```

Run when a package has been completely loaded.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`pkg`**

  (`Module`) â€“ The package (Module) instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_package(self, *, pkg: Module, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run when a package has been completely loaded.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        pkg: The package (Module) instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
    # YORE: Bump 2: Remove block.
    if hasattr(self, "on_package_loaded"):
        self.on_package_loaded(pkg=pkg, loader=loader, **kwargs)
```

### on_type_alias

```
on_type_alias(
    *,
    type_alias: TypeAlias,
    loader: GriffeLoader,
    **kwargs: Any,
) -> None
```

Run on type aliases once the object tree has been fully constructed.

Note

This method runs once the object tree has been fully constructed: data is therefore complete and you can safely hook onto this event.

Parameters:

- #### **`type_alias`**

  (`TypeAlias`) â€“ The type alias instance.

- #### **`loader`**

  (`GriffeLoader`) â€“ The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_type_alias(self, *, type_alias: TypeAlias, loader: GriffeLoader, **kwargs: Any) -> None:
    """Run on type aliases once the object tree has been fully constructed.

    Note:
        This method runs once the object tree has been fully constructed:
        data is therefore complete and you can safely hook onto this event.

    Parameters:
        type_alias: The type alias instance.
        loader: The loader currently in use.
        **kwargs: For forward-compatibility.
    """
```

### on_type_alias_instance

```
on_type_alias_instance(
    *,
    node: AST | ObjectNode,
    type_alias: TypeAlias,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when a TypeAlias has been created.

Warning

This method runs while the object tree is still being constructed: data might be incomplete (class inheritance, alias resolution, etc.). Only hook onto this event if you know what you're doing.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`type_alias`**

  (`TypeAlias`) â€“ The type alias instance.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_type_alias_instance(
    self,
    *,
    node: ast.AST | ObjectNode,
    type_alias: TypeAlias,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None:
    """Run when a TypeAlias has been created.

    Warning:
        This method runs while the object tree is still being constructed:
        data might be incomplete (class inheritance, alias resolution, etc.).
        Only hook onto this event if you know what you're doing.

    Parameters:
        node: The currently visited node.
        type_alias: The type alias instance.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### on_type_alias_node

```
on_type_alias_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None
```

Run when visiting a new type alias node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) â€“ The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) â€“ The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ For forward-compatibility.

Source code in `src/griffe/_internal/extensions/base.py`

```
def on_type_alias_node(self, *, node: ast.AST | ObjectNode, agent: Visitor | Inspector, **kwargs: Any) -> None:
    """Run when visiting a new type alias node during static/dynamic analysis.

    Parameters:
        node: The currently visited node.
        agent: The analysis agent currently running.
        **kwargs: For forward-compatibility.
    """
```

### visit

```
visit(node: AST) -> None
```

Visit a node.

Parameters:

- #### **`node`**

  (`AST`) â€“ The node to visit.

Source code in `src/griffe/_internal/extensions/base.py`

```
def visit(self, node: ast.AST) -> None:
    """Visit a node.

    Parameters:
        node: The node to visit.
    """
    getattr(self, f"visit_{ast_kind(node)}", lambda _: None)(node)
```

## **Advanced API**

## Extensions

```
Extensions(*extensions: Extension)
```

This class helps iterating on extensions that should run at different times.

Parameters:

- ### **`*extensions`**

  (`Extension`, default: `()` ) â€“ The extensions to add.

Methods:

- **`add`** â€“ Add extensions to this container.
- **`call`** â€“ Call the extension hook for the given event.

Source code in `src/griffe/_internal/extensions/base.py`

```
def __init__(self, *extensions: Extension) -> None:
    """Initialize the extensions container.

    Parameters:
        *extensions: The extensions to add.
    """
    self._extensions: list[Extension] = []
    self.add(*extensions)
```

### add

```
add(*extensions: Extension) -> None
```

Add extensions to this container.

Parameters:

- #### **`*extensions`**

  (`Extension`, default: `()` ) â€“ The extensions to add.

Source code in `src/griffe/_internal/extensions/base.py`

```
def add(self, *extensions: Extension) -> None:
    """Add extensions to this container.

    Parameters:
        *extensions: The extensions to add.
    """
    for extension in extensions:
        self._extensions.append(extension)
```

### call

```
call(event: str, **kwargs: Any) -> None
```

Call the extension hook for the given event.

Parameters:

- #### **`event`**

  (`str`) â€“ The triggered event.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Arguments passed to the hook.

Source code in `src/griffe/_internal/extensions/base.py`

```
def call(self, event: str, **kwargs: Any) -> None:
    """Call the extension hook for the given event.

    Parameters:
        event: The triggered event.
        **kwargs: Arguments passed to the hook.
    """
    for extension in self._extensions:
        # YORE: Bump 2: Replace block with line 5.
        if event == "on_alias" and getattr(extension, "__old_on_alias", False):
            with suppress(TypeError):
                getattr(extension, event)(**kwargs)
        else:
            getattr(extension, event, self._noop)(**kwargs)
```

## **Types**

## LoadableExtensionType

```
LoadableExtensionType = Union[
    str, dict[str, Any], Extension, type[Extension]
]
```

All the types that can be passed to `load_extensions`.

## **Builtin extensions**

## builtin_extensions

```
builtin_extensions: set[str] = {
    "dataclasses",
    "unpack_typeddict",
}
```

The names of built-in Griffe extensions.

## DataclassesExtension

Bases: `Extension`

```
              flowchart TD
              griffe.DataclassesExtension[DataclassesExtension]
              griffe._internal.extensions.base.Extension[Extension]

                              griffe._internal.extensions.base.Extension --> griffe.DataclassesExtension
                


              click griffe.DataclassesExtension href "" "griffe.DataclassesExtension"
              click griffe._internal.extensions.base.Extension href "" "griffe._internal.extensions.base.Extension"
```

Built-in extension adding support for dataclasses.

This extension creates `__init__` methods of dataclasses if they don't already exist.

Methods:

- **`on_package`** â€“ Hook for loaded packages.

### on_package

```
on_package(*, pkg: Module, **kwargs: Any) -> None
```

Hook for loaded packages.

Parameters:

- #### **`pkg`**

  (`Module`) â€“ The loaded package.

Source code in `src/griffe/_internal/extensions/dataclasses.py`

```
def on_package(self, *, pkg: Module, **kwargs: Any) -> None:  # noqa: ARG002
    """Hook for loaded packages.

    Parameters:
        pkg: The loaded package.
    """
    _apply_recursively(pkg, set())
```

## UnpackTypedDictExtension

Bases: `Extension`

```
              flowchart TD
              griffe.UnpackTypedDictExtension[UnpackTypedDictExtension]
              griffe._internal.extensions.base.Extension[Extension]

                              griffe._internal.extensions.base.Extension --> griffe.UnpackTypedDictExtension
                


              click griffe.UnpackTypedDictExtension href "" "griffe.UnpackTypedDictExtension"
              click griffe._internal.extensions.base.Extension href "" "griffe._internal.extensions.base.Extension"
```

An extension to handle `Unpack[TypeDict]`.

Methods:

- **`on_class`** â€“ Add an __init__ method to TypedDict classes if missing.
- **`on_function`** â€“ Expand \*\*kwargs: Unpack[TypedDict] in function signatures.

### on_class

```
on_class(*, cls: Class, **kwargs: Any) -> None
```

Add an `__init__` method to `TypedDict` classes if missing.

Source code in `src/griffe/_internal/extensions/unpack_typeddict.py`

```
def on_class(self, *, cls: Class, **kwargs: Any) -> None:  # noqa: ARG002
    """Add an `__init__` method to `TypedDict` classes if missing."""
    for base in cls.bases:
        if isinstance(base, Expr) and base.canonical_path in {"typing.TypedDict", "typing_extensions.TypedDict"}:
            cls.labels.add("typed-dict")
            break
    else:
        return

    required, optional = _get_or_set_attrs(cls)

    if "__init__" not in cls.members:
        # Build the `__init__` method and add it to the class.
        parameters = Parameters(
            Parameter(name="self", kind=ParameterKind.positional_or_keyword),
            *_params_from_attrs(required, optional),
        )
        # TODO: Add `**kwargs` parameter if extra items are allowed.
        init = Function(name="__init__", parameters=parameters, returns="None")
        cls.set_member("__init__", init)
        # Update the `__init__` docstring.
        _update_docstring(init, required, optional)

    # Remove attributes from the class, as they are now in the `__init__` method.
    for attr in chain(required, optional):
        cls.del_member(attr["name"])
```

### on_function

```
on_function(*, func: Function, **kwargs: Any) -> None
```

Expand `**kwargs: Unpack[TypedDict]` in function signatures.

Source code in `src/griffe/_internal/extensions/unpack_typeddict.py`

```
def on_function(self, *, func: Function, **kwargs: Any) -> None:  # noqa: ARG002
    """Expand `**kwargs: Unpack[TypedDict]` in function signatures."""
    # Find any `**kwargs: Unpack[TypedDict]` parameter.
    for parameter in func.parameters:
        if parameter.kind is ParameterKind.var_keyword:
            annotation = parameter.annotation
            if isinstance(annotation, ExprSubscript) and annotation.canonical_path in {
                "typing.Annotated",
                "typing_extensions.Annotated",
            }:
                annotation = annotation.slice.elements[0]  # type: ignore[union-attr]
            if isinstance(annotation, ExprSubscript) and annotation.canonical_path in {
                "typing.Unpack",
                "typing_extensions.Unpack",
            }:
                slice_path = annotation.slice.canonical_path  # type: ignore[union-attr]
                typed_dict = func.modules_collection[slice_path]
                break
    else:
        return

    required, optional = _get_or_set_attrs(typed_dict)

    # Update any parameter section in the docstring.
    # We do this before updating the signature so that
    # parsing the docstring doesn't emit warnings.
    _update_docstring(func, required, optional, parameter)

    # Update the function parameters.
    del func.parameters[parameter.name]
    for param in _params_from_attrs(required, optional):
        func.parameters[param.name] = Parameter(
            name=param.name,
            annotation=param.annotation,
            kind=ParameterKind.keyword_only,
            default=param.default,
            docstring=param.docstring,
        )
```

# Finder

## **Advanced API**

## ModuleFinder

```
ModuleFinder(
    search_paths: Sequence[str | Path] | None = None,
)
```

The Griffe finder, allowing to find modules on the file system.

The module finder is generally not used directly. Each GriffeLoader instance creates its own module finder instance. The finder can be configured when instantiating the loader thanks to the loader's `search_paths` parameter.

Parameters:

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ Optional paths to search into.

Methods:

- **`append_search_path`** â€“ Append a search path.
- **`find_package`** â€“ Find a package or namespace package.
- **`find_spec`** â€“ Find the top-level parent module of a module.
- **`insert_search_path`** â€“ Insert a search path at the given position.
- **`iter_submodules`** â€“ Iterate on a module's submodules, if any.
- **`submodules`** â€“ Return the list of a module's submodules.

Attributes:

- **`accepted_py_module_extensions`** (`list[str]`) â€“ List of extensions supported by the finder.
- **`extensions_set`** (`set[str]`) â€“ Set of extensions supported by the finder.
- **`search_paths`** (`list[Path]`) â€“ The finder search paths.

Source code in `src/griffe/_internal/finder.py`

```
def __init__(self, search_paths: Sequence[str | Path] | None = None) -> None:
    """Initialize the finder.

    Parameters:
        search_paths: Optional paths to search into.
    """
    self._paths_contents: dict[Path, list[Path]] = {}
    self.search_paths: list[Path] = []
    """The finder search paths."""

    # Optimization: pre-compute Paths to relieve CPU when joining paths.
    for path in search_paths or sys.path:
        self.append_search_path(Path(path))

    self._always_scan_for: dict[str, list[Path]] = defaultdict(list)
    self._extend_from_pth_files()
```

### accepted_py_module_extensions

```
accepted_py_module_extensions: list[str] = [
    ".py",
    ".pyc",
    ".pyo",
    ".pyd",
    ".pyi",
    ".so",
]
```

List of extensions supported by the finder.

### extensions_set

```
extensions_set: set[str] = set(
    accepted_py_module_extensions
)
```

Set of extensions supported by the finder.

### search_paths

```
search_paths: list[Path] = []
```

The finder search paths.

### append_search_path

```
append_search_path(path: Path) -> None
```

Append a search path.

The path will be resolved (absolute, normalized). The path won't be appended if it is already in the search paths list.

Parameters:

- #### **`path`**

  (`Path`) â€“ The path to append.

Source code in `src/griffe/_internal/finder.py`

```
def append_search_path(self, path: Path) -> None:
    """Append a search path.

    The path will be resolved (absolute, normalized).
    The path won't be appended if it is already in the search paths list.

    Parameters:
        path: The path to append.
    """
    self._append_search_path(path.resolve())
```

### find_package

```
find_package(
    module_name: str,
) -> Package | NamespacePackage
```

Find a package or namespace package.

Parameters:

- #### **`module_name`**

  (`str`) â€“ The module name.

Raises:

- `ModuleNotFoundError` â€“ When the module cannot be found.

Returns:

- `Package | NamespacePackage` â€“ A package or namespace package wrapper.

Source code in `src/griffe/_internal/finder.py`

```
def find_package(self, module_name: str) -> Package | NamespacePackage:
    """Find a package or namespace package.

    Parameters:
        module_name: The module name.

    Raises:
        ModuleNotFoundError: When the module cannot be found.

    Returns:
        A package or namespace package wrapper.
    """
    filepaths = [
        Path(module_name),
        # TODO: Handle .py[cod] and .so files?
        # This would be needed for package that are composed
        # solely of a file with such an extension.
        Path(f"{module_name}.py"),
    ]

    real_module_name = module_name
    real_module_name = real_module_name.removesuffix("-stubs")
    namespace_dirs = []
    for path in self.search_paths:
        path_contents = self._contents(path)
        if path_contents:
            for choice in filepaths:
                abs_path = path / choice
                if abs_path in path_contents:
                    if abs_path.suffix:
                        stubs = abs_path.with_suffix(".pyi")
                        return Package(real_module_name, abs_path, stubs if stubs.exists() else None)
                    init_module = abs_path / "__init__.py"
                    if init_module.exists() and not _is_pkg_style_namespace(init_module):
                        stubs = init_module.with_suffix(".pyi")
                        return Package(real_module_name, init_module, stubs if stubs.exists() else None)
                    init_module = abs_path / "__init__.pyi"
                    if init_module.exists():
                        # Stubs package.
                        return Package(real_module_name, init_module, None)
                    namespace_dirs.append(abs_path)

    if namespace_dirs:
        return NamespacePackage(module_name, namespace_dirs)

    raise ModuleNotFoundError(module_name)
```

### find_spec

```
find_spec(
    module: str | Path,
    *,
    try_relative_path: bool = True,
    find_stubs_package: bool = False,
) -> tuple[str, Package | NamespacePackage]
```

Find the top-level parent module of a module.

If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths.

Parameters:

- #### **`module`**

  (`str | Path`) â€“ The module name or path.

- #### **`try_relative_path`**

  (`bool`, default: `True` ) â€“ Whether to try finding the module as a relative path, when the given module is not already a path.

- #### **`find_stubs_package`**

  (`bool`, default: `False` ) â€“ Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

Raises:

- `FileNotFoundError` â€“ When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist
- `ModuleNotFoundError` â€“ When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file

Returns:

- `tuple[str, Package | NamespacePackage]` â€“ The name of the module, and an instance representing its (namespace) package.

Source code in `src/griffe/_internal/finder.py`

```
def find_spec(
    self,
    module: str | Path,
    *,
    try_relative_path: bool = True,
    find_stubs_package: bool = False,
) -> tuple[str, Package | NamespacePackage]:
    """Find the top-level parent module of a module.

    If a Path is passed, only try to find the module as a file path.
    If a string is passed, first try to find the module as a file path,
    then look into the search paths.

    Parameters:
        module: The module name or path.
        try_relative_path: Whether to try finding the module as a relative path,
            when the given module is not already a path.
        find_stubs_package: Whether to search for stubs-only package.
            If both the package and its stubs are found, they'll be merged together.
            If only the stubs are found, they'll be used as the package itself.

    Raises:
        FileNotFoundError: When a Path was passed and the module could not be found:

            - the directory has no `__init__.py` file in it
            - the path does not exist

        ModuleNotFoundError: When a string was passed and the module could not be found:

            - no `module/__init__.py`
            - no `module.py`
            - no `module.pth`
            - no `module` directory (namespace packages)
            - or unsupported .pth file

    Returns:
        The name of the module, and an instance representing its (namespace) package.
    """
    module_path: Path | list[Path]
    if isinstance(module, Path):
        module_name, module_path = self._module_name_path(module)
        top_module_name = self._top_module_name(module_path)
    elif try_relative_path:
        try:
            module_name, module_path = self._module_name_path(Path(module))
        except FileNotFoundError:
            module_name = module
            top_module_name = module.split(".", 1)[0]
        else:
            top_module_name = self._top_module_name(module_path)
    else:
        module_name = module
        top_module_name = module.split(".", 1)[0]

    # Only search for actual package, let exceptions bubble up.
    if not find_stubs_package:
        return module_name, self.find_package(top_module_name)

    # Search for both package and stubs-only package.
    try:
        package = self.find_package(top_module_name)
    except ModuleNotFoundError:
        package = None
    try:
        stubs = self.find_package(top_module_name + "-stubs")
    except ModuleNotFoundError:
        stubs = None

    # None found, raise error.
    if package is None and stubs is None:
        raise ModuleNotFoundError(top_module_name)

    # Both found, assemble them to be merged later.
    if package and stubs:
        if isinstance(package, Package) and isinstance(stubs, Package):
            package.stubs = stubs.path
        elif isinstance(package, NamespacePackage) and isinstance(stubs, NamespacePackage):
            package.path += stubs.path
        return module_name, package

    # Return either one.
    return module_name, package or stubs  # type: ignore[return-value]
```

### insert_search_path

```
insert_search_path(position: int, path: Path) -> None
```

Insert a search path at the given position.

The path will be resolved (absolute, normalized). The path won't be inserted if it is already in the search paths list.

Parameters:

- #### **`position`**

  (`int`) â€“ The insert position in the list.

- #### **`path`**

  (`Path`) â€“ The path to insert.

Source code in `src/griffe/_internal/finder.py`

```
def insert_search_path(self, position: int, path: Path) -> None:
    """Insert a search path at the given position.

    The path will be resolved (absolute, normalized).
    The path won't be inserted if it is already in the search paths list.

    Parameters:
        position: The insert position in the list.
        path: The path to insert.
    """
    path = path.resolve()
    if path not in self.search_paths:
        self.search_paths.insert(position, path)
```

### iter_submodules

```
iter_submodules(
    path: Path | list[Path], seen: set | None = None
) -> Iterator[NamePartsAndPathType]
```

Iterate on a module's submodules, if any.

Parameters:

- #### **`path`**

  (`Path | list[Path]`) â€“ The module path.

- #### **`seen`**

  (`set | None`, default: `None` ) â€“ If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with __init__ modules) of the same name found in different namespace packages. As soon as we find an __init__ module, we add its parent path to the seen set, which will be reused when scanning the next namespace packages.

Yields:

- **`name_parts`** ( `tuple[str, ...]` ) â€“ The parts of a submodule name.
- **`filepath`** ( `Path` ) â€“ A submodule filepath.

Source code in `src/griffe/_internal/finder.py`

```
def iter_submodules(
    self,
    path: Path | list[Path],
    seen: set | None = None,
) -> Iterator[NamePartsAndPathType]:
    """Iterate on a module's submodules, if any.

    Parameters:
        path: The module path.
        seen: If not none, this set is used to skip some files.
            The goal is to replicate the behavior of Python by
            only using the first packages (with `__init__` modules)
            of the same name found in different namespace packages.
            As soon as we find an `__init__` module, we add its parent
            path to the `seen` set, which will be reused when scanning
            the next namespace packages.

    Yields:
        name_parts (tuple[str, ...]): The parts of a submodule name.
        filepath (Path): A submodule filepath.
    """
    if isinstance(path, list):
        # We never enter this condition again in recursive calls,
        # so we just have to set `seen` once regardless of its value.
        seen = set()
        for path_elem in path:
            yield from self.iter_submodules(path_elem, seen)
        return

    if path.stem == "__init__":
        path = path.parent
    # Optimization: just check if the file name ends with .py[icod]/.so
    # (to distinguish it from a directory), not if it's an actual file.
    elif path.suffix in self.extensions_set:
        return

    # `seen` is only set when we scan a list of paths (namespace package).
    # `skip` is used to prevent yielding modules
    # of a regular subpackage that we already yielded
    # from another part of the namespace.
    skip = set(seen or ())

    for subpath in self._filter_py_modules(path):
        rel_subpath = subpath.relative_to(path)
        if rel_subpath.parent in skip:
            logger.debug("Skip %s, another module took precedence", subpath)
            continue
        py_file = rel_subpath.suffix == ".py"
        stem = rel_subpath.stem
        if not py_file:
            # `.py[cod]` and `.so` files look like `name.cpython-38-x86_64-linux-gnu.ext`.
            stem = stem.split(".", 1)[0]
        if stem == "__init__":
            # Optimization: since it's a relative path, if it has only one part
            # and is named __init__, it means it's the starting path
            # (no need to compare it against starting path).
            if len(rel_subpath.parts) == 1:
                continue
            yield rel_subpath.parts[:-1], subpath
            if seen is not None:
                seen.add(rel_subpath.parent)
        elif py_file:
            yield rel_subpath.with_suffix("").parts, subpath
        else:
            yield rel_subpath.with_name(stem).parts, subpath
```

### submodules

```
submodules(module: Module) -> list[NamePartsAndPathType]
```

Return the list of a module's submodules.

Parameters:

- #### **`module`**

  (`Module`) â€“ The parent module.

Returns:

- `list[NamePartsAndPathType]` â€“ A list of tuples containing the parts of the submodule name and its path.

Source code in `src/griffe/_internal/finder.py`

```
def submodules(self, module: Module) -> list[NamePartsAndPathType]:
    """Return the list of a module's submodules.

    Parameters:
        module: The parent module.

    Returns:
        A list of tuples containing the parts of the submodule name and its path.
    """
    return sorted(
        chain(
            self.iter_submodules(module.filepath),
            self.iter_submodules(self._always_scan_for[module.name]),
        ),
        key=_module_depth,
    )
```

## Package

```
Package(name: str, path: Path, stubs: Path | None = None)
```

This class is a simple placeholder used during the process of finding packages.

Parameters:

- ### **`name`**

  (`str`) â€“ The package name.

- ### **`path`**

  (`Path`) â€“ The package path(s).

- ### **`stubs`**

  (`Path | None`, default: `None` ) â€“ An optional path to the related stubs file (.pyi).

Attributes:

- **`name`** (`str`) â€“ Package name.
- **`path`** (`Path`) â€“ Package folder path.
- **`stubs`** (`Path | None`) â€“ Package stubs file.

### name

```
name: str
```

Package name.

### path

```
path: Path
```

Package folder path.

### stubs

```
stubs: Path | None = None
```

Package stubs file.

## NamespacePackage

```
NamespacePackage(name: str, path: list[Path])
```

This class is a simple placeholder used during the process of finding packages.

Parameters:

- ### **`name`**

  (`str`) â€“ The package name.

- ### **`path`**

  (`list[Path]`) â€“ The package paths.

Attributes:

- **`name`** (`str`) â€“ Namespace package name.
- **`path`** (`list[Path]`) â€“ Namespace package folder paths.

### name

```
name: str
```

Namespace package name.

### path

```
path: list[Path]
```

Namespace package folder paths.

## **Types**

## NamePartsType

```
NamePartsType = tuple[str, ...]
```

Type alias for the parts of a module name.

## NamePartsAndPathType

```
NamePartsAndPathType = tuple[NamePartsType, Path]
```

Type alias for the parts of a module name and its path.

# Git utilities

Deprecated utilities.

We have decided to stop exposing Git-related utilities as it's not a core part of the library's functionality. The functions documented on this page will become unavailable in the next major version.

## assert_git_repo

```
assert_git_repo(path: str | Path) -> None
```

Deprecated. Assert that a directory is a Git repository.

This function is deprecated and will become unavailable in the next major version.

Parameters:

- ### **`path`**

  (`str | Path`) â€“ Path to a directory.

Raises:

- `OSError` â€“ When the directory is not a Git repository.

Source code in `src/griffe/_internal/git.py`

```
def _assert_git_repo(path: str | Path) -> None:
    """Deprecated. Assert that a directory is a Git repository.

    Parameters:
        path: Path to a directory.

    Raises:
        OSError: When the directory is not a Git repository.
    """
    if not shutil.which("git"):
        raise RuntimeError("Could not find git executable. Please install git.")
    try:
        _git("-C", str(path), "rev-parse", "--is-inside-work-tree")
    except GitError as error:
        raise OSError(f"Not a git repository: {path}") from error
```

## get_latest_tag

```
get_latest_tag(repo: str | Path) -> str
```

Deprecated. Get latest tag of a Git repository.

This function is deprecated and will become unavailable in the next major version.

Parameters:

- ### **`repo`**

  (`str | Path`) â€“ The path to Git repository.

Returns:

- `str` â€“ The latest tag.

Source code in `src/griffe/_internal/git.py`

```
def _get_latest_tag(repo: str | Path) -> str:
    """Deprecated. Get latest tag of a Git repository.

    Parameters:
        repo: The path to Git repository.

    Returns:
        The latest tag.
    """
    if isinstance(repo, str):
        repo = Path(repo)
    if not repo.is_dir():
        repo = repo.parent
    try:
        output = _git("tag", "-l", "--sort=-creatordate")
    except GitError as error:
        raise GitError(f"Cannot list Git tags in {repo}: {error or 'no tags'}") from error
    return output.split("\n", 1)[0]
```

## get_repo_root

```
get_repo_root(repo: str | Path) -> Path
```

Deprecated. Get the root of a Git repository.

This function is deprecated and will become unavailable in the next major version.

Parameters:

- ### **`repo`**

  (`str | Path`) â€“ The path to a Git repository.

Returns:

- `Path` â€“ The root of the repository.

Source code in `src/griffe/_internal/git.py`

```
def _get_repo_root(repo: str | Path) -> Path:
    """Deprecated. Get the root of a Git repository.

    Parameters:
        repo: The path to a Git repository.

    Returns:
        The root of the repository.
    """
    if isinstance(repo, str):
        repo = Path(repo)
    if not repo.is_dir():
        repo = repo.parent
    return Path(_git("-C", str(repo), "rev-parse", "--show-toplevel"))
```

## tmp_worktree

```
tmp_worktree(
    repo: str | Path = ".", ref: str = "HEAD"
) -> Iterator[Path]
```

Deprecated. Context manager that checks out the given reference in the given repository to a temporary worktree.

This function is deprecated and will become unavailable in the next major version.

Parameters:

- ### **`repo`**

  (`str | Path`, default: `'.'` ) â€“ Path to the repository (i.e. the directory containing the .git directory)

- ### **`ref`**

  (`str`, default: `'HEAD'` ) â€“ A Git reference such as a commit, tag or branch.

Yields:

- `Path` â€“ The path to the temporary worktree.

Raises:

- `OSError` â€“ If repo is not a valid .git repository
- `RuntimeError` â€“ If the git executable is unavailable, or if it cannot create a worktree

Source code in `src/griffe/_internal/git.py`

```
@contextmanager
def _tmp_worktree(repo: str | Path = ".", ref: str = "HEAD") -> Iterator[Path]:
    """Deprecated. Context manager that checks out the given reference in the given repository to a temporary worktree.

    Parameters:
        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)
        ref: A Git reference such as a commit, tag or branch.

    Yields:
        The path to the temporary worktree.

    Raises:
        OSError: If `repo` is not a valid `.git` repository
        RuntimeError: If the `git` executable is unavailable, or if it cannot create a worktree
    """
    _assert_git_repo(repo)
    repo_name = Path(repo).resolve().name
    normref = _normalize(ref)  # Branch names can contain slashes.
    with TemporaryDirectory(prefix=f"{_WORKTREE_PREFIX}{repo_name}-{normref}-") as tmp_dir:
        location = os.path.join(tmp_dir, normref)  # noqa: PTH118
        tmp_branch = f"griffe-{normref}"  # Temporary branch name must not already exist.
        try:
            _git("-C", str(repo), "worktree", "add", "-b", tmp_branch, location, ref)
        except GitError as error:
            raise RuntimeError(f"Could not create git worktree: {error}") from error

        try:
            yield Path(location)
        finally:
            _git("-C", str(repo), "worktree", "remove", location, check=False)
            _git("-C", str(repo), "worktree", "prune", check=False)
            _git("-C", str(repo), "branch", "-D", tmp_branch, check=False)
```

# Helpers

## TmpPackage

```
TmpPackage(tmpdir: Path, name: str, path: Path)
```

A temporary package.

The `tmpdir` and `path` parameters can be passed as relative path. They will be resolved to absolute paths after initialization.

Attributes:

- **`name`** (`str`) â€“ The package name, as to dynamically import it.
- **`path`** (`Path`) â€“ The package path.
- **`tmpdir`** (`Path`) â€“ The temporary directory containing the package.

### name

```
name: str
```

The package name, as to dynamically import it.

### path

```
path: Path
```

The package path.

### tmpdir

```
tmpdir: Path
```

The temporary directory containing the package.

## temporary_pyfile

```
temporary_pyfile(
    code: str, *, module_name: str = "module"
) -> Iterator[tuple[str, Path]]
```

Create a Python file containing the given code in a temporary directory.

Parameters:

- ### **`code`**

  (`str`) â€“ The code to write to the temporary file.

- ### **`module_name`**

  (`str`, default: `'module'` ) â€“ The name of the temporary module.

Yields:

- **`module_name`** ( `str` ) â€“ The module name, as to dynamically import it.
- **`module_path`** ( `Path` ) â€“ The module path.

Source code in `src/griffe/_internal/tests.py`

```
@contextmanager
def temporary_pyfile(code: str, *, module_name: str = "module") -> Iterator[tuple[str, Path]]:
    """Create a Python file containing the given code in a temporary directory.

    Parameters:
        code: The code to write to the temporary file.
        module_name: The name of the temporary module.

    Yields:
        module_name: The module name, as to dynamically import it.
        module_path: The module path.
    """
    with tempfile.TemporaryDirectory(prefix=_TMPDIR_PREFIX) as tmpdir:
        tmpfile = Path(tmpdir) / f"{module_name}.py"
        tmpfile.write_text(dedent(code), encoding="utf8")
        yield module_name, tmpfile
```

## temporary_pypackage

```
temporary_pypackage(
    package: str,
    modules: Sequence[str]
    | Mapping[str, str]
    | None = None,
    *,
    init: bool = True,
    inits: bool = True,
) -> Iterator[TmpPackage]
```

Create a package containing the given modules in a temporary directory.

Parameters:

- ### **`package`**

  (`str`) â€“ The package name. Example: "a" gives a package named a, while "a/b" gives a namespace package named a with a package inside named b. If init is false, then b is also a namespace package.

- ### **`modules`**

  (`Sequence[str] | Mapping[str, str] | None`, default: `None` ) â€“ Additional modules to create in the package. If a list, simply touch the files: ["b.py", "c/d.py", "e/f"]. If a dict, keys are the file names and values their contents: {"b.py": "b = 1", "c/d.py": "print('hey from c')"}.

- ### **`init`**

  (`bool`, default: `True` ) â€“ Whether to create an __init__ module in the top package.

- ### **`inits`**

  (`bool`, default: `True` ) â€“ Whether to create __init__ modules in subpackages.

Yields:

- `TmpPackage` â€“ A temporary package.

Source code in `src/griffe/_internal/tests.py`

```
@contextmanager
def temporary_pypackage(
    package: str,
    modules: Sequence[str] | Mapping[str, str] | None = None,
    *,
    init: bool = True,
    inits: bool = True,
) -> Iterator[TmpPackage]:
    """Create a package containing the given modules in a temporary directory.

    Parameters:
        package: The package name. Example: `"a"` gives
            a package named `a`, while `"a/b"` gives a namespace package
            named `a` with a package inside named `b`.
            If `init` is false, then `b` is also a namespace package.
        modules: Additional modules to create in the package.
            If a list, simply touch the files: `["b.py", "c/d.py", "e/f"]`.
            If a dict, keys are the file names and values their contents:
            `{"b.py": "b = 1", "c/d.py": "print('hey from c')"}`.
        init: Whether to create an `__init__` module in the top package.
        inits: Whether to create `__init__` modules in subpackages.

    Yields:
        A temporary package.
    """
    modules = modules or {}
    if isinstance(modules, list):
        modules = dict.fromkeys(modules, "")
    mkdir_kwargs = {"parents": True, "exist_ok": True}
    with tempfile.TemporaryDirectory(prefix=_TMPDIR_PREFIX) as tmpdir:
        tmpdirpath = Path(tmpdir)
        package_name = ".".join(Path(package).parts)
        package_path = tmpdirpath / package
        package_path.mkdir(**mkdir_kwargs)
        if init:
            package_path.joinpath("__init__.py").touch()
        for module_name, module_contents in modules.items():  # type: ignore[union-attr]
            current_path = package_path
            for part in Path(module_name).parts:
                if part.endswith((".py", ".pyi")):
                    current_path.joinpath(part).write_text(dedent(module_contents), encoding="utf8")
                else:
                    current_path /= part
                    current_path.mkdir(**mkdir_kwargs)
                    if inits:
                        current_path.joinpath("__init__.py").touch()
        yield TmpPackage(tmpdirpath, package_name, package_path)
```

## temporary_visited_module

```
temporary_visited_module(
    code: str,
    *,
    module_name: str = "module",
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Iterator[Module]
```

Create and visit a temporary module with the given code.

Parameters:

- ### **`code`**

  (`str`) â€“ The code of the module.

- ### **`module_name`**

  (`str`, default: `'module'` ) â€“ The name of the temporary module.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use when visiting the AST.

- ### **`parent`**

  (`Module | None`, default: `None` ) â€“ The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

Yields:

- `Module` â€“ The visited module.

Source code in `src/griffe/_internal/tests.py`

```
@contextmanager
def temporary_visited_module(
    code: str,
    *,
    module_name: str = "module",
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Iterator[Module]:
    """Create and visit a temporary module with the given code.

    Parameters:
        code: The code of the module.
        module_name: The name of the temporary module.
        extensions: The extensions to use when visiting the AST.
        parent: The optional parent of this module.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.

    Yields:
        The visited module.
    """
    code = dedent(code)
    with temporary_pyfile(code, module_name=module_name) as (_, path):
        lines_collection = lines_collection or LinesCollection()
        lines_collection[path] = code.splitlines()
        module = visit(
            module_name,
            filepath=path,
            code=code,
            extensions=extensions,
            parent=parent,
            docstring_parser=docstring_parser,
            docstring_options=docstring_options,
            lines_collection=lines_collection,
            modules_collection=modules_collection,
        )
        module.modules_collection[module_name] = module
        yield module
```

## temporary_visited_package

```
temporary_visited_package(
    package: str,
    modules: Sequence[str]
    | Mapping[str, str]
    | None = None,
    *,
    init: bool = True,
    inits: bool = True,
    extensions: Extensions | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = False,
    store_source: bool = True,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
    search_sys_path: bool = False,
) -> Iterator[Module]
```

Create and visit a temporary package.

Parameters:

- ### **`package`**

  (`str`) â€“ The package name. Example: "a" gives a package named a, while "a/b" gives a namespace package named a with a package inside named b. If init is false, then b is also a namespace package.

- ### **`modules`**

  (`Sequence[str] | Mapping[str, str] | None`, default: `None` ) â€“ Additional modules to create in the package. If a list, simply touch the files: ["b.py", "c/d.py", "e/f"]. If a dict, keys are the file names and values their contents: {"b.py": "b = 1", "c/d.py": "print('hey from c')"}.

- ### **`init`**

  (`bool`, default: `True` ) â€“ Whether to create an __init__ module in the top package.

- ### **`inits`**

  (`bool`, default: `True` ) â€“ Whether to create __init__ modules in subpackages.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `False` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`store_source`**

  (`bool`, default: `True` ) â€“ Whether to store code source in the lines collection.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) â€“ Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) â€“ Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

- ### **`search_sys_path`**

  (`bool`, default: `False` ) â€“ Whether to search the system paths for the package.

Yields:

- `Module` â€“ A module.

Source code in `src/griffe/_internal/tests.py`

```
@contextmanager
def temporary_visited_package(
    package: str,
    modules: Sequence[str] | Mapping[str, str] | None = None,
    *,
    init: bool = True,
    inits: bool = True,
    extensions: Extensions | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = False,
    store_source: bool = True,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
    search_sys_path: bool = False,
) -> Iterator[Module]:
    """Create and visit a temporary package.

    Parameters:
        package: The package name. Example: `"a"` gives
            a package named `a`, while `"a/b"` gives a namespace package
            named `a` with a package inside named `b`.
            If `init` is false, then `b` is also a namespace package.
        modules: Additional modules to create in the package.
            If a list, simply touch the files: `["b.py", "c/d.py", "e/f"]`.
            If a dict, keys are the file names and values their contents:
            `{"b.py": "b = 1", "c/d.py": "print('hey from c')"}`.
        init: Whether to create an `__init__` module in the top package.
        inits: Whether to create `__init__` modules in subpackages.
        extensions: The extensions to use.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        store_source: Whether to store code source in the lines collection.
        resolve_aliases: Whether to resolve aliases.
        resolve_external: Whether to try to load unspecified modules to resolve aliases.
            Default value (`None`) means to load external modules only if they are the private sibling
            or the origin module (for example when `ast` imports from `_ast`).
        resolve_implicit: When false, only try to resolve an alias if it is explicitly exported.
        search_sys_path: Whether to search the system paths for the package.

    Yields:
        A module.
    """
    search_paths = sys.path if search_sys_path else []
    with temporary_pypackage(package, modules, init=init, inits=inits) as tmp_package:
        yield load(  # type: ignore[misc]
            tmp_package.name,
            search_paths=[tmp_package.tmpdir, *search_paths],
            extensions=extensions,
            docstring_parser=docstring_parser,
            docstring_options=docstring_options,
            lines_collection=lines_collection,
            modules_collection=modules_collection,
            allow_inspection=allow_inspection,
            store_source=store_source,
            resolve_aliases=resolve_aliases,
            resolve_external=resolve_external,
            resolve_implicit=resolve_implicit,
            force_inspection=False,
        )
```

## temporary_inspected_module

```
temporary_inspected_module(
    code: str,
    *,
    module_name: str = "module",
    import_paths: list[Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Iterator[Module]
```

Create and inspect a temporary module with the given code.

Parameters:

- ### **`code`**

  (`str`) â€“ The code of the module.

- ### **`module_name`**

  (`str`, default: `'module'` ) â€“ The name of the temporary module.

- ### **`import_paths`**

  (`list[Path] | None`, default: `None` ) â€“ Paths to import the module from.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use when visiting the AST.

- ### **`parent`**

  (`Module | None`, default: `None` ) â€“ The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

Yields:

- `Module` â€“ The inspected module.

Source code in `src/griffe/_internal/tests.py`

```
@contextmanager
def temporary_inspected_module(
    code: str,
    *,
    module_name: str = "module",
    import_paths: list[Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Iterator[Module]:
    """Create and inspect a temporary module with the given code.

    Parameters:
        code: The code of the module.
        module_name: The name of the temporary module.
        import_paths: Paths to import the module from.
        extensions: The extensions to use when visiting the AST.
        parent: The optional parent of this module.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.

    Yields:
        The inspected module.
    """
    with temporary_pyfile(code, module_name=module_name) as (_, path):
        lines_collection = lines_collection or LinesCollection()
        lines_collection[path] = code.splitlines()
        try:
            module = inspect(
                module_name,
                filepath=path,
                import_paths=import_paths,
                extensions=extensions,
                parent=parent,
                docstring_parser=docstring_parser,
                docstring_options=docstring_options,
                lines_collection=lines_collection,
                modules_collection=modules_collection,
            )
            module.modules_collection[module_name] = module
            yield module
        finally:
            if module_name in sys.modules:
                del sys.modules[module_name]
            invalidate_caches()
```

## temporary_inspected_package

```
temporary_inspected_package(
    package: str,
    modules: Sequence[str]
    | Mapping[str, str]
    | None = None,
    *,
    init: bool = True,
    inits: bool = True,
    extensions: Extensions | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    store_source: bool = True,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
    search_sys_path: bool = False,
) -> Iterator[Module]
```

Create and inspect a temporary package.

Parameters:

- ### **`package`**

  (`str`) â€“ The package name. Example: "a" gives a package named a, while "a/b" gives a namespace package named a with a package inside named b. If init is false, then b is also a namespace package.

- ### **`modules`**

  (`Sequence[str] | Mapping[str, str] | None`, default: `None` ) â€“ Additional modules to create in the package. If a list, simply touch the files: ["b.py", "c/d.py", "e/f"]. If a dict, keys are the file names and values their contents: {"b.py": "b = 1", "c/d.py": "print('hey from c')"}.

- ### **`init`**

  (`bool`, default: `True` ) â€“ Whether to create an __init__ module in the top package.

- ### **`inits`**

  (`bool`, default: `True` ) â€“ Whether to create __init__ modules in subpackages.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules.

- ### **`store_source`**

  (`bool`, default: `True` ) â€“ Whether to store code source in the lines collection.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) â€“ Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) â€“ Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

- ### **`search_sys_path`**

  (`bool`, default: `False` ) â€“ Whether to search the system paths for the package.

Yields:

- `Module` â€“ A module.

Source code in `src/griffe/_internal/tests.py`

```
@contextmanager
def temporary_inspected_package(
    package: str,
    modules: Sequence[str] | Mapping[str, str] | None = None,
    *,
    init: bool = True,
    inits: bool = True,
    extensions: Extensions | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    store_source: bool = True,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
    search_sys_path: bool = False,
) -> Iterator[Module]:
    """Create and inspect a temporary package.

    Parameters:
        package: The package name. Example: `"a"` gives
            a package named `a`, while `"a/b"` gives a namespace package
            named `a` with a package inside named `b`.
            If `init` is false, then `b` is also a namespace package.
        modules: Additional modules to create in the package.
            If a list, simply touch the files: `["b.py", "c/d.py", "e/f"]`.
            If a dict, keys are the file names and values their contents:
            `{"b.py": "b = 1", "c/d.py": "print('hey from c')"}`.
        init: Whether to create an `__init__` module in the top package.
        inits: Whether to create `__init__` modules in subpackages.
        extensions: The extensions to use.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        allow_inspection: Whether to allow inspecting modules.
        store_source: Whether to store code source in the lines collection.
        resolve_aliases: Whether to resolve aliases.
        resolve_external: Whether to try to load unspecified modules to resolve aliases.
            Default value (`None`) means to load external modules only if they are the private sibling
            or the origin module (for example when `ast` imports from `_ast`).
        resolve_implicit: When false, only try to resolve an alias if it is explicitly exported.
        search_sys_path: Whether to search the system paths for the package.

    Yields:
        A module.
    """
    search_paths = sys.path if search_sys_path else []
    with temporary_pypackage(package, modules, init=init, inits=inits) as tmp_package:
        try:
            yield load(  # type: ignore[misc]
                tmp_package.name,
                search_paths=[tmp_package.tmpdir, *search_paths],
                extensions=extensions,
                docstring_parser=docstring_parser,
                docstring_options=docstring_options,
                lines_collection=lines_collection,
                modules_collection=modules_collection,
                allow_inspection=allow_inspection,
                store_source=store_source,
                resolve_aliases=resolve_aliases,
                resolve_external=resolve_external,
                resolve_implicit=resolve_implicit,
                force_inspection=True,
            )
        finally:
            for name in tuple(sys.modules.keys()):
                if name == package or name.startswith(f"{package}."):
                    sys.modules.pop(name, None)
            invalidate_caches()
```

## vtree

```
vtree(
    *objects: Object, return_leaf: bool = False
) -> Object
```

Link objects together, vertically.

Parameters:

- ### **`*objects`**

  (`Object`, default: `()` ) â€“ A sequence of objects. The first one is at the top of the tree.

- ### **`return_leaf`**

  (`bool`, default: `False` ) â€“ Whether to return the leaf instead of the root.

Raises:

- `ValueError` â€“ When no objects are provided.

Returns:

- `Object` â€“ The top or leaf object.

Source code in `src/griffe/_internal/tests.py`

```
def vtree(*objects: Object, return_leaf: bool = False) -> Object:
    """Link objects together, vertically.

    Parameters:
        *objects: A sequence of objects. The first one is at the top of the tree.
        return_leaf: Whether to return the leaf instead of the root.

    Raises:
        ValueError: When no objects are provided.

    Returns:
        The top or leaf object.
    """
    if not objects:
        raise ValueError("At least one object must be provided")
    top = objects[0]
    leaf = top
    for obj in objects[1:]:
        leaf.set_member(obj.name, obj)
        leaf = obj
    return leaf if return_leaf else top
```

## htree

```
htree(*objects: Object) -> Object
```

Link objects together, horizontally.

Parameters:

- ### **`*objects`**

  (`Object`, default: `()` ) â€“ A sequence of objects. All objects starting at the second become members of the first.

Raises:

- `ValueError` â€“ When no objects are provided.

Returns:

- `Object` â€“ The first given object, with all the other objects as members of it.

Source code in `src/griffe/_internal/tests.py`

```
def htree(*objects: Object) -> Object:
    """Link objects together, horizontally.

    Parameters:
        *objects: A sequence of objects. All objects starting at the second become members of the first.

    Raises:
        ValueError: When no objects are provided.

    Returns:
        The first given object, with all the other objects as members of it.
    """
    if not objects:
        raise ValueError("At least one object must be provided")
    top = objects[0]
    for obj in objects[1:]:
        top.set_member(obj.name, obj)
    return top
```

## module_vtree

```
module_vtree(
    path: str,
    *,
    leaf_package: bool = True,
    return_leaf: bool = False,
) -> Module
```

Link objects together, vertically.

Parameters:

- ### **`path`**

  (`str`) â€“ The complete module path, like "a.b.c.d".

- ### **`leaf_package`**

  (`bool`, default: `True` ) â€“ Whether the deepest module should also be a package.

- ### **`return_leaf`**

  (`bool`, default: `False` ) â€“ Whether to return the leaf instead of the root.

Raises:

- `ValueError` â€“ When no objects are provided.

Returns:

- `Module` â€“ The top or leaf module.

Source code in `src/griffe/_internal/tests.py`

```
def module_vtree(path: str, *, leaf_package: bool = True, return_leaf: bool = False) -> Module:
    """Link objects together, vertically.

    Parameters:
        path: The complete module path, like `"a.b.c.d"`.
        leaf_package: Whether the deepest module should also be a package.
        return_leaf: Whether to return the leaf instead of the root.

    Raises:
        ValueError: When no objects are provided.

    Returns:
        The top or leaf module.
    """
    parts = path.split(".")
    modules = [Module(name, filepath=Path(*parts[:index], "__init__.py")) for index, name in enumerate(parts)]
    if not leaf_package:
        filepath = modules[-1].filepath.with_stem(parts[-1])  # type: ignore[union-attr]
        modules[-1]._filepath = filepath
    return vtree(*modules, return_leaf=return_leaf)  # type: ignore[return-value]
```

# Loaders

## **Main API**

## load

```
load(
    objspec: str | Path | None = None,
    /,
    *,
    submodules: bool = True,
    try_relative_path: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    store_source: bool = True,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias
```

Load and return a Griffe object.

In Griffe's context, loading means:

- searching for a package, and finding it on the file system or as a builtin module (see the ModuleFinder class for more information)
- extracting information from each of its (sub)modules, by either parsing the source code (see the visit function) or inspecting the module at runtime (see the inspect function)

The extracted information is stored in a collection of modules, which can be queried later. Each collected module is a tree of objects, representing the structure of the module. See the Module, Class, Function, Attribute, and TypeAlias classes for more information.

The main class used to load modules is GriffeLoader. Convenience functions like this one and load_git are also available.

Example

```
import griffe

module = griffe.load(...)
```

This is a shortcut for:

```
from griffe import GriffeLoader

loader = GriffeLoader(...)
module = loader.load(...)
```

See the documentation for the loader: GriffeLoader.

Parameters:

- ### **`objspec`**

  (`str | Path | None`, default: `None` ) â€“ The Python path of an object, or file path to a module.

- ### **`submodules`**

  (`bool`, default: `True` ) â€“ Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- ### **`try_relative_path`**

  (`bool`, default: `True` ) â€“ Whether to try finding the module as a relative path.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The paths to search into.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) â€“ Whether to force using dynamic analysis when loading data.

- ### **`store_source`**

  (`bool`, default: `True` ) â€“ Whether to store code source in the lines collection.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) â€“ Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) â€“ Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) â€“ Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

Returns:

- `Object | Alias` â€“ A Griffe object.

Source code in `src/griffe/_internal/loader.py`

````
def load(
    objspec: str | Path | None = None,
    /,
    *,
    submodules: bool = True,
    try_relative_path: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    store_source: bool = True,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias:
    """Load and return a Griffe object.

    In Griffe's context, loading means:

    - searching for a package, and finding it on the file system or as a builtin module
        (see the [`ModuleFinder`][griffe.ModuleFinder] class for more information)
    - extracting information from each of its (sub)modules, by either parsing
        the source code (see the [`visit`][griffe.visit] function)
        or inspecting the module at runtime (see the [`inspect`][griffe.inspect] function)

    The extracted information is stored in a collection of modules, which can be queried later.
    Each collected module is a tree of objects, representing the structure of the module.
    See the [`Module`][griffe.Module], [`Class`][griffe.Class],
    [`Function`][griffe.Function], [`Attribute`][griffe.Attribute], and
    [`TypeAlias`][griffe.TypeAlias] classes for more information.

    The main class used to load modules is [`GriffeLoader`][griffe.GriffeLoader].
    Convenience functions like this one and [`load_git`][griffe.load_git] are also available.

    Example:
        ```python
        import griffe

        module = griffe.load(...)
        ```

        This is a shortcut for:

        ```python
        from griffe import GriffeLoader

        loader = GriffeLoader(...)
        module = loader.load(...)
        ```

        See the documentation for the loader: [`GriffeLoader`][griffe.GriffeLoader].

    Parameters:
        objspec: The Python path of an object, or file path to a module.
        submodules: Whether to recurse on the submodules.
            This parameter only makes sense when loading a package (top-level module).
        try_relative_path: Whether to try finding the module as a relative path.
        extensions: The extensions to use.
        search_paths: The paths to search into.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        force_inspection: Whether to force using dynamic analysis when loading data.
        store_source: Whether to store code source in the lines collection.
        find_stubs_package: Whether to search for stubs-only package.
            If both the package and its stubs are found, they'll be merged together.
            If only the stubs are found, they'll be used as the package itself.
        resolve_aliases: Whether to resolve aliases.
        resolve_external: Whether to try to load unspecified modules to resolve aliases.
            Default value (`None`) means to load external modules only if they are the private sibling
            or the origin module (for example when `ast` imports from `_ast`).
        resolve_implicit: When false, only try to resolve an alias if it is explicitly exported.

    Returns:
        A Griffe object.
    """
    loader = GriffeLoader(
        extensions=extensions,
        search_paths=search_paths,
        docstring_parser=docstring_parser,
        docstring_options=docstring_options,
        lines_collection=lines_collection,
        modules_collection=modules_collection,
        allow_inspection=allow_inspection,
        force_inspection=force_inspection,
        store_source=store_source,
    )
    result = loader.load(
        objspec,
        submodules=submodules,
        try_relative_path=try_relative_path,
        find_stubs_package=find_stubs_package,
    )
    if resolve_aliases:
        loader.resolve_aliases(implicit=resolve_implicit, external=resolve_external)
    return result
````

## load_git

```
load_git(
    objspec: str | Path | None = None,
    /,
    *,
    ref: str = "HEAD",
    repo: str | Path = ".",
    submodules: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias
```

Load and return a module from a specific Git reference.

This function will create a temporary [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference before loading `module` with griffe.load.

This function requires that the `git` executable is installed.

Examples:

```
from griffe import load_git

old_api = load_git("my_module", ref="v0.1.0", repo="path/to/repo")
```

Parameters:

- ### **`objspec`**

  (`str | Path | None`, default: `None` ) â€“ The Python path of an object, or file path to a module.

- ### **`ref`**

  (`str`, default: `'HEAD'` ) â€“ A Git reference such as a commit, tag or branch.

- ### **`repo`**

  (`str | Path`, default: `'.'` ) â€“ Path to the repository (i.e. the directory containing the .git directory)

- ### **`submodules`**

  (`bool`, default: `True` ) â€“ Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The paths to search into (relative to the repository root).

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) â€“ Whether to force using dynamic analysis when loading data.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) â€“ Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) â€“ Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) â€“ Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

Returns:

- `Object | Alias` â€“ A Griffe object.

Source code in `src/griffe/_internal/loader.py`

````
def load_git(
    objspec: str | Path | None = None,
    /,
    *,
    ref: str = "HEAD",
    repo: str | Path = ".",
    submodules: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias:
    """Load and return a module from a specific Git reference.

    This function will create a temporary
    [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference
    before loading `module` with [`griffe.load`][griffe.load].

    This function requires that the `git` executable is installed.

    Examples:
        ```python
        from griffe import load_git

        old_api = load_git("my_module", ref="v0.1.0", repo="path/to/repo")
        ```

    Parameters:
        objspec: The Python path of an object, or file path to a module.
        ref: A Git reference such as a commit, tag or branch.
        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)
        submodules: Whether to recurse on the submodules.
            This parameter only makes sense when loading a package (top-level module).
        extensions: The extensions to use.
        search_paths: The paths to search into (relative to the repository root).
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        force_inspection: Whether to force using dynamic analysis when loading data.
        find_stubs_package: Whether to search for stubs-only package.
            If both the package and its stubs are found, they'll be merged together.
            If only the stubs are found, they'll be used as the package itself.
        resolve_aliases: Whether to resolve aliases.
        resolve_external: Whether to try to load unspecified modules to resolve aliases.
            Default value (`None`) means to load external modules only if they are the private sibling
            or the origin module (for example when `ast` imports from `_ast`).
        resolve_implicit: When false, only try to resolve an alias if it is explicitly exported.

    Returns:
        A Griffe object.
    """
    with _tmp_worktree(repo, ref) as worktree:
        search_paths = [worktree / path for path in search_paths or ["."]]
        if isinstance(objspec, Path):
            objspec = worktree / objspec

        return load(
            objspec,
            submodules=submodules,
            try_relative_path=False,
            extensions=extensions,
            search_paths=search_paths,
            docstring_parser=docstring_parser,
            docstring_options=docstring_options,
            lines_collection=lines_collection,
            modules_collection=modules_collection,
            allow_inspection=allow_inspection,
            force_inspection=force_inspection,
            find_stubs_package=find_stubs_package,
            resolve_aliases=resolve_aliases,
            resolve_external=resolve_external,
            resolve_implicit=resolve_implicit,
        )
````

## load_pypi

```
load_pypi(
    package: str,
    distribution: str,
    version_spec: str,
    *,
    submodules: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias
```

Load and return a module from a specific package version downloaded using pip.

Parameters:

- ### **`package`**

  (`str`) â€“ The package import name.

- ### **`distribution`**

  (`str`) â€“ The distribution name.

- ### **`version_spec`**

  (`str`) â€“ The version specifier to use when installing with pip.

- ### **`submodules`**

  (`bool`, default: `True` ) â€“ Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The paths to search into (relative to the repository root).

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) â€“ Whether to force using dynamic analysis when loading data.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) â€“ Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) â€“ Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) â€“ Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

Source code in `src/griffe/_internal/loader.py`

```
def load_pypi(
    package: str,
    distribution: str,
    version_spec: str,
    *,
    submodules: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias:
    """Load and return a module from a specific package version downloaded using pip.

    Parameters:
        package: The package import name.
        distribution: The distribution name.
        version_spec: The version specifier to use when installing with pip.
        submodules: Whether to recurse on the submodules.
            This parameter only makes sense when loading a package (top-level module).
        extensions: The extensions to use.
        search_paths: The paths to search into (relative to the repository root).
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        force_inspection: Whether to force using dynamic analysis when loading data.
        find_stubs_package: Whether to search for stubs-only package.
            If both the package and its stubs are found, they'll be merged together.
            If only the stubs are found, they'll be used as the package itself.
        resolve_aliases: Whether to resolve aliases.
        resolve_external: Whether to try to load unspecified modules to resolve aliases.
            Default value (`None`) means to load external modules only if they are the private sibling
            or the origin module (for example when `ast` imports from `_ast`).
        resolve_implicit: When false, only try to resolve an alias if it is explicitly exported.
    """
    if not all(find_spec(pkg) for pkg in ("pip", "wheel", "platformdirs")):
        raise RuntimeError("Please install Griffe with the 'pypi' extra to use this feature.")

    import platformdirs  # noqa: PLC0415

    pypi_cache_dir = Path(platformdirs.user_cache_dir("griffe"))
    install_dir = pypi_cache_dir / f"{distribution}{version_spec}"
    if install_dir.exists():
        logger.debug("Using cached %s%s", distribution, version_spec)
    else:
        with tempfile.TemporaryDirectory(dir=pypi_cache_dir) as tmpdir:
            install_dir = Path(tmpdir) / distribution
            logger.debug("Downloading %s%s", distribution, version_spec)
            process = subprocess.run(  # noqa: S603
                [
                    sys.executable,
                    "-mpip",
                    "install",
                    "--no-deps",
                    "--no-compile",
                    "--no-warn-script-location",
                    "--no-input",
                    "--disable-pip-version-check",
                    "--no-python-version-warning",
                    "-t",
                    str(install_dir),
                    f"{distribution}{version_spec}",
                ],
                text=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                check=False,
            )
            if process.returncode:
                logger.error(process.stdout)
                raise RuntimeError(f"Could not pip install {distribution}{version_spec}")
            logger.debug(process.stdout)
            shutil.rmtree(install_dir / "bin", ignore_errors=True)
            re_dist = re.sub("[._-]", "[._-]", distribution)
            version = next(
                match.group(1)
                for file in install_dir.iterdir()
                if (match := re.match(rf"{re_dist}-(.+)\.dist-info", file.name, re.IGNORECASE))
            )
            dest_dir = pypi_cache_dir / f"{distribution}=={version}"
            if not dest_dir.exists():
                install_dir.rename(dest_dir)
            install_dir = dest_dir

    if not package:
        files = sorted((file.name.lower() for file in install_dir.iterdir()), reverse=True)
        name = distribution.lower().replace("-", "_")
        if name in files or f"{name}.py" in files:
            package = name
        elif len(files) == 1:
            raise RuntimeError(f"No package found in {distribution}=={version}")
        else:
            try:
                package = next(file.split(".", 1)[0] for file in files if not file.endswith(".dist-info"))
            except StopIteration:
                raise RuntimeError(f"Could not guess package name for {distribution}=={version} (files; {files})")  # noqa: B904

    return load(
        package,
        submodules=submodules,
        try_relative_path=False,
        extensions=extensions,
        search_paths=[install_dir, *(search_paths or ())],
        docstring_parser=docstring_parser,
        docstring_options=docstring_options,
        lines_collection=lines_collection,
        modules_collection=modules_collection,
        allow_inspection=allow_inspection,
        force_inspection=force_inspection,
        find_stubs_package=find_stubs_package,
        resolve_aliases=resolve_aliases,
        resolve_external=resolve_external,
        resolve_implicit=resolve_implicit,
    )
```

## **Advanced API**

## GriffeLoader

```
GriffeLoader(
    *,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    store_source: bool = True,
)
```

The Griffe loader, allowing to load data from modules.

Parameters:

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) â€“ The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) â€“ The paths to search into.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) â€“ Whether to allow inspecting modules when visiting them is not possible.

- ### **`store_source`**

  (`bool`, default: `True` ) â€“ Whether to store code source in the lines collection.

Methods:

- **`expand_exports`** â€“ Expand exports: try to recursively expand all module exports (__all__ values).
- **`expand_wildcards`** â€“ Expand wildcards: try to recursively expand all found wildcards.
- **`load`** â€“ Load an object as a Griffe object, given its Python or file path.
- **`resolve_aliases`** â€“ Resolve aliases.
- **`resolve_module_aliases`** â€“ Follow aliases: try to recursively resolve all found aliases.
- **`stats`** â€“ Compute some statistics.

Attributes:

- **`allow_inspection`** (`bool`) â€“ Whether to allow inspecting (importing) modules for which we can't find sources.
- **`docstring_options`** (`DocstringOptions`) â€“ Configured parsing options.
- **`docstring_parser`** (`DocstringStyle | Parser | None`) â€“ Selected docstring parser.
- **`extensions`** (`Extensions`) â€“ Loaded Griffe extensions.
- **`finder`** (`ModuleFinder`) â€“ The module source finder.
- **`force_inspection`** (`bool`) â€“ Whether to force inspecting (importing) modules, even when sources were found.
- **`ignored_modules`** (`set[str]`) â€“ Special modules to ignore when loading.
- **`lines_collection`** (`LinesCollection`) â€“ Collection of source code lines.
- **`modules_collection`** (`ModulesCollection`) â€“ Collection of modules.
- **`store_source`** (`bool`) â€“ Whether to store source code in the lines collection.

Source code in `src/griffe/_internal/loader.py`

```
def __init__(
    self,
    *,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: DocstringOptions | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    store_source: bool = True,
) -> None:
    """Initialize the loader.

    Parameters:
        extensions: The extensions to use.
        search_paths: The paths to search into.
        docstring_parser: The docstring parser to use. By default, no parsing is done.
        docstring_options: Docstring parsing options.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.
        store_source: Whether to store code source in the lines collection.
    """
    self.extensions: Extensions = extensions or load_extensions()
    """Loaded Griffe extensions."""
    self.docstring_parser: DocstringStyle | Parser | None = docstring_parser
    """Selected docstring parser."""
    self.docstring_options: DocstringOptions = docstring_options or {}
    """Configured parsing options."""
    self.lines_collection: LinesCollection = lines_collection or LinesCollection()
    """Collection of source code lines."""
    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()
    """Collection of modules."""
    self.allow_inspection: bool = allow_inspection
    """Whether to allow inspecting (importing) modules for which we can't find sources."""
    self.force_inspection: bool = force_inspection
    """Whether to force inspecting (importing) modules, even when sources were found."""
    self.store_source: bool = store_source
    """Whether to store source code in the lines collection."""
    self._search_paths: Sequence[str | Path] | None = search_paths
    self._time_stats: dict = {
        "time_spent_visiting": 0,
        "time_spent_inspecting": 0,
    }
```

### allow_inspection

```
allow_inspection: bool = allow_inspection
```

Whether to allow inspecting (importing) modules for which we can't find sources.

### docstring_options

```
docstring_options: DocstringOptions = (
    docstring_options or {}
)
```

Configured parsing options.

### docstring_parser

```
docstring_parser: DocstringStyle | Parser | None = (
    docstring_parser
)
```

Selected docstring parser.

### extensions

```
extensions: Extensions = extensions or load_extensions()
```

Loaded Griffe extensions.

### finder

```
finder: ModuleFinder
```

The module source finder.

### force_inspection

```
force_inspection: bool = force_inspection
```

Whether to force inspecting (importing) modules, even when sources were found.

### ignored_modules

```
ignored_modules: set[str] = {'debugpy', '_pydev'}
```

Special modules to ignore when loading.

For example, `debugpy` and `_pydev` are used when debugging with VSCode and should generally never be loaded.

### lines_collection

```
lines_collection: LinesCollection = (
    lines_collection or LinesCollection()
)
```

Collection of source code lines.

### modules_collection

```
modules_collection: ModulesCollection = (
    modules_collection or ModulesCollection()
)
```

Collection of modules.

### store_source

```
store_source: bool = store_source
```

Whether to store source code in the lines collection.

### expand_exports

```
expand_exports(
    module: Module, seen: set | None = None
) -> None
```

Expand exports: try to recursively expand all module exports (`__all__` values).

See also: Module.exports.

Parameters:

- #### **`module`**

  (`Module`) â€“ The module to recurse on.

- #### **`seen`**

  (`set | None`, default: `None` ) â€“ Used to avoid infinite recursion.

Source code in `src/griffe/_internal/loader.py`

```
def expand_exports(self, module: Module, seen: set | None = None) -> None:
    """Expand exports: try to recursively expand all module exports (`__all__` values).

    See also: [`Module.exports`][griffe.Module.exports].

    Parameters:
        module: The module to recurse on.
        seen: Used to avoid infinite recursion.
    """
    seen = seen or set()
    seen.add(module.path)
    if module.exports is None:
        return

    expanded = []
    for export in module.exports:
        # It's a name: we resolve it, get the module it comes from,
        # recurse into it, and add its exports to the current ones.
        if isinstance(export, ExprName):
            module_path = export.canonical_path.rsplit(".", 1)[0]  # Remove trailing `.__all__`.
            try:
                next_module = self.modules_collection.get_member(module_path)
            except KeyError:
                logger.debug("Cannot expand '%s', try pre-loading corresponding package", export.canonical_path)
                continue
            if next_module.path not in seen:
                self.expand_exports(next_module, seen)
            try:
                expanded += [export for export in next_module.exports if export not in expanded]
            except TypeError:
                logger.warning("Unsupported item in %s.__all__: %s (use strings only)", module.path, export)
        # It's a string, simply add it to the current exports.
        else:
            expanded.append(export)
    module.exports = expanded

    # Make sure to expand exports in all modules.
    for submodule in module.modules.values():
        if not submodule.is_alias and submodule.path not in seen:
            self.expand_exports(submodule, seen)
```

### expand_wildcards

```
expand_wildcards(
    obj: Object,
    *,
    external: bool | None = None,
    seen: set | None = None,
) -> None
```

Expand wildcards: try to recursively expand all found wildcards.

See also: Alias.wildcard.

Parameters:

- #### **`obj`**

  (`Object`) â€“ The object and its members to recurse on.

- #### **`external`**

  (`bool | None`, default: `None` ) â€“ When true, try to load unspecified modules to expand wildcards.

- #### **`seen`**

  (`set | None`, default: `None` ) â€“ Used to avoid infinite recursion.

Source code in `src/griffe/_internal/loader.py`

```
def expand_wildcards(
    self,
    obj: Object,
    *,
    external: bool | None = None,
    seen: set | None = None,
) -> None:
    """Expand wildcards: try to recursively expand all found wildcards.

    See also: [`Alias.wildcard`][griffe.Alias.wildcard].

    Parameters:
        obj: The object and its members to recurse on.
        external: When true, try to load unspecified modules to expand wildcards.
        seen: Used to avoid infinite recursion.
    """
    expanded = []
    to_remove = []
    seen = seen or set()
    seen.add(obj.path)

    # First we expand wildcard imports and store the objects in a temporary `expanded` variable,
    # while also keeping track of the members representing wildcard import, to remove them later.
    for member in obj.members.values():
        # Handle a wildcard.
        if member.is_alias and member.wildcard:  # type: ignore[union-attr]
            package = member.wildcard.split(".", 1)[0]  # type: ignore[union-attr]
            not_loaded = obj.package.path != package and package not in self.modules_collection

            # Try loading the (unknown) package containing the wildcard importe module (if allowed to).
            if not_loaded:
                if external is False or (external is None and package != f"_{obj.package.name}"):
                    continue
                try:
                    self.load(package, try_relative_path=False)
                except (ImportError, LoadingError) as error:
                    logger.debug("Could not expand wildcard import %s in %s: %s", member.name, obj.path, error)
                    continue

            # Try getting the module from which every public object is imported.
            try:
                target = self.modules_collection.get_member(member.target_path)  # type: ignore[union-attr]
            except KeyError:
                logger.debug(
                    "Could not expand wildcard import %s in %s: %s not found in modules collection",
                    member.name,
                    obj.path,
                    cast("Alias", member).target_path,
                )
                continue

            # Recurse into this module, expanding wildcards there before collecting everything.
            if target.path not in seen:
                try:
                    self.expand_wildcards(target, external=external, seen=seen)
                except (AliasResolutionError, CyclicAliasError) as error:
                    logger.debug("Could not expand wildcard import %s in %s: %s", member.name, obj.path, error)
                    continue

            # Collect every imported object.
            expanded.extend(self._expand_wildcard(member))  # type: ignore[arg-type]
            to_remove.append(member.name)

        # Recurse in unseen submodules.
        elif not member.is_alias and member.is_module and member.path not in seen:
            self.expand_wildcards(member, external=external, seen=seen)  # type: ignore[arg-type]

    # Then we remove the members representing wildcard imports.
    for name in to_remove:
        obj.del_member(name)

    # Finally we process the collected objects.
    for new_member, alias_lineno, alias_endlineno in expanded:
        overwrite = False
        already_present = new_member.name in obj.members
        self_alias = (
            new_member.is_alias and cast("Alias", new_member).target_path == f"{obj.path}.{new_member.name}"
        )

        # If a member with the same name is already present in the current object,
        # we only overwrite it if the alias is imported lower in the module
        # (meaning that the alias takes precedence at runtime).
        if already_present:
            old_member = obj.get_member(new_member.name)
            old_lineno = old_member.alias_lineno if old_member.is_alias else old_member.lineno
            overwrite = alias_lineno > (old_lineno or 0)  # type: ignore[operator]

        # 1. If the expanded member is an alias with a target path equal to its own path, we stop.
        #    This situation can arise because of Griffe's mishandling of (abusive) wildcard imports.
        #    We have yet to check how Python handles this itself, or if there's an algorithm
        #    that we could follow to untangle back-and-forth wildcard imports.
        # 2. If the expanded member was already present and we decided not to overwrite it, we stop.
        # 3. Otherwise we proceed further.
        if not self_alias and (not already_present or overwrite):
            alias = Alias(
                new_member.name,
                new_member,
                lineno=alias_lineno,
                endlineno=alias_endlineno,
                parent=obj,  # type: ignore[arg-type]
                wildcard_imported=True,
            )
            # Special case: we avoid overwriting a submodule with an alias.
            # Griffe suffers from this limitation where an object cannot store both
            # a submodule and a member of the same name, while this poses (almost) no issue in Python.
            # We always give precedence to the submodule.
            # See the "avoid member-submodule name shadowing" section in the "Python code" docs page.
            if already_present:
                prev_member = obj.get_member(new_member.name)
                with suppress(AliasResolutionError, CyclicAliasError):
                    if prev_member.is_module:
                        continue

            # Everything went right (supposedly), we add the alias as a member of the current object.
            obj.set_member(new_member.name, alias)
            # YORE: Bump 2: Remove line.
            self.extensions.call("on_wildcard_expansion", alias=alias, loader=self)
```

### load

```
load(
    objspec: str | Path | None = None,
    /,
    *,
    submodules: bool = True,
    try_relative_path: bool = True,
    find_stubs_package: bool = False,
) -> Object | Alias
```

Load an object as a Griffe object, given its Python or file path.

Note that this will load the whole object's package, and return only the specified object. The rest of the package can be accessed from the returned object with regular methods and properties (`parent`, `members`, etc.).

Examples:

```
>>> loader.load("griffe.Module")
Alias("Module", "griffe._internal.models.Module")
```

Parameters:

- #### **`objspec`**

  (`str | Path | None`, default: `None` ) â€“ The Python path of an object, or file path to a module.

- #### **`submodules`**

  (`bool`, default: `True` ) â€“ Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- #### **`try_relative_path`**

  (`bool`, default: `True` ) â€“ Whether to try finding the module as a relative path.

- #### **`find_stubs_package`**

  (`bool`, default: `False` ) â€“ Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

Raises:

- `LoadingError` â€“ When loading a module failed for various reasons.
- `ModuleNotFoundError` â€“ When a module was not found and inspection is disallowed.

Returns:

- `Object | Alias` â€“ A Griffe object.

Source code in `src/griffe/_internal/loader.py`

```
def load(
    self,
    objspec: str | Path | None = None,
    /,
    *,
    submodules: bool = True,
    try_relative_path: bool = True,
    find_stubs_package: bool = False,
) -> Object | Alias:
    """Load an object as a Griffe object, given its Python or file path.

    Note that this will load the whole object's package,
    and return only the specified object.
    The rest of the package can be accessed from the returned object
    with regular methods and properties (`parent`, `members`, etc.).

    Examples:
        >>> loader.load("griffe.Module")
        Alias("Module", "griffe._internal.models.Module")

    Parameters:
        objspec: The Python path of an object, or file path to a module.
        submodules: Whether to recurse on the submodules.
            This parameter only makes sense when loading a package (top-level module).
        try_relative_path: Whether to try finding the module as a relative path.
        find_stubs_package: Whether to search for stubs-only package.
            If both the package and its stubs are found, they'll be merged together.
            If only the stubs are found, they'll be used as the package itself.

    Raises:
        LoadingError: When loading a module failed for various reasons.
        ModuleNotFoundError: When a module was not found and inspection is disallowed.

    Returns:
        A Griffe object.
    """
    obj_path: str
    package = None
    top_module = None

    # We always start by searching paths on the disk,
    # even if inspection is forced.
    logger.debug("Searching path(s) for %s", objspec)
    try:
        obj_path, package = self.finder.find_spec(
            objspec,  # type: ignore[arg-type]
            try_relative_path=try_relative_path,
            find_stubs_package=find_stubs_package,
        )
    except ModuleNotFoundError:
        # If we couldn't find paths on disk and inspection is disabled,
        # re-raise ModuleNotFoundError.
        logger.debug("Could not find path for %s on disk", objspec)
        if not (self.allow_inspection or self.force_inspection):
            raise

        # Otherwise we try to dynamically import the top-level module.
        obj_path = str(objspec)
        top_module_name = obj_path.split(".", 1)[0]
        logger.debug("Trying to dynamically import %s", top_module_name)
        top_module_object = dynamic_import(top_module_name, self.finder.search_paths)

        try:
            top_module_path = top_module_object.__path__
            if not top_module_path:
                raise ValueError(f"Module {top_module_name} has no paths set")  # noqa: TRY301
        except (AttributeError, ValueError):
            # If the top-level module has no `__path__`, we inspect it as-is,
            # and do not try to recurse into submodules (there shouldn't be any in builtin/compiled modules).
            logger.debug("Module %s has no paths set (built-in module?). Inspecting it as-is.", top_module_name)
            top_module = self._inspect_module(top_module_name)
            self.modules_collection.set_member(top_module.path, top_module)
            return self._post_load(top_module, obj_path)

        # We found paths, and use them to build our intermediate Package or NamespacePackage struct.
        logger.debug("Module %s has paths set: %s", top_module_name, top_module_path)
        top_module_path = [Path(path) for path in top_module_path]
        if len(top_module_path) > 1:
            package = NamespacePackage(top_module_name, top_module_path)
        else:
            package = Package(top_module_name, top_module_path[0])

    # We have an intermediate package, and an object path: we're ready to load.
    logger.debug("Found %s: loading", objspec)
    try:
        top_module = self._load_package(package, submodules=submodules)
    except LoadingError:
        logger.exception("Could not load package %s", package)
        raise

    return self._post_load(top_module, obj_path)
```

### resolve_aliases

```
resolve_aliases(
    *,
    implicit: bool = False,
    external: bool | None = None,
    max_iterations: int | None = None,
) -> tuple[set[str], int]
```

Resolve aliases.

Parameters:

- #### **`implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

- #### **`external`**

  (`bool | None`, default: `None` ) â€“ When false, don't try to load unspecified modules to resolve aliases.

- #### **`max_iterations`**

  (`int | None`, default: `None` ) â€“ Maximum number of iterations on the loader modules collection.

Returns:

- `tuple[set[str], int]` â€“ The unresolved aliases and the number of iterations done.

Source code in `src/griffe/_internal/loader.py`

```
def resolve_aliases(
    self,
    *,
    implicit: bool = False,
    external: bool | None = None,
    max_iterations: int | None = None,
) -> tuple[set[str], int]:
    """Resolve aliases.

    Parameters:
        implicit: When false, only try to resolve an alias if it is explicitly exported.
        external: When false, don't try to load unspecified modules to resolve aliases.
        max_iterations: Maximum number of iterations on the loader modules collection.

    Returns:
        The unresolved aliases and the number of iterations done.
    """
    if max_iterations is None:
        max_iterations = float("inf")  # type: ignore[assignment]
    prev_unresolved: set[str] = set()
    unresolved: set[str] = set("0")  # Init to enter loop.
    iteration = 0
    collection = self.modules_collection.members

    # Before resolving aliases, we try to expand wildcard imports again
    # (this was already done in `_post_load()`),
    # this time with the user-configured `external` setting,
    # and with potentially more packages loaded in the collection,
    # allowing to resolve more aliases.
    for wildcards_module in list(collection.values()):
        self.expand_wildcards(wildcards_module, external=external)

    load_failures: set[str] = set()
    while unresolved and unresolved != prev_unresolved and iteration < max_iterations:  # type: ignore[operator]
        prev_unresolved = unresolved - {"0"}
        unresolved = set()
        resolved: set[str] = set()
        iteration += 1
        for module_name in list(collection.keys()):
            module = collection[module_name]
            next_resolved, next_unresolved = self.resolve_module_aliases(
                module,
                implicit=implicit,
                external=external,
                load_failures=load_failures,
            )
            resolved |= next_resolved
            unresolved |= next_unresolved
        logger.debug(
            "Iteration %s finished, %s aliases resolved, still %s to go",
            iteration,
            len(resolved),
            len(unresolved),
        )
    return unresolved, iteration
```

### resolve_module_aliases

```
resolve_module_aliases(
    obj: Object | Alias,
    *,
    implicit: bool = False,
    external: bool | None = None,
    seen: set[str] | None = None,
    load_failures: set[str] | None = None,
) -> tuple[set[str], set[str]]
```

Follow aliases: try to recursively resolve all found aliases.

Parameters:

- #### **`obj`**

  (`Object | Alias`) â€“ The object and its members to recurse on.

- #### **`implicit`**

  (`bool`, default: `False` ) â€“ When false, only try to resolve an alias if it is explicitly exported.

- #### **`external`**

  (`bool | None`, default: `None` ) â€“ When false, don't try to load unspecified modules to resolve aliases.

- #### **`seen`**

  (`set[str] | None`, default: `None` ) â€“ Used to avoid infinite recursion.

- #### **`load_failures`**

  (`set[str] | None`, default: `None` ) â€“ Set of external packages we failed to load (to prevent retries).

Returns:

- `tuple[set[str], set[str]]` â€“ Both sets of resolved and unresolved aliases.

Source code in `src/griffe/_internal/loader.py`

```
def resolve_module_aliases(
    self,
    obj: Object | Alias,
    *,
    implicit: bool = False,
    external: bool | None = None,
    seen: set[str] | None = None,
    load_failures: set[str] | None = None,
) -> tuple[set[str], set[str]]:
    """Follow aliases: try to recursively resolve all found aliases.

    Parameters:
        obj: The object and its members to recurse on.
        implicit: When false, only try to resolve an alias if it is explicitly exported.
        external: When false, don't try to load unspecified modules to resolve aliases.
        seen: Used to avoid infinite recursion.
        load_failures: Set of external packages we failed to load (to prevent retries).

    Returns:
        Both sets of resolved and unresolved aliases.
    """
    resolved = set()
    unresolved = set()
    if load_failures is None:
        load_failures = set()
    seen = seen or set()
    seen.add(obj.path)

    for member in obj.members.values():
        # Handle aliases.
        if member.is_alias:
            if member.wildcard or member.resolved:  # type: ignore[union-attr]
                continue
            if not implicit and not member.is_exported:
                continue

            # Try resolving the alias. If it fails, check if it is because it comes
            # from an external package, and decide if we should load that package
            # to allow the alias to be resolved at the next iteration (maybe).
            try:
                member.resolve_target()  # type: ignore[union-attr]
            except AliasResolutionError as error:
                target = error.alias.target_path
                unresolved.add(member.path)
                package = target.split(".", 1)[0]
                load_module = (
                    (external is True or (external is None and package == f"_{obj.package.name}"))
                    and package not in load_failures
                    and obj.package.path != package
                    and package not in self.modules_collection
                )
                if load_module:
                    logger.debug("Failed to resolve alias %s -> %s", member.path, target)
                    try:
                        self.load(package, try_relative_path=False)
                    except (ImportError, LoadingError) as error:
                        logger.debug("Could not follow alias %s: %s", member.path, error)
                        load_failures.add(package)
            except CyclicAliasError as error:
                logger.debug(str(error))
            else:
                logger.debug("Alias %s was resolved to %s", member.path, member.final_target.path)  # type: ignore[union-attr]
                resolved.add(member.path)

        # Recurse into unseen modules and classes.
        elif member.kind in {Kind.MODULE, Kind.CLASS} and member.path not in seen:
            sub_resolved, sub_unresolved = self.resolve_module_aliases(
                member,
                implicit=implicit,
                external=external,
                seen=seen,
                load_failures=load_failures,
            )
            resolved |= sub_resolved
            unresolved |= sub_unresolved

    return resolved, unresolved
```

### stats

```
stats() -> Stats
```

Compute some statistics.

Returns:

- `Stats` â€“ Some statistics.

Source code in `src/griffe/_internal/loader.py`

```
def stats(self) -> Stats:
    """Compute some statistics.

    Returns:
        Some statistics.
    """
    stats = Stats(self)
    stats.time_spent_visiting = self._time_stats["time_spent_visiting"]
    stats.time_spent_inspecting = self._time_stats["time_spent_inspecting"]
    return stats
```

## ModulesCollection

```
ModulesCollection()
```

Bases: `GetMembersMixin`, `SetMembersMixin`, `DelMembersMixin`

```
              flowchart TD
              griffe.ModulesCollection[ModulesCollection]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]

                              griffe._internal.mixins.GetMembersMixin --> griffe.ModulesCollection
                
                griffe._internal.mixins.SetMembersMixin --> griffe.ModulesCollection
                
                griffe._internal.mixins.DelMembersMixin --> griffe.ModulesCollection
                


              click griffe.ModulesCollection href "" "griffe.ModulesCollection"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
```

A collection of modules, allowing easy access to members.

Initialize the collection.

Methods:

- **`__bool__`** â€“ A modules collection is always true-ish.
- **`__contains__`** â€“ Check if a module is in the collection.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`del_member`** â€“ Delete a member with its name or path.
- **`get_member`** â€“ Get a member with its name or path.
- **`set_member`** â€“ Set a member with its name or path.

Attributes:

- **`all_members`** (`dict[str, Module]`) â€“ Members of the collection.
- **`is_collection`** â€“ Marked as collection to distinguish from objects.
- **`members`** (`dict[str, Module]`) â€“ Members (modules) of the collection.

Source code in `src/griffe/_internal/collections.py`

```
def __init__(self) -> None:
    """Initialize the collection."""
    self.members: dict[str, Module] = {}
    """Members (modules) of the collection."""
```

### all_members

```
all_members: dict[str, Module]
```

Members of the collection.

This property is overwritten to simply return `self.members`, as `all_members` does not make sense for a modules collection.

### is_collection

```
is_collection = True
```

Marked as collection to distinguish from objects.

### members

```
members: dict[str, Module] = {}
```

Members (modules) of the collection.

### __bool__

```
__bool__() -> bool
```

A modules collection is always true-ish.

Source code in `src/griffe/_internal/collections.py`

```
def __bool__(self) -> bool:
    """A modules collection is always true-ish."""
    return True
```

### __contains__

```
__contains__(item: Any) -> bool
```

Check if a module is in the collection.

Source code in `src/griffe/_internal/collections.py`

```
def __contains__(self, item: Any) -> bool:
    """Check if a module is in the collection."""
    return item in self.members
```

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

### del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

### get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## LinesCollection

```
LinesCollection()
```

A simple dictionary containing the modules source code lines.

Initialize the collection.

Methods:

- **`__bool__`** â€“ A lines collection is always true-ish.
- **`__contains__`** â€“ Check if a file path is in the collection.
- **`__getitem__`** â€“ Get the lines of a file path.
- **`__setitem__`** â€“ Set the lines of a file path.
- **`items`** â€“ Return the collection items.
- **`keys`** â€“ Return the collection keys.
- **`values`** â€“ Return the collection values.

Source code in `src/griffe/_internal/collections.py`

```
def __init__(self) -> None:
    """Initialize the collection."""
    self._data: dict[Path, list[str]] = {}
```

### __bool__

```
__bool__() -> bool
```

A lines collection is always true-ish.

Source code in `src/griffe/_internal/collections.py`

```
def __bool__(self) -> bool:
    """A lines collection is always true-ish."""
    return True
```

### __contains__

```
__contains__(item: Path) -> bool
```

Check if a file path is in the collection.

Source code in `src/griffe/_internal/collections.py`

```
def __contains__(self, item: Path) -> bool:
    """Check if a file path is in the collection."""
    return item in self._data
```

### __getitem__

```
__getitem__(key: Path) -> list[str]
```

Get the lines of a file path.

Source code in `src/griffe/_internal/collections.py`

```
def __getitem__(self, key: Path) -> list[str]:
    """Get the lines of a file path."""
    return self._data[key]
```

### __setitem__

```
__setitem__(key: Path, value: list[str]) -> None
```

Set the lines of a file path.

Source code in `src/griffe/_internal/collections.py`

```
def __setitem__(self, key: Path, value: list[str]) -> None:
    """Set the lines of a file path."""
    self._data[key] = value
```

### items

```
items() -> ItemsView
```

Return the collection items.

Returns:

- `ItemsView` â€“ The collection items.

Source code in `src/griffe/_internal/collections.py`

```
def items(self) -> ItemsView:
    """Return the collection items.

    Returns:
        The collection items.
    """
    return self._data.items()
```

### keys

```
keys() -> KeysView
```

Return the collection keys.

Returns:

- `KeysView` â€“ The collection keys.

Source code in `src/griffe/_internal/collections.py`

```
def keys(self) -> KeysView:
    """Return the collection keys.

    Returns:
        The collection keys.
    """
    return self._data.keys()
```

### values

```
values() -> ValuesView
```

Return the collection values.

Returns:

- `ValuesView` â€“ The collection values.

Source code in `src/griffe/_internal/collections.py`

```
def values(self) -> ValuesView:
    """Return the collection values.

    Returns:
        The collection values.
    """
    return self._data.values()
```

## **Additional API**

## Stats

```
Stats(loader: GriffeLoader)
```

Load statistics for a Griffe loader.

Parameters:

- ### **`loader`**

  (`GriffeLoader`) â€“ The loader to compute stats for.

Methods:

- **`as_text`** â€“ Format the statistics as text.

Attributes:

- **`by_kind`** â€“ Number of objects by kind.
- **`lines`** â€“ Total number of lines.
- **`loader`** â€“ The loader to compute stats for.
- **`modules_by_extension`** â€“ Number of modules by extension.
- **`packages`** â€“ Number of packages.
- **`time_spent_inspecting`** â€“ Time spent inspecting modules.
- **`time_spent_serializing`** â€“ Time spent serializing objects.
- **`time_spent_visiting`** â€“ Time spent visiting modules.

Source code in `src/griffe/_internal/stats.py`

```
def __init__(self, loader: GriffeLoader) -> None:
    """Initialiwe the stats object.

    Parameters:
        loader: The loader to compute stats for.
    """
    self.loader = loader
    """The loader to compute stats for."""

    modules_by_extension = defaultdict(
        int,
        {
            "": 0,
            ".py": 0,
            ".pyi": 0,
            ".pyc": 0,
            ".pyo": 0,
            ".pyd": 0,
            ".so": 0,
        },
    )

    top_modules = loader.modules_collection.members.values()

    self.by_kind = {
        Kind.MODULE: 0,
        Kind.CLASS: 0,
        Kind.FUNCTION: 0,
        Kind.ATTRIBUTE: 0,
        Kind.TYPE_ALIAS: 0,
    }
    """Number of objects by kind."""

    self.packages = len(top_modules)
    """Number of packages."""

    self.modules_by_extension = modules_by_extension
    """Number of modules by extension."""

    self.lines = sum(len(lines) for lines in loader.lines_collection.values())
    """Total number of lines."""

    self.time_spent_visiting = 0
    """Time spent visiting modules."""

    self.time_spent_inspecting = 0
    """Time spent inspecting modules."""

    self.time_spent_serializing = 0
    """Time spent serializing objects."""

    for module in top_modules:
        self._itercount(module)
```

### by_kind

```
by_kind = {
    MODULE: 0,
    CLASS: 0,
    FUNCTION: 0,
    ATTRIBUTE: 0,
    TYPE_ALIAS: 0,
}
```

Number of objects by kind.

### lines

```
lines = sum((len(lines)) for lines in (values()))
```

Total number of lines.

### loader

```
loader = loader
```

The loader to compute stats for.

### modules_by_extension

```
modules_by_extension = modules_by_extension
```

Number of modules by extension.

### packages

```
packages = len(top_modules)
```

Number of packages.

### time_spent_inspecting

```
time_spent_inspecting = 0
```

Time spent inspecting modules.

### time_spent_serializing

```
time_spent_serializing = 0
```

Time spent serializing objects.

### time_spent_visiting

```
time_spent_visiting = 0
```

Time spent visiting modules.

### as_text

```
as_text() -> str
```

Format the statistics as text.

Returns:

- `str` â€“ Text stats.

Source code in `src/griffe/_internal/stats.py`

```
def as_text(self) -> str:
    """Format the statistics as text.

    Returns:
        Text stats.
    """
    lines = []
    packages = self.packages
    modules = self.by_kind[Kind.MODULE]
    classes = self.by_kind[Kind.CLASS]
    functions = self.by_kind[Kind.FUNCTION]
    attributes = self.by_kind[Kind.ATTRIBUTE]
    type_aliases = self.by_kind[Kind.TYPE_ALIAS]
    objects = sum((modules, classes, functions, attributes, type_aliases))
    lines.append("Statistics")
    lines.append("---------------------")
    lines.append("Number of loaded objects")
    lines.append(f"  Modules: {modules}")
    lines.append(f"  Classes: {classes}")
    lines.append(f"  Functions: {functions}")
    lines.append(f"  Attributes: {attributes}")
    lines.append(f"  Type aliases: {type_aliases}")
    lines.append(f"  Total: {objects} across {packages} packages")
    per_ext = self.modules_by_extension
    builtin = per_ext[""]
    regular = per_ext[".py"]
    stubs = per_ext[".pyi"]
    compiled = modules - builtin - regular - stubs
    lines.append("")
    lines.append(f"Total number of lines: {self.lines}")
    lines.append("")
    lines.append("Modules")
    lines.append(f"  Builtin: {builtin}")
    lines.append(f"  Compiled: {compiled}")
    lines.append(f"  Regular: {regular}")
    lines.append(f"  Stubs: {stubs}")
    lines.append("  Per extension:")
    for ext, number in sorted(per_ext.items()):
        if ext:
            lines.append(f"    {ext}: {number}")

    visit_time = self.time_spent_visiting / 1000
    inspect_time = self.time_spent_inspecting / 1000
    total_time = visit_time + inspect_time
    visit_percent = visit_time / total_time * 100
    inspect_percent = inspect_time / total_time * 100

    force_inspection = self.loader.force_inspection
    visited_modules = 0 if force_inspection else regular
    try:
        visit_time_per_module = visit_time / visited_modules
    except ZeroDivisionError:
        visit_time_per_module = 0

    inspected_modules = builtin + compiled + (regular if force_inspection else 0)
    try:
        inspect_time_per_module = inspect_time / inspected_modules
    except ZeroDivisionError:
        inspect_time_per_module = 0

    lines.append("")
    lines.append(
        f"Time spent visiting modules ({visited_modules}): "
        f"{visit_time}ms, {visit_time_per_module:.02f}ms/module ({visit_percent:.02f}%)",
    )
    lines.append(
        f"Time spent inspecting modules ({inspected_modules}): "
        f"{inspect_time}ms, {inspect_time_per_module:.02f}ms/module ({inspect_percent:.02f}%)",
    )

    serialize_time = self.time_spent_serializing / 1000
    serialize_time_per_module = serialize_time / modules
    lines.append(f"Time spent serializing: {serialize_time}ms, {serialize_time_per_module:.02f}ms/module")

    return "\n".join(lines)
```

## merge_stubs

```
merge_stubs(mod1: Module, mod2: Module) -> Module
```

Merge stubs into a module.

Parameters:

- ### **`mod1`**

  (`Module`) â€“ A regular module or stubs module.

- ### **`mod2`**

  (`Module`) â€“ A regular module or stubs module.

Raises:

- `ValueError` â€“ When both modules are regular modules (no stubs is passed).

Returns:

- `Module` â€“ The regular module.

Source code in `src/griffe/_internal/merger.py`

```
def merge_stubs(mod1: Module, mod2: Module) -> Module:
    """Merge stubs into a module.

    Parameters:
        mod1: A regular module or stubs module.
        mod2: A regular module or stubs module.

    Raises:
        ValueError: When both modules are regular modules (no stubs is passed).

    Returns:
        The regular module.
    """
    logger.debug("Trying to merge %s and %s", mod1.filepath, mod2.filepath)
    if mod1.filepath.suffix == ".pyi":  # type: ignore[union-attr]
        stubs = mod1
        module = mod2
    elif mod2.filepath.suffix == ".pyi":  # type: ignore[union-attr]
        stubs = mod2
        module = mod1
    else:
        raise ValueError("cannot merge regular (non-stubs) modules together")
    _merge_module_stubs(module, stubs)
    return module
```

# Loggers

## **Main API**

## logger

```
logger: Logger = _get()
```

Our global logger, used throughout the library.

Griffe's output and error messages are logging messages.

Griffe provides the patch_loggers function so dependent libraries can patch Griffe loggers as they see fit.

For example, to fit in the MkDocs logging configuration and prefix each log message with the module name:

```
import logging
from griffe import patch_loggers


class LoggerAdapter(logging.LoggerAdapter):
    def __init__(self, prefix, logger):
        super().__init__(logger, {})
        self.prefix = prefix

    def process(self, msg, kwargs):
        return f"{self.prefix}: {msg}", kwargs


def get_logger(name):
    logger = logging.getLogger(f"mkdocs.plugins.{name}")
    return LoggerAdapter(name, logger)


patch_loggers(get_logger)
```

## get_logger

```
get_logger(name: str = 'griffe') -> Logger
```

Create and return a new logger instance.

Parameters:

- ### **`name`**

  (`str`, default: `'griffe'` ) â€“ The logger name.

Returns:

- `Logger` â€“ The logger.

Source code in `src/griffe/_internal/logger.py`

```
def get_logger(name: str = "griffe") -> Logger:
    """Create and return a new logger instance.

    Parameters:
        name: The logger name.

    Returns:
        The logger.
    """
    return Logger._get(name)
```

## Logger

```
Logger(name: str)
```

Methods:

- **`disable`** â€“ Temporarily disable logging.

Source code in `src/griffe/_internal/logger.py`

```
def __init__(self, name: str) -> None:
    # Default logger that can be patched by third-party.
    self._logger = self.__class__._default_logger(name)
```

### disable

```
disable() -> Iterator[None]
```

Temporarily disable logging.

Source code in `src/griffe/_internal/logger.py`

```
@contextmanager
def disable(self) -> Iterator[None]:
    """Temporarily disable logging."""
    old_level = self._logger.level
    self._logger.setLevel(100)
    try:
        yield
    finally:
        self._logger.setLevel(old_level)
```

## LogLevel

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.LogLevel[LogLevel]

              

              click griffe.LogLevel href "" "griffe.LogLevel"
```

Enumeration of available log levels.

Attributes:

- **`critical`** â€“ The CRITICAL log level.
- **`debug`** â€“ The DEBUG log level.
- **`error`** â€“ The ERROR log level.
- **`info`** â€“ The INFO log level.
- **`success`** â€“ The SUCCESS log level.
- **`trace`** â€“ The TRACE log level.
- **`warning`** â€“ The WARNING log level.

### critical

```
critical = 'critical'
```

The CRITICAL log level.

### debug

```
debug = 'debug'
```

The DEBUG log level.

### error

```
error = 'error'
```

The ERROR log level.

### info

```
info = 'info'
```

The INFO log level.

### success

```
success = 'success'
```

The SUCCESS log level.

### trace

```
trace = 'trace'
```

The TRACE log level.

### warning

```
warning = 'warning'
```

The WARNING log level.

## DEFAULT_LOG_LEVEL

```
DEFAULT_LOG_LEVEL = os.getenv(
    "GRIFFE_LOG_LEVEL", "INFO"
).upper()
```

The default log level for the CLI.

This can be overridden by the `GRIFFE_LOG_LEVEL` environment variable.

## **Advanced API**

## patch_loggers

```
patch_loggers(
    get_logger_func: Callable[[str], Any],
) -> None
```

Patch Griffe logger and Griffe extensions' loggers.

Parameters:

- ### **`get_logger_func`**

  (`Callable[[str], Any]`) â€“ A function accepting a name as parameter and returning a logger.

Source code in `src/griffe/_internal/logger.py`

```
def patch_loggers(get_logger_func: Callable[[str], Any]) -> None:
    """Patch Griffe logger and Griffe extensions' loggers.

    Parameters:
        get_logger_func: A function accepting a name as parameter and returning a logger.
    """
    Logger._patch_loggers(get_logger_func)
```

# Models

Griffe stores information extracted from Python source code into data models.

These models represent trees of objects, starting with modules, and containing classes, functions, attributes, and type aliases.

Modules can have submodules, classes, functions, attributes, and type aliases. Classes can have nested classes, methods, attributes, and type aliases. Functions and attributes do not have any members.

Indirections to objects declared in other modules are represented as "aliases". An alias therefore represents an imported object, and behaves almost exactly like the object it points to: it is a light wrapper around the object, with special methods and properties that allow to access the target's data transparently.

The 6 models:

- Module
- Class
- Function
- Attribute
- Alias
- TypeAlias

## **Model kind enumeration**

## Kind

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.Kind[Kind]

              

              click griffe.Kind href "" "griffe.Kind"
```

Enumeration of the different object kinds.

Attributes:

- **`ALIAS`** â€“ Aliases (imported objects).
- **`ATTRIBUTE`** â€“ Attributes and properties.
- **`CLASS`** â€“ Classes.
- **`FUNCTION`** â€“ Functions and methods.
- **`MODULE`** â€“ Modules.
- **`TYPE_ALIAS`** â€“ Type aliases.

### ALIAS

```
ALIAS = 'alias'
```

Aliases (imported objects).

### ATTRIBUTE

```
ATTRIBUTE = 'attribute'
```

Attributes and properties.

### CLASS

```
CLASS = 'class'
```

Classes.

### FUNCTION

```
FUNCTION = 'function'
```

Functions and methods.

### MODULE

```
MODULE = 'module'
```

Modules.

### TYPE_ALIAS

```
TYPE_ALIAS = 'type alias'
```

Type aliases.

## **Model base classes**

## GetMembersMixin

Mixin class to share methods for accessing members.

Methods:

- **`__getitem__`** â€“ Get a member with its name or path.
- **`get_member`** â€“ Get a member with its name or path.

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

## SetMembersMixin

Mixin class to share methods for setting members.

Methods:

- **`__setitem__`** â€“ Set a member with its name or path.
- **`set_member`** â€“ Set a member with its name or path.

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## DelMembersMixin

Mixin class to share methods for deleting members.

Methods:

- **`__delitem__`** â€“ Delete a member with its name or path.
- **`del_member`** â€“ Delete a member with its name or path.

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

## SerializationMixin

Mixin class to share methods for de/serializing objects.

Methods:

- **`as_json`** â€“ Return this object's data as a JSON string.
- **`from_json`** â€“ Create an instance of this class from a JSON string.

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

## ObjectAliasMixin

Bases: `GetMembersMixin`, `SetMembersMixin`, `DelMembersMixin`, `SerializationMixin`

```
              flowchart TD
              griffe.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.mixins.GetMembersMixin --> griffe.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe.ObjectAliasMixin
                


              click griffe.ObjectAliasMixin href "" "griffe.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

Mixin class to share methods that appear both in objects and aliases, unchanged.

Methods:

- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`set_member`** â€“ Set a member with its name or path.

Attributes:

- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.

### all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

### attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

### classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

### functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

### is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

### is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

### is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

### is_generic

```
is_generic: bool
```

Whether this object is generic.

### is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

### is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

### is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

### is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

### is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

### modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

### type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

### del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

### get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## Object

```
Object(
    name: str,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    runtime: bool = True,
    docstring: Docstring | None = None,
    type_parameters: TypeParameters | None = None,
    parent: Module | Class | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    git_info: GitInfo | None = None,
    analysis: Literal["static", "dynamic"] | None = None,
)
```

Bases: `ObjectAliasMixin`

```
              flowchart TD
              griffe.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.mixins.ObjectAliasMixin --> griffe.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                



              click griffe.Object href "" "griffe.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

An abstract class representing a Python object.

Parameters:

- ### **`name`**

  (`str`) â€“ The object name, as declared in the code.

- ### **`lineno`**

  (`int | None`, default: `None` ) â€“ The object starting line, or None for modules. Lines start at 1.

- ### **`endlineno`**

  (`int | None`, default: `None` ) â€“ The object ending line (inclusive), or None for modules.

- ### **`runtime`**

  (`bool`, default: `True` ) â€“ Whether this object is present at runtime or not.

- ### **`docstring`**

  (`Docstring | None`, default: `None` ) â€“ The object docstring.

- ### **`type_parameters`**

  (`TypeParameters | None`, default: `None` ) â€“ The object type parameters, if any.

- ### **`parent`**

  (`Module | Class | None`, default: `None` ) â€“ The object parent.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) â€“ A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) â€“ A collection of modules.

- ### **`git_info`**

  (`GitInfo | None`, default: `None` ) â€“ Git information.

- ### **`analysis`**

  (`Literal['static', 'dynamic'] | None`, default: `None` ) â€“ The type of analysis used to load this object. None means the object was created manually.

Methods:

- **`__bool__`** â€“ An object is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The number of members in this object, recursively.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this object's data as a dictionary.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`set_member`** â€“ Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this object.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`deprecated`** (`bool | str | None`) â€“ Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The object docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) â€“ Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this object.
- **`inherited`** (`bool`) â€“ Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always false for objects.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for objects.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this function is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this object is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this object is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`kind`** (`Kind`) â€“ The object kind.
- **`labels`** (`set[str]`) â€“ The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to this object or its parents.
- **`name`** (`str`) â€“ The object name.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) â€“ The parent of the object (none if top module).
- **`path`** (`str`) â€“ The dotted path of this object.
- **`public`** (`bool | None`) â€“ Whether this object is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) â€“ Whether this object is available at runtime.
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Source link for this object, if available.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The object type parameters.

Source code in `src/griffe/_internal/models.py`

````
def __init__(
    self,
    name: str,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    runtime: bool = True,
    docstring: Docstring | None = None,
    type_parameters: TypeParameters | None = None,
    parent: Module | Class | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    git_info: GitInfo | None = None,
    analysis: Literal["static", "dynamic"] | None = None,
) -> None:
    """Initialize the object.

    Parameters:
        name: The object name, as declared in the code.
        lineno: The object starting line, or None for modules. Lines start at 1.
        endlineno: The object ending line (inclusive), or None for modules.
        runtime: Whether this object is present at runtime or not.
        docstring: The object docstring.
        type_parameters: The object type parameters, if any.
        parent: The object parent.
        lines_collection: A collection of source code lines.
        modules_collection: A collection of modules.
        git_info: Git information.
        analysis: The type of analysis used to load this object.
            None means the object was created manually.
    """
    self.name: str = name
    """The object name."""

    self.lineno: int | None = lineno
    """The starting line number of the object.

    See also: [`endlineno`][griffe.Object.endlineno].
    """

    self.endlineno: int | None = endlineno
    """The ending line number of the object.

    See also: [`lineno`][griffe.Object.lineno].
    """

    self.docstring: Docstring | None = docstring
    """The object docstring.

    See also: [`has_docstring`][griffe.Object.has_docstring],
    [`has_docstrings`][griffe.Object.has_docstrings].
    """

    # TODO: Maybe move these into `Class` and `Function`.
    # Then always return them in `Class` and `Function`'s `as_dict` methods,
    # and remove the conditional in the `_load_class` and `_load_function` decoders.
    self.type_parameters: TypeParameters = type_parameters or TypeParameters()
    """The object type parameters."""

    self.parent: Module | Class | None = parent
    """The parent of the object (none if top module)."""

    self.members: dict[str, Object | Alias] = {}
    """The object members (modules, classes, functions, attributes, type aliases).

    See also: [`inherited_members`][griffe.Object.inherited_members],
    [`get_member`][griffe.Object.get_member],
    [`set_member`][griffe.Object.set_member],
    [`filter_members`][griffe.Object.filter_members].
    """

    self.labels: set[str] = set()
    """The object labels (`property`, `dataclass`, etc.).

    See also: [`has_labels`][griffe.Object.has_labels]."""

    self.imports: dict[str, str] = {}
    """The other objects imported by this object.

    Keys are the names within the object (`from ... import ... as AS_NAME`),
    while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).
    """

    self.exports: list[str | ExprName] | None = None
    """The names of the objects exported by this (module) object through the `__all__` variable.

    Exports can contain string (object names) or resolvable names,
    like other lists of exports coming from submodules:

    ```python
    from .submodule import __all__ as submodule_all

    __all__ = ["hello", *submodule_all]
    ```

    Exports get expanded by the loader before it expands wildcards and resolves aliases.

    See also: [`GriffeLoader.expand_exports`][griffe.GriffeLoader.expand_exports].
    """

    self.aliases: dict[str, Alias] = {}
    """The aliases pointing to this object."""

    self.runtime: bool = runtime
    """Whether this object is available at runtime.

    Typically, type-guarded objects (under an `if TYPE_CHECKING` condition)
    are not available at runtime.
    """

    self.extra: dict[str, dict[str, Any]] = defaultdict(dict)
    """Namespaced dictionaries storing extra metadata for this object, used by extensions."""

    self.public: bool | None = None
    """Whether this object is public."""

    self.deprecated: bool | str | None = None
    """Whether this object is deprecated (boolean or deprecation message)."""

    self.analysis: Literal["static", "dynamic"] | None = analysis
    """The type of analysis used to load this object.

    None means the object was created manually.
    """

    self._lines_collection: LinesCollection | None = lines_collection
    self._modules_collection: ModulesCollection | None = modules_collection
    self._git_info: GitInfo | None = git_info
    self._source_link: str | None = None

    # Attach the docstring to this object.
    if docstring:
        docstring.parent = self
````

### aliases

```
aliases: dict[str, Alias] = {}
```

The aliases pointing to this object.

### all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

### analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this object.

None means the object was created manually.

### attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

### canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

### classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

### deprecated

```
deprecated: bool | str | None = None
```

Whether this object is deprecated (boolean or deprecation message).

### docstring

```
docstring: Docstring | None = docstring
```

The object docstring.

See also: has_docstring, has_docstrings.

### endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the object.

See also: lineno.

### exports

```
exports: list[str | ExprName] | None = None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

### extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

### filepath

```
filepath: Path | list[Path]
```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')
```

### functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

### git_info

```
git_info: GitInfo | None
```

Git information for this object, if available.

### has_docstring

```
has_docstring: bool
```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

### has_docstrings

```
has_docstrings: bool
```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

### imports

```
imports: dict[str, str] = {}
```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

### inherited

```
inherited: bool = False
```

Always false for objects.

Only aliases can be marked as inherited.

### inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

### is_alias

```
is_alias: bool = False
```

Always false for objects.

### is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

### is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

### is_collection

```
is_collection: bool = False
```

Always false for objects.

### is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

### is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

### is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

### is_generic

```
is_generic: bool
```

Whether this object is generic.

### is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

### is_init_method

```
is_init_method: bool
```

Whether this function is an `__init__` method.

### is_init_module

```
is_init_module: bool
```

Whether this object is an `__init__.py` module.

See also: is_module.

### is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_namespace_package

```
is_namespace_package: bool
```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

### is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

### is_package

```
is_package: bool
```

Whether this object is a package (top module).

See also: is_subpackage.

### is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

### is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

### is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

### is_subpackage

```
is_subpackage: bool
```

Whether this object is a subpackage.

See also: is_package.

### is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

### is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

### kind

```
kind: Kind
```

The object kind.

### labels

```
labels: set[str] = set()
```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

### lineno

```
lineno: int | None = lineno
```

The starting line number of the object.

See also: endlineno.

### lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: lines_collection, source.

### lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

### members

```
members: dict[str, Object | Alias] = {}
```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

### module

```
module: Module
```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
```

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

### modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

### modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

### name

```
name: str = name
```

The object name.

### package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))
```

### parent

```
parent: Module | Class | None = parent
```

The parent of the object (none if top module).

### path

```
path: str
```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'
```

### public

```
public: bool | None = None
```

Whether this object is public.

### relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

### relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

### runtime

```
runtime: bool = runtime
```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

### source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

### source_link

```
source_link: str | None
```

Source link for this object, if available.

### type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

### type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)
```

The object type parameters.

### __bool__

```
__bool__() -> bool
```

An object is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An object is always true-ish."""
    return True
```

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __len__

```
__len__() -> int
```

The number of members in this object, recursively.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The number of members in this object, recursively."""
    return len(self.members) + sum(len(member) for member in self.members.values())
```

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this object's data as a dictionary.

See also: as_json.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:
    """Return this object's data as a dictionary.

    See also: [`as_json`][griffe.Object.as_json].

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base: dict[str, Any] = {
        "kind": self.kind,
        "name": self.name,
        "runtime": self.runtime,
    }

    if self.public is not None:
        base["public"] = self.public
    if self.exports is not None:
        base["exports"] = [str(export) for export in self.exports]
    if self.imports:
        base["imports"] = self.imports
    if self.deprecated is not None:
        base["deprecated"] = self.deprecated
    if self.lineno is not None:
        base["lineno"] = self.lineno
    if self.endlineno is not None:
        base["endlineno"] = self.endlineno
    if self.docstring:
        base["docstring"] = self.docstring
    if self.type_parameters:
        base["type_parameters"] = [type_param.as_dict(**kwargs) for type_param in self.type_parameters]
    if self.labels:
        base["labels"] = self.labels
    if self.members:
        base["members"] = {name: member.as_dict(full=full, **kwargs) for name, member in self.members.items()}
    if self.analysis:
        base["analysis"] = self.analysis
    if self._git_info is not None:
        base["git_info"] = asdict(self._git_info)
    if self._source_link is not None:
        base["source_link"] = self._source_link
    # TODO: Include `self.extra`?

    if full:
        base.update(
            {
                "path": self.path,
                "filepath": self.filepath,
                "relative_package_filepath": self.relative_package_filepath,
                "is_public": self.is_public,
                "is_deprecated": self.is_deprecated,
                "is_private": self.is_private,
                "is_class_private": self.is_class_private,
                "is_special": self.is_special,
                "is_imported": self.is_imported,
                "is_exported": self.is_exported,
                "is_wildcard_exposed": self.is_wildcard_exposed,
                # TODO: Add these properties?
                # "is_alias": self.is_alias,
                # "is_collection": self.is_collection,
                # "is_module": self.is_module,
                # "is_class": self.is_class,
                # "is_function": self.is_function,
                # "is_attribute": self.is_attribute,
                # "is_type_alias": self.is_type_alias,
                # "is_init_module": self.is_init_module,
                # "is_package": self.is_package,
                # "is_subpackage": self.is_subpackage,
                # "is_namespace_package": self.is_namespace_package,
                # "is_namespace_subpackage": self.is_namespace_subpackage,
                # "has_docstring": self.has_docstring,
                # "has_docstrings": self.has_docstrings,
            },
        )

        with suppress(ValueError):
            base["relative_filepath"] = self.relative_filepath

        if "source_link" not in base and (source_link := self.source_link) is not None:
            base["source_link"] = source_link

    return base
```

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

### del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

### filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members.

Parameters:

- #### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Object.members].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    if not predicates:
        return self.members
    members: dict[str, Object | Alias] = {
        name: member for name, member in self.members.items() if all(predicate(member) for predicate in predicates)
    }
    return members
```

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

### get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

### has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- #### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Object.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return set(labels).issubset(self.labels)
```

### is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- #### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Object.is_module],
    [`is_class`][griffe.Object.is_class],
    [`is_function`][griffe.Object.is_function],
    [`is_attribute`][griffe.Object.is_attribute],
    [`is_type_alias`][griffe.Object.is_type_alias],
    [`is_alias`][griffe.Object.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    if isinstance(kind, set):
        if not kind:
            raise ValueError("kind must not be an empty set")
        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)
    if isinstance(kind, str):
        kind = Kind(kind)
    return self.kind is kind
```

### resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- #### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    # TODO: Better match Python's own scoping rules?
    # Also, maybe return regular paths instead of canonical ones?

    # Name is a type parameter.
    if name in self.type_parameters:
        type_parameter = self.type_parameters[name]
        if type_parameter.kind is TypeParameterKind.type_var_tuple:
            prefix = "*"
        elif type_parameter.kind is TypeParameterKind.param_spec:
            prefix = "**"
        else:
            prefix = ""
        return f"{self.path}[{prefix}{name}]"

    # Name is a member of this object.
    if name in self.members:
        if self.members[name].is_alias:
            return self.members[name].target_path  # type: ignore[union-attr]
        return self.members[name].path

    # Name unknown and no more parent scope, could be a built-in.
    if self.parent is None:
        raise NameResolutionError(f"{name} could not be resolved in the scope of {self.path}")

    # Name is parent, non-module object.
    if name == self.parent.name and not self.parent.is_module:
        return self.parent.path

    # Recurse in parent.
    return self.parent.resolve(name)
```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## **Type parameters**

## TypeParameters

```
TypeParameters(*type_parameters: TypeParameter)
```

This class is a container for type parameters.

It allows to get type parameters using their position (index) or their name:

```
>>> type_parameters = TypeParameters(TypeParameter("hello"), kind=TypeParameterKind.type_var)
>>> type_parameters[0] is type_parameters["hello"]
True
```

Parameters:

- ### **`*type_parameters`**

  (`TypeParameter`, default: `()` ) â€“ The initial type parameters to add to the container.

Methods:

- **`__contains__`** â€“ Whether a type parameter with the given name is present.
- **`__delitem__`** â€“ Delete a type parameter by index or name.
- **`__getitem__`** â€“ Get a type parameter by index or name.
- **`__iter__`** â€“ Iterate over the type parameters, in order.
- **`__len__`** â€“ The number of type parameters.
- **`__setitem__`** â€“ Set a type parameter by index or name.
- **`add`** â€“ Add a type parameter to the container.

Source code in `src/griffe/_internal/models.py`

```
def __init__(self, *type_parameters: TypeParameter) -> None:
    """Initialize the type parameters container.

    Parameters:
        *type_parameters: The initial type parameters to add to the container.
    """
    self._type_params: list[TypeParameter] = list(type_parameters)
```

### __contains__

```
__contains__(type_param_name: str)
```

Whether a type parameter with the given name is present.

Source code in `src/griffe/_internal/models.py`

```
def __contains__(self, type_param_name: str):
    """Whether a type parameter with the given name is present."""
    try:
        next(param for param in self._type_params if param.name == type_param_name.lstrip("*"))
    except StopIteration:
        return False
    return True
```

### __delitem__

```
__delitem__(name_or_index: int | str) -> None
```

Delete a type parameter by index or name.

Source code in `src/griffe/_internal/models.py`

```
def __delitem__(self, name_or_index: int | str) -> None:
    """Delete a type parameter by index or name."""
    if isinstance(name_or_index, int):
        del self._type_params[name_or_index]
    else:
        name = name_or_index.lstrip("*")
        try:
            index = next(idx for idx, param in enumerate(self._type_params) if param.name == name)
        except StopIteration as error:
            raise KeyError(f"type parameter {name_or_index} not found") from error
        del self._type_params[index]
```

### __getitem__

```
__getitem__(name_or_index: int | str) -> TypeParameter
```

Get a type parameter by index or name.

Source code in `src/griffe/_internal/models.py`

```
def __getitem__(self, name_or_index: int | str) -> TypeParameter:
    """Get a type parameter by index or name."""
    if isinstance(name_or_index, int):
        return self._type_params[name_or_index]
    name = name_or_index.lstrip("*")
    try:
        return next(param for param in self._type_params if param.name == name)
    except StopIteration as error:
        raise KeyError(f"type parameter {name_or_index} not found") from error
```

### __iter__

```
__iter__()
```

Iterate over the type parameters, in order.

Source code in `src/griffe/_internal/models.py`

```
def __iter__(self):
    """Iterate over the type parameters, in order."""
    return iter(self._type_params)
```

### __len__

```
__len__()
```

The number of type parameters.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self):
    """The number of type parameters."""
    return len(self._type_params)
```

### __setitem__

```
__setitem__(
    name_or_index: int | str, type_parameter: TypeParameter
) -> None
```

Set a type parameter by index or name.

Source code in `src/griffe/_internal/models.py`

```
def __setitem__(self, name_or_index: int | str, type_parameter: TypeParameter) -> None:
    """Set a type parameter by index or name."""
    if isinstance(name_or_index, int):
        self._type_params[name_or_index] = type_parameter
    else:
        name = name_or_index.lstrip("*")
        try:
            index = next(idx for idx, param in enumerate(self._type_params) if param.name == name)
        except StopIteration:
            self._type_params.append(type_parameter)
        else:
            self._type_params[index] = type_parameter
```

### add

```
add(type_parameter: TypeParameter) -> None
```

Add a type parameter to the container.

Parameters:

- #### **`type_parameter`**

  (`TypeParameter`) â€“ The function parameter to add.

Raises:

- `ValueError` â€“ When a type parameter with the same name is already present.

Source code in `src/griffe/_internal/models.py`

```
def add(self, type_parameter: TypeParameter) -> None:
    """Add a type parameter to the container.

    Parameters:
        type_parameter: The function parameter to add.

    Raises:
        ValueError: When a type parameter with the same name is already present.
    """
    if type_parameter.name in self:
        raise ValueError(f"type parameter {type_parameter.name} already present")
    self._type_params.append(type_parameter)
```

## TypeParameter

```
TypeParameter(
    name: str,
    *,
    kind: TypeParameterKind,
    bound: str | Expr | None = None,
    constraints: Sequence[str | Expr] | None = None,
    default: str | Expr | None = None,
)
```

This class represents a type parameter.

Parameters:

- ### **`name`**

  (`str`) â€“ The type parameter name, without leading stars (\* or \*\*).

- ### **`kind`**

  (`TypeParameterKind`) â€“ The type parameter kind.

- ### **`bound`**

  (`str | Expr | None`, default: `None` ) â€“ The type parameter bound, if any. Mutually exclusive with constraints.

- ### **`constraints`**

  (`Sequence[str | Expr] | None`, default: `None` ) â€“ The type parameter constraints, if any. Mutually exclusive with bound.

- ### **`default`**

  (`str | Expr | None`, default: `None` ) â€“ The type parameter default, if any.

Raises:

- `ValueError` â€“ When more than one of bound and constraints is set.

Methods:

- **`as_dict`** â€“ Return this type parameter's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The type parameter bound or constraints.
- **`bound`** (`str | Expr | None`) â€“ The type parameter bound.
- **`constraints`** (`tuple[str | Expr, ...] | None`) â€“ The type parameter constraints.
- **`default`** (`str | Expr | None`) â€“ The type parameter default value.
- **`kind`** (`TypeParameterKind`) â€“ The type parameter kind.
- **`name`** (`str`) â€“ The type parameter name.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    name: str,
    *,
    kind: TypeParameterKind,
    bound: str | Expr | None = None,
    constraints: Sequence[str | Expr] | None = None,
    default: str | Expr | None = None,
) -> None:
    """Initialize the type parameter.

    Parameters:
        name: The type parameter name, without leading stars (`*` or `**`).
        kind: The type parameter kind.
        bound: The type parameter bound, if any.
            Mutually exclusive with `constraints`.
        constraints: The type parameter constraints, if any.
            Mutually exclusive with `bound`.
        default: The type parameter default, if any.

    Raises:
        ValueError: When more than one of `bound` and `constraints` is set.
    """
    if bound is not None and constraints:
        raise ValueError("bound and constraints are mutually exclusive")

    self.name: str = name
    """The type parameter name."""

    self.kind: TypeParameterKind = kind
    """The type parameter kind."""

    self.annotation: str | Expr | None
    """The type parameter bound or constraints."""

    if constraints:
        self.constraints = constraints
    else:
        self.bound = bound

    self.default: str | Expr | None = default
    """The type parameter default value."""
```

### annotation

```
annotation: str | Expr | None
```

The type parameter bound or constraints.

### bound

```
bound: str | Expr | None
```

The type parameter bound.

### constraints

```
constraints: tuple[str | Expr, ...] | None
```

The type parameter constraints.

### default

```
default: str | Expr | None = default
```

The type parameter default value.

### kind

```
kind: TypeParameterKind = kind
```

The type parameter kind.

### name

```
name: str = name
```

The type parameter name.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this type parameter's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this type parameter's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base: dict[str, Any] = {
        "name": self.name,
        "kind": self.kind,
        "annotation": self.annotation,
        "default": self.default,
    }
    return base
```

## TypeParameterKind

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.TypeParameterKind[TypeParameterKind]

              

              click griffe.TypeParameterKind href "" "griffe.TypeParameterKind"
```

Enumeration of the different type parameter kinds.

Attributes:

- **`param_spec`** â€“ Parameter specification variable.
- **`type_var`** â€“ Type variable.
- **`type_var_tuple`** â€“ Type variable tuple.

### param_spec

```
param_spec = 'param-spec'
```

Parameter specification variable.

### type_var

```
type_var = 'type-var'
```

Type variable.

### type_var_tuple

```
type_var_tuple = 'type-var-tuple'
```

Type variable tuple.

## **Git information**

## KnownGitService

```
KnownGitService = Literal[
    "github",
    "gitlab",
    "sourcehut",
    "gitea",
    "gogs",
    "forgejo",
    "codeberg",
    "radicle",
]
```

Known Git hosting services.

## GitInfo

```
GitInfo(
    repository: Path,
    service: KnownGitService,
    remote_url: str,
    commit_hash: str,
)
```

Information about a Git repository.

Methods:

- **`from_package`** â€“ Create a GitInfo instance from a Griffe package.
- **`get_source_link`** â€“ Get the source link for the file at the given line numbers.

Attributes:

- **`commit_hash`** (`str`) â€“ A commit hash (usually the current checked-out one).
- **`remote_url`** (`str`) â€“ The remote URL of the Git repository.
- **`repository`** (`Path`) â€“ The path to the Git repository.
- **`service`** (`KnownGitService`) â€“ The Git hosting service (used to build the right URLs).

### commit_hash

```
commit_hash: str
```

A commit hash (usually the current checked-out one).

### remote_url

```
remote_url: str
```

The remote URL of the Git repository.

### repository

```
repository: Path
```

The path to the Git repository.

### service

```
service: KnownGitService
```

The Git hosting service (used to build the right URLs).

### from_package

```
from_package(package: Module) -> GitInfo | None
```

Create a GitInfo instance from a Griffe package.

Returns:

- `GitInfo | None` â€“ The GitInfo instance, or None if unknown.

Source code in `src/griffe/_internal/git.py`

```
@classmethod
def from_package(cls, package: Module) -> GitInfo | None:
    """Create a GitInfo instance from a Griffe package.

    Returns:
        The GitInfo instance, or None if unknown.
    """
    try:
        path = package.filepath[0] if isinstance(package.filepath, list) else package.filepath
    except BuiltinModuleError:
        return None
    try:
        repo = _get_repo_root(path)
        if not _is_tracked(path.relative_to(repo), repo):
            return None
        remote_url = _get_git_remote_url(repo)
        if not (service := _get_git_known_service(remote_url)):
            return None
        commit_hash = _get_git_commit_hash(repo)
    except (GitError, ValueError, OSError):
        # `ValueError` can happen if `path` is not relative to `repo`.
        # `OSError` is caught just to be safe.
        return None
    return cls(repository=repo, service=service, remote_url=remote_url, commit_hash=commit_hash)
```

### get_source_link

```
get_source_link(
    filepath: str | Path, lineno: int, endlineno: int
) -> str | None
```

Get the source link for the file at the given line numbers.

Returns:

- `str | None` â€“ The source link, or None if unknown.

Source code in `src/griffe/_internal/git.py`

```
def get_source_link(self, filepath: str | Path, lineno: int, endlineno: int) -> str | None:
    """Get the source link for the file at the given line numbers.

    Returns:
        The source link, or None if unknown.
    """
    return _get_source_link(self.service, self.remote_url, self.commit_hash, filepath, lineno, endlineno)
```

# Serializers

## **Main API**

See the as_json() and from_json() methods of objects.

## **Advanced API**

## JSONEncoder

```
JSONEncoder(*args: Any, full: bool = False, **kwargs: Any)
```

Bases: `JSONEncoder`

```
              flowchart TD
              griffe.JSONEncoder[JSONEncoder]

              

              click griffe.JSONEncoder href "" "griffe.JSONEncoder"
```

JSON encoder.

JSON encoders can be used directly, or through the json.dump or json.dumps methods.

Examples:

```
>>> from griffe import JSONEncoder
>>> JSONEncoder(full=True).encode(..., **kwargs)
```

```
>>> import json
>>> from griffe import JSONEncoder
>>> json.dumps(..., cls=JSONEncoder, full=True, **kwargs)
```

Parameters:

- ### **`*args`**

  (`Any`, default: `()` ) â€“ See json.JSONEncoder.

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to dump full data or base data. If you plan to reload the data in Python memory using the json_decoder, you don't need the full data as it can be inferred again using the base data. If you want to feed a non-Python tool instead, dump the full data.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ See json.JSONEncoder.

Methods:

- **`default`** â€“ Return a serializable representation of the given object.

Attributes:

- **`full`** (`bool`) â€“ Whether to dump full data or base data.

Source code in `src/griffe/_internal/encoders.py`

```
def __init__(
    self,
    *args: Any,
    full: bool = False,
    **kwargs: Any,
) -> None:
    """Initialize the encoder.

    Parameters:
        *args: See [`json.JSONEncoder`][].
        full: Whether to dump full data or base data.
            If you plan to reload the data in Python memory
            using the [`json_decoder`][griffe.json_decoder],
            you don't need the full data as it can be inferred again
            using the base data. If you want to feed a non-Python
            tool instead, dump the full data.
        **kwargs: See [`json.JSONEncoder`][].
    """
    super().__init__(*args, **kwargs)
    self.full: bool = full
    """Whether to dump full data or base data."""
```

### full

```
full: bool = full
```

Whether to dump full data or base data.

### default

```
default(obj: Any) -> Any
```

Return a serializable representation of the given object.

Parameters:

- #### **`obj`**

  (`Any`) â€“ The object to serialize.

Returns:

- `Any` â€“ A serializable representation.

Source code in `src/griffe/_internal/encoders.py`

```
def default(self, obj: Any) -> Any:
    """Return a serializable representation of the given object.

    Parameters:
        obj: The object to serialize.

    Returns:
        A serializable representation.
    """
    try:
        return obj.as_dict(full=self.full)
    except AttributeError:
        return _json_encoder_map.get(type(obj), super().default)(obj)
```

## json_decoder

```
json_decoder(
    obj_dict: dict[str, Any],
) -> (
    dict[str, Any]
    | Object
    | Alias
    | Parameter
    | TypeParameter
    | str
    | Expr
)
```

Decode dictionaries as data classes.

The json.loads method walks the tree from bottom to top.

Examples:

```
>>> import json
>>> from griffe import json_decoder
>>> json.loads(..., object_hook=json_decoder)
```

Parameters:

- ### **`obj_dict`**

  (`dict[str, Any]`) â€“ The dictionary to decode.

Returns:

- `dict[str, Any] | Object | Alias | Parameter | TypeParameter | str | Expr` â€“ An instance of a data class.

Source code in `src/griffe/_internal/encoders.py`

```
def json_decoder(
    obj_dict: dict[str, Any],
) -> dict[str, Any] | Object | Alias | Parameter | TypeParameter | str | expressions.Expr:
    """Decode dictionaries as data classes.

    The [`json.loads`][] method walks the tree from bottom to top.

    Examples:
        >>> import json
        >>> from griffe import json_decoder
        >>> json.loads(..., object_hook=json_decoder)

    Parameters:
        obj_dict: The dictionary to decode.

    Returns:
        An instance of a data class.
    """
    # Load expressions.
    if "cls" in obj_dict:
        return _load_expression(obj_dict)

    # Load objects and parameters.
    if "kind" in obj_dict:
        kind = obj_dict["kind"]
        if kind in _loader_map:
            return _loader_map[kind](obj_dict)
        # YORE: EOL 3.11: Replace `.__members__.values()` with `` within line.
        if kind in ParameterKind.__members__.values():
            return _load_parameter(obj_dict)
        # YORE: EOL 3.11: Replace `.__members__.values()` with `` within line.
        if kind in TypeParameterKind.__members__.values():
            return _load_type_parameter(obj_dict)

    # Return dict as is.
    return obj_dict
```

# Docstring models

## **Main API**

## Docstring

```
Docstring(
    value: str,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    parent: Object | None = None,
    parser: DocstringStyle | Parser | None = None,
    parser_options: DocstringOptions | None = None,
)
```

This class represents docstrings.

Parameters:

- ### **`value`**

  (`str`) â€“ The docstring value.

- ### **`lineno`**

  (`int | None`, default: `None` ) â€“ The starting line number.

- ### **`endlineno`**

  (`int | None`, default: `None` ) â€“ The ending line number.

- ### **`parent`**

  (`Object | None`, default: `None` ) â€“ The parent object on which this docstring is attached.

- ### **`parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. By default, no parsing is done.

- ### **`parser_options`**

  (`DocstringOptions | None`, default: `None` ) â€“ Additional docstring parsing options.

Methods:

- **`as_dict`** â€“ Return this docstring's data as a dictionary.
- **`parse`** â€“ Parse the docstring into structured data.

Attributes:

- **`endlineno`** (`int | None`) â€“ The ending line number of the docstring.
- **`lineno`** (`int | None`) â€“ The starting line number of the docstring.
- **`lines`** (`list[str]`) â€“ The lines of the docstring.
- **`parent`** (`Object | None`) â€“ The object this docstring is attached to.
- **`parsed`** (`list[DocstringSection]`) â€“ The docstring sections, parsed into structured data.
- **`parser`** (`DocstringStyle | Parser | None`) â€“ The selected docstring parser.
- **`parser_options`** (`DocstringOptions`) â€“ The configured parsing options.
- **`source`** (`str`) â€“ The original, uncleaned value of the docstring as written in the source.
- **`value`** (`str`) â€“ The original value of the docstring, cleaned by inspect.cleandoc.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    value: str,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    parent: Object | None = None,
    parser: DocstringStyle | Parser | None = None,
    parser_options: DocstringOptions | None = None,
) -> None:
    """Initialize the docstring.

    Parameters:
        value: The docstring value.
        lineno: The starting line number.
        endlineno: The ending line number.
        parent: The parent object on which this docstring is attached.
        parser: The docstring parser to use. By default, no parsing is done.
        parser_options: Additional docstring parsing options.
    """
    self.value: str = inspect.cleandoc(value.rstrip())
    """The original value of the docstring, cleaned by `inspect.cleandoc`.

    See also: [`source`][griffe.Docstring.source].
    """

    self.lineno: int | None = lineno
    """The starting line number of the docstring.

    See also: [`endlineno`][griffe.Docstring.endlineno]."""

    self.endlineno: int | None = endlineno
    """The ending line number of the docstring.

    See also: [`lineno`][griffe.Docstring.lineno]."""

    self.parent: Object | None = parent
    """The object this docstring is attached to."""

    self.parser: DocstringStyle | Parser | None = parser
    """The selected docstring parser.

    See also: [`parser_options`][griffe.Docstring.parser_options],
    [`parse`][griffe.Docstring.parse].
    """

    self.parser_options: DocstringOptions = parser_options or {}
    """The configured parsing options.

    See also: [`parser`][griffe.Docstring.parser],
    [`parse`][griffe.Docstring.parse].
    """
```

### endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the docstring.

See also: lineno.

### lineno

```
lineno: int | None = lineno
```

The starting line number of the docstring.

See also: endlineno.

### lines

```
lines: list[str]
```

The lines of the docstring.

See also: source.

### parent

```
parent: Object | None = parent
```

The object this docstring is attached to.

### parsed

```
parsed: list[DocstringSection]
```

The docstring sections, parsed into structured data.

### parser

```
parser: DocstringStyle | Parser | None = parser
```

The selected docstring parser.

See also: parser_options, parse.

### parser_options

```
parser_options: DocstringOptions = parser_options or {}
```

The configured parsing options.

See also: parser, parse.

### source

```
source: str
```

The original, uncleaned value of the docstring as written in the source.

It is a simple concatenation of the source lines. These source lines will include quotes (single/double/triple) and might include leading whitespace and indentation, as well as trailing comments.

Raises:

- `ValueError` â€“ If the original docstring cannot be retrieved (no parent, no line numbers, or attached to namespace package).

See also: value.

### value

```
value: str = cleandoc(rstrip())
```

The original value of the docstring, cleaned by `inspect.cleandoc`.

See also: source.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this docstring's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(
    self,
    *,
    full: bool = False,
    **kwargs: Any,  # noqa: ARG002
) -> dict[str, Any]:
    """Return this docstring's data as a dictionary.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base: dict[str, Any] = {
        "value": self.value,
        "lineno": self.lineno,
        "endlineno": self.endlineno,
    }
    if full:
        base["parsed"] = self.parsed
    return base
```

### parse

```
parse(
    parser: DocstringStyle | Parser | None = None,
    **options: Any,
) -> list[DocstringSection]
```

Parse the docstring into structured data.

See also: parser, parser_options.

Parameters:

- #### **`parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) â€“ The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section).

- #### **`**options`**

  (`Any`, default: `{}` ) â€“ Additional docstring parsing options.

Returns:

- `list[DocstringSection]` â€“ The parsed docstring as a list of sections.

Source code in `src/griffe/_internal/models.py`

```
def parse(
    self,
    parser: DocstringStyle | Parser | None = None,
    **options: Any,
) -> list[DocstringSection]:
    """Parse the docstring into structured data.

    See also: [`parser`][griffe.Docstring.parser],
    [`parser_options`][griffe.Docstring.parser_options].

    Parameters:
        parser: The docstring parser to use.
            In order: use the given parser, or the self parser, or no parser (return a single text section).
        **options: Additional docstring parsing options.

    Returns:
        The parsed docstring as a list of sections.
    """
    return parse(self, parser or self.parser, **(options or self.parser_options))
```

## **Advanced API: Sections**

## DocstringSectionKind

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.DocstringSectionKind[DocstringSectionKind]

              

              click griffe.DocstringSectionKind href "" "griffe.DocstringSectionKind"
```

Enumeration of the possible docstring section kinds.

Attributes:

- **`admonition`** â€“ Admonition block.
- **`attributes`** â€“ Attributes section.
- **`classes`** â€“ Classes section.
- **`deprecated`** â€“ Deprecation section.
- **`examples`** â€“ Examples section.
- **`functions`** â€“ Functions section.
- **`modules`** â€“ Modules section.
- **`other_parameters`** â€“ Other parameters (keyword arguments) section.
- **`parameters`** â€“ Parameters section.
- **`raises`** â€“ Raises (exceptions) section.
- **`receives`** â€“ Received value(s) (generators) section.
- **`returns`** â€“ Returned value(s) section.
- **`text`** â€“ Text section.
- **`type_aliases`** â€“ Type aliases section.
- **`type_parameters`** â€“ Type parameters section.
- **`warns`** â€“ Warnings section.
- **`yields`** â€“ Yielded value(s) (generators) section.

### admonition

```
admonition = 'admonition'
```

Admonition block.

### attributes

```
attributes = 'attributes'
```

Attributes section.

### classes

```
classes = 'classes'
```

Classes section.

### deprecated

```
deprecated = 'deprecated'
```

Deprecation section.

### examples

```
examples = 'examples'
```

Examples section.

### functions

```
functions = 'functions'
```

Functions section.

### modules

```
modules = 'modules'
```

Modules section.

### other_parameters

```
other_parameters = 'other parameters'
```

Other parameters (keyword arguments) section.

### parameters

```
parameters = 'parameters'
```

Parameters section.

### raises

```
raises = 'raises'
```

Raises (exceptions) section.

### receives

```
receives = 'receives'
```

Received value(s) (generators) section.

### returns

```
returns = 'returns'
```

Returned value(s) section.

### text

```
text = 'text'
```

Text section.

### type_aliases

```
type_aliases = 'type aliases'
```

Type aliases section.

### type_parameters

```
type_parameters = 'type parameters'
```

Type parameters section.

### warns

```
warns = 'warns'
```

Warnings section.

### yields

```
yields = 'yields'
```

Yielded value(s) (generators) section.

## DocstringSectionText

```
DocstringSectionText(value: str, title: str | None = None)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionText[DocstringSectionText]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionText
                


              click griffe.DocstringSectionText href "" "griffe.DocstringSectionText"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a text section.

Parameters:

- ### **`value`**

  (`str`) â€“ The section text.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`str`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: str, title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section text.
        title: An optional title.
    """
    super().__init__(title)
    self.value: str = value
```

### kind

```
kind: DocstringSectionKind = text
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: str = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionParameters

```
DocstringSectionParameters(
    value: list[DocstringParameter],
    title: str | None = None,
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionParameters[DocstringSectionParameters]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionParameters
                


              click griffe.DocstringSectionParameters href "" "griffe.DocstringSectionParameters"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a parameters section.

Parameters:

- ### **`value`**

  (`list[DocstringParameter]`) â€“ The section parameters.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringParameter]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringParameter], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section parameters.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringParameter] = value
```

### kind

```
kind: DocstringSectionKind = parameters
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringParameter] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionOtherParameters

```
DocstringSectionOtherParameters(
    value: list[DocstringParameter],
    title: str | None = None,
)
```

Bases: `DocstringSectionParameters`

```
              flowchart TD
              griffe.DocstringSectionOtherParameters[DocstringSectionOtherParameters]
              griffe._internal.docstrings.models.DocstringSectionParameters[DocstringSectionParameters]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSectionParameters --> griffe.DocstringSectionOtherParameters
                                griffe._internal.docstrings.models.DocstringSection --> griffe._internal.docstrings.models.DocstringSectionParameters
                



              click griffe.DocstringSectionOtherParameters href "" "griffe.DocstringSectionOtherParameters"
              click griffe._internal.docstrings.models.DocstringSectionParameters href "" "griffe._internal.docstrings.models.DocstringSectionParameters"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents an other parameters section.

Parameters:

- ### **`value`**

  (`list[DocstringParameter]`) â€“ The section parameters.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringParameter]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringParameter], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section parameters.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringParameter] = value
```

### kind

```
kind: DocstringSectionKind = other_parameters
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringParameter] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionTypeParameters

```
DocstringSectionTypeParameters(
    value: list[DocstringTypeParameter],
    title: str | None = None,
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionTypeParameters[DocstringSectionTypeParameters]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionTypeParameters
                


              click griffe.DocstringSectionTypeParameters href "" "griffe.DocstringSectionTypeParameters"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a type parameters section.

Parameters:

- ### **`value`**

  (`list[DocstringTypeParameter]`) â€“ The section type parameters.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringTypeParameter]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringTypeParameter], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section type parameters.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringTypeParameter] = value
```

### kind

```
kind: DocstringSectionKind = type_parameters
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringTypeParameter] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionRaises

```
DocstringSectionRaises(
    value: list[DocstringRaise], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionRaises[DocstringSectionRaises]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionRaises
                


              click griffe.DocstringSectionRaises href "" "griffe.DocstringSectionRaises"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a raises section.

Parameters:

- ### **`value`**

  (`list[DocstringRaise]`) â€“ The section exceptions.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringRaise]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringRaise], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section exceptions.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringRaise] = value
```

### kind

```
kind: DocstringSectionKind = raises
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringRaise] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionWarns

```
DocstringSectionWarns(
    value: list[DocstringWarn], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionWarns[DocstringSectionWarns]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionWarns
                


              click griffe.DocstringSectionWarns href "" "griffe.DocstringSectionWarns"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a warns section.

Parameters:

- ### **`value`**

  (`list[DocstringWarn]`) â€“ The section warnings.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringWarn]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringWarn], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section warnings.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringWarn] = value
```

### kind

```
kind: DocstringSectionKind = warns
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringWarn] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionReturns

```
DocstringSectionReturns(
    value: list[DocstringReturn], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionReturns[DocstringSectionReturns]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionReturns
                


              click griffe.DocstringSectionReturns href "" "griffe.DocstringSectionReturns"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a returns section.

Parameters:

- ### **`value`**

  (`list[DocstringReturn]`) â€“ The section returned items.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringReturn]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringReturn], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section returned items.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringReturn] = value
```

### kind

```
kind: DocstringSectionKind = returns
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringReturn] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionYields

```
DocstringSectionYields(
    value: list[DocstringYield], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionYields[DocstringSectionYields]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionYields
                


              click griffe.DocstringSectionYields href "" "griffe.DocstringSectionYields"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a yields section.

Parameters:

- ### **`value`**

  (`list[DocstringYield]`) â€“ The section yielded items.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringYield]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringYield], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section yielded items.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringYield] = value
```

### kind

```
kind: DocstringSectionKind = yields
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringYield] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionReceives

```
DocstringSectionReceives(
    value: list[DocstringReceive], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionReceives[DocstringSectionReceives]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionReceives
                


              click griffe.DocstringSectionReceives href "" "griffe.DocstringSectionReceives"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a receives section.

Parameters:

- ### **`value`**

  (`list[DocstringReceive]`) â€“ The section received items.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringReceive]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringReceive], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section received items.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringReceive] = value
```

### kind

```
kind: DocstringSectionKind = receives
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringReceive] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionExamples

```
DocstringSectionExamples(
    value: list[tuple[Literal[text, examples], str]],
    title: str | None = None,
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionExamples[DocstringSectionExamples]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionExamples
                


              click griffe.DocstringSectionExamples href "" "griffe.DocstringSectionExamples"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents an examples section.

Parameters:

- ### **`value`**

  (`list[tuple[Literal[text, examples], str]]`) â€“ The section examples.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[tuple[Literal[text, examples], str]]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    value: list[tuple[Literal[DocstringSectionKind.text, DocstringSectionKind.examples], str]],
    title: str | None = None,
) -> None:
    """Initialize the section.

    Parameters:
        value: The section examples.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[tuple[Literal[DocstringSectionKind.text, DocstringSectionKind.examples], str]] = value
```

### kind

```
kind: DocstringSectionKind = examples
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[tuple[Literal[text, examples], str]] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionAttributes

```
DocstringSectionAttributes(
    value: list[DocstringAttribute],
    title: str | None = None,
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionAttributes[DocstringSectionAttributes]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionAttributes
                


              click griffe.DocstringSectionAttributes href "" "griffe.DocstringSectionAttributes"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents an attributes section.

Parameters:

- ### **`value`**

  (`list[DocstringAttribute]`) â€“ The section attributes.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringAttribute]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringAttribute], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section attributes.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringAttribute] = value
```

### kind

```
kind: DocstringSectionKind = attributes
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringAttribute] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionFunctions

```
DocstringSectionFunctions(
    value: list[DocstringFunction], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionFunctions[DocstringSectionFunctions]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionFunctions
                


              click griffe.DocstringSectionFunctions href "" "griffe.DocstringSectionFunctions"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a functions/methods section.

Parameters:

- ### **`value`**

  (`list[DocstringFunction]`) â€“ The section functions.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringFunction]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringFunction], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section functions.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringFunction] = value
```

### kind

```
kind: DocstringSectionKind = functions
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringFunction] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionClasses

```
DocstringSectionClasses(
    value: list[DocstringClass], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionClasses[DocstringSectionClasses]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionClasses
                


              click griffe.DocstringSectionClasses href "" "griffe.DocstringSectionClasses"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a classes section.

Parameters:

- ### **`value`**

  (`list[DocstringClass]`) â€“ The section classes.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringClass]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringClass], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section classes.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringClass] = value
```

### kind

```
kind: DocstringSectionKind = classes
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringClass] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionTypeAliases

```
DocstringSectionTypeAliases(
    value: list[DocstringTypeAlias],
    title: str | None = None,
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionTypeAliases[DocstringSectionTypeAliases]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionTypeAliases
                


              click griffe.DocstringSectionTypeAliases href "" "griffe.DocstringSectionTypeAliases"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a type aliases section.

Parameters:

- ### **`value`**

  (`list[DocstringTypeAlias]`) â€“ The section classes.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringTypeAlias]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringTypeAlias], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section classes.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringTypeAlias] = value
```

### kind

```
kind: DocstringSectionKind = type_aliases
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringTypeAlias] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionModules

```
DocstringSectionModules(
    value: list[DocstringModule], title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionModules[DocstringSectionModules]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionModules
                


              click griffe.DocstringSectionModules href "" "griffe.DocstringSectionModules"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a modules section.

Parameters:

- ### **`value`**

  (`list[DocstringModule]`) â€“ The section modules.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`list[DocstringModule]`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, value: list[DocstringModule], title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        value: The section modules.
        title: An optional title.
    """
    super().__init__(title)
    self.value: list[DocstringModule] = value
```

### kind

```
kind: DocstringSectionKind = modules
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: list[DocstringModule] = value
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionDeprecated

```
DocstringSectionDeprecated(
    version: str, text: str, title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionDeprecated[DocstringSectionDeprecated]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionDeprecated
                


              click griffe.DocstringSectionDeprecated href "" "griffe.DocstringSectionDeprecated"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents a deprecated section.

Parameters:

- ### **`version`**

  (`str`) â€“ The deprecation version.

- ### **`text`**

  (`str`) â€“ The deprecation text.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`DocstringDeprecated`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, version: str, text: str, title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        version: The deprecation version.
        text: The deprecation text.
        title: An optional title.
    """
    super().__init__(title)
    self.value: DocstringDeprecated = DocstringDeprecated(annotation=version, description=text)
```

### kind

```
kind: DocstringSectionKind = deprecated
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: DocstringDeprecated = DocstringDeprecated(
    annotation=version, description=text
)
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## DocstringSectionAdmonition

```
DocstringSectionAdmonition(
    kind: str, text: str, title: str | None = None
)
```

Bases: `DocstringSection`

```
              flowchart TD
              griffe.DocstringSectionAdmonition[DocstringSectionAdmonition]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionAdmonition
                


              click griffe.DocstringSectionAdmonition href "" "griffe.DocstringSectionAdmonition"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
```

This class represents an admonition section.

Parameters:

- ### **`kind`**

  (`str`) â€“ The admonition kind.

- ### **`text`**

  (`str`) â€“ The admonition text.

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`DocstringAdmonition`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, kind: str, text: str, title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        kind: The admonition kind.
        text: The admonition text.
        title: An optional title.
    """
    super().__init__(title)
    self.value: DocstringAdmonition = DocstringAdmonition(annotation=kind, description=text)
```

### kind

```
kind: DocstringSectionKind = admonition
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: DocstringAdmonition = DocstringAdmonition(
    annotation=kind, description=text
)
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

## **Advanced API: Section items**

## DocstringAdmonition

```
DocstringAdmonition(
    *,
    description: str,
    annotation: str | Expr | None = None,
)
```

Bases: `DocstringElement`

```
              flowchart TD
              griffe.DocstringAdmonition[DocstringAdmonition]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringAdmonition
                


              click griffe.DocstringAdmonition href "" "griffe.DocstringAdmonition"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents an admonition.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`description`**

  (`str`) â€“ The element description.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`contents`** (`str`) â€“ The contents of this admonition.
- **`description`** (`str`) â€“ The element description.
- **`kind`** (`str | Expr | None`) â€“ The kind of this admonition.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, *, description: str, annotation: str | Expr | None = None) -> None:
    """Initialize the element.

    Parameters:
        annotation: The element annotation, if any.
        description: The element description.
    """
    self.description: str = description
    """The element description."""
    self.annotation: str | Expr | None = annotation
    """The element annotation."""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### contents

```
contents: str
```

The contents of this admonition.

### description

```
description: str = description
```

The element description.

### kind

```
kind: str | Expr | None
```

The kind of this admonition.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "annotation": self.annotation,
        "description": self.description,
    }
```

## DocstringDeprecated

```
DocstringDeprecated(
    *,
    description: str,
    annotation: str | Expr | None = None,
)
```

Bases: `DocstringElement`

```
              flowchart TD
              griffe.DocstringDeprecated[DocstringDeprecated]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringDeprecated
                


              click griffe.DocstringDeprecated href "" "griffe.DocstringDeprecated"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented deprecated item.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`description`**

  (`str`) â€“ The element description.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`version`** (`str`) â€“ The version of this deprecation.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, *, description: str, annotation: str | Expr | None = None) -> None:
    """Initialize the element.

    Parameters:
        annotation: The element annotation, if any.
        description: The element description.
    """
    self.description: str = description
    """The element description."""
    self.annotation: str | Expr | None = annotation
    """The element annotation."""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### version

```
version: str
```

The version of this deprecation.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "annotation": self.annotation,
        "description": self.description,
    }
```

## DocstringRaise

```
DocstringRaise(
    *,
    description: str,
    annotation: str | Expr | None = None,
)
```

Bases: `DocstringElement`

```
              flowchart TD
              griffe.DocstringRaise[DocstringRaise]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringRaise
                


              click griffe.DocstringRaise href "" "griffe.DocstringRaise"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented raise value.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`description`**

  (`str`) â€“ The element description.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, *, description: str, annotation: str | Expr | None = None) -> None:
    """Initialize the element.

    Parameters:
        annotation: The element annotation, if any.
        description: The element description.
    """
    self.description: str = description
    """The element description."""
    self.annotation: str | Expr | None = annotation
    """The element annotation."""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "annotation": self.annotation,
        "description": self.description,
    }
```

## DocstringWarn

```
DocstringWarn(
    *,
    description: str,
    annotation: str | Expr | None = None,
)
```

Bases: `DocstringElement`

```
              flowchart TD
              griffe.DocstringWarn[DocstringWarn]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringWarn
                


              click griffe.DocstringWarn href "" "griffe.DocstringWarn"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented warn value.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`description`**

  (`str`) â€“ The element description.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, *, description: str, annotation: str | Expr | None = None) -> None:
    """Initialize the element.

    Parameters:
        annotation: The element annotation, if any.
        description: The element description.
    """
    self.description: str = description
    """The element description."""
    self.annotation: str | Expr | None = annotation
    """The element annotation."""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "annotation": self.annotation,
        "description": self.description,
    }
```

## DocstringReturn

```
DocstringReturn(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringReturn[DocstringReturn]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringReturn
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringReturn href "" "griffe.DocstringReturn"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented return value.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringYield

```
DocstringYield(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringYield[DocstringYield]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringYield
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringYield href "" "griffe.DocstringYield"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented yield value.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringReceive

```
DocstringReceive(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringReceive[DocstringReceive]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringReceive
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringReceive href "" "griffe.DocstringReceive"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented receive value.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringParameter

```
DocstringParameter(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringParameter[DocstringParameter]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringParameter
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringParameter href "" "griffe.DocstringParameter"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represent a documented function parameter.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`default`** (`str | Expr | None`) â€“ The default value of this parameter.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### default

```
default: str | Expr | None
```

The default value of this parameter.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringTypeParameter

```
DocstringTypeParameter(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringTypeParameter[DocstringTypeParameter]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringTypeParameter
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringTypeParameter href "" "griffe.DocstringTypeParameter"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represent a documented type parameter.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`bound`** (`str | Expr | None`) â€“ The bound of this type parameter.
- **`constraints`** (`tuple[str | Expr, ...] | None`) â€“ The constraints of this type parameter.
- **`default`** (`str | Expr | None`) â€“ The default value of this type parameter.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### bound

```
bound: str | Expr | None
```

The bound of this type parameter.

### constraints

```
constraints: tuple[str | Expr, ...] | None
```

The constraints of this type parameter.

### default

```
default: str | Expr | None
```

The default value of this type parameter.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringAttribute

```
DocstringAttribute(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringAttribute[DocstringAttribute]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringAttribute
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringAttribute href "" "griffe.DocstringAttribute"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented module/class attribute.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringFunction

```
DocstringFunction(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringFunction[DocstringFunction]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringFunction
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringFunction href "" "griffe.DocstringFunction"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented function.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`signature`** (`str | Expr | None`) â€“ The function signature.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### signature

```
signature: str | Expr | None
```

The function signature.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringClass

```
DocstringClass(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringClass[DocstringClass]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringClass
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringClass href "" "griffe.DocstringClass"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented class.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`signature`** (`str | Expr | None`) â€“ The class signature.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### signature

```
signature: str | Expr | None
```

The class signature.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringTypeAlias

```
DocstringTypeAlias(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringTypeAlias[DocstringTypeAlias]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringTypeAlias
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringTypeAlias href "" "griffe.DocstringTypeAlias"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented type alias.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringModule

```
DocstringModule(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringNamedElement`

```
              flowchart TD
              griffe.DocstringModule[DocstringModule]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringModule
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringModule href "" "griffe.DocstringModule"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This class represents a documented module.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## **Models base classes**

## DocstringElement

```
DocstringElement(
    *,
    description: str,
    annotation: str | Expr | None = None,
)
```

This base class represents annotated, nameless elements.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`description`**

  (`str`) â€“ The element description.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, *, description: str, annotation: str | Expr | None = None) -> None:
    """Initialize the element.

    Parameters:
        annotation: The element annotation, if any.
        description: The element description.
    """
    self.description: str = description
    """The element description."""
    self.annotation: str | Expr | None = annotation
    """The element annotation."""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "annotation": self.annotation,
        "description": self.description,
    }
```

## DocstringNamedElement

```
DocstringNamedElement(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)
```

Bases: `DocstringElement`

```
              flowchart TD
              griffe.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringNamedElement
                


              click griffe.DocstringNamedElement href "" "griffe.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
```

This base class represents annotated, named elements.

Parameters:

- ### **`name`**

  (`str`) â€“ The element name.

- ### **`description`**

  (`str`) â€“ The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The element value, as a string.

Methods:

- **`as_dict`** â€“ Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The element annotation.
- **`description`** (`str`) â€“ The element description.
- **`name`** (`str`) â€“ The element name.
- **`value`** (`str | Expr | None`) â€“ The element value, if any

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(
    self,
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
) -> None:
    """Initialize the element.

    Parameters:
        name: The element name.
        description: The element description.
        annotation: The element annotation, if any.
        value: The element value, as a string.
    """
    super().__init__(description=description, annotation=annotation)
    self.name: str = name
    """The element name."""
    self.value: str | Expr | None = value
    """The element value, if any"""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The element annotation.

### description

```
description: str = description
```

The element description.

### name

```
name: str = name
```

The element name.

### value

```
value: str | Expr | None = value
```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this element's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = {"name": self.name, **super().as_dict(**kwargs)}
    if self.value is not None:
        base["value"] = self.value
    return base
```

## DocstringSection

```
DocstringSection(title: str | None = None)
```

This class represents a docstring section.

Parameters:

- ### **`title`**

  (`str | None`, default: `None` ) â€“ An optional title.

Methods:

- **`__bool__`** â€“ Whether this section has a true-ish value.
- **`as_dict`** â€“ Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) â€“ The section kind.
- **`title`** (`str | None`) â€“ The section title.
- **`value`** (`Any`) â€“ The section value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __init__(self, title: str | None = None) -> None:
    """Initialize the section.

    Parameters:
        title: An optional title.
    """
    self.title: str | None = title
    """The section title."""
    self.value: Any = None
    """The section value."""
```

### kind

```
kind: DocstringSectionKind
```

The section kind.

### title

```
title: str | None = title
```

The section title.

### value

```
value: Any = None
```

The section value.

### __bool__

```
__bool__() -> bool
```

Whether this section has a true-ish value.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def __bool__(self) -> bool:
    """Whether this section has a true-ish value."""
    return bool(self.value)
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/docstrings/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this section's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    if hasattr(self.value, "as_dict"):  # noqa: SIM108
        serialized_value = self.value.as_dict(**kwargs)
    else:
        serialized_value = self.value
    base = {"kind": self.kind.value, "value": serialized_value}
    if self.title:
        base["title"] = self.title
    return base
```

# Docstring parsers

## **Main API**

## parse

```
parse(
    docstring: Docstring,
    parser: DocstringStyle | Parser | None,
    **options: Any,
) -> list[DocstringSection]
```

Parse the docstring.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring to parse.

- ### **`parser`**

  (`DocstringStyle | Parser | None`) â€“ The docstring parser to use. If None, return a single text section.

- ### **`**options`**

  (`Any`, default: `{}` ) â€“ The options accepted by the parser.

Returns:

- `list[DocstringSection]` â€“ A list of docstring sections.

Source code in `src/griffe/_internal/docstrings/parsers.py`

```
def parse(
    docstring: Docstring,
    parser: DocstringStyle | Parser | None,
    **options: Any,
) -> list[DocstringSection]:
    """Parse the docstring.

    Parameters:
        docstring: The docstring to parse.
        parser: The docstring parser to use. If None, return a single text section.
        **options: The options accepted by the parser.

    Returns:
        A list of docstring sections.
    """
    if parser:
        if not isinstance(parser, Parser):
            parser = Parser(parser)
        return parsers[parser](docstring, **options)
    return [DocstringSectionText(docstring.value)] if docstring.value else []
```

## parse_auto

```
parse_auto(
    docstring: Docstring,
    *,
    method: DocstringDetectionMethod = "heuristics",
    style_order: list[Parser]
    | list[DocstringStyle]
    | None = None,
    default: Parser | DocstringStyle | None = None,
    per_style_options: PerStyleOptions | None = None,
    **options: Any,
) -> list[DocstringSection]
```

Parse a docstring by automatically detecting the style it uses.

See infer_docstring_style for more information on the available parameters.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring to parse.

- ### **`method`**

  (`DocstringDetectionMethod`, default: `'heuristics'` ) â€“ The method to use to infer the parser.

- ### **`style_order`**

  (`list[Parser] | list[DocstringStyle] | None`, default: `None` ) â€“ The order of the styles to try when inferring the parser.

- ### **`default`**

  (`Parser | DocstringStyle | None`, default: `None` ) â€“ The default parser to use if the inference fails.

- ### **`per_style_options`**

  (`PerStyleOptions | None`, default: `None` ) â€“ Additional parsing options per style.

- ### **`**options`**

  (`Any`, default: `{}` ) â€“ Deprecated. Use per_style_options instead.

Returns:

- `list[DocstringSection]` â€“ A list of docstring sections.

Source code in `src/griffe/_internal/docstrings/auto.py`

```
def parse_auto(
    docstring: Docstring,
    *,
    method: DocstringDetectionMethod = "heuristics",
    style_order: list[Parser] | list[DocstringStyle] | None = None,
    default: Parser | DocstringStyle | None = None,
    per_style_options: PerStyleOptions | None = None,
    # YORE: Bump 2: Remove line.
    **options: Any,
) -> list[DocstringSection]:
    """Parse a docstring by automatically detecting the style it uses.

    See [`infer_docstring_style`][griffe.infer_docstring_style] for more information
    on the available parameters.

    Parameters:
        docstring: The docstring to parse.
        method: The method to use to infer the parser.
        style_order: The order of the styles to try when inferring the parser.
        default: The default parser to use if the inference fails.
        per_style_options: Additional parsing options per style.
        **options: Deprecated. Use `per_style_options` instead.

    Returns:
        A list of docstring sections.
    """
    from griffe._internal.docstrings.parsers import parse  # noqa: PLC0415

    # YORE: Bump 2: Replace block with `per_style_options = per_style_options or {}`.
    if options:
        if per_style_options:
            raise ValueError("Cannot use both `options` and `per_style_options`.")
        warn("`**options` are deprecated. Use `per_style_options` instead.", DeprecationWarning, stacklevel=2)
        per_style_options = {"google": options, "numpy": options, "sphinx": options}  # type: ignore[assignment]
    elif not per_style_options:
        per_style_options = {}

    style, sections = infer_docstring_style(
        docstring,
        method=method,
        style_order=style_order,
        default=default,
        per_style_options=per_style_options,
    )
    if sections is None:
        return parse(docstring, style, **per_style_options.get(style, {}))  # type: ignore[arg-type,typeddict-item,union-attr]
    return sections
```

## parse_google

```
parse_google(
    docstring: Docstring,
    *,
    ignore_init_summary: bool = False,
    trim_doctest_flags: bool = True,
    returns_multiple_items: bool = True,
    returns_named_value: bool = True,
    returns_type_in_property_summary: bool = False,
    receives_multiple_items: bool = True,
    receives_named_value: bool = True,
    warn_unknown_params: bool = True,
    warn_missing_types: bool = True,
    warnings: bool = True,
    **options: Any,
) -> list[DocstringSection]
```

Parse a Google-style docstring.

This function iterates on lines of a docstring to build sections. It then returns this list of sections.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring to parse.

- ### **`ignore_init_summary`**

  (`bool`, default: `False` ) â€“ Whether to ignore the summary in __init__ methods' docstrings.

- ### **`trim_doctest_flags`**

  (`bool`, default: `True` ) â€“ Whether to remove doctest flags from Python example blocks.

- ### **`returns_multiple_items`**

  (`bool`, default: `True` ) â€“ Whether to parse multiple items in Yields and Returns sections. When true, each item's continuation lines must be indented. When false (single item), no further indentation is required.

- ### **`returns_named_value`**

  (`bool`, default: `True` ) â€“ Whether to parse Yields and Returns section items as name and description, rather than type and description. When true, type must be wrapped in parentheses: (int): Description.. Names are optional: name (int): Description.. When false, parentheses are optional but the items cannot be named: int: Description.

- ### **`receives_multiple_items`**

  (`bool`, default: `True` ) â€“ Whether to parse multiple items in Receives sections. When true, each item's continuation lines must be indented. When false (single item), no further indentation is required.

- ### **`receives_named_value`**

  (`bool`, default: `True` ) â€“ Whether to parse Receives section items as name and description, rather than type and description. When true, type must be wrapped in parentheses: (int): Description.. Names are optional: name (int): Description.. When false, parentheses are optional but the items cannot be named: int: Description.

- ### **`returns_type_in_property_summary`**

  (`bool`, default: `False` ) â€“ Whether to parse the return type of properties at the beginning of their summary: str: Summary of the property.

- ### **`warn_unknown_params`**

  (`bool`, default: `True` ) â€“ Warn about documented parameters not appearing in the signature.

- ### **`warn_missing_types`**

  (`bool`, default: `True` ) â€“ Warn about missing types/annotations for parameters, return values, etc.

- ### **`warnings`**

  (`bool`, default: `True` ) â€“ Whether to log warnings at all.

- ### **`**options`**

  (`Any`, default: `{}` ) â€“ Swallowing keyword arguments for backward-compatibility.

Returns:

- `list[DocstringSection]` â€“ A list of docstring sections.

Source code in `src/griffe/_internal/docstrings/google.py`

````
def parse_google(
    docstring: Docstring,
    *,
    ignore_init_summary: bool = False,
    trim_doctest_flags: bool = True,
    returns_multiple_items: bool = True,
    returns_named_value: bool = True,
    returns_type_in_property_summary: bool = False,
    receives_multiple_items: bool = True,
    receives_named_value: bool = True,
    warn_unknown_params: bool = True,
    warn_missing_types: bool = True,
    warnings: bool = True,
    # YORE: Bump 2: Remove line.
    **options: Any,
) -> list[DocstringSection]:
    """Parse a Google-style docstring.

    This function iterates on lines of a docstring to build sections.
    It then returns this list of sections.

    Parameters:
        docstring: The docstring to parse.
        ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings.
        trim_doctest_flags: Whether to remove doctest flags from Python example blocks.
        returns_multiple_items: Whether to parse multiple items in `Yields` and `Returns` sections.
            When true, each item's continuation lines must be indented.
            When false (single item), no further indentation is required.
        returns_named_value: Whether to parse `Yields` and `Returns` section items as name and description, rather than type and description.
            When true, type must be wrapped in parentheses: `(int): Description.`. Names are optional: `name (int): Description.`.
            When false, parentheses are optional but the items cannot be named: `int: Description`.
        receives_multiple_items: Whether to parse multiple items in `Receives` sections.
            When true, each item's continuation lines must be indented.
            When false (single item), no further indentation is required.
        receives_named_value: Whether to parse `Receives` section items as name and description, rather than type and description.
            When true, type must be wrapped in parentheses: `(int): Description.`. Names are optional: `name (int): Description.`.
            When false, parentheses are optional but the items cannot be named: `int: Description`.
        returns_type_in_property_summary: Whether to parse the return type of properties
            at the beginning of their summary: `str: Summary of the property`.
        warn_unknown_params: Warn about documented parameters not appearing in the signature.
        warn_missing_types: Warn about missing types/annotations for parameters, return values, etc.
        warnings: Whether to log warnings at all.
        **options: Swallowing keyword arguments for backward-compatibility.

    Returns:
        A list of docstring sections.
    """
    sections: list[DocstringSection] = []
    current_section = []

    in_code_block = False
    lines = docstring.lines

    # YORE: Bump 2: Remove block.
    if options:
        warn("Passing additional options is deprecated, these options are ignored.", DeprecationWarning, stacklevel=2)

    options = {
        "ignore_init_summary": ignore_init_summary,
        "trim_doctest_flags": trim_doctest_flags,
        "returns_multiple_items": returns_multiple_items,
        "returns_named_value": returns_named_value,
        "returns_type_in_property_summary": returns_type_in_property_summary,
        "receives_multiple_items": receives_multiple_items,
        "receives_named_value": receives_named_value,
        "warn_unknown_params": warn_unknown_params,
        "warn_missing_types": warn_missing_types,
        "warnings": warnings,
    }

    ignore_summary = (
        options["ignore_init_summary"]
        and docstring.parent is not None
        and docstring.parent.name == "__init__"
        and docstring.parent.is_function
        and docstring.parent.parent is not None
        and docstring.parent.parent.is_class
    )

    offset = 2 if ignore_summary else 0

    while offset < len(lines):
        line_lower = lines[offset].lower()

        if in_code_block:
            if line_lower.lstrip(" ").startswith("```"):
                in_code_block = False
            current_section.append(lines[offset])

        elif line_lower.lstrip(" ").startswith("```"):
            in_code_block = True
            current_section.append(lines[offset])

        elif match := _RE_ADMONITION.match(lines[offset]):
            groups = match.groupdict()
            title = groups["title"]
            admonition_type = groups["type"]
            is_section = admonition_type.lower() in _section_kind

            has_previous_line = offset > 0
            blank_line_above = not has_previous_line or _is_empty_line(lines[offset - 1])
            has_next_line = offset < len(lines) - 1
            has_next_lines = offset < len(lines) - 2
            blank_line_below = has_next_line and _is_empty_line(lines[offset + 1])
            blank_lines_below = has_next_lines and _is_empty_line(lines[offset + 2])
            indented_line_below = has_next_line and not blank_line_below and lines[offset + 1].startswith(" ")
            indented_lines_below = has_next_lines and not blank_lines_below and lines[offset + 2].startswith(" ")
            if not (indented_line_below or indented_lines_below):
                # Do not warn when there are no contents,
                # this is most probably not a section or admonition.
                current_section.append(lines[offset])
                offset += 1
                continue
            reasons = []
            kind = "section" if is_section else "admonition"
            if (indented_line_below or indented_lines_below) and not blank_line_above:
                reasons.append(f"Missing blank line above {kind}")
            if indented_lines_below and blank_line_below:
                reasons.append(f"Extraneous blank line below {kind} title")
            if reasons:
                if warnings:
                    reasons_string = "; ".join(reasons)
                    docstring_warning(
                        docstring,
                        offset,
                        f"Possible {kind} skipped, reasons: {reasons_string}",
                        LogLevel.debug,
                    )
                current_section.append(lines[offset])
                offset += 1
                continue

            if is_section:
                if current_section:
                    if any(current_section):
                        sections.append(DocstringSectionText("\n".join(current_section).rstrip("\n")))
                    current_section = []
                reader = _section_reader[_section_kind[admonition_type.lower()]]
                section, offset = reader(docstring, offset=offset + 1, **options)  # type: ignore[operator]
                if section:
                    section.title = title
                    sections.append(section)

            else:
                contents, offset = _read_block(docstring, offset=offset + 1)
                if contents:
                    if current_section:
                        if any(current_section):
                            sections.append(DocstringSectionText("\n".join(current_section).rstrip("\n")))
                        current_section = []
                    if title is None:
                        title = admonition_type
                    admonition_type = admonition_type.lower().replace(" ", "-")
                    sections.append(DocstringSectionAdmonition(kind=admonition_type, text=contents, title=title))
                else:
                    with suppress(IndexError):
                        current_section.append(lines[offset])
        else:
            current_section.append(lines[offset])

        offset += 1

    if current_section and any(current_section):
        sections.append(DocstringSectionText("\n".join(current_section).rstrip("\n")))

    if (
        returns_type_in_property_summary
        and sections
        and docstring.parent
        and docstring.parent.is_attribute
        and "property" in docstring.parent.labels
    ):
        lines = sections[0].value.lstrip().split("\n")
        if ":" in lines[0]:
            annotation, line = lines[0].split(":", 1)
            lines = [line, *lines[1:]]
            sections[0].value = "\n".join(lines)
            sections.append(
                DocstringSectionReturns(
                    [DocstringReturn("", description="", annotation=parse_docstring_annotation(annotation, docstring))],
                ),
            )

    return sections
````

## parse_numpy

```
parse_numpy(
    docstring: Docstring,
    *,
    ignore_init_summary: bool = False,
    trim_doctest_flags: bool = True,
    warn_unknown_params: bool = True,
    warn_missing_types: bool = True,
    warnings: bool = True,
    **options: Any,
) -> list[DocstringSection]
```

Parse a Numpydoc-style docstring.

This function iterates on lines of a docstring to build sections. It then returns this list of sections.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring to parse.

- ### **`ignore_init_summary`**

  (`bool`, default: `False` ) â€“ Whether to ignore the summary in __init__ methods' docstrings.

- ### **`trim_doctest_flags`**

  (`bool`, default: `True` ) â€“ Whether to remove doctest flags from Python example blocks.

- ### **`warn_unknown_params`**

  (`bool`, default: `True` ) â€“ Warn about documented parameters not appearing in the signature.

- ### **`warn_missing_types`**

  (`bool`, default: `True` ) â€“ Warn about missing types/annotations for parameters, return values, etc.

- ### **`warnings`**

  (`bool`, default: `True` ) â€“ Whether to log warnings at all.

- ### **`**options`**

  (`Any`, default: `{}` ) â€“ Swallowing keyword arguments for backward-compatibility.

Returns:

- `list[DocstringSection]` â€“ A list of docstring sections.

Source code in `src/griffe/_internal/docstrings/numpy.py`

````
def parse_numpy(
    docstring: Docstring,
    *,
    ignore_init_summary: bool = False,
    trim_doctest_flags: bool = True,
    warn_unknown_params: bool = True,
    warn_missing_types: bool = True,
    warnings: bool = True,
    # YORE: Bump 2: Remove line.
    **options: Any,
) -> list[DocstringSection]:
    """Parse a Numpydoc-style docstring.

    This function iterates on lines of a docstring to build sections.
    It then returns this list of sections.

    Parameters:
        docstring: The docstring to parse.
        ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings.
        trim_doctest_flags: Whether to remove doctest flags from Python example blocks.
        warn_unknown_params: Warn about documented parameters not appearing in the signature.
        warn_missing_types: Warn about missing types/annotations for parameters, return values, etc.
        warnings: Whether to log warnings at all.
        **options: Swallowing keyword arguments for backward-compatibility.

    Returns:
        A list of docstring sections.
    """
    sections: list[DocstringSection] = []
    current_section = []
    admonition_title = ""

    in_code_block = False
    lines = docstring.lines

    # YORE: Bump 2: Remove block.
    if options:
        warn("Passing additional options is deprecated, these options are ignored.", DeprecationWarning, stacklevel=2)

    options = {
        "trim_doctest_flags": trim_doctest_flags,
        "ignore_init_summary": ignore_init_summary,
        "warn_unknown_params": warn_unknown_params,
        "warn_missing_types": warn_missing_types,
        "warnings": warnings,
    }

    ignore_summary = (
        options["ignore_init_summary"]
        and docstring.parent is not None
        and docstring.parent.name == "__init__"
        and docstring.parent.is_function
        and docstring.parent.parent is not None
        and docstring.parent.parent.is_class
    )

    offset = 2 if ignore_summary else 0

    while offset < len(lines):
        line_lower = lines[offset].lower()

        # Code blocks can contain dash lines that we must not interpret.
        if in_code_block:
            # End of code block.
            if line_lower.lstrip(" ").startswith("```"):
                in_code_block = False
            # Lines in code block must not be interpreted in any way.
            current_section.append(lines[offset])

        # Start of code block.
        elif line_lower.lstrip(" ").startswith("```"):
            in_code_block = True
            current_section.append(lines[offset])

        # Dash lines after empty lines lose their meaning.
        elif _is_empty_line(lines[offset]):
            current_section.append("")

        # End of the docstring, wrap up.
        elif offset == len(lines) - 1:
            current_section.append(lines[offset])
            _append_section(sections, current_section, admonition_title)
            admonition_title = ""
            current_section = []

        # Dash line after regular, non-empty line.
        elif _is_dash_line(lines[offset + 1]):
            # Finish reading current section.
            _append_section(sections, current_section, admonition_title)
            current_section = []

            # Start parsing new (known) section.
            if line_lower in _section_kind:
                admonition_title = ""
                reader = _section_reader[_section_kind[line_lower]]
                section, offset = reader(docstring, offset=offset + 2, **options)  # type: ignore[operator]
                if section:
                    sections.append(section)

            # Start parsing admonition.
            else:
                admonition_title = lines[offset]
                offset += 1  # Skip next dash line.

        # Regular line.
        else:
            current_section.append(lines[offset])

        offset += 1

    # Finish current section.
    _append_section(sections, current_section, admonition_title)

    return sections
````

## parse_sphinx

```
parse_sphinx(
    docstring: Docstring,
    *,
    warn_unknown_params: bool = True,
    warnings: bool = True,
    **options: Any,
) -> list[DocstringSection]
```

Parse a Sphinx-style docstring.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring to parse.

- ### **`warn_unknown_params`**

  (`bool`, default: `True` ) â€“ Warn about documented parameters not appearing in the signature.

- ### **`warnings`**

  (`bool`, default: `True` ) â€“ Whether to log warnings at all.

- ### **`**options`**

  (`Any`, default: `{}` ) â€“ Swallowing keyword arguments for backward-compatibility.

Returns:

- `list[DocstringSection]` â€“ A list of docstring sections.

Source code in `src/griffe/_internal/docstrings/sphinx.py`

```
def parse_sphinx(
    docstring: Docstring,
    *,
    warn_unknown_params: bool = True,
    warnings: bool = True,
    # YORE: Bump 2: Remove line.
    **options: Any,
) -> list[DocstringSection]:
    """Parse a Sphinx-style docstring.

    Parameters:
        docstring: The docstring to parse.
        warn_unknown_params: Warn about documented parameters not appearing in the signature.
        warnings: Whether to log warnings at all.
        **options: Swallowing keyword arguments for backward-compatibility.

    Returns:
        A list of docstring sections.
    """
    parsed_values = _ParsedValues()

    # YORE: Bump 2: Remove block.
    if options:
        warn("Passing additional options is deprecated, these options are ignored.", DeprecationWarning, stacklevel=2)

    options = {
        "warn_unknown_params": warn_unknown_params,
        "warnings": warnings,
    }

    lines = docstring.lines
    curr_line_index = 0

    while curr_line_index < len(lines):
        line = lines[curr_line_index]
        for field_type in _field_types:
            if field_type.matches(line):
                # https://github.com/python/mypy/issues/5485
                curr_line_index = field_type.reader(docstring, curr_line_index, parsed_values, **options)
                break
        else:
            parsed_values.description.append(line)

        curr_line_index += 1

    return _parsed_values_to_sections(parsed_values)
```

## DocstringStyle

```
DocstringStyle = Literal[
    "google", "numpy", "sphinx", "auto"
]
```

The supported docstring styles (literal values of the Parser enumeration).

## **Parser options**

## DocstringOptions

```
DocstringOptions = Union[
    GoogleOptions, NumpyOptions, SphinxOptions, AutoOptions
]
```

The options for each docstring style.

## GoogleOptions

```
GoogleOptions(
    *,
    ignore_init_summary: bool = ...,
    trim_doctest_flags: bool = ...,
    returns_multiple_items: bool = ...,
    returns_named_value: bool = ...,
    returns_type_in_property_summary: bool = ...,
    receives_multiple_items: bool = ...,
    receives_named_value: bool = ...,
    warn_unknown_params: bool = ...,
    warn_missing_types: bool = ...,
    warnings: bool = ...,
)
```

Bases: `TypedDict`

```
              flowchart TD
              griffe.GoogleOptions[GoogleOptions]

              

              click griffe.GoogleOptions href "" "griffe.GoogleOptions"
```

Options for parsing Google-style docstrings.

Parameters:

- ### **`ignore_init_summary`**

  (`bool`, default: `...` ) â€“ Whether to ignore the summary in __init__ methods' docstrings.

- ### **`trim_doctest_flags`**

  (`bool`, default: `...` ) â€“ Whether to remove doctest flags from Python example blocks.

- ### **`returns_multiple_items`**

  (`bool`, default: `...` ) â€“ Whether to parse multiple items in Yields and Returns sections.

- ### **`returns_named_value`**

  (`bool`, default: `...` ) â€“ Whether to parse Yields and Returns section items as name and description, rather than type and description.

- ### **`returns_type_in_property_summary`**

  (`bool`, default: `...` ) â€“ Whether to parse the return type of properties at the beginning of their summary.

- ### **`receives_multiple_items`**

  (`bool`, default: `...` ) â€“ Whether to parse multiple items in Receives sections.

- ### **`receives_named_value`**

  (`bool`, default: `...` ) â€“ Whether to parse Receives section items as name and description, rather than type and description.

- ### **`warn_unknown_params`**

  (`bool`, default: `...` ) â€“ Whether to warn about unknown parameters.

- ### **`warn_missing_types`**

  (`bool`, default: `...` ) â€“ Whether to warn about missing types/annotations for parameters, return values, etc.

- ### **`warnings`**

  (`bool`, default: `...` ) â€“ Whether to issue warnings for parsing issues.

## NumpyOptions

```
NumpyOptions(
    *,
    ignore_init_summary: bool = ...,
    trim_doctest_flags: bool = ...,
    warn_unknown_params: bool = ...,
    warn_missing_types: bool = ...,
    warnings: bool = ...,
)
```

Bases: `TypedDict`

```
              flowchart TD
              griffe.NumpyOptions[NumpyOptions]

              

              click griffe.NumpyOptions href "" "griffe.NumpyOptions"
```

Options for parsing Numpydoc-style docstrings.

Parameters:

- ### **`ignore_init_summary`**

  (`bool`, default: `...` ) â€“ Whether to ignore the summary in __init__ methods' docstrings.

- ### **`trim_doctest_flags`**

  (`bool`, default: `...` ) â€“ Whether to remove doctest flags from Python example blocks.

- ### **`warn_unknown_params`**

  (`bool`, default: `...` ) â€“ Whether to warn about unknown parameters.

- ### **`warn_missing_types`**

  (`bool`, default: `...` ) â€“ Whether to warn about missing types/annotations for parameters, return values, etc.

- ### **`warnings`**

  (`bool`, default: `...` ) â€“ Whether to issue warnings for parsing issues.

## SphinxOptions

```
SphinxOptions(
    *, warn_unknown_params: bool = ..., warnings: bool = ...
)
```

Bases: `TypedDict`

```
              flowchart TD
              griffe.SphinxOptions[SphinxOptions]

              

              click griffe.SphinxOptions href "" "griffe.SphinxOptions"
```

Options for parsing Sphinx-style docstrings.

Parameters:

- ### **`warn_unknown_params`**

  (`bool`, default: `...` ) â€“ Whether to warn about unknown parameters.

- ### **`warnings`**

  (`bool`, default: `...` ) â€“ Whether to issue warnings for parsing issues.

## AutoOptions

```
AutoOptions(
    *,
    method: DocstringDetectionMethod = ...,
    style_order: list[Parser]
    | list[DocstringStyle]
    | None = ...,
    default: Parser | DocstringStyle | None = ...,
    per_style_options: PerStyleOptions | None = ...,
)
```

Bases: `TypedDict`

```
              flowchart TD
              griffe.AutoOptions[AutoOptions]

              

              click griffe.AutoOptions href "" "griffe.AutoOptions"
```

Options for Auto-style docstrings.

Parameters:

- ### **`method`**

  (`DocstringDetectionMethod`, default: `...` ) â€“ The method to use to infer the parser.

- ### **`style_order`**

  (`list[Parser] | list[DocstringStyle] | None`, default: `...` ) â€“ The order of styles to try when inferring the parser.

- ### **`default`**

  (`Parser | DocstringStyle | None`, default: `...` ) â€“ The default parser to use if the inference fails.

- ### **`per_style_options`**

  (`PerStyleOptions | None`, default: `...` ) â€“ Additional parsing options per style.

## PerStyleOptions

```
PerStyleOptions(
    *,
    google: GoogleOptions = ...,
    numpy: NumpyOptions = ...,
    sphinx: SphinxOptions = ...,
)
```

Bases: `TypedDict`

```
              flowchart TD
              griffe.PerStyleOptions[PerStyleOptions]

              

              click griffe.PerStyleOptions href "" "griffe.PerStyleOptions"
```

Per-style options for docstring parsing.

Parameters:

- ### **`google`**

  (`GoogleOptions`, default: `...` ) â€“ Options for Google-style docstrings.

- ### **`numpy`**

  (`NumpyOptions`, default: `...` ) â€“ Options for Numpy-style docstrings.

- ### **`sphinx`**

  (`SphinxOptions`, default: `...` ) â€“ Options for Sphinx-style docstrings.

## **Advanced API**

## Parser

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.Parser[Parser]

              

              click griffe.Parser href "" "griffe.Parser"
```

Enumeration of the different docstring parsers.

Attributes:

- **`auto`** â€“ Infer docstring parser.
- **`google`** â€“ Google-style docstrings parser.
- **`numpy`** â€“ Numpydoc-style docstrings parser.
- **`sphinx`** â€“ Sphinx-style docstrings parser.

### auto

```
auto = 'auto'
```

Infer docstring parser.

### google

```
google = 'google'
```

Google-style docstrings parser.

### numpy

```
numpy = 'numpy'
```

Numpydoc-style docstrings parser.

### sphinx

```
sphinx = 'sphinx'
```

Sphinx-style docstrings parser.

## parsers

```
parsers: dict[
    Parser, Callable[[Docstring], list[DocstringSection]]
] = {
    auto: parse_auto,
    google: parse_google,
    sphinx: parse_sphinx,
    numpy: parse_numpy,
}
```

## parse_docstring_annotation

```
parse_docstring_annotation(
    annotation: str,
    docstring: Docstring,
    log_level: LogLevel = error,
) -> str | Expr
```

Parse a string into a true name or expression that can be resolved later.

Parameters:

- ### **`annotation`**

  (`str`) â€“ The annotation to parse.

- ### **`docstring`**

  (`Docstring`) â€“ The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression.

- ### **`log_level`**

  (`LogLevel`, default: `error` ) â€“ Log level to use to log a message.

Returns:

- `str | Expr` â€“ The string unchanged, or a new name or expression.

Source code in `src/griffe/_internal/docstrings/utils.py`

```
def parse_docstring_annotation(
    annotation: str,
    docstring: Docstring,
    log_level: LogLevel = LogLevel.error,
) -> str | Expr:
    """Parse a string into a true name or expression that can be resolved later.

    Parameters:
        annotation: The annotation to parse.
        docstring: The docstring in which the annotation appears.
            The docstring's parent is accessed to bind a resolver to the resulting name/expression.
        log_level: Log level to use to log a message.

    Returns:
        The string unchanged, or a new name or expression.
    """
    with suppress(
        AttributeError,  # Docstring has no parent that can be used to resolve names.
        SyntaxError,  # Annotation contains syntax errors.
    ):
        code = compile(annotation, mode="eval", filename="", flags=PyCF_ONLY_AST, optimize=2)
        if code.body:  # type: ignore[attr-defined]
            name_or_expr = safe_get_annotation(
                code.body,  # type: ignore[attr-defined]
                parent=docstring.parent,  # type: ignore[arg-type]
                log_level=log_level,
            )
            return name_or_expr or annotation
    return annotation
```

## docstring_warning

```
docstring_warning(
    docstring: Docstring,
    offset: int,
    message: str,
    log_level: LogLevel = warning,
) -> None
```

Log a warning when parsing a docstring.

This function logs a warning message by prefixing it with the filepath and line number.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring object.

- ### **`offset`**

  (`int`) â€“ The offset in the docstring lines.

- ### **`message`**

  (`str`) â€“ The message to log.

Returns:

- `None` â€“ A function used to log parsing warnings if name was passed, else none.

Source code in `src/griffe/_internal/docstrings/utils.py`

```
def docstring_warning(
    docstring: Docstring,
    offset: int,
    message: str,
    log_level: LogLevel = LogLevel.warning,
) -> None:
    """Log a warning when parsing a docstring.

    This function logs a warning message by prefixing it with the filepath and line number.

    Parameters:
        docstring: The docstring object.
        offset: The offset in the docstring lines.
        message: The message to log.

    Returns:
        A function used to log parsing warnings if `name` was passed, else none.
    """

    def warn(docstring: Docstring, offset: int, message: str, log_level: LogLevel = LogLevel.warning) -> None:
        try:
            prefix = docstring.parent.relative_filepath  # type: ignore[union-attr]
        except (AttributeError, ValueError):
            prefix = "<module>"
        except BuiltinModuleError:
            prefix = f"<module: {docstring.parent.module.name}>"  # type: ignore[union-attr]
        log = getattr(logger, log_level.value)
        log(f"{prefix}:{(docstring.lineno or 0) + offset}: {message}")

    warn(docstring, offset, message, log_level)
```

## DocstringDetectionMethod

```
DocstringDetectionMethod = Literal[
    "heuristics", "max_sections"
]
```

The supported methods to infer docstring styles.

## infer_docstring_style

```
infer_docstring_style(
    docstring: Docstring,
    *,
    method: DocstringDetectionMethod = "heuristics",
    style_order: list[Parser]
    | list[DocstringStyle]
    | None = None,
    default: Parser | DocstringStyle | None = None,
    per_style_options: PerStyleOptions | None = None,
    **options: Any,
) -> tuple[Parser | None, list[DocstringSection] | None]
```

Infer the parser to use for the docstring.

The 'heuristics' method uses regular expressions. The 'max_sections' method parses the docstring with all parsers specified in `style_order` and returns the one who parsed the most sections.

If heuristics fail, the `default` parser is returned. If multiple parsers parsed the same number of sections, `style_order` is used to decide which one to return. The `default` parser is never used with the 'max_sections' method.

Additional options are parsed to the detected parser, if any.

Parameters:

- ### **`docstring`**

  (`Docstring`) â€“ The docstring to parse.

- ### **`method`**

  (`DocstringDetectionMethod`, default: `'heuristics'` ) â€“ The method to use to infer the parser.

- ### **`style_order`**

  (`list[Parser] | list[DocstringStyle] | None`, default: `None` ) â€“ The order of the styles to try when inferring the parser.

- ### **`default`**

  (`Parser | DocstringStyle | None`, default: `None` ) â€“ The default parser to use if the inference fails.

- ### **`per_style_options`**

  (`PerStyleOptions | None`, default: `None` ) â€“ Additional parsing options per style.

- ### **`**options`**

  (`Any`, default: `{}` ) â€“ Deprecated. Use per_style_options instead.

Returns:

- `tuple[Parser | None, list[DocstringSection] | None]` â€“ The inferred parser, and optionally parsed sections (when method is 'max_sections').

Source code in `src/griffe/_internal/docstrings/auto.py`

```
def infer_docstring_style(
    docstring: Docstring,
    *,
    method: DocstringDetectionMethod = "heuristics",
    style_order: list[Parser] | list[DocstringStyle] | None = None,
    default: Parser | DocstringStyle | None = None,
    per_style_options: PerStyleOptions | None = None,
    # YORE: Bump 2: Remove line.
    **options: Any,
) -> tuple[Parser | None, list[DocstringSection] | None]:
    """Infer the parser to use for the docstring.

    The 'heuristics' method uses regular expressions. The 'max_sections' method
    parses the docstring with all parsers specified in `style_order` and returns
    the one who parsed the most sections.

    If heuristics fail, the `default` parser is returned. If multiple parsers
    parsed the same number of sections, `style_order` is used to decide which
    one to return. The `default` parser is never used with the 'max_sections' method.

    Additional options are parsed to the detected parser, if any.

    Parameters:
        docstring: The docstring to parse.
        method: The method to use to infer the parser.
        style_order: The order of the styles to try when inferring the parser.
        default: The default parser to use if the inference fails.
        per_style_options: Additional parsing options per style.
        **options: Deprecated. Use `per_style_options` instead.

    Returns:
        The inferred parser, and optionally parsed sections (when method is 'max_sections').
    """
    from griffe._internal.docstrings.parsers import parsers  # noqa: PLC0415

    # YORE: Bump 2: Replace block with `per_style_options = per_style_options or {}`.
    if options:
        if per_style_options:
            raise ValueError("Cannot use both `options` and `per_style_options`.")
        warn("`**options` is deprecated. Use `per_style_options` instead.", DeprecationWarning, stacklevel=2)
        per_style_options = {"google": options, "numpy": options, "sphinx": options}  # type: ignore[assignment]
    elif not per_style_options:
        per_style_options = {}

    style_order = [Parser(style) if isinstance(style, str) else style for style in style_order or _default_style_order]

    if method == "heuristics":
        for style in style_order:
            pattern, replacements = _patterns[style]
            patterns = [
                re.compile(pattern.format(replacement), re.IGNORECASE | re.MULTILINE) for replacement in replacements
            ]
            if any(pattern.search(docstring.value) for pattern in patterns):
                return style, None
        return default if default is None or isinstance(default, Parser) else Parser(default), None

    if method == "max_sections":
        style_sections = {}
        for style in style_order:
            style_sections[style] = parsers[style](docstring, **per_style_options.get(style, {}))  # type: ignore[arg-type,union-attr]
        style_lengths = {style: len(section) for style, section in style_sections.items()}
        max_sections = max(style_lengths.values())
        for style in style_order:
            if style_lengths[style] == max_sections:
                return style, style_sections[style]

    raise ValueError(f"Invalid method '{method}'.")
```

# Alias

```
Alias(
    name: str,
    target: str | Object | Alias,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    runtime: bool = True,
    parent: Module | Class | Alias | None = None,
    inherited: bool = False,
    wildcard_imported: bool = False,
    analysis: Literal["static", "dynamic"] | None = None,
)
```

Bases: `ObjectAliasMixin`

```
              flowchart TD
              griffe.Alias[Alias]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.mixins.ObjectAliasMixin --> griffe.Alias
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                



              click griffe.Alias href "" "griffe.Alias"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

This class represents an alias, or indirection, to an object declared in another module.

Aliases represent objects that are in the scope of a module or class, but were imported from another module.

They behave almost exactly like regular objects, to a few exceptions:

- line numbers are those of the alias, not the target
- the path is the alias path, not the canonical one
- the name can be different from the target's
- if the target can be resolved, the kind is the target's kind
- if the target cannot be resolved, the kind becomes Kind.ALIAS

Parameters:

- ## **`name`**

  (`str`) â€“ The alias name.

- ## **`target`**

  (`str | Object | Alias`) â€“ If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set.

- ## **`lineno`**

  (`int | None`, default: `None` ) â€“ The alias starting line number.

- ## **`endlineno`**

  (`int | None`, default: `None` ) â€“ The alias ending line number.

- ## **`runtime`**

  (`bool`, default: `True` ) â€“ Whether this alias is present at runtime or not.

- ## **`parent`**

  (`Module | Class | Alias | None`, default: `None` ) â€“ The alias parent.

- ## **`inherited`**

  (`bool`, default: `False` ) â€“ Whether this alias wraps an inherited member.

- ## **`wildcard_imported`**

  (`bool`, default: `False` ) â€“ Whether this alias was created using a wildcard import.

- ## **`analysis`**

  (`Literal['static', 'dynamic'] | None`, default: `None` ) â€“ The type of analysis used to load this alias. None means the alias was created manually.

Methods:

- **`__bool__`** â€“ An alias is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The length of an alias is always 1.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this alias' data as a dictionary.
- **`as_json`** â€“ Return this target's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`mro`** â€“ Return a list of classes in order corresponding to Python's MRO.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`resolve_target`** â€“ Resolve the target.
- **`set_member`** â€“ Set a member with its name or path.
- **`signature`** â€“ Construct the class/function signature.

Attributes:

- **`alias_endlineno`** (`int | None`) â€“ The ending line number of the alias.
- **`alias_lineno`** (`int | None`) â€“ The starting line number of the alias.
- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this alias.
- **`annotation`** (`str | Expr | None`) â€“ The attribute type annotation.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`bases`** (`list[Expr | str]`) â€“ The class bases.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`decorators`** (`list[Decorator]`) â€“ The class/function decorators.
- **`deleter`** (`Function | None`) â€“ The deleter linked to this function (property).
- **`deprecated`** (`str | bool | None`) â€“ Whether this alias is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The target docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the target object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path (or directory list for namespace packages) where this object was defined.
- **`final_target`** (`Object`) â€“ The final, resolved target, if possible.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Get the Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this alias' target has a non-empty docstring.
- **`has_docstrings`** (`bool`) â€“ Whether this alias' target or any of its members has a non-empty docstring.
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this alias' target.
- **`imports_future_annotations`** (`bool`) â€“ Whether this module import future annotations.
- **`inherited`** (`bool`) â€“ Whether this alias represents an inherited member.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always true for aliases.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for aliases.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this method is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this module is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this module is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this module is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this module is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this module is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`keywords`** (`dict[str, Expr | str]`) â€“ The class keywords.
- **`kind`** (`Kind`) â€“ The target's kind, or Kind.ALIAS if the target cannot be resolved.
- **`labels`** (`set[str]`) â€“ The target labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the target object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The target's members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to the alias parents.
- **`name`** (`str`) â€“ The alias name.
- **`overloads`** (`dict[str, list[Function]] | list[Function] | None`) â€“ The overloaded signatures declared in this class/module or for this function.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parameters`** (`Parameters`) â€“ The parameters of the current function or __init__ method for classes.
- **`parent`** (`Module | Class | Alias | None`) â€“ The parent of this alias.
- **`path`** (`str`) â€“ The dotted path / import path of this object.
- **`public`** (`bool | None`) â€“ Whether this alias is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`resolved`** (`bool`) â€“ Whether this alias' target is resolved.
- **`resolved_bases`** (`list[Object]`) â€“ Resolved class bases.
- **`returns`** (`str | Expr | None`) â€“ The function return type annotation.
- **`runtime`** (`bool`) â€“ Whether this alias is available at runtime.
- **`setter`** (`Function | None`) â€“ The setter linked to this function (property).
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Get the source link for this object, if available.
- **`target`** (`Object | Alias`) â€“ The resolved target (actual object), if possible.
- **`target_path`** (`str`) â€“ The path of this alias' target.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The target type parameters.
- **`value`** (`str | Expr | None`) â€“ The attribute or type alias value.
- **`wildcard`** (`str | None`) â€“ The module on which the wildcard import is performed (if any).
- **`wildcard_imported`** (`bool`) â€“ Whether this alias was created using a wildcard import.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    name: str,
    target: str | Object | Alias,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    runtime: bool = True,
    parent: Module | Class | Alias | None = None,
    inherited: bool = False,
    wildcard_imported: bool = False,
    analysis: Literal["static", "dynamic"] | None = None,
) -> None:
    """Initialize the alias.

    Parameters:
        name: The alias name.
        target: If it's a string, the target resolution is delayed until accessing the target property.
            If it's an object, or even another alias, the target is immediately set.
        lineno: The alias starting line number.
        endlineno: The alias ending line number.
        runtime: Whether this alias is present at runtime or not.
        parent: The alias parent.
        inherited: Whether this alias wraps an inherited member.
        wildcard_imported: Whether this alias was created using a wildcard import.
        analysis: The type of analysis used to load this alias.
            None means the alias was created manually.
    """
    self.name: str = name
    """The alias name."""

    self.alias_lineno: int | None = lineno
    """The starting line number of the alias."""

    self.alias_endlineno: int | None = endlineno
    """The ending line number of the alias."""

    self.runtime: bool = runtime
    """Whether this alias is available at runtime."""

    self.inherited: bool = inherited
    """Whether this alias represents an inherited member."""

    self.wildcard_imported: bool = wildcard_imported
    """Whether this alias was created using a wildcard import."""

    self.public: bool | None = None
    """Whether this alias is public."""

    self.deprecated: str | bool | None = None
    """Whether this alias is deprecated (boolean or deprecation message)."""

    self.analysis: Literal["static", "dynamic"] | None = analysis
    """The type of analysis used to load this alias.

    None means the alias was created manually.
    """

    self._parent: Module | Class | Alias | None = parent
    self._passed_through: bool = False

    self.target_path: str
    """The path of this alias' target."""

    if isinstance(target, str):
        self._target: Object | Alias | None = None
        self.target_path = target
    else:
        self._target = target
        self.target_path = target.path
        self._update_target_aliases()
```

## alias_endlineno

```
alias_endlineno: int | None = endlineno
```

The ending line number of the alias.

## alias_lineno

```
alias_lineno: int | None = lineno
```

The starting line number of the alias.

## aliases

```
aliases: dict[str, Alias]
```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this alias.

None means the alias was created manually.

## annotation

```
annotation: str | Expr | None
```

The attribute type annotation.

## attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## bases

```
bases: list[Expr | str]
```

The class bases.

See also: Class, resolved_bases, mro.

## canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## decorators

```
decorators: list[Decorator]
```

The class/function decorators.

See also: Function, Class.

## deleter

```
deleter: Function | None
```

The deleter linked to this function (property).

## deprecated

```
deprecated: str | bool | None = None
```

Whether this alias is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None
```

The target docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None
```

The ending line number of the target object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]
```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

## final_target

```
final_target: Object
```

The final, resolved target, if possible.

This will iterate through the targets until a non-alias object is found.

See also: target, resolve_target, resolved.

## functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## git_info

```
git_info: GitInfo | None
```

Get the Git information for this object, if available.

## has_docstring

```
has_docstring: bool
```

Whether this alias' target has a non-empty docstring.

See also: has_docstrings, docstring.

## has_docstrings

```
has_docstrings: bool
```

Whether this alias' target or any of its members has a non-empty docstring.

See also: has_docstring, docstring.

## imports

```
imports: dict[str, str]
```

The other objects imported by this alias' target.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

See also: is_imported.

## imports_future_annotations

```
imports_future_annotations: bool
```

Whether this module import future annotations.

## inherited

```
inherited: bool = inherited
```

Whether this alias represents an inherited member.

## inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

Each inherited member of the target will be wrapped in an alias, to preserve correct object access paths.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = True
```

Always true for aliases.

## is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module, is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False
```

Always false for aliases.

See also: ModulesCollection.

## is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

## is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module, is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool
```

Whether this object is generic.

## is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

## is_init_method

```
is_init_method: bool
```

Whether this method is an `__init__` method.

## is_init_module

```
is_init_module: bool
```

Whether this module is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool
```

Whether this module is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this module is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool
```

Whether this module is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool
```

Whether this module is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module, is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

## keywords

```
keywords: dict[str, Expr | str]
```

The class keywords.

## kind

```
kind: Kind
```

The target's kind, or `Kind.ALIAS` if the target cannot be resolved.

See also: is_kind.

## labels

```
labels: set[str]
```

The target labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None
```

The starting line number of the target object.

See also: endlineno.

## lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: source, lines_collection.

## lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias]
```

The target's members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module
```

The parent module of this object.

See also: package.

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to the alias parents.

## name

```
name: str = name
```

The alias name.

## overloads

```
overloads: dict[str, list[Function]] | list[Function] | None
```

The overloaded signatures declared in this class/module or for this function.

## package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

## parameters

```
parameters: Parameters
```

The parameters of the current function or `__init__` method for classes.

This property can fetch inherited members, and therefore is part of the consumer API: do not use when producing Griffe trees!

## parent

```
parent: Module | Class | Alias | None
```

The parent of this alias.

## path

```
path: str
```

The dotted path / import path of this object.

See also: canonical_path.

## public

```
public: bool | None = None
```

Whether this alias is public.

## relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## resolved

```
resolved: bool
```

Whether this alias' target is resolved.

## resolved_bases

```
resolved_bases: list[Object]
```

Resolved class bases.

This method is part of the consumer API: do not use when producing Griffe trees!

## returns

```
returns: str | Expr | None
```

The function return type annotation.

## runtime

```
runtime: bool = runtime
```

Whether this alias is available at runtime.

## setter

```
setter: Function | None
```

The setter linked to this function (property).

## source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

## source_link

```
source_link: str | None
```

Get the source link for this object, if available.

## target

```
target: Object | Alias
```

The resolved target (actual object), if possible.

Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target.

See also: final_target, resolve_target, resolved.

## target_path

```
target_path: str
```

The path of this alias' target.

## type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters
```

The target type parameters.

## value

```
value: str | Expr | None
```

The attribute or type alias value.

## wildcard

```
wildcard: str | None
```

The module on which the wildcard import is performed (if any).

See also: GriffeLoader.expand_wildcards.

## wildcard_imported

```
wildcard_imported: bool = wildcard_imported
```

Whether this alias was created using a wildcard import.

## __bool__

```
__bool__() -> bool
```

An alias is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An alias is always true-ish."""
    return True
```

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __len__

```
__len__() -> int
```

The length of an alias is always 1.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The length of an alias is always 1."""
    return 1
```

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

## as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this alias' data as a dictionary.

See also: as_json.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this alias' data as a dictionary.

    See also: [`as_json`][griffe.Alias.as_json].

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base: dict[str, Any] = {
        "kind": Kind.ALIAS,
        "name": self.name,
        "target_path": self.target_path,
        "runtime": self.runtime,
        "inherited": self.inherited,
    }

    if self.public is not None:
        base["public"] = self.public
    if self.deprecated is not None:
        base["deprecated"] = self.deprecated
    if self.alias_lineno:
        base["lineno"] = self.alias_lineno
    if self.alias_endlineno:
        base["endlineno"] = self.alias_endlineno
    if self.analysis:
        base["analysis"] = self.analysis

    if full:
        base.update(
            {
                "path": self.path,
                "is_public": self.is_public,
                "is_deprecated": self.is_deprecated,
                "is_private": self.is_private,
                "is_class_private": self.is_class_private,
                "is_special": self.is_special,
                "is_imported": self.is_imported,
                "is_exported": self.is_exported,
                "is_wildcard_exposed": self.is_wildcard_exposed,
            },
        )

    return base
```

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this target's data as a JSON string.

See also: as_dict.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/models.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this target's data as a JSON string.

    See also: [`as_dict`][griffe.Alias.as_dict].

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    try:
        return self.final_target.as_json(full=full, **kwargs)
    except (AliasResolutionError, CyclicAliasError):
        return super().as_json(full=full, **kwargs)
```

## del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members, get_member, set_member.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Alias.members],
    [`get_member`][griffe.Alias.get_member],
    [`set_member`][griffe.Alias.set_member].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    return self.final_target.filter_members(*predicates)
```

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

## get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

## has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Alias.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return self.final_target.has_labels(*labels)
```

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Alias.is_module],
    [`is_class`][griffe.Alias.is_class],
    [`is_function`][griffe.Alias.is_function],
    [`is_attribute`][griffe.Alias.is_attribute],
    [`is_type_alias`][griffe.Alias.is_type_alias],
    [`is_alias`][griffe.Alias.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    return self.final_target.is_kind(kind)
```

## mro

```
mro() -> list[Class]
```

Return a list of classes in order corresponding to Python's MRO.

Source code in `src/griffe/_internal/models.py`

```
def mro(self) -> list[Class]:
    """Return a list of classes in order corresponding to Python's MRO."""
    return cast("Class", self.final_target).mro()
```

## resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    return self.final_target.resolve(name)
```

## resolve_target

```
resolve_target() -> None
```

Resolve the target.

See also: target, final_target, resolved.

Raises:

- `AliasResolutionError` â€“ When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection.
- `CyclicAliasError` â€“ When the resolved target is the alias itself.

Source code in `src/griffe/_internal/models.py`

```
def resolve_target(self) -> None:
    """Resolve the target.

    See also: [`target`][griffe.Alias.target],
    [`final_target`][griffe.Alias.final_target],
    [`resolved`][griffe.Alias.resolved].

    Raises:
        AliasResolutionError: When the target cannot be resolved.
            It happens when the target does not exist,
            or could not be loaded (unhandled dynamic object?),
            or when the target is from a module that was not loaded
            and added to the collection.
        CyclicAliasError: When the resolved target is the alias itself.
    """
    # Here we try to resolve the whole alias chain recursively.
    # We detect cycles by setting a "passed through" state variable
    # on each alias as we pass through it. Passing a second time
    # through an alias will raise a CyclicAliasError.

    # If a single link of the chain cannot be resolved,
    # the whole chain stays unresolved. This prevents
    # bad surprises later, in code that checks if
    # an alias is resolved by checking only
    # the first link of the chain.
    if self._passed_through:
        raise CyclicAliasError([self.target_path])
    self._passed_through = True
    try:
        self._resolve_target()
    finally:
        self._passed_through = False
```

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## signature

```
signature(
    *, return_type: bool = False, name: str | None = None
) -> str
```

Construct the class/function signature.

Parameters:

- ### **`return_type`**

  (`bool`, default: `False` ) â€“ Whether to include the return type in the signature.

- ### **`name`**

  (`str | None`, default: `None` ) â€“ The name of the class/function to use in the signature.

Returns:

- `str` â€“ A string representation of the class/function signature.

Source code in `src/griffe/_internal/models.py`

```
def signature(self, *, return_type: bool = False, name: str | None = None) -> str:
    """Construct the class/function signature.

    Parameters:
        return_type: Whether to include the return type in the signature.
        name: The name of the class/function to use in the signature.

    Returns:
        A string representation of the class/function signature.
    """
    return cast("Union[Class, Function]", self.final_target).signature(return_type=return_type, name=name)
```

# Attribute

```
Attribute(
    *args: Any,
    value: str | Expr | None = None,
    annotation: str | Expr | None = None,
    **kwargs: Any,
)
```

Bases: `Object`

```
              flowchart TD
              griffe.Attribute[Attribute]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Attribute
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Attribute href "" "griffe.Attribute"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

The class representing a Python module/class/instance attribute.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) â€“ See griffe.Object.

- ## **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The attribute value, if any.

- ## **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The attribute annotation, if any.

- ## **`**kwargs`**

  (`Any`, default: `{}` ) â€“ See griffe.Object.

Methods:

- **`__bool__`** â€“ An object is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The number of members in this object, recursively.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this attribute's data as a dictionary.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`set_member`** â€“ Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this object.
- **`annotation`** (`str | Expr | None`) â€“ The attribute type annotation.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`deleter`** (`Function | None`) â€“ The deleter linked to this property.
- **`deprecated`** (`bool | str | None`) â€“ Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The object docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) â€“ Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this object.
- **`inherited`** (`bool`) â€“ Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always false for objects.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for objects.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this function is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this object is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this object is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`kind`** â€“ The object kind.
- **`labels`** (`set[str]`) â€“ The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to this object or its parents.
- **`name`** (`str`) â€“ The object name.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) â€“ The parent of the object (none if top module).
- **`path`** (`str`) â€“ The dotted path of this object.
- **`public`** (`bool | None`) â€“ Whether this object is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) â€“ Whether this object is available at runtime.
- **`setter`** (`Function | None`) â€“ The setter linked to this property.
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Source link for this object, if available.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The object type parameters.
- **`value`** (`str | Expr | None`) â€“ The attribute value.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    *args: Any,
    value: str | Expr | None = None,
    annotation: str | Expr | None = None,
    **kwargs: Any,
) -> None:
    """Initialize the function.

    Parameters:
        *args: See [`griffe.Object`][].
        value: The attribute value, if any.
        annotation: The attribute annotation, if any.
        **kwargs: See [`griffe.Object`][].
    """
    super().__init__(*args, **kwargs)
    self.value: str | Expr | None = value
    """The attribute value."""
    self.annotation: str | Expr | None = annotation
    """The attribute type annotation."""
    self.setter: Function | None = None
    """The setter linked to this property."""
    self.deleter: Function | None = None
    """The deleter linked to this property."""
```

## aliases

```
aliases: dict[str, Alias] = {}
```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this object.

None means the object was created manually.

## annotation

```
annotation: str | Expr | None = annotation
```

The attribute type annotation.

## attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## deleter

```
deleter: Function | None = None
```

The deleter linked to this property.

## deprecated

```
deprecated: bool | str | None = None
```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring
```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]
```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')
```

## functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## git_info

```
git_info: GitInfo | None
```

Git information for this object, if available.

## has_docstring

```
has_docstring: bool
```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool
```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}
```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## inherited

```
inherited: bool = False
```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False
```

Always false for objects.

## is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False
```

Always false for objects.

## is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

## is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool
```

Whether this object is generic.

## is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

## is_init_method

```
is_init_method: bool
```

Whether this function is an `__init__` method.

## is_init_module

```
is_init_module: bool
```

Whether this object is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool
```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool
```

Whether this object is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool
```

Whether this object is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

## kind

```
kind = ATTRIBUTE
```

The object kind.

## labels

```
labels: set[str] = set()
```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno
```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}
```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module
```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
```

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## name

```
name: str = name
```

The object name.

## package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))
```

## parent

```
parent: Module | Class | None = parent
```

The parent of the object (none if top module).

## path

```
path: str
```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'
```

## public

```
public: bool | None = None
```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## runtime

```
runtime: bool = runtime
```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## setter

```
setter: Function | None = None
```

The setter linked to this property.

## source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

## source_link

```
source_link: str | None
```

Source link for this object, if available.

## type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)
```

The object type parameters.

## value

```
value: str | Expr | None = value
```

The attribute value.

## __bool__

```
__bool__() -> bool
```

An object is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An object is always true-ish."""
    return True
```

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __len__

```
__len__() -> int
```

The number of members in this object, recursively.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The number of members in this object, recursively."""
    return len(self.members) + sum(len(member) for member in self.members.values())
```

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this attribute's data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this attribute's data as a dictionary.

    See also: [`as_json`][griffe.Attribute.as_json].

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = super().as_dict(**kwargs)
    if self.value is not None:
        base["value"] = self.value
    if self.annotation is not None:
        base["annotation"] = self.annotation
    return base
```

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

## del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Object.members].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    if not predicates:
        return self.members
    members: dict[str, Object | Alias] = {
        name: member for name, member in self.members.items() if all(predicate(member) for predicate in predicates)
    }
    return members
```

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

## get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

## has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Object.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return set(labels).issubset(self.labels)
```

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Object.is_module],
    [`is_class`][griffe.Object.is_class],
    [`is_function`][griffe.Object.is_function],
    [`is_attribute`][griffe.Object.is_attribute],
    [`is_type_alias`][griffe.Object.is_type_alias],
    [`is_alias`][griffe.Object.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    if isinstance(kind, set):
        if not kind:
            raise ValueError("kind must not be an empty set")
        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)
    if isinstance(kind, str):
        kind = Kind(kind)
    return self.kind is kind
```

## resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    # TODO: Better match Python's own scoping rules?
    # Also, maybe return regular paths instead of canonical ones?

    # Name is a type parameter.
    if name in self.type_parameters:
        type_parameter = self.type_parameters[name]
        if type_parameter.kind is TypeParameterKind.type_var_tuple:
            prefix = "*"
        elif type_parameter.kind is TypeParameterKind.param_spec:
            prefix = "**"
        else:
            prefix = ""
        return f"{self.path}[{prefix}{name}]"

    # Name is a member of this object.
    if name in self.members:
        if self.members[name].is_alias:
            return self.members[name].target_path  # type: ignore[union-attr]
        return self.members[name].path

    # Name unknown and no more parent scope, could be a built-in.
    if self.parent is None:
        raise NameResolutionError(f"{name} could not be resolved in the scope of {self.path}")

    # Name is parent, non-module object.
    if name == self.parent.name and not self.parent.is_module:
        return self.parent.path

    # Recurse in parent.
    return self.parent.resolve(name)
```

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

# Class

```
Class(
    *args: Any,
    bases: Sequence[Expr | str] | None = None,
    decorators: list[Decorator] | None = None,
    keywords: dict[str, Any] | None = None,
    **kwargs: Any,
)
```

Bases: `Object`

```
              flowchart TD
              griffe.Class[Class]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Class
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Class href "" "griffe.Class"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

The class representing a Python class.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) â€“ See griffe.Object.

- ## **`bases`**

  (`Sequence[Expr | str] | None`, default: `None` ) â€“ The list of base classes, if any.

- ## **`decorators`**

  (`list[Decorator] | None`, default: `None` ) â€“ The class decorators, if any.

- ## **`keywords`**

  (`dict[str, Any] | None`, default: `None` ) â€“ The class keywords arguments, if any.

- ## **`**kwargs`**

  (`Any`, default: `{}` ) â€“ See griffe.Object.

Methods:

- **`__bool__`** â€“ An object is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The number of members in this object, recursively.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this class' data as a dictionary.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`mro`** â€“ Return a list of classes in order corresponding to Python's MRO.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`set_member`** â€“ Set a member with its name or path.
- **`signature`** â€“ Construct the class signature.

Attributes:

- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this object.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`bases`** (`list[Expr | str]`) â€“ The class bases.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`decorators`** (`list[Decorator]`) â€“ The class decorators.
- **`deprecated`** (`bool | str | None`) â€“ Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The object docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) â€“ Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this object.
- **`inherited`** (`bool`) â€“ Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always false for objects.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for objects.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this function is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this object is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this object is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`keywords`** (`dict[str, Any]`) â€“ The class keywords arguments.
- **`kind`** â€“ The object kind.
- **`labels`** (`set[str]`) â€“ The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to this object or its parents.
- **`name`** (`str`) â€“ The object name.
- **`overloads`** (`dict[str, list[Function]]`) â€“ The overloaded signatures declared in this class.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parameters`** (`Parameters`) â€“ The parameters of this class' __init__ method, if any.
- **`parent`** (`Module | Class | None`) â€“ The parent of the object (none if top module).
- **`path`** (`str`) â€“ The dotted path of this object.
- **`public`** (`bool | None`) â€“ Whether this object is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`resolved_bases`** (`list[Object]`) â€“ Resolved class bases.
- **`runtime`** (`bool`) â€“ Whether this object is available at runtime.
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Source link for this object, if available.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The object type parameters.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    *args: Any,
    bases: Sequence[Expr | str] | None = None,
    decorators: list[Decorator] | None = None,
    keywords: dict[str, Any] | None = None,
    **kwargs: Any,
) -> None:
    """Initialize the class.

    Parameters:
        *args: See [`griffe.Object`][].
        bases: The list of base classes, if any.
        decorators: The class decorators, if any.
        keywords: The class keywords arguments, if any.
        **kwargs: See [`griffe.Object`][].
    """
    super().__init__(*args, **kwargs)

    self.bases: list[Expr | str] = list(bases) if bases else []
    """The class bases.

    See also: [`resolved_bases`][griffe.Class.resolved_bases],
    [`mro`][griffe.Class.mro].
    """

    self.decorators: list[Decorator] = decorators or []
    """The class decorators."""

    self.keywords: dict[str, Any] = keywords or {}
    """The class keywords arguments."""

    self.overloads: dict[str, list[Function]] = defaultdict(list)
    """The overloaded signatures declared in this class."""
```

## aliases

```
aliases: dict[str, Alias] = {}
```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this object.

None means the object was created manually.

## attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## bases

```
bases: list[Expr | str] = list(bases) if bases else []
```

The class bases.

See also: resolved_bases, mro.

## canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## decorators

```
decorators: list[Decorator] = decorators or []
```

The class decorators.

## deprecated

```
deprecated: bool | str | None = None
```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring
```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]
```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')
```

## functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## git_info

```
git_info: GitInfo | None
```

Git information for this object, if available.

## has_docstring

```
has_docstring: bool
```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool
```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}
```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## inherited

```
inherited: bool = False
```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False
```

Always false for objects.

## is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False
```

Always false for objects.

## is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

## is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool
```

Whether this object is generic.

## is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

## is_init_method

```
is_init_method: bool
```

Whether this function is an `__init__` method.

## is_init_module

```
is_init_module: bool
```

Whether this object is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool
```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool
```

Whether this object is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool
```

Whether this object is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

## keywords

```
keywords: dict[str, Any] = keywords or {}
```

The class keywords arguments.

## kind

```
kind = CLASS
```

The object kind.

## labels

```
labels: set[str] = set()
```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno
```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}
```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module
```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
```

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## name

```
name: str = name
```

The object name.

## overloads

```
overloads: dict[str, list[Function]] = defaultdict(list)
```

The overloaded signatures declared in this class.

## package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))
```

## parameters

```
parameters: Parameters
```

The parameters of this class' `__init__` method, if any.

This property fetches inherited members, and therefore is part of the consumer API: do not use when producing Griffe trees!

## parent

```
parent: Module | Class | None = parent
```

The parent of the object (none if top module).

## path

```
path: str
```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'
```

## public

```
public: bool | None = None
```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## resolved_bases

```
resolved_bases: list[Object]
```

Resolved class bases.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: bases, mro.

## runtime

```
runtime: bool = runtime
```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

## source_link

```
source_link: str | None
```

Source link for this object, if available.

## type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)
```

The object type parameters.

## __bool__

```
__bool__() -> bool
```

An object is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An object is always true-ish."""
    return True
```

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __len__

```
__len__() -> int
```

The number of members in this object, recursively.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The number of members in this object, recursively."""
    return len(self.members) + sum(len(member) for member in self.members.values())
```

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this class' data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this class' data as a dictionary.

    See also: [`as_json`][griffe.Class.as_json].

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = super().as_dict(**kwargs)
    base["bases"] = self.bases
    base["decorators"] = [dec.as_dict(**kwargs) for dec in self.decorators]
    return base
```

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

## del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Object.members].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    if not predicates:
        return self.members
    members: dict[str, Object | Alias] = {
        name: member for name, member in self.members.items() if all(predicate(member) for predicate in predicates)
    }
    return members
```

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

## get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

## has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Object.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return set(labels).issubset(self.labels)
```

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Object.is_module],
    [`is_class`][griffe.Object.is_class],
    [`is_function`][griffe.Object.is_function],
    [`is_attribute`][griffe.Object.is_attribute],
    [`is_type_alias`][griffe.Object.is_type_alias],
    [`is_alias`][griffe.Object.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    if isinstance(kind, set):
        if not kind:
            raise ValueError("kind must not be an empty set")
        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)
    if isinstance(kind, str):
        kind = Kind(kind)
    return self.kind is kind
```

## mro

```
mro() -> list[Class]
```

Return a list of classes in order corresponding to Python's MRO.

See also: bases, resolved_bases.

Source code in `src/griffe/_internal/models.py`

```
def mro(self) -> list[Class]:
    """Return a list of classes in order corresponding to Python's MRO.

    See also: [`bases`][griffe.Class.bases],
    [`resolved_bases`][griffe.Class.resolved_bases].
    """
    return self._mro()[1:]  # Remove self.
```

## resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    # TODO: Better match Python's own scoping rules?
    # Also, maybe return regular paths instead of canonical ones?

    # Name is a type parameter.
    if name in self.type_parameters:
        type_parameter = self.type_parameters[name]
        if type_parameter.kind is TypeParameterKind.type_var_tuple:
            prefix = "*"
        elif type_parameter.kind is TypeParameterKind.param_spec:
            prefix = "**"
        else:
            prefix = ""
        return f"{self.path}[{prefix}{name}]"

    # Name is a member of this object.
    if name in self.members:
        if self.members[name].is_alias:
            return self.members[name].target_path  # type: ignore[union-attr]
        return self.members[name].path

    # Name unknown and no more parent scope, could be a built-in.
    if self.parent is None:
        raise NameResolutionError(f"{name} could not be resolved in the scope of {self.path}")

    # Name is parent, non-module object.
    if name == self.parent.name and not self.parent.is_module:
        return self.parent.path

    # Recurse in parent.
    return self.parent.resolve(name)
```

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## signature

```
signature(
    *, return_type: bool = False, name: str | None = None
) -> str
```

Construct the class signature.

Parameters:

- ### **`return_type`**

  (`bool`, default: `False` ) â€“ Whether to include the return type in the signature.

- ### **`name`**

  (`str | None`, default: `None` ) â€“ The name of the class to use in the signature.

Returns:

- `str` â€“ A string representation of the class signature.

Source code in `src/griffe/_internal/models.py`

```
def signature(self, *, return_type: bool = False, name: str | None = None) -> str:
    """Construct the class signature.

    Parameters:
        return_type: Whether to include the return type in the signature.
        name: The name of the class to use in the signature.

    Returns:
        A string representation of the class signature.
    """
    all_members = self.all_members
    if "__init__" in all_members:
        init = all_members["__init__"]
        if isinstance(init, Function):
            return init.signature(return_type=return_type, name=name or self.name)
    return ""
```

## **Utilities**

## c3linear_merge

```
c3linear_merge(*lists: list[_T]) -> list[_T]
```

Merge lists of lists in the order defined by the C3Linear algorithm.

Parameters:

- ### **`*lists`**

  (`list[_T]`, default: `()` ) â€“ Lists of items.

Returns:

- `list[_T]` â€“ The merged list of items.

Source code in `src/griffe/_internal/c3linear.py`

```
def c3linear_merge(*lists: list[_T]) -> list[_T]:
    """Merge lists of lists in the order defined by the C3Linear algorithm.

    Parameters:
        *lists: Lists of items.

    Returns:
        The merged list of items.
    """
    result: list[_T] = []
    linearizations = _DependencyList(*lists)  # type: ignore[arg-type]

    while True:
        if linearizations.exhausted:
            return result

        for head in linearizations.heads:
            if head and (head not in linearizations.tails):
                result.append(head)  # type: ignore[arg-type]
                linearizations.remove(head)

                # Once candidate is found, continue iteration
                # from the first element of the list.
                break
        else:
            # Loop never broke, no linearization could possibly be found.
            raise ValueError("Cannot compute C3 linearization")
```

# Function

```
Function(
    *args: Any,
    parameters: Parameters | None = None,
    returns: str | Expr | None = None,
    decorators: list[Decorator] | None = None,
    **kwargs: Any,
)
```

Bases: `Object`

```
              flowchart TD
              griffe.Function[Function]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Function
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Function href "" "griffe.Function"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

The class representing a Python function.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) â€“ See griffe.Object.

- ## **`parameters`**

  (`Parameters | None`, default: `None` ) â€“ The function parameters.

- ## **`returns`**

  (`str | Expr | None`, default: `None` ) â€“ The function return annotation.

- ## **`decorators`**

  (`list[Decorator] | None`, default: `None` ) â€“ The function decorators, if any.

- ## **`**kwargs`**

  (`Any`, default: `{}` ) â€“ See griffe.Object.

Methods:

- **`__bool__`** â€“ An object is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The number of members in this object, recursively.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this function's data as a dictionary.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`set_member`** â€“ Set a member with its name or path.
- **`signature`** â€“ Construct the function signature.

Attributes:

- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this object.
- **`annotation`** (`str | Expr | None`) â€“ The type annotation of the returned value.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`decorators`** (`list[Decorator]`) â€“ The function decorators.
- **`deprecated`** (`bool | str | None`) â€“ Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The object docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) â€“ Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this object.
- **`inherited`** (`bool`) â€“ Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always false for objects.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for objects.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this function is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this object is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this object is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`kind`** â€“ The object kind.
- **`labels`** (`set[str]`) â€“ The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to this object or its parents.
- **`name`** (`str`) â€“ The object name.
- **`overloads`** (`list[Function] | None`) â€“ The overloaded signatures of this function.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parameters`** (`Parameters`) â€“ The function parameters.
- **`parent`** (`Module | Class | None`) â€“ The parent of the object (none if top module).
- **`path`** (`str`) â€“ The dotted path of this object.
- **`public`** (`bool | None`) â€“ Whether this object is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`returns`** (`str | Expr | None`) â€“ The function return type annotation.
- **`runtime`** (`bool`) â€“ Whether this object is available at runtime.
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Source link for this object, if available.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The object type parameters.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    *args: Any,
    parameters: Parameters | None = None,
    returns: str | Expr | None = None,
    decorators: list[Decorator] | None = None,
    **kwargs: Any,
) -> None:
    """Initialize the function.

    Parameters:
        *args: See [`griffe.Object`][].
        parameters: The function parameters.
        returns: The function return annotation.
        decorators: The function decorators, if any.
        **kwargs: See [`griffe.Object`][].
    """
    super().__init__(*args, **kwargs)
    self.parameters: Parameters = parameters or Parameters()
    """The function parameters."""
    self.returns: str | Expr | None = returns
    """The function return type annotation."""
    self.decorators: list[Decorator] = decorators or []
    """The function decorators."""
    self.overloads: list[Function] | None = None
    """The overloaded signatures of this function."""

    for parameter in self.parameters:
        parameter.function = self
```

## aliases

```
aliases: dict[str, Alias] = {}
```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this object.

None means the object was created manually.

## annotation

```
annotation: str | Expr | None
```

The type annotation of the returned value.

## attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## decorators

```
decorators: list[Decorator] = decorators or []
```

The function decorators.

## deprecated

```
deprecated: bool | str | None = None
```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring
```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]
```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')
```

## functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## git_info

```
git_info: GitInfo | None
```

Git information for this object, if available.

## has_docstring

```
has_docstring: bool
```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool
```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}
```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## inherited

```
inherited: bool = False
```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False
```

Always false for objects.

## is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False
```

Always false for objects.

## is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

## is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool
```

Whether this object is generic.

## is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

## is_init_method

```
is_init_method: bool
```

Whether this function is an `__init__` method.

## is_init_module

```
is_init_module: bool
```

Whether this object is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool
```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool
```

Whether this object is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool
```

Whether this object is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

## kind

```
kind = FUNCTION
```

The object kind.

## labels

```
labels: set[str] = set()
```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno
```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}
```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module
```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
```

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## name

```
name: str = name
```

The object name.

## overloads

```
overloads: list[Function] | None = None
```

The overloaded signatures of this function.

## package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))
```

## parameters

```
parameters: Parameters = parameters or Parameters()
```

The function parameters.

## parent

```
parent: Module | Class | None = parent
```

The parent of the object (none if top module).

## path

```
path: str
```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'
```

## public

```
public: bool | None = None
```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## returns

```
returns: str | Expr | None = returns
```

The function return type annotation.

## runtime

```
runtime: bool = runtime
```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

## source_link

```
source_link: str | None
```

Source link for this object, if available.

## type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)
```

The object type parameters.

## __bool__

```
__bool__() -> bool
```

An object is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An object is always true-ish."""
    return True
```

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __len__

```
__len__() -> int
```

The number of members in this object, recursively.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The number of members in this object, recursively."""
    return len(self.members) + sum(len(member) for member in self.members.values())
```

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this function's data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this function's data as a dictionary.

    See also: [`as_json`][griffe.Function.as_json].

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = super().as_dict(**kwargs)
    base["decorators"] = [dec.as_dict(**kwargs) for dec in self.decorators]
    base["parameters"] = [param.as_dict(**kwargs) for param in self.parameters]
    base["returns"] = self.returns
    return base
```

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

## del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Object.members].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    if not predicates:
        return self.members
    members: dict[str, Object | Alias] = {
        name: member for name, member in self.members.items() if all(predicate(member) for predicate in predicates)
    }
    return members
```

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

## get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

## has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Object.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return set(labels).issubset(self.labels)
```

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Object.is_module],
    [`is_class`][griffe.Object.is_class],
    [`is_function`][griffe.Object.is_function],
    [`is_attribute`][griffe.Object.is_attribute],
    [`is_type_alias`][griffe.Object.is_type_alias],
    [`is_alias`][griffe.Object.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    if isinstance(kind, set):
        if not kind:
            raise ValueError("kind must not be an empty set")
        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)
    if isinstance(kind, str):
        kind = Kind(kind)
    return self.kind is kind
```

## resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    # We're in an `__init__` method...
    if self.parent and self.name == "__init__":
        # ...and name is a parameter name: resolve to the parameter.
        if name in self.parameters:
            return f"{self.parent.path}({name})"

        # Kind of a special case: we avoid resolving to instance-attributes from a function scope.
        # See issue https://github.com/mkdocstrings/griffe/issues/367.
        resolved = super().resolve(name)
        try:
            obj = self.modules_collection.get_member(resolved)
        except KeyError:
            return resolved
        try:
            if obj.is_attribute and "instance-attribute" in obj.labels:
                raise NameResolutionError(name)
        except AliasResolutionError:
            pass
        return resolved
    return super().resolve(name)
```

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

## signature

```
signature(
    *, return_type: bool = True, name: str | None = None
) -> str
```

Construct the function signature.

Parameters:

- ### **`return_type`**

  (`bool`, default: `True` ) â€“ Whether to include the return type in the signature.

- ### **`name`**

  (`str | None`, default: `None` ) â€“ The name of the function to use in the signature.

Returns:

- `str` â€“ A string representation of the function signature.

Source code in `src/griffe/_internal/models.py`

```
def signature(self, *, return_type: bool = True, name: str | None = None) -> str:
    """Construct the function signature.

    Parameters:
        return_type: Whether to include the return type in the signature.
        name: The name of the function to use in the signature.

    Returns:
        A string representation of the function signature.
    """
    signature = f"{name or self.name}("

    has_pos_only = any(p.kind == ParameterKind.positional_only for p in self.parameters)
    render_pos_only_separator = True
    render_kw_only_separator = True

    param_strs = []

    for index, param in enumerate(self.parameters):
        # Skip 'self' or 'cls' for class methods if it's the first parameter.
        if index == 0 and param.name in ("self", "cls") and self.parent and self.parent.is_class:
            continue

        param_str = ""

        # Handle parameter kind and separators.
        if param.kind != ParameterKind.positional_only:
            if has_pos_only and render_pos_only_separator:
                render_pos_only_separator = False
                param_strs.append("/")

            if param.kind == ParameterKind.keyword_only and render_kw_only_separator:
                render_kw_only_separator = False
                param_strs.append("*")

        # Handle variadic parameters.
        if param.kind == ParameterKind.var_positional:
            param_str = "*"
            render_kw_only_separator = False
        elif param.kind == ParameterKind.var_keyword:
            param_str = "**"

        # Add parameter name.
        param_str += param.name

        # Handle type annotation
        if param.annotation is not None:
            param_str += f": {param.annotation}"
            equal = " = "  # Space around equal when annotation is present.
        else:
            equal = "="  # No space when no annotation.

        # Handle default value.
        if param.default is not None and param.kind not in {
            ParameterKind.var_positional,
            ParameterKind.var_keyword,
        }:
            param_str += f"{equal}{param.default}"

        param_strs.append(param_str)

    # If we have positional-only parameters but no '/' was added yet
    if has_pos_only and render_pos_only_separator:
        param_strs.append("/")

    signature += ", ".join(param_strs)
    signature += ")"

    # Add return type if present.
    if return_type and self.annotation:
        signature += f" -> {self.annotation}"

    return signature
```

## Parameters

```
Parameters(*parameters: Parameter)
```

This class is a container for parameters.

It allows to get parameters using their position (index) or their name:

```
>>> parameters = Parameters(Parameter("hello"))
>>> parameters[0] is parameters["hello"]
True
```

See also: Parameter.

Parameters:

- ### **`*parameters`**

  (`Parameter`, default: `()` ) â€“ The initial parameters to add to the container.

Methods:

- **`__contains__`** â€“ Whether a parameter with the given name is present.
- **`__delitem__`** â€“ Delete a parameter by index or name.
- **`__getitem__`** â€“ Get a parameter by index or name.
- **`__iter__`** â€“ Iterate over the parameters, in order.
- **`__len__`** â€“ The number of parameters.
- **`__setitem__`** â€“ Set a parameter by index or name.
- **`add`** â€“ Add a parameter to the container.

Source code in `src/griffe/_internal/models.py`

```
def __init__(self, *parameters: Parameter) -> None:
    """Initialize the parameters container.

    Parameters:
        *parameters: The initial parameters to add to the container.
    """
    self._params: list[Parameter] = list(parameters)
```

### __contains__

```
__contains__(param_name: str)
```

Whether a parameter with the given name is present.

Source code in `src/griffe/_internal/models.py`

```
def __contains__(self, param_name: str):
    """Whether a parameter with the given name is present."""
    try:
        next(param for param in self._params if param.name == param_name.lstrip("*"))
    except StopIteration:
        return False
    return True
```

### __delitem__

```
__delitem__(name_or_index: int | str) -> None
```

Delete a parameter by index or name.

Source code in `src/griffe/_internal/models.py`

```
def __delitem__(self, name_or_index: int | str) -> None:
    """Delete a parameter by index or name."""
    if isinstance(name_or_index, int):
        del self._params[name_or_index]
    else:
        name = name_or_index.lstrip("*")
        try:
            index = next(idx for idx, param in enumerate(self._params) if param.name == name)
        except StopIteration as error:
            raise KeyError(f"parameter {name_or_index} not found") from error
        del self._params[index]
```

### __getitem__

```
__getitem__(name_or_index: int | str) -> Parameter
```

Get a parameter by index or name.

Source code in `src/griffe/_internal/models.py`

```
def __getitem__(self, name_or_index: int | str) -> Parameter:
    """Get a parameter by index or name."""
    if isinstance(name_or_index, int):
        return self._params[name_or_index]
    name = name_or_index.lstrip("*")
    try:
        return next(param for param in self._params if param.name == name)
    except StopIteration as error:
        raise KeyError(f"parameter {name_or_index} not found") from error
```

### __iter__

```
__iter__()
```

Iterate over the parameters, in order.

Source code in `src/griffe/_internal/models.py`

```
def __iter__(self):
    """Iterate over the parameters, in order."""
    return iter(self._params)
```

### __len__

```
__len__()
```

The number of parameters.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self):
    """The number of parameters."""
    return len(self._params)
```

### __setitem__

```
__setitem__(
    name_or_index: int | str, parameter: Parameter
) -> None
```

Set a parameter by index or name.

Source code in `src/griffe/_internal/models.py`

```
def __setitem__(self, name_or_index: int | str, parameter: Parameter) -> None:
    """Set a parameter by index or name."""
    if isinstance(name_or_index, int):
        self._params[name_or_index] = parameter
    else:
        name = name_or_index.lstrip("*")
        try:
            index = next(idx for idx, param in enumerate(self._params) if param.name == name)
        except StopIteration:
            self._params.append(parameter)
        else:
            self._params[index] = parameter
```

### add

```
add(parameter: Parameter) -> None
```

Add a parameter to the container.

Parameters:

- #### **`parameter`**

  (`Parameter`) â€“ The function parameter to add.

Raises:

- `ValueError` â€“ When a parameter with the same name is already present.

Source code in `src/griffe/_internal/models.py`

```
def add(self, parameter: Parameter) -> None:
    """Add a parameter to the container.

    Parameters:
        parameter: The function parameter to add.

    Raises:
        ValueError: When a parameter with the same name is already present.
    """
    if parameter.name in self:
        raise ValueError(f"parameter {parameter.name} already present")
    self._params.append(parameter)
```

## Parameter

```
Parameter(
    name: str,
    *,
    annotation: str | Expr | None = None,
    kind: ParameterKind | None = None,
    default: str | Expr | None = None,
    docstring: Docstring | None = None,
)
```

This class represent a function parameter.

See also: Parameters.

Parameters:

- ### **`name`**

  (`str`) â€“ The parameter name, without leading stars (\* or \*\*).

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) â€“ The parameter annotation, if any.

- ### **`kind`**

  (`ParameterKind | None`, default: `None` ) â€“ The parameter kind.

- ### **`default`**

  (`str | Expr | None`, default: `None` ) â€“ The parameter default, if any.

- ### **`docstring`**

  (`Docstring | None`, default: `None` ) â€“ The parameter docstring.

Methods:

- **`__eq__`** â€“ Parameters are equal if all their attributes except docstring and function are equal.
- **`as_dict`** â€“ Return this parameter's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) â€“ The parameter type annotation.
- **`default`** (`str | Expr | None`) â€“ The parameter default value.
- **`docstring`** (`Docstring | None`) â€“ The parameter docstring.
- **`function`** (`Function | None`) â€“ The parent function of the parameter.
- **`kind`** (`ParameterKind | None`) â€“ The parameter kind.
- **`name`** (`str`) â€“ The parameter name.
- **`required`** (`bool`) â€“ Whether this parameter is required.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    name: str,
    *,
    annotation: str | Expr | None = None,
    kind: ParameterKind | None = None,
    default: str | Expr | None = None,
    docstring: Docstring | None = None,
) -> None:
    """Initialize the parameter.

    Parameters:
        name: The parameter name, without leading stars (`*` or `**`).
        annotation: The parameter annotation, if any.
        kind: The parameter kind.
        default: The parameter default, if any.
        docstring: The parameter docstring.
    """
    self.name: str = name
    """The parameter name."""
    self.annotation: str | Expr | None = annotation
    """The parameter type annotation."""
    self.kind: ParameterKind | None = kind
    """The parameter kind."""
    self.default: str | Expr | None = default
    """The parameter default value."""
    self.docstring: Docstring | None = docstring
    """The parameter docstring."""
    # The parent function is set in `Function.__init__`,
    # when the parameters are assigned to the function.
    self.function: Function | None = None
    """The parent function of the parameter."""
```

### annotation

```
annotation: str | Expr | None = annotation
```

The parameter type annotation.

### default

```
default: str | Expr | None = default
```

The parameter default value.

### docstring

```
docstring: Docstring | None = docstring
```

The parameter docstring.

### function

```
function: Function | None = None
```

The parent function of the parameter.

### kind

```
kind: ParameterKind | None = kind
```

The parameter kind.

### name

```
name: str = name
```

The parameter name.

### required

```
required: bool
```

Whether this parameter is required.

### __eq__

```
__eq__(value: object) -> bool
```

Parameters are equal if all their attributes except `docstring` and `function` are equal.

Source code in `src/griffe/_internal/models.py`

```
def __eq__(self, value: object, /) -> bool:
    """Parameters are equal if all their attributes except `docstring` and `function` are equal."""
    if not isinstance(value, Parameter):
        return NotImplemented
    return (
        self.name == value.name
        and self.annotation == value.annotation
        and self.kind == value.kind
        and self.default == value.default
    )
```

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]
```

Return this parameter's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, *, full: bool = False, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this parameter's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base: dict[str, Any] = {
        "name": self.name,
        "annotation": self.annotation,
        "kind": self.kind,
        "default": self.default,
    }
    if self.docstring:
        base["docstring"] = self.docstring.as_dict(full=full)
    return base
```

## ParameterKind

Bases: `str`, `Enum`

```
              flowchart TD
              griffe.ParameterKind[ParameterKind]

              

              click griffe.ParameterKind href "" "griffe.ParameterKind"
```

Enumeration of the different parameter kinds.

Attributes:

- **`keyword_only`** â€“ Keyword-only parameter.
- **`positional_only`** â€“ Positional-only parameter.
- **`positional_or_keyword`** â€“ Positional or keyword parameter.
- **`var_keyword`** â€“ Variadic keyword parameter.
- **`var_positional`** â€“ Variadic positional parameter.

### keyword_only

```
keyword_only = 'keyword-only'
```

Keyword-only parameter.

### positional_only

```
positional_only = 'positional-only'
```

Positional-only parameter.

### positional_or_keyword

```
positional_or_keyword = 'positional or keyword'
```

Positional or keyword parameter.

### var_keyword

```
var_keyword = 'variadic keyword'
```

Variadic keyword parameter.

### var_positional

```
var_positional = 'variadic positional'
```

Variadic positional parameter.

## ParametersType

```
ParametersType = list[
    tuple[
        str,
        Optional[AST],
        ParameterKind,
        Optional[Union[str, AST]],
    ]
]
```

Type alias for the list of parameters of a function.

## Decorator

```
Decorator(
    value: str | Expr,
    *,
    lineno: int | None,
    endlineno: int | None,
)
```

This class represents decorators.

Parameters:

- ### **`value`**

  (`str | Expr`) â€“ The decorator code.

- ### **`lineno`**

  (`int | None`) â€“ The starting line number.

- ### **`endlineno`**

  (`int | None`) â€“ The ending line number.

Methods:

- **`as_dict`** â€“ Return this decorator's data as a dictionary.

Attributes:

- **`callable_path`** (`str`) â€“ The path of the callable used as decorator.
- **`endlineno`** (`int | None`) â€“ The ending line number of the decorator.
- **`lineno`** (`int | None`) â€“ The starting line number of the decorator.
- **`value`** (`str | Expr`) â€“ The decorator value (as a Griffe expression or string).

Source code in `src/griffe/_internal/models.py`

```
def __init__(self, value: str | Expr, *, lineno: int | None, endlineno: int | None) -> None:
    """Initialize the decorator.

    Parameters:
        value: The decorator code.
        lineno: The starting line number.
        endlineno: The ending line number.
    """
    self.value: str | Expr = value
    """The decorator value (as a Griffe expression or string)."""
    self.lineno: int | None = lineno
    """The starting line number of the decorator."""
    self.endlineno: int | None = endlineno
    """The ending line number of the decorator."""
```

### callable_path

```
callable_path: str
```

The path of the callable used as decorator.

### endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the decorator.

### lineno

```
lineno: int | None = lineno
```

The starting line number of the decorator.

### value

```
value: str | Expr = value
```

The decorator value (as a Griffe expression or string).

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this decorator's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:  # noqa: ARG002
    """Return this decorator's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    return {
        "value": self.value,
        "lineno": self.lineno,
        "endlineno": self.endlineno,
    }
```

# Module

```
Module(
    *args: Any,
    filepath: Path | list[Path] | None = None,
    **kwargs: Any,
)
```

Bases: `Object`

```
              flowchart TD
              griffe.Module[Module]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Module
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Module href "" "griffe.Module"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

The class representing a Python module.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) â€“ See griffe.Object.

- ## **`filepath`**

  (`Path | list[Path] | None`, default: `None` ) â€“ The module file path (directory for namespace [sub]packages, none for builtin modules).

- ## **`**kwargs`**

  (`Any`, default: `{}` ) â€“ See griffe.Object.

Methods:

- **`__bool__`** â€“ An object is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The number of members in this object, recursively.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this module's data as a dictionary.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`set_member`** â€“ Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this object.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`deprecated`** (`bool | str | None`) â€“ Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The object docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path of this module.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) â€“ Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this object.
- **`imports_future_annotations`** (`bool`) â€“ Whether this module import future annotations.
- **`inherited`** (`bool`) â€“ Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always false for objects.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for objects.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this function is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this module is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this module is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this module is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this module is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this module is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`kind`** â€“ The object kind.
- **`labels`** (`set[str]`) â€“ The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to this object or its parents.
- **`name`** (`str`) â€“ The object name.
- **`overloads`** (`dict[str, list[Function]]`) â€“ The overloaded signatures declared in this module.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) â€“ The parent of the object (none if top module).
- **`path`** (`str`) â€“ The dotted path of this object.
- **`public`** (`bool | None`) â€“ Whether this object is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) â€“ Whether this object is available at runtime.
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Source link for this object, if available.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The object type parameters.

Source code in `src/griffe/_internal/models.py`

```
def __init__(self, *args: Any, filepath: Path | list[Path] | None = None, **kwargs: Any) -> None:
    """Initialize the module.

    Parameters:
        *args: See [`griffe.Object`][].
        filepath: The module file path (directory for namespace [sub]packages, none for builtin modules).
        **kwargs: See [`griffe.Object`][].
    """
    super().__init__(*args, **kwargs)
    self._filepath: Path | list[Path] | None = filepath
    self.overloads: dict[str, list[Function]] = defaultdict(list)
    """The overloaded signatures declared in this module."""
```

## aliases

```
aliases: dict[str, Alias] = {}
```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this object.

None means the object was created manually.

## attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## deprecated

```
deprecated: bool | str | None = None
```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring
```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]
```

The file path of this module.

Raises:

- `BuiltinModuleError` â€“ When the instance filepath is None.

## functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## git_info

```
git_info: GitInfo | None
```

Git information for this object, if available.

## has_docstring

```
has_docstring: bool
```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool
```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}
```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## imports_future_annotations

```
imports_future_annotations: bool
```

Whether this module import future annotations.

## inherited

```
inherited: bool = False
```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False
```

Always false for objects.

## is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False
```

Always false for objects.

## is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

## is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool
```

Whether this object is generic.

## is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

## is_init_method

```
is_init_method: bool
```

Whether this function is an `__init__` method.

## is_init_module

```
is_init_module: bool
```

Whether this module is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool
```

Whether this module is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this module is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool
```

Whether this module is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool
```

Whether this module is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

## kind

```
kind = MODULE
```

The object kind.

## labels

```
labels: set[str] = set()
```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno
```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}
```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module
```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
```

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

## name

```
name: str = name
```

The object name.

## overloads

```
overloads: dict[str, list[Function]] = defaultdict(list)
```

The overloaded signatures declared in this module.

## package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))
```

## parent

```
parent: Module | Class | None = parent
```

The parent of the object (none if top module).

## path

```
path: str
```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'
```

## public

```
public: bool | None = None
```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

## runtime

```
runtime: bool = runtime
```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

## source_link

```
source_link: str | None
```

Source link for this object, if available.

## type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)
```

The object type parameters.

## __bool__

```
__bool__() -> bool
```

An object is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An object is always true-ish."""
    return True
```

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

## __len__

```
__len__() -> int
```

The number of members in this object, recursively.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The number of members in this object, recursively."""
    return len(self.members) + sum(len(member) for member in self.members.values())
```

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this module's data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this module's data as a dictionary.

    See also: [`as_json`][griffe.Module.as_json].

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = super().as_dict(**kwargs)
    if isinstance(self._filepath, list):
        base["filepath"] = [str(path) for path in self._filepath]
    elif self._filepath:
        base["filepath"] = str(self._filepath)
    else:
        base["filepath"] = None
    return base
```

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

## del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Object.members].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    if not predicates:
        return self.members
    members: dict[str, Object | Alias] = {
        name: member for name, member in self.members.items() if all(predicate(member) for predicate in predicates)
    }
    return members
```

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

## get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

## has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Object.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return set(labels).issubset(self.labels)
```

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Object.is_module],
    [`is_class`][griffe.Object.is_class],
    [`is_function`][griffe.Object.is_function],
    [`is_attribute`][griffe.Object.is_attribute],
    [`is_type_alias`][griffe.Object.is_type_alias],
    [`is_alias`][griffe.Object.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    if isinstance(kind, set):
        if not kind:
            raise ValueError("kind must not be an empty set")
        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)
    if isinstance(kind, str):
        kind = Kind(kind)
    return self.kind is kind
```

## resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    # TODO: Better match Python's own scoping rules?
    # Also, maybe return regular paths instead of canonical ones?

    # Name is a type parameter.
    if name in self.type_parameters:
        type_parameter = self.type_parameters[name]
        if type_parameter.kind is TypeParameterKind.type_var_tuple:
            prefix = "*"
        elif type_parameter.kind is TypeParameterKind.param_spec:
            prefix = "**"
        else:
            prefix = ""
        return f"{self.path}[{prefix}{name}]"

    # Name is a member of this object.
    if name in self.members:
        if self.members[name].is_alias:
            return self.members[name].target_path  # type: ignore[union-attr]
        return self.members[name].path

    # Name unknown and no more parent scope, could be a built-in.
    if self.parent is None:
        raise NameResolutionError(f"{name} could not be resolved in the scope of {self.path}")

    # Name is parent, non-module object.
    if name == self.parent.name and not self.parent.is_module:
        return self.parent.path

    # Recurse in parent.
    return self.parent.resolve(name)
```

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- ### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```

# Type Alias

## TypeAlias

```
TypeAlias(
    *args: Any,
    value: str | Expr | None = None,
    **kwargs: Any,
)
```

Bases: `Object`

```
              flowchart TD
              griffe.TypeAlias[TypeAlias]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.TypeAlias
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.TypeAlias href "" "griffe.TypeAlias"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
```

The class representing a Python type alias.

Parameters:

- ### **`*args`**

  (`Any`, default: `()` ) â€“ See griffe.Object.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) â€“ The type alias value.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ See griffe.Object.

Methods:

- **`__bool__`** â€“ An object is always true-ish.
- **`__delitem__`** â€“ Delete a member with its name or path.
- **`__getitem__`** â€“ Get a member with its name or path.
- **`__len__`** â€“ The number of members in this object, recursively.
- **`__setitem__`** â€“ Set a member with its name or path.
- **`as_dict`** â€“ Return this type alias's data as a dictionary.
- **`as_json`** â€“ Return this object's data as a JSON string.
- **`del_member`** â€“ Delete a member with its name or path.
- **`filter_members`** â€“ Filter and return members based on predicates.
- **`from_json`** â€“ Create an instance of this class from a JSON string.
- **`get_member`** â€“ Get a member with its name or path.
- **`has_labels`** â€“ Tell if this object has all the given labels.
- **`is_kind`** â€“ Tell if this object is of the given kind.
- **`resolve`** â€“ Resolve a name within this object's and parents' scope.
- **`set_member`** â€“ Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) â€“ The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) â€“ All members (declared and inherited).
- **`analysis`** (`Literal['static', 'dynamic'] | None`) â€“ The type of analysis used to load this object.
- **`attributes`** (`dict[str, Attribute]`) â€“ The attribute members.
- **`canonical_path`** (`str`) â€“ The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) â€“ The class members.
- **`deprecated`** (`bool | str | None`) â€“ Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) â€“ The object docstring.
- **`endlineno`** (`int | None`) â€“ The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) â€“ The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) â€“ Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) â€“ The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) â€“ The function members.
- **`git_info`** (`GitInfo | None`) â€“ Git information for this object, if available.
- **`has_docstring`** (`bool`) â€“ Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) â€“ Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) â€“ The other objects imported by this object.
- **`inherited`** (`bool`) â€“ Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) â€“ Members that are inherited from base classes.
- **`is_alias`** (`bool`) â€“ Always false for objects.
- **`is_attribute`** (`bool`) â€“ Whether this object is an attribute.
- **`is_class`** (`bool`) â€“ Whether this object is a class.
- **`is_class_private`** (`bool`) â€“ Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) â€“ Always false for objects.
- **`is_deprecated`** (`bool`) â€“ Whether this object is deprecated.
- **`is_exported`** (`bool`) â€“ Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) â€“ Whether this object is a function.
- **`is_generic`** (`bool`) â€“ Whether this object is generic.
- **`is_imported`** (`bool`) â€“ Whether this object/alias was imported from another module.
- **`is_init_method`** (`bool`) â€“ Whether this function is an __init__ method.
- **`is_init_module`** (`bool`) â€“ Whether this object is an __init__.py module.
- **`is_module`** (`bool`) â€“ Whether this object is a module.
- **`is_namespace_package`** (`bool`) â€“ Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) â€“ Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) â€“ Whether this object is a package (top module).
- **`is_private`** (`bool`) â€“ Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) â€“ Whether this object is considered public.
- **`is_special`** (`bool`) â€“ Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) â€“ Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) â€“ Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) â€“ Whether this object/alias is exposed to wildcard imports.
- **`kind`** â€“ The object kind.
- **`labels`** (`set[str]`) â€“ The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) â€“ The starting line number of the object.
- **`lines`** (`list[str]`) â€“ The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) â€“ The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) â€“ The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) â€“ The parent module of this object.
- **`modules`** (`dict[str, Module]`) â€“ The module members.
- **`modules_collection`** (`ModulesCollection`) â€“ The modules collection attached to this object or its parents.
- **`name`** (`str`) â€“ The object name.
- **`package`** (`Module`) â€“ The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) â€“ The parent of the object (none if top module).
- **`path`** (`str`) â€“ The dotted path of this object.
- **`public`** (`bool | None`) â€“ Whether this object is public.
- **`relative_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) â€“ The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) â€“ Whether this object is available at runtime.
- **`source`** (`str`) â€“ The source code of this object.
- **`source_link`** (`str | None`) â€“ Source link for this object, if available.
- **`type_aliases`** (`dict[str, TypeAlias]`) â€“ The type alias members.
- **`type_parameters`** (`TypeParameters`) â€“ The object type parameters.
- **`value`** (`str | Expr | None`) â€“ The type alias value.

Source code in `src/griffe/_internal/models.py`

```
def __init__(
    self,
    *args: Any,
    value: str | Expr | None = None,
    **kwargs: Any,
) -> None:
    """Initialize the function.

    Parameters:
        *args: See [`griffe.Object`][].
        value: The type alias value.
        **kwargs: See [`griffe.Object`][].
    """
    super().__init__(*args, **kwargs)
    self.value: str | Expr | None = value
    """The type alias value."""
```

### aliases

```
aliases: dict[str, Alias] = {}
```

The aliases pointing to this object.

### all_members

```
all_members: dict[str, Object | Alias]
```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

### analysis

```
analysis: Literal['static', 'dynamic'] | None = analysis
```

The type of analysis used to load this object.

None means the object was created manually.

### attributes

```
attributes: dict[str, Attribute]
```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

### canonical_path

```
canonical_path: str
```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

### classes

```
classes: dict[str, Class]
```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

### deprecated

```
deprecated: bool | str | None = None
```

Whether this object is deprecated (boolean or deprecation message).

### docstring

```
docstring: Docstring | None = docstring
```

The object docstring.

See also: has_docstring, has_docstrings.

### endlineno

```
endlineno: int | None = endlineno
```

The ending line number of the object.

See also: lineno.

### exports

```
exports: list[str | ExprName] | None = None
```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]
```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

### extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)
```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

### filepath

```
filepath: Path | list[Path]
```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')
```

### functions

```
functions: dict[str, Function]
```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

### git_info

```
git_info: GitInfo | None
```

Git information for this object, if available.

### has_docstring

```
has_docstring: bool
```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

### has_docstrings

```
has_docstrings: bool
```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

### imports

```
imports: dict[str, str] = {}
```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

### inherited

```
inherited: bool = False
```

Always false for objects.

Only aliases can be marked as inherited.

### inherited_members

```
inherited_members: dict[str, Alias]
```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

### is_alias

```
is_alias: bool = False
```

Always false for objects.

### is_attribute

```
is_attribute: bool
```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

### is_class

```
is_class: bool
```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_class_private

```
is_class_private: bool
```

Whether this object/alias is class-private (starts with `__` and is a class member).

### is_collection

```
is_collection: bool = False
```

Always false for objects.

### is_deprecated

```
is_deprecated: bool
```

Whether this object is deprecated.

### is_exported

```
is_exported: bool
```

Whether this object/alias is exported (listed in `__all__`).

### is_function

```
is_function: bool
```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

### is_generic

```
is_generic: bool
```

Whether this object is generic.

### is_imported

```
is_imported: bool
```

Whether this object/alias was imported from another module.

### is_init_method

```
is_init_method: bool
```

Whether this function is an `__init__` method.

### is_init_module

```
is_init_module: bool
```

Whether this object is an `__init__.py` module.

See also: is_module.

### is_module

```
is_module: bool
```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_namespace_package

```
is_namespace_package: bool
```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

### is_namespace_subpackage

```
is_namespace_subpackage: bool
```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

### is_package

```
is_package: bool
```

Whether this object is a package (top module).

See also: is_subpackage.

### is_private

```
is_private: bool
```

Whether this object/alias is private (starts with `_`) but not special.

### is_public

```
is_public: bool
```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

### is_special

```
is_special: bool
```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

### is_subpackage

```
is_subpackage: bool
```

Whether this object is a subpackage.

See also: is_package.

### is_type_alias

```
is_type_alias: bool
```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

### is_wildcard_exposed

```
is_wildcard_exposed: bool
```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` â€“ True or False.

### kind

```
kind = TYPE_ALIAS
```

The object kind.

### labels

```
labels: set[str] = set()
```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

### lineno

```
lineno: int | None = lineno
```

The starting line number of the object.

See also: endlineno.

### lines

```
lines: list[str]
```

The lines containing the source of this object.

See also: lines_collection, source.

### lines_collection

```
lines_collection: LinesCollection
```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

### members

```
members: dict[str, Object | Alias] = {}
```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

### module

```
module: Module
```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
```

Raises:

- `ValueError` â€“ When the object is not a module and does not have a parent.

### modules

```
modules: dict[str, Module]
```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

### modules_collection

```
modules_collection: ModulesCollection
```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` â€“ When no modules collection can be found in the object or its parents.

### name

```
name: str = name
```

The object name.

### package

```
package: Module
```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))
```

### parent

```
parent: Module | Class | None = parent
```

The parent of the object (none if top module).

### path

```
path: str
```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'
```

### public

```
public: bool | None = None
```

Whether this object is public.

### relative_filepath

```
relative_filepath: Path
```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

### relative_package_filepath

```
relative_package_filepath: Path
```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` â€“ When the relative path could not be computed.

### runtime

```
runtime: bool = runtime
```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

### source

```
source: str
```

The source code of this object.

See also: lines, lines_collection.

### source_link

```
source_link: str | None
```

Source link for this object, if available.

### type_aliases

```
type_aliases: dict[str, TypeAlias]
```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

### type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)
```

The object type parameters.

### value

```
value: str | Expr | None = value
```

The type alias value.

### __bool__

```
__bool__() -> bool
```

An object is always true-ish.

Source code in `src/griffe/_internal/models.py`

```
def __bool__(self) -> bool:
    """An object is always true-ish."""
    return True
```

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __delitem__(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> del griffe_object["foo"]
        >>> del griffe_object["path.to.bar"]
        >>> del griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        try:
            del self.members[name]  # type: ignore[attr-defined]
        except KeyError:
            del self.inherited_members[name]  # type: ignore[attr-defined]
    else:
        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def __getitem__(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Members will be looked up in both declared members and inherited ones,
    triggering computation of the latter.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> qux = griffe_object[("path", "to", "qux")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.all_members[parts[0]]  # type: ignore[attr-defined]
    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]
```

### __len__

```
__len__() -> int
```

The number of members in this object, recursively.

Source code in `src/griffe/_internal/models.py`

```
def __len__(self) -> int:
    """The number of members in this object, recursively."""
    return len(self.members) + sum(len(member) for member in self.members.values())
```

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux
```

Source code in `src/griffe/_internal/mixins.py`

```
def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the consumer API:
    do not use when producing Griffe trees!

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object["foo"] = foo
        >>> griffe_object["path.to.bar"] = bar
        >>> griffe_object[("path", "to", "qux")] = qux
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]
```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]
```

Return this type alias's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options.

Returns:

- `dict[str, Any]` â€“ A dictionary.

Source code in `src/griffe/_internal/models.py`

```
def as_dict(self, **kwargs: Any) -> dict[str, Any]:
    """Return this type alias's data as a dictionary.

    Parameters:
        **kwargs: Additional serialization options.

    Returns:
        A dictionary.
    """
    base = super().as_dict(**kwargs)
    base["value"] = self.value
    return base
```

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str
```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) â€“ Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional serialization options passed to encoder.

Returns:

- `str` â€“ A JSON string.

Source code in `src/griffe/_internal/mixins.py`

```
def as_json(self, *, full: bool = False, **kwargs: Any) -> str:
    """Return this object's data as a JSON string.

    Parameters:
        full: Whether to return full info, or just base info.
        **kwargs: Additional serialization options passed to encoder.

    Returns:
        A JSON string.
    """
    from griffe._internal.encoders import JSONEncoder  # Avoid circular import.  # noqa: PLC0415

    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)
```

### del_member

```
del_member(key: str | Sequence[str]) -> None
```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))
```

Source code in `src/griffe/_internal/mixins.py`

```
def del_member(self, key: str | Sequence[str]) -> None:
    """Delete a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> griffe_object.del_member("foo")
        >>> griffe_object.del_member("path.to.bar")
        >>> griffe_object.del_member(("path", "to", "qux"))
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        del self.members[name]  # type: ignore[attr-defined]
    else:
        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]
```

### filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]
```

Filter and return members based on predicates.

See also: members.

Parameters:

- #### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) â€“ A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` â€“ A dictionary of members.

Source code in `src/griffe/_internal/models.py`

```
def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -> dict[str, Object | Alias]:
    """Filter and return members based on predicates.

    See also: [`members`][griffe.Object.members].

    Parameters:
        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

    Returns:
        A dictionary of members.
    """
    if not predicates:
        return self.members
    members: dict[str, Object | Alias] = {
        name: member for name, member in self.members.items() if all(predicate(member) for predicate in predicates)
    }
    return members
```

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType
```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) â€“ JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) â€“ Additional options passed to decoder.

Returns:

- `_ObjType` â€“ An Object instance.

Raises:

- `TypeError` â€“ When the json_string does not represent and object of the class from which this classmethod has been called.

Source code in `src/griffe/_internal/mixins.py`

```
@classmethod
def from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -> _ObjType:  # noqa: PYI019
    """Create an instance of this class from a JSON string.

    Parameters:
        json_string: JSON to decode into Object.
        **kwargs: Additional options passed to decoder.

    Returns:
        An Object instance.

    Raises:
        TypeError: When the json_string does not represent and object
            of the class from which this classmethod has been called.
    """
    from griffe._internal.encoders import json_decoder  # Avoid circular import.  # noqa: PLC0415

    kwargs.setdefault("object_hook", json_decoder)
    obj = json.loads(json_string, **kwargs)
    if not isinstance(obj, cls):
        raise TypeError(f"provided JSON object is not of type {cls}")
    return obj
```

### get_member

```
get_member(key: str | Sequence[str]) -> Any
```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]
```

Source code in `src/griffe/_internal/mixins.py`

```
def get_member(self, key: str | Sequence[str]) -> Any:
    """Get a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Members will be looked up in declared members only, not inherited ones.

    Parameters:
        key: The name or path of the member.

    Examples:
        >>> foo = griffe_object["foo"]
        >>> bar = griffe_object["path.to.bar"]
        >>> bar = griffe_object[("path", "to", "bar")]
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        return self.members[parts[0]]  # type: ignore[attr-defined]
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
```

### has_labels

```
has_labels(*labels: str) -> bool
```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- #### **`*labels`**

  (`str`, default: `()` ) â€“ Labels that must be present.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def has_labels(self, *labels: str) -> bool:
    """Tell if this object has all the given labels.

    See also: [`labels`][griffe.Object.labels].

    Parameters:
        *labels: Labels that must be present.

    Returns:
        True or False.
    """
    return set(labels).issubset(self.labels)
```

### is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool
```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- #### **`kind`**

  (`str | Kind | set[str | Kind]`) â€“ An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` â€“ When an empty set is given as argument.

Returns:

- `bool` â€“ True or False.

Source code in `src/griffe/_internal/models.py`

```
def is_kind(self, kind: str | Kind | set[str | Kind]) -> bool:
    """Tell if this object is of the given kind.

    See also: [`is_module`][griffe.Object.is_module],
    [`is_class`][griffe.Object.is_class],
    [`is_function`][griffe.Object.is_function],
    [`is_attribute`][griffe.Object.is_attribute],
    [`is_type_alias`][griffe.Object.is_type_alias],
    [`is_alias`][griffe.Object.is_alias].

    Parameters:
        kind: An instance or set of kinds (strings or enumerations).

    Raises:
        ValueError: When an empty set is given as argument.

    Returns:
        True or False.
    """
    if isinstance(kind, set):
        if not kind:
            raise ValueError("kind must not be an empty set")
        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)
    if isinstance(kind, str):
        kind = Kind(kind)
    return self.kind is kind
```

### resolve

```
resolve(name: str) -> str
```

Resolve a name within this object's and parents' scope.

Parameters:

- #### **`name`**

  (`str`) â€“ The name to resolve.

Raises:

- `NameResolutionError` â€“ When the name could not be resolved.

Returns:

- `str` â€“ The resolved name.

Source code in `src/griffe/_internal/models.py`

```
def resolve(self, name: str) -> str:
    """Resolve a name within this object's and parents' scope.

    Parameters:
        name: The name to resolve.

    Raises:
        NameResolutionError: When the name could not be resolved.

    Returns:
        The resolved name.
    """
    # TODO: Better match Python's own scoping rules?
    # Also, maybe return regular paths instead of canonical ones?

    # Name is a type parameter.
    if name in self.type_parameters:
        type_parameter = self.type_parameters[name]
        if type_parameter.kind is TypeParameterKind.type_var_tuple:
            prefix = "*"
        elif type_parameter.kind is TypeParameterKind.param_spec:
            prefix = "**"
        else:
            prefix = ""
        return f"{self.path}[{prefix}{name}]"

    # Name is a member of this object.
    if name in self.members:
        if self.members[name].is_alias:
            return self.members[name].target_path  # type: ignore[union-attr]
        return self.members[name].path

    # Name unknown and no more parent scope, could be a built-in.
    if self.parent is None:
        raise NameResolutionError(f"{name} could not be resolved in the scope of {self.path}")

    # Name is parent, non-module object.
    if name == self.parent.name and not self.parent.is_module:
        return self.parent.path

    # Recurse in parent.
    return self.parent.resolve(name)
```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None
```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) â€“ The name or path of the member.

- #### **`value`**

  (`Object | Alias`) â€“ The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)
```

Source code in `src/griffe/_internal/mixins.py`

```
def set_member(self, key: str | Sequence[str], value: Object | Alias) -> None:
    """Set a member with its name or path.

    This method is part of the producer API:
    you can use it safely while building Griffe trees
    (for example in Griffe extensions).

    Parameters:
        key: The name or path of the member.
        value: The member.

    Examples:
        >>> griffe_object.set_member("foo", foo)
        >>> griffe_object.set_member("path.to.bar", bar)
        >>> griffe_object.set_member(("path", "to", "qux"), qux)
    """
    parts = _get_parts(key)
    if len(parts) == 1:
        name = parts[0]
        if name in self.members:  # type: ignore[attr-defined]
            member = self.members[name]  # type: ignore[attr-defined]
            if not member.is_alias:
                # When reassigning a module to an existing one,
                # try to merge them as one regular and one stubs module
                # (implicit support for .pyi modules).
                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):
                    # Accessing attributes of the value or member can trigger alias errors.
                    # Accessing file paths can trigger a builtin module error.
                    with suppress(AliasResolutionError, CyclicAliasError, BuiltinModuleError):
                        if value.is_module and value.filepath != member.filepath:
                            with suppress(ValueError):
                                value = merge_stubs(member, value)  # type: ignore[arg-type]
                for alias in member.aliases.values():
                    with suppress(CyclicAliasError):
                        alias.target = value
        self.members[name] = value  # type: ignore[attr-defined]
        if self.is_collection:  # type: ignore[attr-defined]
            value._modules_collection = self  # type: ignore[union-attr]
        else:
            value.parent = self  # type: ignore[assignment]
    else:
        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]
```
# Extensions

# Built-in extensions

Built-in extensions are maintained in Griffe's code base. They generally bring support for core features of the Python language or its standard library.

| Extension                               | Description                                     |
| --------------------------------------- | ----------------------------------------------- |
| [`dataclasses`](dataclasses/)           | Support for dataclasses.                        |
| [`unpack_typeddict`](unpack-typeddict/) | Support for typing.Unpack and typing.TypedDict. |

# `dataclasses`

The `dataclasses` extension adds support for dataclasses from the standard library. It works both statically and dynamically. When used statically, it re-creates the `__init__` methods and their signatures (as Griffe objects), that would otherwise be created at runtime. When used dynamically, it does nothing since `__init__` methods are created by the library and can be inspected normally.

Example:

```
from dataclasses import dataclass


@dataclass
class Room:
    uid: int
    name: str
    capacity: int = 10
    available: bool = True
```

With the `dataclasses` extension enabled, the Griffe object for the `Room` class will get an `__init__` method with the following signature:

```
def __init__(self, uid: int, name: str, capacity: int = 10, available: bool = True) -> None:
    ...
```

Additional metadata like `ClassVar`, the `init` and `kw_only` parameters, or the `KW_ONLY` sentinel are also recognized and will update the `__init__` method signature accordingly.

**This extension is enabled by default.** It is always added last. If you need to give it a higher priority, you can explictly enable it to change its position in the list of extensions (it will run only once):

```
$ griffe dump -e dataclasses,other my_package
```

```
import griffe

my_package = griffe.load("my_package", extensions=griffe.load_extensions("dataclasses", "other"))
```

mkdocs.yml

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - dataclasses
          - other
```

# `unpack_typeddict`

The `unpack_typeddict` extension adds support for Unpack and TypedDict from the standard library. When enabled, it will add an `__init__` method to typed dictionaries, and expand `**kwargs: Unpack[...]` (the ellipsis being a typed dict class) in function signatures to the relevant parameters, using the typed dict attributes or added signature. The extension will also update any Parameters section in the function docstring, to reflect the signature update.

Example:

```
from typing import TypedDict, Unpack


class GreetKwargs(TypedDict):
    name: str
    """The name of a person to greet."""
    shout: bool
    """Whether to shout."""


def greet(**kwargs: Unpack[GreetKwargs]) -> str:
    """Greet someone.

    Parameters:
        **kwargs: Greet parameters.

    Returns:
        A message.
    """
    message = f"Hello {kwargs['name']}!"
    if kwargs["shout"]:
        return message.upper() + "!!"
    return message
```

With the `unpack_typeddict` extension enabled, the data loaded by Griffe will be updated as follows:

```
class GreetKwargs(TypedDict):
    # Attributes removed from Griffe data.

    # Added by the extension to Griffe data (not to the runtime class):
    def __init__(self, *, name: str, shout: bool) -> None:
        """
        Parameters:
            name: The name of a person to greet.
            shout: Whether to shout.
        """


def greet(*, name: str, shout: bool) -> str:
    """Greet someone.

    Parameters:
        name: The name of a person to greet.
        shout: Whether to shout.

    Returns:
        A message.
    """
```

Thanks to this `__init__` method now appearing in the typed dictionary, tools like mkdocstrings can now render a proper signature for `GreetKwargs`.

Note

Our example shows a Google-style docstring, but we actually insert a structured docstring section into the parsed data, which is style-agnostic, so it works with any docstring style.

To enable the extension:

```
$ griffe dump -e unpack_typeddict my_package
```

```
import griffe

my_package = griffe.load("my_package", extensions=griffe.load_extensions("unpack_typeddict"))
```

mkdocs.yml

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - unpack_typeddict
```

# Official extensions

Official extensions are developed and maintained within the mkdocstrings organization on GitHub, in separate repositories. They generally bring support for various third-party libraries or other documentation-related features that are part of Python's standard library.

| Extension                                               | Description                                                                                                                   |
| ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| [`autodocstringstyle`](autodocstringstyle/)             | Set docstring style to `auto` for external packages.                                                                          |
| [`inherited-docstrings`](inherited-docstrings/)         | Inherit docstrings from parent classes.                                                                                       |
| [`public-redundant-aliases`](public-redundant-aliases/) | Mark objects imported with redundant aliases as public.                                                                       |
| [`public-wildcard-imports`](public-wildcard-imports/)   | Mark wildcard imported objects as public.                                                                                     |
| [`pydantic`](pydantic/)                                 | Support for [Pydantic](https://docs.pydantic.dev/latest/) models.                                                             |
| [`runtime-objects`](runtime-objects/)                   | Access runtime objects corresponding to each loaded Griffe object through their `extra` attribute.                            |
| [`sphinx`](sphinx/)                                     | Parse [Sphinx](https://www.sphinx-doc.org/)-comments above attributes (`#:`) as docstrings.                                   |
| [`typing-doc`](typingdoc/)                              | Support for [PEP 727](https://peps.python.org/pep-0727/)'s typing.Doc, "Documentation in Annotated Metadata".                 |
| [`warnings-deprecated`](warnings-deprecated/)           | Support for [PEP 702](https://peps.python.org/pep-0702/)'s warnings.deprecated, "Marking deprecations using the type system". |

# `griffe-autodocstringstyle`

- **PyPI**: [`griffe-autodocstringstyle`](https://pypi.org/project/griffe-autodocstringstyle/)
- **GitHub**: [mkdocstrings/griffe-autodocstringstyle](https://github.com/mkdocstrings/griffe-autodocstringstyle)
- **Documentation:** [mkdocstrings.github.io/griffe-autodocstringstyle](https://mkdocstrings.github.io/griffe-autodocstringstyle)
- **Extension name:** `griffe_autodocstringstyle`

______________________________________________________________________

This extension sets the docstring parser to `auto` for all the docstrings of external packages. Packages are considered "external" when their sources are found in a virtual environment instead of a folder under the current working directory. Setting their docstring style to `auto` is useful if you plan on rendering the docstring of these objects in your own documentation.

# `griffe-inherited-docstrings`

- **PyPI**: [`griffe-inherited-docstrings`](https://pypi.org/project/griffe-inherited-docstrings/)
- **GitHub**: [mkdocstrings/griffe-inherited-docstrings](https://github.com/mkdocstrings/griffe-inherited-docstrings)
- **Documentation:** [mkdocstrings.github.io/griffe-inherited-docstrings](https://mkdocstrings.github.io/griffe-inherited-docstrings)
- **Extension name:** `griffe_inherited_docstrings`

______________________________________________________________________

This extension, when enabled, iterates over the declared members of all classes found within a package, and if they don't have a docstring, but do have a parent member with a docstring, sets their docstring to that parent's docstring.

```
class Base:
    attr = "hello"
    """Hello."""

    def hello(self):
        """Hello again."""
        ...

class Derived(Base):
    attr = "bye"

    def hello(self):
        ...
```

In the example above, *without* the extension `Derived.attr` and `Derived.hello` have no docstrings, while *with* the extension they will have the `Base.attr` and `Base.hello` docstrings attached, respectively.

# `griffe-public-redundant-aliases`

- **PyPI**: [`griffe-public-redundant-aliases`](https://pypi.org/project/griffe-public-redundant-aliases/)
- **GitHub**: [mkdocstrings/griffe-public-redundant-aliases](https://github.com/mkdocstrings/griffe-public-redundant-aliases)
- **Documentation:** [mkdocstrings.github.io/griffe-public-redundant-aliases](https://mkdocstrings.github.io/griffe-public-redundant-aliases)
- **Extension name:** `griffe_public_redundant_aliases`

______________________________________________________________________

This extension marks every object that was imported with a redundant alias as public. See our documentation on the [redundant aliases convention](../../../guide/users/recommendations/public-apis/#redundant-aliases).

# `griffe-public-wildcard-imports`

- **PyPI**: [`griffe-public-wildcard-imports`](https://pypi.org/project/griffe-public-wildcard-imports/)
- **GitHub**: [mkdocstrings/griffe-public-wildcard-imports](https://github.com/mkdocstrings/griffe-public-wildcard-imports)
- **Documentation:** [mkdocstrings.github.io/griffe-public-wildcard-imports](https://mkdocstrings.github.io/griffe-public-wildcard-imports)
- **Extension name:** `griffe_public_wildcard_imports`

______________________________________________________________________

This extension marks every object that was imported with a wildcard import as public. See our documentation on the [wildcard imports convention](../../../guide/users/recommendations/public-apis/#wildcard-imports).

# `griffe-pydantic`

- **PyPI**: [`griffe-pydantic`](https://pypi.org/project/griffe-pydantic/)
- **GitHub**: [mkdocstrings/griffe-pydantic](https://github.com/mkdocstrings/griffe-pydantic)
- **Documentation:** [mkdocstrings.github.io/griffe-pydantic](https://mkdocstrings.github.io/griffe-pydantic)
- **Extension name:** `griffe_pydantic`

______________________________________________________________________

This extension adds support for [Pydantic](https://docs.pydantic.dev/latest/) models. It extracts useful information from them, stores this information into the `extra` attribute of objects, and binds custom mkdocstrings templates to the objects for better rendering. The extension works both statically and dynamically, and supports model inheritance.

# `griffe-runtime-objects`

- **PyPI**: [`griffe-runtime-objects`](https://pypi.org/project/griffe-runtime-objects/)
- **GitHub**: [mkdocstrings/griffe-runtime-objects](https://github.com/mkdocstrings/griffe-runtime-objects)
- **Documentation:** [mkdocstrings.github.io/griffe-runtime-objects](https://mkdocstrings.github.io/griffe-runtime-objects)
- **Extension name:** `griffe_runtime_objects`

______________________________________________________________________

This extension stores runtime objects corresponding to each loaded Griffe object into its `extra` attribute, under the `runtime-objects` namespace.

```
>>> import griffe
>>> griffe_data = griffe.load("griffe", extensions=griffe.load_extensions("griffe_runtime_objects"), resolve_aliases=True)
>>> griffe_data["parse"].extra
defaultdict(<class 'dict'>, {'runtime-objects': {'object': <function parse at 0x78685c951260>}})
>>> griffe_data["Module"].extra
defaultdict(<class 'dict'>, {'runtime-objects': {'object': <class 'griffe._internal.models.Module'>}})
```

It can be useful in combination with mkdocstrings-python and custom templates, to iterate over object values or their attributes that couldn't be loaded by Griffe itself (for example, objects built dynamically and loaded as attributes won't have "members" to iterate over).

# `griffe-sphinx`

- **PyPI**: [`griffe-sphinx`](https://pypi.org/project/griffe-sphinx/)
- **GitHub**: [mkdocstrings/griffe-sphinx](https://github.com/mkdocstrings/griffe-sphinx)
- **Documentation:** [mkdocstrings.github.io/griffe-sphinx](https://mkdocstrings.github.io/griffe-sphinx)
- **Extension name:** `griffe_sphinx`

______________________________________________________________________

This extension reads Sphinx comments placed above attribute assignments and uses them as docstrings.

```
#: Summary of `module_attr`.
module_attr = "hello"


class Hello:
    #: Summary of `class_attr`.
    #:
    #: Description of the class attribute.
    #: *Markup* and [cross-references][] are __supported__,
    #: just like in regular docstrings.
    class_attr = "hello"

    def __init__(self):
        #: Summary of `instance_attr`.
        self.instance_attr = "hello"
```

Comments are treated exactly like regular docstrings: they are "cleaned" (dedented and stripped of leading and trailing newlines) and can contain any markup you want, be it Markdown, rST, AsciiDoc, etc.

Trailing comments are not supported:

```
module_attr  #: This is not supported.
```

# `griffe-typingdoc`

- **PyPI**: [`griffe-typingdoc`](https://pypi.org/project/griffe-typingdoc/)
- **GitHub**: [mkdocstrings/griffe-typingdoc](https://github.com/mkdocstrings/griffe-typingdoc)
- **Documentation:** [mkdocstrings.github.io/griffe-typingdoc](https://mkdocstrings.github.io/griffe-typingdoc)
- **Extension name:** `griffe_typingdoc`

______________________________________________________________________

This extension reads docstrings for parameters, return values and more from type annotations using Annotated and the Doc class suggested in [PEP 727](https://peps.python.org/pep-0727/). Documenting parameters and return values this way makes it possible to completely avoid relying on a particular "docstring style" (Google, Numpydoc, Sphinx, etc.) and just use plain markup in module/classes/function docstrings. Docstrings therefore do not have to be parsed at all.

```
from typing import Annotated as An
from typing_extensions import Doc


def function(
    param1: An[int, Doc("Some integer value.")],
    param2: An[
        str,
        Doc(
            """
            Summary of the parameter.

            Multi-line docstrings can be used, as usual.
            Any **markup** is supported, as usual.
            """
        )
    ]
) -> An[bool, Doc("Whether you like PEP 727.")]:
    """Summary of the function.

    No more "Args", "Parameters" or "Returns" sections.
    Just plain markup.
    """
    ...
```

PEP 727 is likely to be withdrawn or rejected, but the `Doc` class will remain in `typing_extensions`, [as told by Jelle Zijlstra](https://discuss.python.org/t/pep-727-documentation-metadata-in-typing/32566/183):

> Weâ€™ll probably keep it in `typing_extensions` indefinitely even if the PEP gets withdrawn or rejected, for backwards compatibility reasons.
>
> You are free to use it in your own code using the typing-extensions version. If usage of `typing_extensions.Doc` becomes widespread, that will be a good argument for accepting the PEP and putting it in the standard library.

# `griffe-warnings-deprecated`

- **PyPI**: [`griffe-warnings-deprecated`](https://pypi.org/project/griffe-warnings-deprecated/)
- **GitHub**: [mkdocstrings/griffe-warnings-deprecated](https://github.com/mkdocstrings/griffe-warnings-deprecated)
- **Documentation:** [mkdocstrings.github.io/griffe-warnings-deprecated](https://mkdocstrings.github.io/griffe-warnings-deprecated)
- **Extension name:** `griffe_warnings_deprecated`

______________________________________________________________________

This extension adds support for functions and classes decorated with @warnings.deprecated(...), as implemented thanks to [PEP 702](https://peps.python.org/pep-0702/). The message provided in the decorator call will be stored in the corresponding Griffe object's deprecated attribute (usable by downstream rendering templates), and will also add an admonition to the object's docstring with the provided message as text.

```
from warnings import deprecated

@deprecated("This function is **deprecated**. Use [another one][package.another_func] instead.")
def deprecated_func():
    ...


def another_func():
    ...
```

# Third-party extensions

Third-party extensions are developed and maintained outside of the mkdocstrings organization, by various developers. They generally bring support for third-party libraries.

| Extension                                                   | Description                                                                                                                   |
| ----------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| [`docstring-inheritance`](docstring-inheritance/)           | A more advanced docstring inheritance utility that also provides a Griffe extension.                                          |
| [`fastapi`](https://github.com/fbraem/griffe-fastapi)       | Search for functions that are decorated with an APIRouter and adds the extra fields to a function.                            |
| [`fieldz`](fieldz/)                                         | Support for data-class like objects (dataclasses, pydantic, attrs, etc.) using [fieldz](https://github.com/pyapp-kit/fieldz). |
| [`generics`](generics/)                                     | Resolve generic type parameters as bound types in subclasses.                                                                 |
| [`inherited-method-crossrefs`](inherited-method-crossrefs/) | Replace docstrings of inherited methods with cross-references to parents.                                                     |
| [`modernized-annotations`](modernized-annotations/)         | Modernize type annotations by adopting PEP 585 and PEP 604.                                                                   |

You can find more third-party extensions by exploring the [`griffe-extension` topic on GitHub](https://github.com/topics/griffe-extension). You can also check out the "in-project" extensions (not published to PyPI) used in various projects on GitHub by [searching for "griffe extension" in code](https://github.com/search?q=griffe+Extension+language%3Apython&type=code).

# `docstring-inheritance`

- **PyPI**: [`docstring-inheritance`](https://pypi.org/project/docstring-inheritance/)
- **GitHub**: [AntoineD/docstring-inheritance](https://github.com/AntoineD/docstring-inheritance)
- **Extension name:** `docstring_inheritance.griffe`

______________________________________________________________________

`docstring-inheritance` is a Python package that allows to avoid writing and maintaining duplicated Python docstrings. The typical usage is to enable the inheritance of the docstrings from a base class such that its derived classes fully or partially inherit the docstrings. It provides a Griffe extension and recommends to use it alongside the official [`inherited-docstrings`](../../official/inherited-docstrings/) extension in MkDocs:

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - griffe_inherited_docstrings
          - docstring_inheritance.griffe
```

# `griffe-fastapi`

- **PyPI**: [`griffe-fastapi`](https://pypi.org/project/griffe-fastapi/)
- **GitHub**: [fbraem/griffe-fastapi](https://github.com/fbraem/griffe-fastapi)
- **Extension name:** `griffe_fastapi`

______________________________________________________________________

This extension will search for functions that are decorated with an APIRouter and adds the following extra fields to a function:

- api: the path of the api
- method: the HTTP method
- responses: a dictionary with the responses

These fields are then rendered with a custom mkdocstrings template provided by the extension.

# `griffe-fieldz`

- **PyPI**: [`griffe-fieldz`](https://pypi.org/project/griffe-fieldz/)
- **GitHub**: [pyapp-kit/griffe-fieldz](https://github.com/pyapp-kit/griffe-fieldz)
- **Extension name:** `griffe_fieldz`

______________________________________________________________________

This extension adds support for data-class like things (pydantic, attrs, etc...). This extension will inject the fields of the data-class into the documentation, preventing you from duplicating field metadata in your docstrings.

It supports anything that [fieldz](https://github.com/pyapp-kit/fieldz) supports, which is currently:

- [`dataclasses.dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass)
- [`pydantic.BaseModel`](https://docs.pydantic.dev/latest/)
- [`attrs.define`](https://www.attrs.org/en/stable/overview.html)
- [`msgspec.Struct`](https://jcristharif.com/msgspec/)

# `griffe-generics`

- **PyPI**: [`griffe-generics`](https://pypi.org/project/griffe-generics/)
- **GitHub**: [jonghwanhyeon/griffe-generics](https://github.com/jonghwanhyeon/griffe-generics)
- **Extension name:** `griffe_generics`

______________________________________________________________________

This extension resolves generic type parameters as bound types in subclasses. For example, if a parent class inherits from `Generics[L]`, and a subclass specifies `L` as `Hashable`, then all type annotations using `L` in the class methods or attributes inherited from the parent class will be transformed to use `Hashable` instead.

# `griffe-inherited-method-crossrefs`

- **PyPI**: [`griffe-inherited-method-crossrefs`](https://pypi.org/project/griffe-inherited-method-crossrefs/)
- **GitHub**: [mlprt/griffe-inherited-method-crossrefs](https://github.com/mlprt/griffe-inherited-method-crossrefs)
- **Extension name:** `griffe_inherited_method_crossrefs`

______________________________________________________________________

This extension replaces docstrings of inherited methods with cross-references to parent methods. For example, if a class `foo.Child` inherits the method `do_something` from `bar.Parent`, then in the generated documentation, the docstring of `Child.do_something` will appear similar to

> Inherited from [bar.Parent](https://example.com/link/to/bar.Parent.do_something)

whereas the docstring of `bar.Parent.do_something` will be unaffected.

This is contrast to the official [`inherited-docstrings`](../../official/inherited-docstrings/) extension which simply attaches the docstring of the parent method to the subclass method, which means that modifying the subclass method docstring also modifies the parent method docstring (it's the same object).

# `griffe-modernized-annotations`

- **PyPI**: [`griffe-modernized-annotations`](https://pypi.org/project/griffe-modernized-annotations/)
- **GitHub**: [jonghwanhyeon/griffe-modernized-annotations](https://github.com/jonghwanhyeon/griffe-modernized-annotations)
- **Extension name:** `griffe_modernized_annotations`

______________________________________________________________________

This extension modernizes type annotations by adopting [PEP 585](https://peps.python.org/pep-0585/) and [PEP 604](https://peps.python.org/pep-0604/). For example, it will transform `Union[A, B]` into `A | B`, and `List[str]` into `list[str]`.
# Contributing

# Contributor guide

Welcome to the Griffe contributor guide! If you are familiar with Python tooling, development, and contributions to open-source projects, see the [TL;DR](#tldr) at the end, otherwise we recommend you walk through the following pages:

- [Environment setup](setup/)
- [Management commands](commands/)
- [Development workflow](workflow/)

Regular contributors might be interested in the following documents that explain Griffe's design and inner workings:

- [Architecture](architecture/)

If you are unsure about what to contribute to, you can check out [our issue tracker](https://github.com/mkdocstrings/griffe/issues) to see if some issues are interesting to you, or you could check out [our coverage report](coverage/) to help us cover more of the codebase with tests.

## TL;DR

- Install [Python](https://www.python.org/), [uv](https://docs.astral.sh/uv/) and [direnv](https://direnv.net/)
- Fork, clone, and enter repository
- Run `direnv allow` and `make setup`
- Checkout a new branch
- Edit code, tests and/or documentation
- Run `make format check test docs` to check everything
- Commit, push, open PR

# Project architecture

This document describes how the project is architectured, both regarding boilerplate and actual code. We start by giving an overview of the project's contents:

```
ðŸ“ .git/
ðŸ“ .github/ # (1)!
ðŸ“ .venv/ # (2)!
ðŸ“ .venvs/ # (3)!
ðŸ“ .vscode/ # (4)!
ðŸ“ config/ # (5)!
ðŸ“ docs/ # (6)!
ðŸ“ htmlcov/ # (7)!
ðŸ“ scripts/ # (8)!
ðŸ“ site/ # (9)!
ðŸ“ src/ # (10)!
ðŸ“ tests/ # (11)!
 .copier-answers.yml # (12)!
 .envrc # (13)!
 .gitignore
 CHANGELOG.md
 CODE_OF_CONDUCT.md
 CONTRIBUTING.md
 LICENSE
 Makefile # (14)!
 README.md
 duties.py # (15)!
 logo.svg
 mkdocs.yml # (16)!
 pyproject.toml # (17)!
 uv.lock
```

1. GitHub workflows, issue templates and other configuration.

   ```
   ðŸ“ ISSUE_TEMPLATE/ # (1)!
   ðŸ“ workflows/ # (2)!
    FUNDING.yml
    pull_request_template.md
   ```

   1. ```
       1-bug.md
       2-feature.md
       3-docs.md
       4-change.md
       config.yml
      ```
   1. ```
       ci.yml
       release.yml
       sponsors.yml
      ```

1. The default virtual environment (git-ignored). See make setup command.

1. The virtual environments for all supported Python versions (git-ignored). See make setup command.

1. The configuration for VSCode (git-ignored). See make vscode command.

   ```
    configurationCache.log
    dryrun.log
    launch.json
    settings.json
    targets.log
    tasks.json
   ```

1. Contains our tooling configuration. See [Scripts, configuration](#scripts-configuration).

   ```
   ðŸ“ vscode/ # (1)!
    coverage.ini
    git-changelog.toml
    mypy.ini
    pytest.ini
    ruff.toml
   ```

   1. ```
       launch.json
       settings.json
       tasks.json
      ```

1. Documentation sources (Markdown pages). See make docs task.

   ```
   ðŸ“ .overrides/ # (1)!
   ðŸ“ css/ # (2)!
   ðŸ“ extensions/ # (3)!
   ðŸ“ guide/ # (4)!
   ðŸ“ img/ # (5)!
   ðŸ“ js/ # (6)!
   ðŸ“ reference/ # (7)!
    alternatives.md
    changelog.md
    code-of-conduct.md
    community.md
    contributing.md
    credits.md
    downstream-projects.md
    extensions.md
    getting-help.md
    getting-started.md
    guide.md
    index.md
    installation.md
    introduction.md
    license.md
    logo.svg
    playground.md
    reference.md
    schema-docstrings-options.json
    schema.json
   ```

   1. Customization of [Material for MkDocs](https://squidfunk.github.io/mkdocs-material/)' templates.

      ```
      ðŸ“ partials/ # (1)!
       main.html
      ```

      1. ```
          comments.html
          path-item.html
         ```

   1. ```
       custom.css
       material.css
       mkdocstrings.css
      ```

   1. ```
      ðŸ“ built-in/ # (1)!
      ðŸ“ official/ # (2)!
      ðŸ“ third-party/ # (3)!
       built-in.md
       official.md
       third-party.md
      ```

      1. ```
          dataclasses.md
          unpack-typeddict.md
         ```
      1. ```
          autodocstringstyle.md
          inherited-docstrings.md
          public-redundant-aliases.md
          public-wildcard-imports.md
          pydantic.md
          runtime-objects.md
          sphinx.md
          typingdoc.md
          warnings-deprecated.md
         ```
      1. ```
          docstring-inheritance.md
          fastapi.md
          fieldz.md
          generics.md
          inherited-method-crossrefs.md
          modernized-annotations.md
         ```

   1. ```
      ðŸ“ contributors/ # (1)!
      ðŸ“ users/ # (2)!
       contributors.md
       users.md
      ```

      1. ```
          architecture.md
          commands.md
          setup.md
          workflow.md
         ```
      1. ```
         ðŸ“ how-to/ # (1)!
         ðŸ“ recommendations/ # (2)!
          checking.md
          extending.md
          loading.md
          navigating.md
          serializing.md
         ```
         1. ```
             parse-docstrings.md
             selectively-inspect.md
             set-docstring-styles.md
             set-git-info.md
             support-decorators.md
            ```
         1. ```
             docstrings.md
             public-apis.md
             python-code.md
            ```

   1. ```
       favicon.ico
       gha_annotations_1.png
       gha_annotations_2.png
      ```

   1. ```
       feedback.js
      ```

   1. ```
      ðŸ“ api/ # (1)!
       api.md
       cli.md
       docstrings.md
      ```

      1. Python API reference, injected with [mkdocstrings](https://mkdocstrings.github.io/).

         ```
         ðŸ“ docstrings/ # (1)!
         ðŸ“ models/ # (2)!
          agents.md
          checks.md
          cli.md
          docstrings.md
          exceptions.md
          expressions.md
          extensions.md
          finder.md
          git.md
          helpers.md
          loaders.md
          loggers.md
          models.md
          serializers.md
         ```

         1. ```
             models.md
             parsers.md
            ```
         1. ```
             alias.md
             attribute.md
             class.md
             function.md
             module.md
             type_alias.md
            ```

1. HTML report for Python code coverage (git-ignored), integrated in the [Coverage report](../coverage/) page. See make coverage task.

1. Our different scripts. See [Scripts, configuration](#scripts-configuration).

   ```
    gen_credits.py
    gen_griffe_json.py
    gen_structure_docs.py
    get_version.py
    griffe_exts.py
    make
    make.py
   ```

1. Documentation site, built with `make run mkdocs build` (git-ignored).

1. The source of our Python package(s). See [Sources](#sources) and [Program structure](#program-structure).

   ```
   ðŸ“ griffe/ # (1)!
   ```

   1. Our public API, exposed to users. See [Program structure](#program-structure).

      ```
      ðŸ“ _internal/ # (1)!
       __init__.py
       __main__.py
       py.typed
      ```

      1. Our internal API, hidden from users. See [Program structure](#program-structure).

         ```
         ðŸ“ agents/ # (1)!
         ðŸ“ docstrings/ # (2)!
         ðŸ“ extensions/ # (3)!
          __init__.py
          c3linear.py
          cli.py
          collections.py
          debug.py
          diff.py
          encoders.py
          enumerations.py
          exceptions.py
          expressions.py
          finder.py
          git.py
          importer.py
          loader.py
          logger.py
          merger.py
          mixins.py
          models.py
          py.typed
          stats.py
          tests.py
         ```

         1. ```
            ðŸ“ nodes/ # (1)!
             __init__.py
             inspector.py
             visitor.py
            ```
            1. ```
                __init__.py
                assignments.py
                ast.py
                docstrings.py
                exports.py
                imports.py
                parameters.py
                runtime.py
                values.py
               ```
         1. ```
             __init__.py
             auto.py
             google.py
             models.py
             numpy.py
             parsers.py
             sphinx.py
             utils.py
            ```
         1. ```
             __init__.py
             base.py
             dataclasses.py
             unpack_typeddict.py
            ```

1. Our test suite. See [Tests](#tests).

   ```
   ðŸ“ fixtures/
   ðŸ“ test_docstrings/ # (1)!
   ðŸ“ test_extensions/ # (2)!
    __init__.py
    conftest.py
    helpers.py
    test_api.py
    test_cli.py
    test_diff.py
    test_encoders.py
    test_expressions.py
    test_finder.py
    test_functions.py
    test_git.py
    test_inheritance.py
    test_inspector.py
    test_loader.py
    test_merger.py
    test_mixins.py
    test_models.py
    test_nodes.py
    test_public_api.py
    test_stdlib.py
    test_visitor.py
   ```

   1. ```
       __init__.py
       conftest.py
       helpers.py
       test_google.py
       test_numpy.py
       test_sphinx.py
       test_warnings.py
      ```
   1. ```
       __init__.py
       test_base.py
       test_dataclasses.py
       test_unpack_typeddict.py
      ```

1. The answers file generated by [Copier](https://copier.readthedocs.io/en/stable/). See [Boilerplate](#boilerplate).

1. The environment configuration, automatically sourced by [direnv](https://direnv.net/). See [commands](../commands/).

1. A dummy makefile, only there for auto-completion. See [commands](../commands/).

1. Our project tasks, written with [duty](https://pawamoy.github.io/duty). See Tasks.

1. The build configuration for our docs. See make docs task.

1. The project metadata and production dependencies.

## Boilerplate

This project's skeleton (the file-tree shown above) is actually generated from a [Copier](https://copier.readthedocs.io/en/stable/) template called [copier-uv](https://pawamoy.github.io/copier-uv/). When generating the project, Copier asks a series of questions (configured by the template itself), and the answers are used to render the file and directory names, as well as the file contents. Copier also records answers in the `.copier-answers.yml` file, allowing to update the project with latest changes from the template while reusing previous answers.

To update the project (in order to apply latest changes from the template), we use the following command:

```
copier update --trust --skip-answered
```

## Scripts, configuration

We have a few scripts that let us manage the various maintenance aspects for this project. The entry-point is the `make` script located in the `scripts` folder. It doesn't need any dependency to be installed to run. See [Management commands](../commands/) for more information.

The `make` script can also invoke what we call "tasks". Tasks need our development dependencies to be installed to run. These tasks are written in the `duties.py` file, and the development dependencies are listed in `devdeps.txt`.

The tools used in tasks have their configuration files stored in the `config` folder, to unclutter the root of the repository. The tasks take care of calling the tools with the right options to locate their respective configuration files.

## Sources

Sources are located in the `src` folder, following the [src-layout](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/). We use [PDM-Backend](https://backend.pdm-project.org/) to build source and wheel distributions, and configure it in `pyproject.toml` to search for packages in the `src` folder.

## Tests

Our test suite is located in the `tests` folder. It is located outside of the sources as to not pollute distributions (it would be very wrong to publish a `tests` package as part of our distributions, since this name is extremely common), or worse, the public API. The `tests` folder is however included in our source distributions (`.tar.gz`), alongside most of our metadata and configuration files. Check out `pyproject.toml` to get the full list of files included in our source distributions.

The test suite is based on [pytest](https://docs.pytest.org/en/8.2.x/). Test modules reflect our internal API structure, and except for a few test modules that test specific aspects of our API, each test module tests the logic from the corresponding module in the internal API. For example, `test_finder.py` tests code of the `griffe._internal.finder` internal module, while `test_functions` tests our ability to extract correct information from function signatures, statically. The general rule of thumb when writing new tests is to mirror the internal API. If a test touches to many aspects of the loading process, it can be added to the `test_loader` test module.

## Program structure

The internal API is contained within the `src/griffe/_internal` folder. The top-level `griffe/__init__.py` module exposes all the public API, by importing the internal objects from various submodules of `griffe._internal`.

Users then import `griffe` directly, or import objects from it.

We'll be honest: our code organization is not the most elegant, but it works Have a look at the following module dependency graph, which will basically tell you nothing except that we have a lot of inter-module dependencies. Arrows read as "imports from". The code base is generally pleasant to work with though.

*You can zoom and pan all diagrams on this page with mouse inputs.*

The following sections are generated automatically by iterating on the modules of our public and internal APIs respectively, and extracting the comment blocks at the top of each module. The comment blocks are addressed to readers of the code (maintainers, contributors), while module docstrings are addressed to users of the API. Module docstrings in our internal API are never written, because our module layout is hidden, and therefore modules aren't part of the public API, so it doesn't make much sense to write "user documentation" in them.

### CLI entrypoint

#### `griffe.__main__`

Entry-point module, in case you use `python -m griffe`.

Why does this file exist, and why `__main__`? For more info, read:

- <https://www.python.org/dev/peps/pep-0338/>
- <https://docs.python.org/3/using/cmdline.html#cmdoption-m>

### Public API

#### `griffe`

This top-level module imports all public names from the package, and exposes them as public objects. We have tests to make sure no object is forgotten in this list.

### Internal API

The internal API layout doesn't follow any particular paradigm: we simply organize code in different modules, depending on what the code is used for.

#### `agents`

These modules contain the different agents that are able to extract data.

##### `inspector.py`

This module contains our dynamic analysis agent, capable of inspecting modules and objects in memory, at runtime.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `nodes`

These submodules contain utilities for working with AST and object nodes.

###### `assignments.py`

This module contains utilities for extracting information from assignment nodes.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `ast.py`

This module contains utilities for navigating AST nodes.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `docstrings.py`

This module contains utilities for extracting docstrings from nodes.

###### `exports.py`

This module contains utilities for extracting exports from `__all__` assignments.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `imports.py`

This module contains utilities for working with imports and relative imports.

###### `parameters.py`

This module contains utilities for extracting information from parameter nodes.

###### `runtime.py`

This module contains utilities for extracting information from runtime objects.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `values.py`

This module contains utilities for extracting attribute values.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `visitor.py`

This module contains our static analysis agent, capable of parsing and visiting sources, statically.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `c3linear.py`

This module contains a single function, `c3linear_merge`. The function is generic enough to be in its own module.

- Copyright (c) 2019 Vitaly R. Samigullin
- Adapted from <https://github.com/pilosus/c3linear>
- Adapted from <https://github.com/tristanlatr/pydocspec>

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `cli.py`

This module contains all CLI-related things. Why does this file exist, and why not put this in `__main__`?

We might be tempted to import things from `__main__` later, but that will cause problems; the code will get executed twice:

- When we run `python -m griffe`, Python will execute `__main__.py` as a script. That means there won't be any `griffe.__main__` in `sys.modules`.
- When you import `__main__` it will get executed again (as a module) because there's no `griffe.__main__` in `sys.modules`.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `collections.py`

This module contains collection-related classes, which are used throughout the API.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `debug.py`

This module is here to help users report bugs. It provides a function to print environment information, which is called from the public `griffe.debug` module (when called with `python -m griffe.debug`) or thanks to the `--debug-info` CLI flag.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `diff.py`

This module exports "breaking changes" related utilities. The logic here is to iterate on objects and their members recursively, to yield found breaking changes.

The breakage class definitions might sound a bit verbose, but declaring them this way helps with (de)serialization, which we don't use yet, but could use in the future.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `docstrings`

These submodules define models and parsers for docstrings.

##### `auto.py`

This module defines functions to parse docstrings by guessing their style.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `google.py`

This module defines functions to parse Google-style docstrings into structured data.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `models.py`

This module contains the models for storing docstrings structured data.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `numpy.py`

This module defines functions to parse Numpy-style docstrings into structured data.

Based on <https://numpydoc.readthedocs.io/en/latest/format.html>, it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification.

Rejected as non particularly Pythonic or useful as sections:

- See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup.

Rejected as naturally handled by the user-chosen markup:

- Warnings: this is just markup.
- Notes: again, just markup.
- References: again, just markup.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `parsers.py`

This module imports all the defined parsers and provides a generic function to parse docstrings.

##### `sphinx.py`

This module defines functions to parse Sphinx docstrings into structured data.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `utils.py`

This module contains utilities for docstrings parsers.

#### `encoders.py`

This module contains data encoders/serializers and decoders/deserializers. We only support JSON for now, but might want to add more formats in the future.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `enumerations.py`

This module contains all the enumerations of the package.

#### `exceptions.py`

This module contains all the exceptions specific to Griffe.

#### `expressions.py`

This module contains the data classes that represent resolvable names and expressions. First we declare data classes for each kind of expression, mostly corresponding to Python's AST nodes. Then we declare builder methods, that iterate AST nodes and build the corresponding data classes, and two utilities `_yield` and `_join` to help iterate on expressions. Finally we declare a few public helpers to safely get expressions from AST nodes in different scenarios.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `extensions`

These submodules contain our extension system, as well as built-in extensions.

##### `base.py`

This module contains the base class for extensions and the functions to load them.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `dataclasses.py`

Built-in extension adding support for dataclasses.

This extension re-creates `__init__` methods of dataclasses during static analysis.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `unpack_typeddict.py`

Todo

Support `extra_items=type`. TODO: Support `closed=True/False`.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `finder.py`

This module contains the code allowing to find modules.

Note: It might be possible to replace a good part of this module's logic with utilities from `importlib` (however the util in question is private):

```
>>> from importlib.util import _find_spec
>>> _find_spec("griffe.agents", _find_spec("griffe", None).submodule_search_locations)
ModuleSpec(
    name='griffe.agents',
    loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fa5f34e8110>,
    origin='/media/data/dev/griffe/src/griffe/agents/__init__.py',
    submodule_search_locations=['/media/data/dev/griffe/src/griffe/agents'],
)
```

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `git.py`

This module contains Git utilities, used by our load_git function, which in turn is used to load the API for different snapshots of a Git repository and find breaking changes between them.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `importer.py`

This module contains utilities to dynamically import objects. These utilities are used by our Inspector to dynamically import objects specified as Python paths, like `package.module.Class.method`.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `loader.py`

This module contains all the logic for loading API data from sources or compiled modules.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `logger.py`

This module contains the logger used throughout Griffe. The logger is actually a wrapper around the standard Python logger. We wrap it so that it is easier for other downstream libraries to patch it. For example, mkdocstrings-python patches the logger to relocate it as a child of `mkdocs.plugins` so that it fits in the MkDocs logging configuration.

We use a single, global logger because our public API is exposed in a single module, `griffe`. Extensions however should use their own logger, which is why we provide the `get_logger` function.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `merger.py`

This module contains utilities to merge stubs data and concrete data.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `mixins.py`

This module contains some mixins classes that hold shared methods of the different kinds of objects, and aliases.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `models.py`

This module contains our models definitions, to represent Python objects (and other aspects of Python APIs)... in Python.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `stats.py`

This module contains utilities to compute loading statistics, like time spent visiting modules statically or dynamically.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `tests.py`

This module contains helpers. They simplify programmatic use of Griffe, for example to load data from strings or to create temporary packages. They are particularly useful for our own tests suite.

xml version="1.0" encoding="UTF-8" standalone="no"?

# Management commands

The entry-point to run commands to manage the project is our Python `make` script, located in the `scripts` folder. You can either call it directly with `./scripts/make`, or you can use [direnv](https://direnv.net/) to add the script to your command line path. Once direnv is installed and hooked into your shell, allow it once for this directory with `direnv allow`. Now you can directly call the Python script with `make`. The `Makefile` is just here to provide auto-completion.

Try typing `make` or `make help` to show the available commands.

```
$ make
Available commands
  help                  Print this help. Add task name to print help.
  setup                 Setup all virtual environments (install dependencies).
  run                   Run a command in the default virtual environment.
  multirun              Run a command for all configured Python versions.
  allrun                Run a command in all virtual environments.
  3.x                   Run a command in the virtual environment for Python 3.x.
  clean                 Delete build artifacts and cache files.
  vscode                Configure VSCode to work on this project.
```

## Commands

Commands are always available: they don't require any Python dependency to be installed.

### `setup`

Setup all virtual environments (install dependencies).

```
make setup
```

The `setup` command installs all the Python dependencies required to work on the project. Virtual environments and dependencies are managed by [uv](https://github.com/astral-sh/uv). Development dependencies are listed in the `devdeps.txt` file.

The command will create a virtual environment in the `.venv` folder, as well as one virtual environment per supported Python version in the `.venvs/3.x` folders. Supported Python versions are listed in the `scripts/make` file, and can be overridden by setting the `PYTHON_VERSIONS` environment variable.

If you cloned the repository on the same file-system as uv's cache, everything will be hard linked from the cache, so don't worry about wasting disk space.

Once dependencies are installed, try running `make` or `make help` again, to show additional tasks.

```
$ make
Available commands
  help                  Print this help. Add task name to print help.
  setup                 Setup all virtual environments (install dependencies).
  run                   Run a command in the default virtual environment.
  multirun              Run a command for all configured Python versions.
  allrun                Run a command in all virtual environments.
  3.x                   Run a command in the virtual environment for Python 3.x.
  clean                 Delete build artifacts and cache files.
  vscode                Configure VSCode to work on this project.

Available tasks
  build                 Build source and wheel distributions.
  changelog             Update the changelog in-place with latest commits.
  check                 Check it all!
  check-api             Check for API breaking changes.
  check-docs            Check if the documentation builds correctly.
  check-quality         Check the code quality.
  check-types           Check that the code is correctly typed.
  coverage              Report coverage as text and HTML.
  docs                  Serve the documentation (localhost:8000).
  docs-deploy           Deploy the documentation to GitHub pages.
  format                Run formatting tools on the code.
  fuzz                  Fuzz Griffe against generated Python code.
  publish               Publish source and wheel distributions to PyPI.
  release               Release a new version of the project.
  test                  Run the test suite.
```

These tasks are written using [duty](https://github.com/pawamoy/duty) (a task runner), and located in the `duties.py` module in the repository root.

Some of these tasks will run in the default virtual environment (`.venv`), while others will run in all the supported Python version environments (`.venvs/3.x`).

Source code in `scripts/make.py`

````
@_command("setup")
def setup() -> None:
    """Setup all virtual environments (install dependencies).

    ```bash
    make setup
    ```

    The `setup` command installs all the Python dependencies required to work on the project.
    Virtual environments and dependencies are managed by [uv](https://github.com/astral-sh/uv).
    Development dependencies are listed in the `devdeps.txt` file.

    The command will create a virtual environment in the `.venv` folder,
    as well as one virtual environment per supported Python version in the `.venvs/3.x` folders.
    Supported Python versions are listed in the `scripts/make` file, and can be overridden
    by setting the `PYTHON_VERSIONS` environment variable.

    If you cloned the repository on the same file-system as uv's cache,
    everything will be hard linked from the cache, so don't worry about wasting disk space.

    Once dependencies are installed, try running `make` or `make help` again, to show additional tasks.

    ```console exec="1" source="console" id="make-help2"
    $ alias make="$PWD/scripts/make"  # markdown-exec: hide
    $ make
    ```

    These tasks are written using [duty](https://github.com/pawamoy/duty) (a task runner),
    and located in the `duties.py` module in the repository root.

    Some of these tasks will run in the default virtual environment (`.venv`),
    while others will run in all the supported Python version environments (`.venvs/3.x`).
    """
    if not shutil.which("uv"):
        raise ValueError("make: setup: uv must be installed, see https://github.com/astral-sh/uv")

    print("Installing dependencies (default environment)")
    default_venv = Path(".venv")
    if not default_venv.exists():
        _shell("uv venv --python python")
    _uv_install(default_venv)

    if PYTHON_VERSIONS:
        for version in PYTHON_VERSIONS:
            print(f"\nInstalling dependencies (python{version})")
            venv_path = Path(f".venvs/{version}")
            if not venv_path.exists():
                _shell(f"uv venv --python {version} {venv_path}")
            with _environ(VIRTUAL_ENV=str(venv_path.resolve())):
                _uv_install(venv_path)
````

### `help`

Print this help. Add task name to print help.

```
make help [TASK]
```

When the Python dependencies are not installed, this command just print the available commands. When the Python dependencies are installed, [duty](https://github.com/pawamoy/duty) is available so the command can also print the available tasks.

If you add a task name after the command, it will print help for this specific task.

Source code in `scripts/make.py`

````
@_command("help")
def help(*args: str) -> None:
    """Print this help. Add task name to print help.

    ```bash
    make help [TASK]
    ```

    When the Python dependencies are not installed,
    this command just print the available commands.
    When the Python dependencies are installed,
    [duty](https://github.com/pawamoy/duty) is available
    so the command can also print the available tasks.

    If you add a task name after the command, it will print help for this specific task.
    """
    if len(args) > 1:
        _run("default", "duty", "--help", args[1])
    else:
        print("Available commands", flush=True)
        for cmd in _commands:
            print(f"  {cmd.__cmdname__:21} {cmd.__doc__.splitlines()[0]}", flush=True)  # type: ignore[attr-defined,union-attr]
        if Path(".venv").exists():
            print("\nAvailable tasks", flush=True)
            run("duty", "--list")
````

### `run`

Run a command in the default virtual environment.

```
make run <CMD> [ARG...]
```

This command runs an arbitrary command inside the default virtual environment (`.venv`). It is especially useful to start a Python interpreter without having to first activate the virtual environment: `make run python`.

Source code in `scripts/make.py`

````
@_command("run")
def run(cmd: str, *args: str, **kwargs: Any) -> None:
    """Run a command in the default virtual environment.

    ```bash
    make run <CMD> [ARG...]
    ```

    This command runs an arbitrary command inside the default virtual environment (`.venv`).
    It is especially useful to start a Python interpreter without having to first activate
    the virtual environment: `make run python`.
    """
    _run("default", cmd, *args, **kwargs)
````

### `multirun`

Run a command for all configured Python versions.

```
make multirun <CMD> [ARG...]
```

This command runs an arbitrary command inside the environments for all supported Python versions. It is especially useful for running tests.

Source code in `scripts/make.py`

````
@_command("multirun")
def multirun(cmd: str, *args: str, **kwargs: Any) -> None:
    """Run a command for all configured Python versions.

    ```bash
    make multirun <CMD> [ARG...]
    ```

    This command runs an arbitrary command inside the environments
    for all supported Python versions. It is especially useful for running tests.
    """
    if PYTHON_VERSIONS:
        for version in PYTHON_VERSIONS:
            run3x(version, cmd, *args, **kwargs)
    else:
        run(cmd, *args, **kwargs)
````

### `allrun`

Run a command in all virtual environments.

```
make multirun <CMD> [ARG...]
```

This command runs an arbitrary command inside the default environment, as well as the environments for all supported Python versions.

This command is especially useful to install, remove or update dependencies in all environments at once. For example, if you want to install a dependency in editable mode, from a local source:

```
make allrun uv pip install -e ../other-project
```

Source code in `scripts/make.py`

````
@_command("allrun")
def allrun(cmd: str, *args: str, **kwargs: Any) -> None:
    """Run a command in all virtual environments.

    ```bash
    make multirun <CMD> [ARG...]
    ```

    This command runs an arbitrary command inside the default environment,
    as well as the environments for all supported Python versions.

    This command is especially useful to install, remove or update dependencies
    in all environments at once. For example, if you want to install a dependency
    in editable mode, from a local source:

    ```bash
    make allrun uv pip install -e ../other-project
    ```
    """
    run(cmd, *args, **kwargs)
    if PYTHON_VERSIONS:
        multirun(cmd, *args, **kwargs)
````

### `3.x`

Run a command in the virtual environment for Python 3.x.

```
make 3.x <CMD> [ARG...]
```

This command runs an arbitrary command inside the environment of the selected Python version. It can be useful if you want to run a task that usually runs in the default environment with a different Python version.

Source code in `scripts/make.py`

````
@_command("3.x")
def run3x(version: str, cmd: str, *args: str, **kwargs: Any) -> None:
    """Run a command in the virtual environment for Python 3.x.

    ```bash
    make 3.x <CMD> [ARG...]
    ```

    This command runs an arbitrary command inside the environment of the selected Python version.
    It can be useful if you want to run a task that usually runs in the default environment
    with a different Python version.
    """
    _run(version, cmd, *args, **kwargs)
````

### `clean`

Delete build artifacts and cache files.

```
make clean
```

This command simply deletes build artifacts and cache files and folders such as `build/`, `.cache/`, etc.. The virtual environments (`.venv` and `.venvs/*`) are not removed by this command.

Source code in `scripts/make.py`

````
@_command("clean")
def clean() -> None:
    """Delete build artifacts and cache files.

    ```bash
    make clean
    ```

    This command simply deletes build artifacts and cache files and folders
    such as `build/`, `.cache/`, etc.. The virtual environments (`.venv` and `.venvs/*`)
    are not removed by this command.
    """
    paths_to_clean = ["build", "dist", "htmlcov", "site", ".coverage*", ".pdm-build"]
    for path in paths_to_clean:
        _shell(f"rm -rf {path}")

    cache_dirs = [".cache", ".pytest_cache", ".mypy_cache", ".ruff_cache", "__pycache__"]
    for dirpath in Path().rglob("*/"):
        if dirpath.parts[0] not in (".venv", ".venvs") and dirpath.name in cache_dirs:
            shutil.rmtree(dirpath, ignore_errors=True)
````

### `vscode`

Configure VSCode to work on this project.

```
make vscode
```

This command configures the [VSCode editor](https://code.visualstudio.com/) by copying the following files into the `.vscode` directory:

- `launch.json`, for run configurations (to run debug sessions)
- `settings.json`, for various editor settings like linting tools and their configuration
- `tasks.json`, for running tasks directly from VSCode's interface

Warning: These files will be overwritten every time the command is run.

Source code in `scripts/make.py`

````
@_command("vscode")
def vscode() -> None:
    """Configure VSCode to work on this project.

    ```bash
    make vscode
    ```

    This command configures the [VSCode editor](https://code.visualstudio.com/)
    by copying the following files into the `.vscode` directory:

    - `launch.json`, for run configurations (to run debug sessions)
    - `settings.json`, for various editor settings like linting tools and their configuration
    - `tasks.json`, for running tasks directly from VSCode's interface

    Warning:
        These files will be overwritten every time the command is run.
    """
    Path(".vscode").mkdir(parents=True, exist_ok=True)
    _shell("cp -v config/vscode/* .vscode")
````

## Tasks

Tasks require the Python dependencies to be installed. They use various tools and libraries to assert code quality, run tests, serve the documentation locally, or build and publish distributions of your project. There are multiple ways to run tasks:

- `make TASK`, the main, configured way to run a task
- `make run duty TASK`, to run a task in the default environment
- `make multirun duty TASK`, to run a task on all supported Python versions
- `make allrun duty TASK`, to run a task in *all* environments
- `make 3.x duty TASK`, to run a task on a specific Python version

### `build`

Build source and wheel distributions.

```
make build
```

Build distributions of your project for the current version. The build task uses the [`build` tool](https://build.pypa.io/en/stable/) to build `.tar.gz` (Gzipped sources archive) and `.whl` (wheel) distributions of your project in the `dist` directory.

Source code in `duties.py`

````
@duty
def build(ctx: Context) -> None:
    """Build source and wheel distributions.

    ```bash
    make build
    ```

    Build distributions of your project for the current version.
    The build task uses the [`build` tool](https://build.pypa.io/en/stable/)
    to build `.tar.gz` (Gzipped sources archive) and `.whl` (wheel) distributions
    of your project in the `dist` directory.
    """
    ctx.run(
        tools.build(),
        title="Building source and wheel distributions",
        pty=PTY,
    )
````

### `changelog`

Update the changelog in-place with latest commits.

```
make changelog [bump=VERSION]
```

Update the changelog in-place. The changelog task uses [git-changelog](https://pawamoy.github.io/git-changelog/) to read Git commits and parse their messages to infer the new version based on our commit message convention.

The new version will be based on the types of the latest commits, unless a specific version is provided with the `bump` parameter.

If the group of commits contains only bug fixes (`fix:`) and/or commits that are not interesting for users (`chore:`, `style:`, etc.), the changelog will gain a new **patch** entry. It means that the new suggested version will be a patch bump of the previous one: `0.1.1` becomes `0.1.2`.

If the group of commits contains at least one feature (`feat:`), the changelog will gain a new **minor** entry. It means that the new suggested version will be a minor bump of the previous one: `0.1.1` becomes `0.2.0`.

If there is, in the group of commits, a commit whose body contains something like `Breaking change`, the changelog will gain a new **major** entry, unless the version is still an "alpha" version (starting with 0), in which case it gains a **minor** entry. It means that the new suggested version will be a major bump of the previous one: `1.2.1` becomes `2.0.0`, but `0.2.1` is only bumped up to `0.3.0`. Moving from "alpha" status to "beta" or "stable" status is a choice left to the developers, when they consider the package is ready for it.

The configuration for git-changelog is located at `config/git-changelog.toml`.

Parameters:

- **`bump`** (`str`, default: `''` ) â€“ Bump option passed to git-changelog.

Source code in `duties.py`

````
@duty
def changelog(ctx: Context, bump: str = "") -> None:
    """Update the changelog in-place with latest commits.

    ```bash
    make changelog [bump=VERSION]
    ```

    Update the changelog in-place. The changelog task uses [git-changelog](https://pawamoy.github.io/git-changelog/)
    to read Git commits and parse their messages to infer the new version based
    on our [commit message convention][commit-message-convention].

    The new version will be based on the types of the latest commits,
    unless a specific version is provided with the `bump` parameter.

    If the group of commits contains only bug fixes (`fix:`)
    and/or commits that are not interesting for users (`chore:`, `style:`, etc.),
    the changelog will gain a new **patch** entry.
    It means that the new suggested version will be a patch bump
    of the previous one: `0.1.1` becomes `0.1.2`.

    If the group of commits contains at least one feature (`feat:`),
    the changelog will gain a new **minor** entry.
    It means that the new suggested version will be a minor bump
    of the previous one: `0.1.1` becomes `0.2.0`.

    If there is, in the group of commits, a commit whose body contains something like `Breaking change`,
    the changelog will gain a new **major** entry, unless the version is still an "alpha" version (starting with 0),
    in which case it gains a **minor** entry.
    It means that the new suggested version will be a major bump
    of the previous one: `1.2.1` becomes `2.0.0`, but `0.2.1` is only bumped up to `0.3.0`.
    Moving from "alpha" status to "beta" or "stable" status is a choice left to the developers,
    when they consider the package is ready for it.

    The configuration for git-changelog is located at `config/git-changelog.toml`.

    Parameters:
        bump: Bump option passed to git-changelog.
    """
    ctx.run(tools.git_changelog(bump=bump or None), title="Updating changelog")
    ctx.run(tools.yore.check(bump=bump or _get_changelog_version()), title="Checking legacy code")
````

### `check`

Check it all!

```
make check
```

Composite command to run all the check commands:

- check-quality, to check the code quality on all Python versions
- check-types, to type-check the code on all Python versions
- check-docs, to check the docs on all Python versions
- check-api, to check for API breaking changes

Source code in `duties.py`

````
@duty(pre=["check-quality", "check-types", "check-docs", "check-api"])
def check(ctx: Context) -> None:
    """Check it all!

    ```bash
    make check
    ```

    Composite command to run all the check commands:

    - [`check-quality`][], to check the code quality on all Python versions
    - [`check-types`][], to type-check the code on all Python versions
    - [`check-docs`][], to check the docs on all Python versions
    - [`check-api`][], to check for API breaking changes
    """
````

### `check-api`

Check for API breaking changes.

```
make check-api
```

Compare the current code to the latest version (Git tag) using [Griffe](https://mkdocstrings.github.io/griffe/), to search for API breaking changes since latest version. It is set to allow failures, and is more about providing information than preventing CI to pass.

Parameters:

- **`*cli_args`** (`str`, default: `()` ) â€“ Additional Griffe CLI arguments.

Source code in `duties.py`

````
@duty(nofail=PY_VERSION == PY_DEV)
def check_api(ctx: Context, *cli_args: str) -> None:
    """Check for API breaking changes.

    ```bash
    make check-api
    ```

    Compare the current code to the latest version (Git tag)
    using [Griffe](https://mkdocstrings.github.io/griffe/),
    to search for API breaking changes since latest version.
    It is set to allow failures, and is more about providing information
    than preventing CI to pass.

    Parameters:
        *cli_args: Additional Griffe CLI arguments.
    """
    ctx.run(
        tools.griffe.check(
            "griffe",
            search=["src"],
            color=True,
            extensions=[
                "griffe_inherited_docstrings",
                # YORE: Bump 2: Remove line.
                "scripts/griffe_exts.py",
                "unpack_typeddict",
            ],
        ).add_args(*cli_args),
        title="Checking for API breaking changes",
        nofail=True,
    )
````

### `check-docs`

Check if the documentation builds correctly.

```
make check-docs
```

Build the docs with [MkDocs](https://www.mkdocs.org/) in strict mode.

The configuration for MkDocs is located at `mkdocs.yml`.

This task builds the documentation with strict behavior: any warning will be considered an error and the command will fail. The warnings/errors can be about incorrect docstring format, or invalid cross-references.

Source code in `duties.py`

````
@duty(nofail=PY_VERSION == PY_DEV)
def check_docs(ctx: Context) -> None:
    """Check if the documentation builds correctly.

    ```bash
    make check-docs
    ```

    Build the docs with [MkDocs](https://www.mkdocs.org/) in strict mode.

    The configuration for MkDocs is located at `mkdocs.yml`.

    This task builds the documentation with strict behavior:
    any warning will be considered an error and the command will fail.
    The warnings/errors can be about incorrect docstring format,
    or invalid cross-references.
    """
    Path("htmlcov").mkdir(parents=True, exist_ok=True)
    Path("htmlcov/index.html").touch(exist_ok=True)
    if CI:
        os.environ["DEPLOY"] = "true"
    with _material_insiders():
        ctx.run(
            tools.mkdocs.build(strict=True, verbose=True),
            title=_pyprefix("Building documentation"),
        )
````

### `check-quality`

Check the code quality.

```
make check-quality
```

Check the code quality using [Ruff](https://astral.sh/ruff).

The configuration for Ruff is located at `config/ruff.toml`. In this file, you can deactivate rules or activate others to customize your analysis. Rule identifiers always start with one or more capital letters, like `D`, `S` or `BLK`, then followed by a number.

You can ignore a rule on a specific code line by appending a `noqa` comment ("no quality analysis/assurance"):

src/your_package/module.py

```
print("a code line that triggers a Ruff warning")  # noqa: ID
```

...where ID is the identifier of the rule you want to ignore for this line.

Example:

src/your_package/module.py

```
import subprocess
```

````
```console
$ make check-quality
âœ— Checking code quality (1)
> ruff check --config=config/ruff.toml src/ tests/ scripts/
src/your_package/module.py:2:1: S404 Consider possible security implications associated with subprocess module.
````

Now add a comment to ignore this warning.

```python title="src/your_package/module.py"
import subprocess  # noqa: S404
```

```console
$ make check-quality
âœ“ Checking code quality
```

You can disable multiple different warnings on a single line by separating them with commas, for example `# noqa: D300,D301`.

```

You can disable a warning globally by adding its ID
into the list in `config/ruff.toml`.

You can also disable warnings per file, like so:

config/ruff.toml

```

[per-file-ignores] "src/your_package/your_module.py" = [ "T201", # Print statement ]

```


Source code in `duties.py`

```

@duty(nofail=PY_VERSION == PY_DEV) def check_quality(ctx: Context) -> None: """Check the code quality.

````
```bash
make check-quality
```

Check the code quality using [Ruff](https://astral.sh/ruff).

The configuration for Ruff is located at `config/ruff.toml`.
In this file, you can deactivate rules or activate others to customize your analysis.
Rule identifiers always start with one or more capital letters, like `D`, `S` or `BLK`,
then followed by a number.

You can ignore a rule on a specific code line by appending
a `noqa` comment ("no quality analysis/assurance"):

```python title="src/your_package/module.py"
print("a code line that triggers a Ruff warning")  # noqa: ID
```

...where ID is the identifier of the rule you want to ignore for this line.

Example:
    ```python title="src/your_package/module.py"
    import subprocess
    ```

    ```console
    $ make check-quality
    âœ— Checking code quality (1)
    > ruff check --config=config/ruff.toml src/ tests/ scripts/
    src/your_package/module.py:2:1: S404 Consider possible security implications associated with subprocess module.
    ```

    Now add a comment to ignore this warning.

    ```python title="src/your_package/module.py"
    import subprocess  # noqa: S404
    ```

    ```console
    $ make check-quality
    âœ“ Checking code quality
    ```

    You can disable multiple different warnings on a single line
    by separating them with commas, for example `# noqa: D300,D301`.

You can disable a warning globally by adding its ID
into the list in `config/ruff.toml`.

You can also disable warnings per file, like so:

```toml title="config/ruff.toml"
[per-file-ignores]
"src/your_package/your_module.py" = [
    "T201",  # Print statement
]
```
"""
ctx.run(
    tools.ruff.check(*PY_SRC_LIST, config="config/ruff.toml"),
    title=_pyprefix("Checking code quality"),
)
````

```

### `check-types`

Check that the code is correctly typed.

```

make check-types

```

Run type-checking on the code with [Mypy](https://mypy.readthedocs.io/).

The configuration for Mypy is located at `config/mypy.ini`.

If you cannot or don't know how to fix a typing error in your code,
as a last resort you can ignore this specific error with a comment:

src/your_package/module.py

```

print("a code line that triggers a Mypy warning") # type: ignore[ID]

```

...where ID is the name of the warning.

Example:

src/your_package/module.py

```

result = data_dict.get(key, None).value

```

```

```console
$ make check-types
âœ— Checking types (1)
> mypy --config-file=config/mypy.ini src/ tests/ scripts/
src/your_package/module.py:2:1: Item "None" of "Data | None" has no attribute "value" [union-attr]
```

Now add a comment to ignore this warning.

```python title="src/your_package/module.py"
result = data_dict.get(key, None).value  # type: ignore[union-attr]
```

```console
$ make check-types
âœ“ Checking types
```

```


Source code in `duties.py`

```

@duty(nofail=PY_VERSION == PY_DEV) def check_types(ctx: Context) -> None: """Check that the code is correctly typed.

````
```bash
make check-types
```

Run type-checking on the code with [Mypy](https://mypy.readthedocs.io/).

The configuration for Mypy is located at `config/mypy.ini`.

If you cannot or don't know how to fix a typing error in your code,
as a last resort you can ignore this specific error with a comment:

```python title="src/your_package/module.py"
print("a code line that triggers a Mypy warning")  # type: ignore[ID]
```

...where ID is the name of the warning.

Example:
    ```python title="src/your_package/module.py"
    result = data_dict.get(key, None).value
    ```

    ```console
    $ make check-types
    âœ— Checking types (1)
    > mypy --config-file=config/mypy.ini src/ tests/ scripts/
    src/your_package/module.py:2:1: Item "None" of "Data | None" has no attribute "value" [union-attr]
    ```

    Now add a comment to ignore this warning.

    ```python title="src/your_package/module.py"
    result = data_dict.get(key, None).value  # type: ignore[union-attr]
    ```

    ```console
    $ make check-types
    âœ“ Checking types
    ```
"""
os.environ["FORCE_COLOR"] = "1"
ctx.run(
    tools.mypy(*PY_SRC_LIST, config_file="config/mypy.ini"),
    title=_pyprefix("Type-checking"),
)
````

```

### `coverage`

Report coverage as text and HTML.

```

make coverage

```

Combine coverage data from multiple test runs with [Coverage.py](https://coverage.readthedocs.io/),
then generate an HTML report into the `htmlcov` directory,
and print a text report in the console.


Source code in `duties.py`

```

@duty(silent=True, aliases=["cov"]) def coverage(ctx: Context) -> None: """Report coverage as text and HTML.

````
```bash
make coverage
```

Combine coverage data from multiple test runs with [Coverage.py](https://coverage.readthedocs.io/),
then generate an HTML report into the `htmlcov` directory,
and print a text report in the console.
"""
ctx.run(tools.coverage.combine(), nofail=True)
ctx.run(tools.coverage.report(rcfile="config/coverage.ini"), capture=False)
ctx.run(tools.coverage.html(rcfile="config/coverage.ini"))
````

```

### `docs`

Serve the documentation (localhost:8000).

```

make docs

```

This task uses [MkDocs](https://www.mkdocs.org/) to serve the documentation locally.

Parameters:

- **`*cli_args`**
  (`str`, default:
  `()`
  )
  â€“
  Additional MkDocs CLI arguments.
- **`host`**
  (`str`, default:
  `'127.0.0.1'`
  )
  â€“
  The host to serve the docs from.
- **`port`**
  (`int`, default:
  `8000`
  )
  â€“
  The port to serve the docs on.


Source code in `duties.py`

```

@duty def docs(ctx: Context, \*cli_args: str, host: str = "127.0.0.1", port: int = 8000) -> None: """Serve the documentation (localhost:8000).

````
```bash
make docs
```

This task uses [MkDocs](https://www.mkdocs.org/) to serve the documentation locally.

Parameters:
    *cli_args: Additional MkDocs CLI arguments.
    host: The host to serve the docs from.
    port: The port to serve the docs on.
"""
with _material_insiders():
    ctx.run(
        tools.mkdocs.serve(dev_addr=f"{host}:{port}").add_args(*cli_args),
        title="Serving documentation",
        capture=False,
    )
````

```

### `docs-deploy`

Deploy the documentation to GitHub pages.

```

make docs-deploy

```

Use [MkDocs](https://www.mkdocs.org/) to build and deploy the documentation to GitHub pages.


Source code in `duties.py`

```

@duty def docs_deploy(ctx: Context) -> None: """Deploy the documentation to GitHub pages.

````
```bash
make docs-deploy
```

Use [MkDocs](https://www.mkdocs.org/) to build and deploy the documentation to GitHub pages.
"""
os.environ["DEPLOY"] = "true"
with _material_insiders() as insiders:
    if not insiders:
        ctx.run(lambda: False, title="Not deploying docs without Material for MkDocs Insiders!")
    ctx.run(tools.mkdocs.gh_deploy(force=True), title="Deploying documentation")
````

```

### `format`

Run formatting tools on the code.

```

make format

```

Format the code with [Ruff](https://astral.sh/ruff).
This command will also automatically fix some coding issues when possible.


Source code in `duties.py`

```

@duty def format(ctx: Context) -> None: """Run formatting tools on the code.

````
```bash
make format
```

Format the code with [Ruff](https://astral.sh/ruff).
This command will also automatically fix some coding issues when possible.
"""
ctx.run(
    tools.ruff.check(*PY_SRC_LIST, config="config/ruff.toml", fix_only=True, exit_zero=True),
    title="Auto-fixing code",
)
ctx.run(tools.ruff.format(*PY_SRC_LIST, config="config/ruff.toml"), title="Formatting code")
````

```

### `fuzz`

Fuzz Griffe against generated Python code.

Parameters:

- **`ctx`**
  (`Context`)
  â€“
  The context instance (passed automatically).
- **`size`**
  (`int`, default:
  `20`
  )
  â€“
  The size of the case set (number of cases to test).
- **`seeds`**
  (`_Seeds`, default:
  `_Seeds()`
  )
  â€“
  Seeds to test or exclude (comma-separated integers).
- **`min_seed`**
  (`int`, default:
  `0`
  )
  â€“
  Minimum value for the seeds range.
- **`max_seed`**
  (`int`, default:
  `1000000`
  )
  â€“
  Maximum value for the seeds range.


Source code in `duties.py`

```

@duty def fuzz( ctx: Context, \*, size: int = 20, min_seed: int = 0, max_seed: int = 1_000_000, seeds: \_Seeds = \_Seeds(), # noqa: B008 ) -> None: """Fuzz Griffe against generated Python code.

```
Parameters:
    ctx: The context instance (passed automatically).
    size: The size of the case set (number of cases to test).
    seeds: Seeds to test or exclude (comma-separated integers).
    min_seed: Minimum value for the seeds range.
    max_seed: Maximum value for the seeds range.
"""
from griffe import visit  # noqa: PLC0415

warnings.simplefilter("ignore", SyntaxWarning)

def fails(code: str, filepath: Path) -> bool:
    try:
        visit(filepath.stem, filepath=filepath, code=code)
    except Exception:  # noqa: BLE001
        return True
    return False

def test_seed(seed: int, revisit: bool = False) -> bool:  # noqa: FBT001,FBT002
    filepath = Path(gettempdir(), f"fuzz_{seed}_{sys.version_info.minor}.py")
    if filepath.exists():
        if revisit:
            code = filepath.read_text()
        else:
            return True
    else:
        code = generate(seed)
        filepath.write_text(code)

    if fails(code, filepath):
        new_code = minimize(code, partial(fails, filepath=filepath))
        if code != new_code:
            filepath.write_text(new_code)
        return False
    return True

revisit = bool(seeds)
seeds = seeds or sample(range(min_seed, max_seed + 1), size)  # type: ignore[assignment]
for seed in seeds:
    ctx.run(test_seed, args=[seed, revisit], title=f"Visiting code generated with seed {seed}")
```

```

### `publish`

Publish source and wheel distributions to PyPI.

```

make publish

```

Publish the source and wheel distributions of your project to PyPI
using [Twine](https://twine.readthedocs.io/).


Source code in `duties.py`

```

@duty def publish(ctx: Context) -> None: """Publish source and wheel distributions to PyPI.

````
```bash
make publish
```

Publish the source and wheel distributions of your project to PyPI
using [Twine](https://twine.readthedocs.io/).
"""
if not Path("dist").exists():
    ctx.run("false", title="No distribution files found")
dists = [str(dist) for dist in Path("dist").iterdir()]
ctx.run(
    tools.twine.upload(*dists, skip_existing=True),
    title="Publishing source and wheel distributions to PyPI",
    pty=PTY,
)
````

```

### `release`

Release a new version of the project.

```

make release [version=VERSION]

```

This task will:

- Stage changes to `pyproject.toml` and `CHANGELOG.md`
- Commit the changes with a message like `chore: Prepare release 1.0.0`
- Tag the commit with the new version number
- Push the commit and the tag to the remote repository
- Build source and wheel distributions
- Publish the distributions to PyPI
- Deploy the documentation to GitHub pages

Parameters:

- **`version`**
  (`str`, default:
  `''`
  )
  â€“
  The new version number to use. If not provided, you will be prompted for it.


Source code in `duties.py`

```

@duty(post=["build", "publish", "docs-deploy"]) def release(ctx: Context, version: str = "") -> None: """Release a new version of the project.

````
```bash
make release [version=VERSION]
```

This task will:

- Stage changes to `pyproject.toml` and `CHANGELOG.md`
- Commit the changes with a message like `chore: Prepare release 1.0.0`
- Tag the commit with the new version number
- Push the commit and the tag to the remote repository
- Build source and wheel distributions
- Publish the distributions to PyPI
- Deploy the documentation to GitHub pages

Parameters:
    version: The new version number to use. If not provided, you will be prompted for it.
"""
if not (version := (version or input("> Version to release: ")).strip()):
    ctx.run("false", title="A version must be provided")
ctx.run("git add pyproject.toml CHANGELOG.md", title="Staging files", pty=PTY)
ctx.run(["git", "commit", "-m", f"chore: Prepare release {version}"], title="Committing changes", pty=PTY)
ctx.run(f"git tag -m '' -a {version}", title="Tagging commit", pty=PTY)
ctx.run("git push", title="Pushing commits", pty=False)
ctx.run("git push --tags", title="Pushing tags", pty=False)
````

```

### `test`

Run the test suite.

```

make test

```

Run the test suite with [Pytest](https://docs.pytest.org/) and plugins.
Code source coverage is computed thanks to
[coveragepy](https://coverage.readthedocs.io/en/coverage-5.1/).

Parameters:

- **`*cli_args`**
  (`str`, default:
  `()`
  )
  â€“
  Additional Pytest CLI arguments.


Source code in `duties.py`

```

@duty(nofail=PY_VERSION == PY_DEV) def test(ctx: Context, \*cli_args: str) -> None: """Run the test suite.

````
```bash
make test
```

Run the test suite with [Pytest](https://docs.pytest.org/) and plugins.
Code source coverage is computed thanks to
[coveragepy](https://coverage.readthedocs.io/en/coverage-5.1/).

Parameters:
    *cli_args: Additional Pytest CLI arguments.
"""
os.environ["COVERAGE_FILE"] = f".coverage.{PY_VERSION}"
os.environ["PYTHONWARNDEFAULTENCODING"] = "1"
ctx.run(
    tools.pytest(
        "tests",
        config_file="config/pytest.ini",
        color="yes",
    ).add_args("-n", "auto", *cli_args),
    title=_pyprefix("Running tests"),
)
````

```
```

# Environment setup

To work on the project, whether to update the code or the documentation, you will have to setup a development environment.

## Requirements

The only requirement is that you have [Python](https://www.python.org/) and [uv](https://docs.astral.sh/uv/) installed and available on your command line path.

```
curl -LsSf https://astral.sh/uv/install.sh | sh
```

See [Installation methods](https://docs.astral.sh/uv/getting-started/installation/).

```
pip install --user uv
```

[pip](https://pip.pypa.io/en/stable/) is the main package installer for Python.

```
pipx install uv
```

[pipx](https://pipx.pypa.io/stable/) allows to install and run Python applications in isolated environments.

```
rye install uv
```

[Rye](https://rye.astral.sh/) is an all-in-one solution for Python project management, written in Rust.

Optionally, we recommend using [direnv](https://direnv.net/), which will add our `scripts` folder to your path when working on the project, allowing to call our `make` Python script with the usual `make` command.

## Fork and clone

[Fork the repository on GitHub](https://github.com/mkdocstrings/griffe/fork), then clone it locally:

```
gh repo clone griffe
```

The [`gh` GitHub CLI](https://cli.github.com/) allows you to interact with GitHub on the command line.

```
git clone git@github.com:your-username/griffe
```

See the documentation on GitHub for [Connecting with SSH](https://docs.github.com/en/authentication/connecting-to-github-with-ssh) and for [Cloning a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository).

```
git clone https://github.com/your-username/griffe
```

See the documentation on GitHub for [Cloning a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository).

## Install dependencies

First, enter the repository.

If you installed [direnv](https://direnv.net/):

- run `direnv allow`
- run `make setup`

If you didn't install [direnv](https://direnv.net/), just run `./scripts/make setup`.

The setup command will install all the Python dependencies required to work on the project. This command will create a virtual environment in the `.venv` folder, as well as one virtual environment per supported Python version in the `.venvs/3.x` folders. If you cloned the repository on the same file-system as [uv](https://docs.astral.sh/uv/)'s cache, everything will be hard linked from the cache, so don't worry about wasting disk space.

## IDE setup

If you work in VSCode, we provide [a command to configure VSCode](../commands/#vscode) for the project.

# Development workflow

This document describes our workflow when developing features, fixing bugs and updating the documentation. It also includes guidelines for pull requests on GitHub.

## Features and bug fixes

The development worklow is rather usual.

**For a new feature:**

1. create a new branch: `git switch -c feat-summary`
1. edit the code and the documentation
1. write new tests

**For a bug fix:**

1. create a new branch: `git switch -c fix-summary`
1. write tests that fail but are expected to pass once the bug is fixed
1. run make test to make sure the new tests fail
1. fix the code

**For a docs update:**

1. create a new branch: `git switch -c docs-summary`

1. start the live reloading server: `make docs` (1)

1. update the documentation

1. preview changes at <http://localhost:8000>

1. To speed-up the live reloading, disable mkdocstrings with `MKDOCSTRINGS_ENABLED=false make docs`.

**Before committing:**

1. run make format to auto-format the code
1. run make check to check everything (fix any warning)
1. run make test to run the tests (fix any issue)
1. if you updated the documentation or the project dependencies:
   1. run make docs
   1. go to <http://localhost:8000> and check that everything looks good

Once you are ready to commit, follow our [commit message convention](#commit-message-convention).

Occasional contributors

If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.

## Breaking changes and deprecations

Breaking changes should generally be avoided. If we decide to add a breaking change anyway, we should first allow a deprecation period. To deprecate parts of the API, check [Griffe's hints on how to deprecate things](../../users/checking/).

Use make check-api to check if there are any breaking changes. All of them should allow deprecation periods. Run this command again until no breaking changes are detected.

Deprecated code should also be marked as legacy code. We use [Yore](https://pawamoy.github.io/yore/) to mark legacy code. Similarly, code branches made to support older version of Python should be marked as legacy code using Yore too.

Examples:

Remove function when we bump to 2.0

```
# YORE: Bump 2: Remove block.
def deprecated_function():
    ...
```

Simplify imports when Python 3.15 is EOL

```
# YORE: EOL 3.15: Replace block with line 4.
try:
    import ...
except ImportError:
    import ...
```

Check [Yore's docs](https://pawamoy.github.io/yore/), and Yore-comments in our own code base (`git grep -A1 YORE`) to learn how to use it.

Occasional contributors

If you are unsure about how to deprecate something or mark legacy code, let us do it during review.

## Commit message convention

Commit messages must follow our convention based on the [Angular style](https://gist.github.com/stephenparish/9941e89d80e2bc58a153#format-of-the-commit-message) or the [Karma convention](https://karma-runner.github.io/4.0/dev/git-commit-msg.html):

```
type(scope): Subject

Body.
```

**Subject and body must be valid Markdown.** Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general. Example:

```
feat: Add CLI option to run in verbose mode
```

Scope and body are optional. Type can be:

- `build`: About packaging, building wheels, etc.
- `chore`: About packaging or repo/files management.
- `ci`: About Continuous Integration.
- `deps`: Dependencies update.
- `docs`: About documentation.
- `feat`: New feature.
- `fix`: Bug fix.
- `perf`: About performance.
- `refactor`: Changes that are not features or bug fixes.
- `style`: A change in code style/format.
- `tests`: About tests.

If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:

```
This is the body of the commit message.

Issue-10: https://github.com/namespace/project/issues/10
Related-to-PR-namespace/other-project#15: https://github.com/namespace/other-project/pull/15
```

These "trailers" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons `:`. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).

We do not enforce a line length on commit messages summary and body.

Occasional contributors

If this convention seems unclear to you, just write the message of your choice, and we will rewrite it ourselves before merging.

## Pull requests guidelines

Link to any related issue in the Pull Request message.

During the review, we recommend using fixups:

```
# SHA is the SHA of the commit you want to fix
git commit --fixup=SHA
```

Once all the changes are approved, you can squash your commits:

```
git rebase -i --autosquash main
```

And force-push:

```
git push -f
```

Occasional contributors

If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.

## Release process

Occasional or even regular contributors don't *have* to read this, but can anyway if they are interested in our release process.

Once we are ready for a new release (a few bugfixes and/or features merged in the main branch), maintainers should update the changelog. If our [commit message convention](./#commit-message-convention) was properly followed, the changelog can be automatically updated from the messages in the Git history with make changelog. This task updates the changelog in place to add a new version entry.

Once the changelog is updated, maintainers should review the new version entry, to:

- (optionally) add general notes for this new version, like highlights
- insert **Breaking changes** and **Deprecations** sections if needed, before other sections
- add links to the relevant parts of the documentation
- fix typos or markup if needed

Once the changelog is ready, a new release can be made with make release. If the version wasn't passed on the command-line with `make release version=x.x.x`, the task will prompt you for it. **Use the same version as the one that was just added to the changelog.** For example if the new version added to the changelog is `7.8.9`, use `make release version=7.8.9`.

The release task will stage the changelog, commit, tag, push, then build distributions and upload them to PyPI.org, and finally deploy the documentation. If any of these steps fail, you can manually run each step with Git commands, then make build, make publish and make docs-deploy.

# Other

# License

```
ISC License

Copyright (c) 2021, TimothÃ©e Mazzucotelli

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
```

# Community

Griffe is part of is the [mkdocstrings](https://mkdocstrings.github.io/) ecosystem, and therefore part of the [MkDocs](https://www.mkdocs.org/) ecosystem too. These two ecosystems have wonderful communities and we invite you to join them Make sure to read and follow our [code of conduct](../code-of-conduct/) when engaging with the community.

You can start new discussions on GitHub, in the following repositories, depending on the specificity of the discussion: [griffe](https://github.com/mkdocstrings/griffe), [mkdocstrings-python](https://github.com/mkdocstrings/python), [mkdocstrings](https://github.com/mkdocstrings/mkdocstrings), and [MkDocs](https://github.com/mkdocs/mkdocs).

You can also join our dedicated Gitter channels: [Griffe channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im), [mkdocstrings-python channel](https://app.gitter.im/#/room/#mkdocstrings_python:gitter.im), [mkdocstrings channel](https://app.gitter.im/#/room/#mkdocstrings_community:gitter.im), and [MkDocs channel](https://app.gitter.im/#/room/#mkdocs_community:gitter.im).

The best place to share about Griffe is of course our Gitter channel.

[Join Griffe's Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im)

More generally, Griffe is also related to **API documentation** and **API analysis** (static or dynamic): if your project is related to these two domains, but in different ecosystems (other programming languages, static site generators, or environments), feel free to drop us a message! We are always happy to share with other actors in these domains

- [Getting help](../getting-help/)
- [Contributing](../contributing/)
- [Code of conduct](../code-of-conduct/)
- [Credits](../credits/)

# Getting help

If you have a quick question regarding Griffe, ask on our [Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im).

For more complex questions, or actual issues that require showing code and configuration, please create [new Q/A discussions](https://github.com/mkdocstrings/griffe/discussions/categories/q-a) or [new bug reports](https://github.com/mkdocstrings/griffe/issues) respectively. Make sure to search previous discussions and issues to avoid creating duplicates. Also make sure to read our documentation before asking questions or opening bug reports. Don't hesitate to report unclear or missing documentation, we will do our best to improve it.

In any case (quick or complex questions) please remember to be **kind**, and to follow our [code of conduct](../code-of-conduct/). The people helping you do so voluntarily, in their free time. Be respectful of their time, and of your own. Help them help you by providing all the necessary information in minimal, reproducible examples. When creating a bug report, make sure to fill out the issue template.

# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience
- Focusing on what is best not just for us as individuals, but for the overall community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email address, without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.

Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [dev@pawamoy.fr](mailto:dev@pawamoy.fr). All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of actions.

**Consequence**: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 2.1, available at <https://www.contributor-covenant.org/version/2/1/code_of_conduct.html>.

Community Impact Guidelines were inspired by [Mozilla's code of conduct enforcement ladder](https://github.com/mozilla/diversity).

For answers to common questions about this code of conduct, see the FAQ at <https://www.contributor-covenant.org/faq>. Translations are available at <https://www.contributor-covenant.org/translations>.

# Alternatives

Similar projects exist in the ecosystem. They generally allow to extract API data from Python source, or to build a representation of the Python source or Python API. Some of them also allow to compare representations to find breaking changes.

## Docspec

[Docspec](https://github.com/NiklasRosenstein/python-docspec) is a JSON object specification for representing API documentation of programming languages. While in it's current form it is targeting Python APIs, it is intended to be able to represent other programming languages in the future as well.

The repository contains two projects, docspec and docspec-python. **docspec** is the reference implementation for reading/writing the JSON format and API for representing API objects in memory. **docspec-python** is a parser for Python packages and modules based on lib2to3 producing docspec API object representations.

## Frappucino

[Frappucino](https://github.com/Carreau/frappuccino) allows you to make sure you haven't broken your API, by first taking an imprint of your API at one point in time and then compare it to the current project state. The goal is to warn you when incompatible changes have been introduced, and to list these changes.

## Other related projects

The work of [@tristanlatr](https://github.com/tristanlatr) is worth checking out, notably his [ast-nodes](https://github.com/tristanlatr/ast-nodes) and [astuce](https://github.com/tristanlatr/astuce) projects, which aim at providing lower-level Python AST utilities to help implementing API data extraction with powerful inference. Tristan is [advocating for more interoperability](https://github.com/mkdocstrings/griffe/discussions/287) between Docspec, Griffe and his own projects.

We should also mention our own simplified "Griffe" variants for other programming languages, such as [Griffe TypeDoc](https://mkdocstrings.github.io/griffe-typedoc/), which extracts API data from TypeScript sources thanks to [TypeDoc](https://typedoc.org/), and builds Python objects from it.

______________________________________________________________________

The following projects are more than API data extraction tools, but deserve being mentioned.

### Papyri

[Papyri](https://github.com/jupyter/papyri) is a set of tools to build, publish (future functionality - to be done), install and render documentation within IPython and Jupyter.

Papyri [has considered using Griffe in the past](https://github.com/jupyter/papyri/issues/249) , but eventually went with their own solution, trying to be compatible with Griffe serialization format.

### pdoc

[pdoc](https://github.com/mitmproxy/pdoc) is a documentation renderer for Python projects. pdoc's main feature is a focus on simplicity: pdoc aims to do one thing and do it well.

### Sphinx AutoAPI

[Sphinx AutoAPI](https://github.com/readthedocs/sphinx-autoapi) is a new approach to API documentation in Sphinx. It is a Sphinx extension for generating complete API documentation without needing to load, run, or import the project being documented. In contrast to the traditional [Sphinx autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), which requires manual authoring and uses code imports, AutoAPI finds and generates documentation by parsing source code.

Sphinx AutoAPI is [considering Griffe as a data extraction backend](https://github.com/readthedocs/sphinx-autoapi/issues/444)

# Downstream projects

Griffe is used by various projects in the Python ecosystem. They are listed below in alphabetical order. [Griffe extensions are listed on their own page.](../extensions/)

## api2mdx

[api2mdx](https://github.com/Mirascope/api2mdx) is a Python tool that generates `mdx` documentation for Python APIs. Under the hood, it uses Griffe.

## Cybersecurity AI (CAI)

[Cybersecurity AI (CAI)](https://github.com/aliasrobotics/cai) is a lightweight, open-source framework that empowers security professionals to build and deploy AI-powered offensive and defensive automation. It uses Griffe to parse docstrings in order to generate function schema for MCP tools. I believe it reused code from Pydantic AI.

## Fumadocs

[Fumadocs](https://fumadocs.dev/) is a beautiful documentation framework for developers, flexible, performant, running on your React framework. It uses Griffe to extract and render Python API documentation.

## griffe2md

[griffe2md](https://mkdocstrings.github.io/griffe2md/) outputs API docs in Markdown. It uses Griffe to load the data, and then use Jinja templates to render documentation in Markdown, just like [mkdocstrings-python](https://mkdocstrings.github.io/python/), but in Markdown instead of HTML.

## Griffe TUI

[Griffe TUI](https://mkdocstrings.github.io/griffe-tui/) is a textual user interface for Griffe. It offers 100% offline, beautiful Python API docs, in your terminal, thanks to Griffe and [Textual](https://textual.textualize.io/).

## Griffonner

[Griffonner](https://will-langdale.github.io/griffonner/) is a template-first Python documentation generator that gets out of your way. Griffonner uses Griffe to parse your Python code and Jinja2 templates to generate docs in any format you want.

## Hippogriffe

[Hippogriffe](https://github.com/patrick-kidger/hippogriffe) is a set of tweaks on top of the MkDocs + mkdocstrings-python + Griffe documentation stack. It adds source links to GitHub to each top-level class or function, pretty-formats type annotations, improves unions/generics display, and more. Hippogriffe is used as a MkDocs plugin.

## mdxify

[mdxify](https://github.com/zzstoatzz/mdxify) generates API documentation from Python modules with automatic navigation and source links. MDX is the default output and Markdown is also supported via `--format md`.

## Mistral AI Python Client

The [Python client of Mistral AI](https://github.com/mistralai/client-python) uses Griffe to parse docstrings of Python-written MCP tools.

## mkdocstrings-python

Of course, Griffe is what powers [the Python handler of mkdocstrings](https://mkdocstrings.github.io/python/). mkdocstrings is a plugin for [MkDocs](https://www.mkdocs.org/) that allows rendering API docs easily.

## OpenAI Agents SDK

The [OpenAI Agents SDK](https://github.com/openai/openai-agents-python) is a lightweight yet powerful framework for building multi-agent workflows. It was inspired by Pydantic AI and uses Griffe the same way, to parse docstrings in order to generate function schemas.

## pydanclick

[Pydanclick](https://pypi.org/project/pydanclick/) allows to use [Pydantic](https://docs.pydantic.dev/latest/) models as [Click](https://click.palletsprojects.com/en/8.1.x/) options. It uses Griffe to parse docstrings and find Attributes sections, to help itself build Click options.

## PydanticAI

[PydanticAI](https://ai.pydantic.dev/) is a Python Agent Framework designed to make it less painful to build production grade applications with Generative AI. It uses Griffe to extract tool and parameter descriptions from docstrings.

## quartodoc

[quartodoc](https://machow.github.io/quartodoc/) lets you quickly generate Python package API reference documentation using Markdown and [Quarto](https://quarto.org/). quartodoc is designed as an alternative to [Sphinx](https://www.sphinx-doc.org/en/master/). It uses Griffe to load API data and parse docstrings in order to render HTML documentation, just like [mkdocstrings-python](https://mkdocstrings.github.io/python/), but for Quarto instead of Mkdocs.

# Credits

These projects were used to build *griffe*. **Thank you!**

[Python](https://www.python.org/) | [uv](https://github.com/astral-sh/uv) | [copier-uv](https://github.com/pawamoy/copier-uv)

### Runtime dependencies

| Project                                                | Summary                                                                                            | Version (accepted) | Version (last resolved) | License     |
| ------------------------------------------------------ | -------------------------------------------------------------------------------------------------- | ------------------ | ----------------------- | ----------- |
| [colorama](https://pypi.org/project/colorama/)         | Cross-platform colored terminal text.                                                              | `~=0.4, >=0.4`     | `0.4.6`                 | BSD License |
| [platformdirs](https://pypi.org/project/platformdirs/) | A small Python package for determining appropriate platform-specific dirs, e.g. a `user data dir`. | `>=4.4, >=4.2`     | `4.5.0`                 | MIT         |

### Development dependencies

| Project                                                                                                          | Summary                                                                                                   | Version (accepted) | Version (last resolved)   | License                                                        |
| ---------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------ | ------------------------- | -------------------------------------------------------------- |
| [ansimarkup](https://pypi.org/project/ansimarkup/)                                                               | Produce colored terminal text with an xml-like markup                                                     | `~=1.4`            | `1.5.0`                   | Revised BSD License                                            |
| [attrs](https://pypi.org/project/attrs/)                                                                         | Classes Without Boilerplate                                                                               | `>=22.2.0`         | `25.4.0`                  | MIT                                                            |
| [babel](https://pypi.org/project/babel/)                                                                         | Internationalization utilities                                                                            | `>=2.7.0`          | `2.17.0`                  | BSD-3-Clause                                                   |
| [backrefs](https://pypi.org/project/backrefs/)                                                                   | A wrapper around re and regex that adds additional back references.                                       | `~=5.7.post1`      | `5.9`                     | MIT                                                            |
| [beautifulsoup4](https://pypi.org/project/beautifulsoup4/)                                                       | Screen-scraping library                                                                                   | `>=4.12`           | `4.14.2`                  | MIT License                                                    |
| [build](https://pypi.org/project/build/)                                                                         | A simple, correct Python build frontend                                                                   | `>=1.2`            | `1.3.0`                   | MIT                                                            |
| [cappa](https://pypi.org/project/cappa/)                                                                         | Declarative CLI argument parser.                                                                          | `>=0.29`           | `0.30.4`                  | ?                                                              |
| [certifi](https://pypi.org/project/certifi/)                                                                     | Python package for providing Mozilla's CA Bundle.                                                         | `>=2017.4.17`      | `2025.10.5`               | MPL-2.0                                                        |
| [cffi](https://pypi.org/project/cffi/)                                                                           | Foreign Function Interface for Python calling C code.                                                     | `>=1.14`           | `2.0.0`                   | MIT                                                            |
| [charset-normalizer](https://pypi.org/project/charset-normalizer/)                                               | The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet.   | `>=2, <4`          | `3.4.4`                   | MIT                                                            |
| [click](https://pypi.org/project/click/)                                                                         | Composable command line interface toolkit                                                                 | `<8.2.2`           | `8.2.1`                   | BSD-3-Clause                                                   |
| [code2flow](https://pypi.org/project/code2flow/)                                                                 | Visualize your source code as DOT flowcharts                                                              | `>=2.5`            | `2.5.1`                   | MIT                                                            |
| [colorama](https://pypi.org/project/colorama/)                                                                   | Cross-platform colored terminal text.                                                                     | `~=0.4, >=0.4`     | `0.4.6`                   | BSD License                                                    |
| [coverage](https://pypi.org/project/coverage/)                                                                   | Code coverage measurement for Python                                                                      | `>=7.10.6`         | `7.11.3`                  | Apache-2.0                                                     |
| [cryptography](https://pypi.org/project/cryptography/)                                                           | cryptography is a package which provides cryptographic recipes and primitives to Python developers.       | `>=2.0`            | `46.0.3`                  | Apache-2.0 OR BSD-3-Clause                                     |
| [csscompressor](https://pypi.org/project/csscompressor/)                                                         | A python port of YUI CSS Compressor                                                                       | `>=0.9.5`          | `0.9.5`                   | BSD                                                            |
| [docutils](https://pypi.org/project/docutils/)                                                                   | Docutils -- Python Documentation Utilities                                                                | `>=0.21.2`         | `0.22.3`                  | Public Domain + BSD License + GNU General Public License (GPL) |
| [duty](https://pypi.org/project/duty/)                                                                           | A simple task runner.                                                                                     | `>=1.6`            | `1.6.3`                   | ISC                                                            |
| [execnet](https://pypi.org/project/execnet/)                                                                     | execnet: rapid multi-Python deployment                                                                    | `>=2.1`            | `2.1.1`                   | MIT                                                            |
| [failprint](https://pypi.org/project/failprint/)                                                                 | Run a command, print its output only if it fails.                                                         | `>=1.0.5`          | `1.0.6`                   | ISC                                                            |
| [ghp-import](https://pypi.org/project/ghp-import/)                                                               | Copy your docs directly to the gh-pages branch.                                                           | `>=1.0`            | `2.1.0`                   | Apache Software License                                        |
| [git-changelog](https://pypi.org/project/git-changelog/)                                                         | Automatic Changelog generator using Jinja2 templates.                                                     | `>=2.5`            | `2.6.3`                   | ISC                                                            |
| [gitdb](https://pypi.org/project/gitdb/)                                                                         | Git Object Database                                                                                       | `>=4.0.1, <5`      | `4.0.12`                  | BSD License                                                    |
| [GitPython](https://pypi.org/project/GitPython/)                                                                 | GitPython is a Python library used to interact with Git repositories                                      | `>=3.1.44`         | `3.1.45`                  | BSD-3-Clause                                                   |
| [griffe-inherited-docstrings](https://pypi.org/project/griffe-inherited-docstrings/)                             | Griffe extension for inheriting docstrings.                                                               | `>=1.1.2`          | `1.1.2`                   | ISC                                                            |
| [htmlmin2](https://pypi.org/project/htmlmin2/)                                                                   | An HTML Minifier                                                                                          | `>=0.1.13`         | `0.1.13`                  | BSD                                                            |
| [humanize](https://pypi.org/project/humanize/)                                                                   | Python humanize utilities                                                                                 | `>=4.9`            | `4.14.0`                  | MIT                                                            |
| [id](https://pypi.org/project/id/)                                                                               | A tool for generating OIDC identities                                                                     |                    | `1.5.0`                   | Apache Software License                                        |
| [idna](https://pypi.org/project/idna/)                                                                           | Internationalized Domain Names in Applications (IDNA)                                                     | `>=2.5, <4`        | `3.11`                    | BSD-3-Clause                                                   |
| [iniconfig](https://pypi.org/project/iniconfig/)                                                                 | brain-dead simple config-ini parsing                                                                      | `>=1.0.1`          | `2.3.0`                   | MIT                                                            |
| [jaraco.classes](https://pypi.org/project/jaraco.classes/)                                                       | Utility functions for Python class constructs                                                             |                    | `3.4.0`                   | MIT License                                                    |
| [jaraco.context](https://pypi.org/project/jaraco.context/)                                                       | Useful decorators and context managers                                                                    |                    | `6.0.1`                   | MIT License                                                    |
| [jaraco.functools](https://pypi.org/project/jaraco.functools/)                                                   | Functools like those found in stdlib                                                                      |                    | `4.3.0`                   | MIT                                                            |
| [jeepney](https://pypi.org/project/jeepney/)                                                                     | Low-level, pure Python DBus protocol wrapper.                                                             | `>=0.4.2`          | `0.9.0`                   | MIT                                                            |
| [Jinja2](https://pypi.org/project/Jinja2/)                                                                       | A very fast and expressive template engine.                                                               | `>=3.0`            | `3.1.6`                   | BSD License                                                    |
| [jsmin](https://pypi.org/project/jsmin/)                                                                         | JavaScript minifier.                                                                                      | `>=3.0.1`          | `3.0.1`                   | MIT License                                                    |
| [jsonschema](https://pypi.org/project/jsonschema/)                                                               | An implementation of JSON Schema validation for Python                                                    | `>=4.17`           | `4.25.1`                  | MIT                                                            |
| [jsonschema-specifications](https://pypi.org/project/jsonschema-specifications/)                                 | The JSON Schema meta-schemas and vocabularies, exposed as a Registry                                      | `>=2023.03.6`      | `2025.9.1`                | MIT                                                            |
| [keyring](https://pypi.org/project/keyring/)                                                                     | Store and access your passwords safely.                                                                   | `>=21.2.0`         | `25.6.0`                  | MIT License                                                    |
| [Markdown](https://pypi.org/project/Markdown/)                                                                   | Python implementation of John Gruber's Markdown.                                                          | `~=3.2`            | `3.10`                    | BSD-3-Clause                                                   |
| [markdown-callouts](https://pypi.org/project/markdown-callouts/)                                                 | Markdown extension: a classier syntax for admonitions                                                     | `>=0.4`            | `0.4.0`                   | MIT                                                            |
| [markdown-exec](https://pypi.org/project/markdown-exec/)                                                         | Utilities to execute code blocks in Markdown files.                                                       | `>=1.8`            | `1.11.0.1.1.1`            | ISC                                                            |
| [markdown-it-py](https://pypi.org/project/markdown-it-py/)                                                       | Python port of markdown-it. Markdown parsing, done right!                                                 | `>=2.2.0`          | `3.0.0`                   | MIT License                                                    |
| [markdownify](https://pypi.org/project/markdownify/)                                                             | Convert HTML to markdown.                                                                                 | `>=0.14`           | `1.2.0`                   | MIT License                                                    |
| [MarkupSafe](https://pypi.org/project/MarkupSafe/)                                                               | Safely add untrusted strings to HTML/XML markup.                                                          | `>=2.0`            | `3.0.3`                   | BSD-3-Clause                                                   |
| [mdformat](https://pypi.org/project/mdformat/)                                                                   | CommonMark compliant Markdown formatter                                                                   | `>=0.7.21`         | `0.7.22`                  | MIT License                                                    |
| [mdformat_tables](https://pypi.org/project/mdformat_tables/)                                                     | An mdformat plugin for rendering tables.                                                                  | `>=1.0`            | `1.0.0`                   | MIT License                                                    |
| [mdurl](https://pypi.org/project/mdurl/)                                                                         | Markdown URL utilities                                                                                    | `~=0.1`            | `0.1.2`                   | MIT License                                                    |
| [mergedeep](https://pypi.org/project/mergedeep/)                                                                 | A deep merge function for ðŸ.                                                                             | `~=1.3`            | `1.3.4`                   | MIT License                                                    |
| [mkdocs](https://pypi.org/project/mkdocs/)                                                                       | Project documentation with Markdown.                                                                      | `>=1.6`            | `1.6.1`                   | BSD-2-Clause                                                   |
| [mkdocs-autorefs](https://pypi.org/project/mkdocs-autorefs/)                                                     | Automatically link across pages in MkDocs.                                                                | `>=1.4`            | `1.4.3`                   | ISC                                                            |
| [mkdocs-coverage](https://pypi.org/project/mkdocs-coverage/)                                                     | MkDocs plugin to integrate your coverage HTML report into your site.                                      | `>=1.0`            | `2.0.0`                   | ISC                                                            |
| [mkdocs-gen-files](https://pypi.org/project/mkdocs-gen-files/)                                                   | MkDocs plugin to programmatically generate documentation pages during the build                           | `>=0.5`            | `0.5.0`                   | MIT                                                            |
| [mkdocs-get-deps](https://pypi.org/project/mkdocs-get-deps/)                                                     | MkDocs extension that lists all dependencies according to a mkdocs.yml file                               | `>=0.2.0`          | `0.2.0`                   | MIT                                                            |
| [mkdocs-git-revision-date-localized-plugin](https://pypi.org/project/mkdocs-git-revision-date-localized-plugin/) | Mkdocs plugin that enables displaying the localized date of the last git modification of a markdown file. | `>=1.2`            | `1.5.0`                   | MIT                                                            |
| [mkdocs-llmstxt](https://pypi.org/project/mkdocs-llmstxt/)                                                       | MkDocs plugin to generate an /llms.txt file.                                                              | `>=0.2`            | `0.4.0`                   | ISC                                                            |
| [mkdocs-material](https://pypi.org/project/mkdocs-material/)                                                     | Documentation that simply works                                                                           | `>=9.5`            | `9.6.18+insiders.4.53.17` | MIT                                                            |
| [mkdocs-material-extensions](https://pypi.org/project/mkdocs-material-extensions/)                               | Extension pack for Python Markdown and MkDocs Material.                                                   | `~=1.3`            | `1.3.1`                   | MIT                                                            |
| [mkdocs-minify-plugin](https://pypi.org/project/mkdocs-minify-plugin/)                                           | An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk                           | `>=0.8`            | `0.8.0`                   | MIT                                                            |
| [mkdocs-redirects](https://pypi.org/project/mkdocs-redirects/)                                                   | A MkDocs plugin for dynamic page redirects to prevent broken links                                        | `>=1.2`            | `1.2.2`                   | MIT                                                            |
| [mkdocs-section-index](https://pypi.org/project/mkdocs-section-index/)                                           | MkDocs plugin to allow clickable sections that lead to an index page                                      | `>=0.3`            | `0.3.10`                  | MIT                                                            |
| [mkdocstrings](https://pypi.org/project/mkdocstrings/)                                                           | Automatic documentation from sources, for MkDocs.                                                         | `>=0.29`           | `0.30.1`                  | ISC                                                            |
| [mkdocstrings-python](https://pypi.org/project/mkdocstrings-python/)                                             | A Python handler for mkdocstrings.                                                                        | `>=1.16.2`         | `1.18.2.1.12.1`           | ISC                                                            |
| [more-itertools](https://pypi.org/project/more-itertools/)                                                       | More routines for operating on iterables, beyond itertools                                                |                    | `10.8.0`                  | MIT                                                            |
| [mypy](https://pypi.org/project/mypy/)                                                                           | Optional static typing for Python                                                                         | `>=1.10`           | `1.18.2`                  | MIT                                                            |
| [mypy_extensions](https://pypi.org/project/mypy_extensions/)                                                     | Type system extensions for programs checked with the mypy type checker.                                   | `>=1.0.0`          | `1.1.0`                   | MIT                                                            |
| [nh3](https://pypi.org/project/nh3/)                                                                             | Python binding to Ammonia HTML sanitizer Rust crate                                                       | `>=0.2.14`         | `0.3.2`                   | MIT                                                            |
| [packaging](https://pypi.org/project/packaging/)                                                                 | Core utilities for Python packages                                                                        | `>=24.0`           | `25.0`                    | Apache Software License + BSD License                          |
| [paginate](https://pypi.org/project/paginate/)                                                                   | Divides large result sets into pages for easier browsing                                                  | `~=0.5`            | `0.5.7`                   | MIT                                                            |
| [pathspec](https://pypi.org/project/pathspec/)                                                                   | Utility library for gitignore style pattern matching of file paths.                                       | `>=0.9.0`          | `0.12.1`                  | Mozilla Public License 2.0 (MPL 2.0)                           |
| [platformdirs](https://pypi.org/project/platformdirs/)                                                           | A small Python package for determining appropriate platform-specific dirs, e.g. a `user data dir`.        | `>=4.4, >=4.2`     | `4.5.0`                   | MIT                                                            |
| [pluggy](https://pypi.org/project/pluggy/)                                                                       | plugin and hook calling mechanisms for python                                                             | `>=1.2`            | `1.6.0`                   | MIT                                                            |
| [ptyprocess](https://pypi.org/project/ptyprocess/)                                                               | Run a subprocess in a pseudo terminal                                                                     | `~=0.6`            | `0.7.0`                   | ISC License (ISCL)                                             |
| [pycparser](https://pypi.org/project/pycparser/)                                                                 | C parser in Python                                                                                        |                    | `2.23`                    | BSD-3-Clause                                                   |
| [pydeps](https://pypi.org/project/pydeps/)                                                                       | Display module dependencies                                                                               | `>=1.12`           | `3.0.1`                   | BSD                                                            |
| [Pygments](https://pypi.org/project/Pygments/)                                                                   | Pygments is a syntax highlighting package written in Python.                                              | `~=2.16`           | `2.19.2`                  | BSD-2-Clause                                                   |
| [pygments-ansi-color](https://pypi.org/project/pygments-ansi-color/)                                             |                                                                                                           | `>=0.3`            | `0.3.0`                   | Apache Software License                                        |
| [pymdown-extensions](https://pypi.org/project/pymdown-extensions/)                                               | Extension pack for Python Markdown.                                                                       | `~=10.2`           | `10.16.1`                 | MIT                                                            |
| [pyproject_hooks](https://pypi.org/project/pyproject_hooks/)                                                     | Wrappers to call pyproject.toml-based build backend hooks.                                                |                    | `1.2.0`                   | MIT License                                                    |
| [pysource-codegen](https://pypi.org/project/pysource-codegen/)                                                   | generate random python code to test linter/formatter/and other tools                                      | `>=0.7`            | `0.7.1`                   | MIT                                                            |
| [pysource-minimize](https://pypi.org/project/pysource-minimize/)                                                 | minimize python source code                                                                               | `>=0.10`           | `0.10.1`                  | MIT                                                            |
| [pytest](https://pypi.org/project/pytest/)                                                                       | pytest: simple powerful testing with Python                                                               | `>=8.2`            | `9.0.0`                   | MIT                                                            |
| [pytest-cov](https://pypi.org/project/pytest-cov/)                                                               | Pytest plugin for measuring coverage.                                                                     | `>=5.0`            | `7.0.0`                   | MIT                                                            |
| [pytest-gitconfig](https://pypi.org/project/pytest-gitconfig/)                                                   | Provide a Git config sandbox for testing                                                                  | `>=0.8.0`          | `0.8.0`                   | MIT                                                            |
| [pytest-randomly](https://pypi.org/project/pytest-randomly/)                                                     | Pytest plugin to randomly order tests and control random.seed.                                            | `>=3.15`           | `4.0.1`                   | MIT                                                            |
| [pytest-xdist](https://pypi.org/project/pytest-xdist/)                                                           | pytest xdist plugin for distributed testing, most importantly across multiple CPUs                        | `>=3.6`            | `3.8.0`                   | MIT                                                            |
| [python-dateutil](https://pypi.org/project/python-dateutil/)                                                     | Extensions to the standard Python datetime module                                                         | `>=2.8.1`          | `2.9.0.post0`             | BSD License + Apache Software License                          |
| [PyYAML](https://pypi.org/project/PyYAML/)                                                                       | YAML parser and emitter for Python                                                                        | `>=5.1`            | `6.0.3`                   | MIT                                                            |
| [pyyaml_env_tag](https://pypi.org/project/pyyaml_env_tag/)                                                       | A custom YAML tag for referencing environment variables in YAML files.                                    | `>=0.1`            | `1.1`                     | MIT                                                            |
| [readme_renderer](https://pypi.org/project/readme_renderer/)                                                     | readme_renderer is a library for rendering readme descriptions for Warehouse                              | `>=35.0`           | `44.0`                    | Apache License, Version 2.0                                    |
| [referencing](https://pypi.org/project/referencing/)                                                             | JSON Referencing + Python                                                                                 | `>=0.28.4`         | `0.37.0`                  | MIT                                                            |
| [requests](https://pypi.org/project/requests/)                                                                   | Python HTTP for Humans.                                                                                   | `>=2.20`           | `2.32.5`                  | Apache-2.0                                                     |
| [requests-toolbelt](https://pypi.org/project/requests-toolbelt/)                                                 | A utility belt for advanced users of python-requests                                                      | `>=0.8.0, !=0.9.0` | `1.0.0`                   | Apache 2.0                                                     |
| [rfc3986](https://pypi.org/project/rfc3986/)                                                                     | Validating URI References per RFC 3986                                                                    | `>=1.4.0`          | `2.0.0`                   | Apache 2.0                                                     |
| [rich](https://pypi.org/project/rich/)                                                                           | Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal           | `>=12.0.0`         | `14.2.0`                  | MIT                                                            |
| [rpds-py](https://pypi.org/project/rpds-py/)                                                                     | Python bindings to Rust's persistent data structures (rpds)                                               | `>=0.7.1`          | `0.28.0`                  | MIT                                                            |
| [ruff](https://pypi.org/project/ruff/)                                                                           | An extremely fast Python linter and code formatter, written in Rust.                                      | `>=0.4`            | `0.14.4`                  | MIT License                                                    |
| [SecretStorage](https://pypi.org/project/SecretStorage/)                                                         | Python bindings to FreeDesktop.org Secret Service API                                                     | `>=3.2`            | `3.4.0`                   | BSD-3-Clause                                                   |
| [semver](https://pypi.org/project/semver/)                                                                       | Python helper for Semantic Versioning (<https://semver.org>)                                              | `>=3.0`            | `3.0.4`                   | BSD License                                                    |
| [six](https://pypi.org/project/six/)                                                                             | Python 2 and 3 compatibility utilities                                                                    | `>=1.15, <2`       | `1.17.0`                  | MIT                                                            |
| [smmap](https://pypi.org/project/smmap/)                                                                         | A pure Python implementation of a sliding window memory map manager                                       | `>=3.0.1, <6`      | `5.0.2`                   | BSD-3-Clause                                                   |
| [soupsieve](https://pypi.org/project/soupsieve/)                                                                 | A modern CSS selector implementation for Beautiful Soup.                                                  | `>1.2`             | `2.8`                     | MIT                                                            |
| [stdlib-list](https://pypi.org/project/stdlib-list/)                                                             | A list of Python Standard Libraries (2.7 through 3.14).                                                   |                    | `0.12.0`                  | MIT License                                                    |
| [twine](https://pypi.org/project/twine/)                                                                         | Collection of utilities for publishing packages on PyPI                                                   | `>=5.1`            | `6.2.0`                   | Apache-2.0                                                     |
| [type-lens](https://pypi.org/project/type-lens/)                                                                 | type-lens is a Python template project designed to simplify the setup of a new project.                   | `>=0.2.5`          | `0.2.6`                   | MIT                                                            |
| [types-Markdown](https://pypi.org/project/types-Markdown/)                                                       | Typing stubs for Markdown                                                                                 | `>=3.6`            | `3.10.0.20251106`         | Apache-2.0                                                     |
| [types-PyYAML](https://pypi.org/project/types-PyYAML/)                                                           | Typing stubs for PyYAML                                                                                   | `>=6.0`            | `6.0.12.20250915`         | Apache-2.0                                                     |
| [typing_extensions](https://pypi.org/project/typing_extensions/)                                                 | Backported and Experimental Type Hints for Python 3.9+                                                    | `>=4.9`            | `4.15.0`                  | PSF-2.0                                                        |
| [urllib3](https://pypi.org/project/urllib3/)                                                                     | HTTP library with thread-safe connection pooling, file post, and more.                                    | `>=1.26.0`         | `2.5.0`                   | MIT                                                            |
| [watchdog](https://pypi.org/project/watchdog/)                                                                   | Filesystem events monitoring                                                                              | `>=2.0`            | `6.0.0`                   | Apache-2.0                                                     |
| [wcwidth](https://pypi.org/project/wcwidth/)                                                                     | Measures the displayed width of unicode strings in a terminal                                             | `>=0.2.13`         | `0.2.14`                  | MIT                                                            |
| [yore](https://pypi.org/project/yore/)                                                                           | Manage legacy code with comments.                                                                         | `>=0.3.3`          | `0.4.5`                   | ISC                                                            |

**[More credits from the author](http://pawamoy.github.io/credits/)**

# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/) and this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).

## [1.15.0](https://github.com/mkdocstrings/griffe/releases/tag/1.15.0) - 2025-11-10

[Compare with 1.14.0](https://github.com/mkdocstrings/griffe/compare/1.14.0...1.15.0)

### Features

- Prefer stub over target object if not the same kind ([196bcf4](https://github.com/mkdocstrings/griffe/commit/196bcf412972ac2a8c79346ac37655a4199dffb6) by Kattni). [Discussion-mkdocstrings-803](https://github.com/mkdocstrings/mkdocstrings/discussions/803), [PR-422](https://github.com/mkdocstrings/griffe/pull/422)
- Parse keywords in class declarations ([0709f0d](https://github.com/mkdocstrings/griffe/commit/0709f0d15411b1c1707fc43f10def8c38b3eba93) by TimothÃ©e Mazzucotelli).
- Support unpacking typed dicts in signatures and docstrings ([60cbb5f](https://github.com/mkdocstrings/griffe/commit/60cbb5f4af0e20831c25d4ba7d5fa8aa13556340) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-python-207](https://github.com/mkdocstrings/python/issues/207), [Issue-284](https://github.com/mkdocstrings/griffe/issues/284)
- Support checking packages from PyPI directly ([e04a5cf](https://github.com/mkdocstrings/griffe/commit/e04a5cfe381439e14b78e21b55c2f7a75082b30c) by TimothÃ©e Mazzucotelli).
- Support expression modernization ([4ae5d25](https://github.com/mkdocstrings/griffe/commit/4ae5d257024cdc5f128dde5aa961390cd233d08e) by TimothÃ©e Mazzucotelli).
- Support `auto` docstring style (infer from docstring) ([4d0a9ee](https://github.com/mkdocstrings/griffe/commit/4d0a9ee29a3f17e795c3bbb3e32303890d7c1432) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Make type aliases available at runtime ([9debb52](https://github.com/mkdocstrings/griffe/commit/9debb52b2906cca704df32c45333c8ae3bd6e162) by sgt). [Discussion-425](https://github.com/mkdocstrings/griffe/discussions/425), [PR-426](https://github.com/mkdocstrings/griffe/pull/426)
- Fix loading namespace packages from JSON ([3cccf27](https://github.com/mkdocstrings/griffe/commit/3cccf2740ebcf174671aed1cf5fdbf787c076679) by Bartosz SÅ‚awecki). [Issue-407](https://github.com/mkdocstrings/griffe/issues/407), [PR-413](https://github.com/mkdocstrings/griffe/pull/413)
- Catch error when computing relative filepath for serialization ([92a23d4](https://github.com/mkdocstrings/griffe/commit/92a23d4aa4b967777bfd4c8cbc19eb4a0795102d) by TimothÃ©e Mazzucotelli).
- Defer creating module finder until first load ([c52dd22](https://github.com/mkdocstrings/griffe/commit/c52dd22a3b8690bf3ecfe5359b47b8bf65ca59f9) by Bartosz SÅ‚awecki). [Issue-410](https://github.com/mkdocstrings/griffe/issues/410), [PR-411](https://github.com/mkdocstrings/griffe/pull/411), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Always return a string or `None` from `ObjectNode.module_path` ([06c2f2f](https://github.com/mkdocstrings/griffe/commit/06c2f2f1974a62bf8195a089b0cc8cd343ae1784) by Frank David MartÃ­nez M). [PR-419](https://github.com/mkdocstrings/griffe/pull/419), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Don't add parentheses around comprehension target (implicit) tuple ([cbdb6a9](https://github.com/mkdocstrings/griffe/commit/cbdb6a9a398acc4adc924b7ec4cc1abe966a4db4) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-python-311](https://github.com/mkdocstrings/python/issues/311)
- Add missing space in dictionary comprehension ([3a6dc36](https://github.com/mkdocstrings/griffe/commit/3a6dc3628982770d65e7ce7adeeadfc0ab601ef1) by Nicolas IOOSS). [Issue-mkdocstrings-python-311](https://github.com/mkdocstrings/python/issues/311), [PR-420](https://github.com/mkdocstrings/griffe/pull/420)
- Do not ignore stderr in case there is a problem in a git call. (#416) ([9a5d014](https://github.com/mkdocstrings/griffe/commit/9a5d014b3f9d5f7ac4ffdf27a49dacc437776f84) by Muhammet SoytÃ¼rk). [Issue-415](https://github.com/mkdocstrings/griffe/issues/415), [PR-416](https://github.com/mkdocstrings/griffe/pull/416)

### Code Refactoring

- Update code base for Python 3.10 ([37aaf06](https://github.com/mkdocstrings/griffe/commit/37aaf06f06311ea1f114442233af750d18583173) by TimothÃ©e Mazzucotelli).
- Improve handling of typed dicts ([5bed1be](https://github.com/mkdocstrings/griffe/commit/5bed1be1c62b4e8c083f8f1a808ec9664caacc4f) by TimothÃ©e Mazzucotelli). [Issue-284](https://github.com/mkdocstrings/griffe/issues/284), [Issue-mkdocstrings-python-207](https://github.com/mkdocstrings/python/issues/207), [PR-414](https://github.com/mkdocstrings/griffe/pull/414)
- Reuse private method to append search path to reduce code duplication ([0a82cf5](https://github.com/mkdocstrings/griffe/commit/0a82cf52a118204f8290c309273bae9b14ec2126) by TimothÃ©e Mazzucotelli).
- Don't produce an empty text section when "parsing" an empty unstyled docstring ([90bd71c](https://github.com/mkdocstrings/griffe/commit/90bd71cb2a2f438c39b32f821b588af3b8feed66) by TimothÃ©e Mazzucotelli).
- Don't produce empty text section when parsing an empty Google-style docstring ([1cbf2a3](https://github.com/mkdocstrings/griffe/commit/1cbf2a38a8b9988f91030623e01c0ce883e33abe) by TimothÃ©e Mazzucotelli).
- Use plain ANSI codes, don't import them from Colorama ([90978b4](https://github.com/mkdocstrings/griffe/commit/90978b4d86307b283948064e5a5f411114d30748) by TimothÃ©e Mazzucotelli).

## [1.14.0](https://github.com/mkdocstrings/griffe/releases/tag/1.14.0) - 2025-09-05

[Compare with 1.13.0](https://github.com/mkdocstrings/griffe/compare/1.13.0...1.14.0)

### Deprecations

- The `on_alias` event's signature changed from `on_alias(self, *, node: AST | ObjectNode, alias: Alias, agent: Visitor | Inspector, **kwargs)` (an analysis event) to `on_alias(self, *, alias: Alias, loader: GriffeLoader, **kwargs)` (a load event). Use the new signature, or rename your method to `on_alias_instance` to keep the old signature (`on_alias_instance` is a new analysis event that replaces the old `on_alias` one). Backward compatibility is maintained until next major version.
- The `on_wildcard_expansion` event is deprecated. Instead, use the `on_alias` event, and check the wildcard_imported boolean attribute of aliases.
- The `on_package_loaded` event is renamed to `on_package`. Backward compatibility is maintained until next major version.
- The use of previously exposed Git-related utilities (`assert_git_repo`, `get_repo_root`, `get_latest_tag` and `tmp_worktree`) is deprecated, as they are not a core part of the library's functionality. These utilities are now part of our internal API.

### Features

- Add `analysis` attribute on objects and aliases, telling whether they were loaded through static or dynamic analysis, or created manually ([d792a56](https://github.com/mkdocstrings/griffe/commit/d792a56fcecdf2003791356b857262cba8235f04) by TimothÃ©e Mazzucotelli).
- Expose Git info in objects, allowing to compute a new `source_link` property (see Source information in our docs) ([2a8d824](https://github.com/mkdocstrings/griffe/commit/2a8d824840b277d9941981583372abf36d3b17fe) by TimothÃ©e Mazzucotelli). [Issue-361](https://github.com/mkdocstrings/griffe/issues/361), [Issue-mkdocstrings-python-253](https://github.com/mkdocstrings/python/issues/253)
- Add `wildcard_imported` boolean attribute to aliases, deprecate `on_wildcard_expansion` event ([821300d](https://github.com/mkdocstrings/griffe/commit/821300db5d43af0ad7a4d82ff2df15a7fa5f63d6) by TimothÃ©e Mazzucotelli).
- Add load events that run once a tree is fully constructed, matching analysis events but safer to hook onto (see Load events in our docs) ([77f928a](https://github.com/mkdocstrings/griffe/commit/77f928aeab857cb45564462a4f849c2df2cca99a) by TimothÃ©e Mazzucotelli). [Issue-346](https://github.com/mkdocstrings/griffe/issues/346)

### Code Refactoring

- Provide typed dicts for docstring options ([945880a](https://github.com/mkdocstrings/griffe/commit/945880a04dcbe6eae31afa5021766533c73edc91) by TimothÃ©e Mazzucotelli). [Issue-370](https://github.com/mkdocstrings/griffe/issues/370)
- Allow parenthesized type to be glued (no space) to parameter name in Google-style docstrings ([4b6f939](https://github.com/mkdocstrings/griffe/commit/4b6f939e12540ce4fb6941f0c95253e3111e7f6f) by TimothÃ©e Mazzucotelli). [Issue-375](https://github.com/mkdocstrings/griffe/issues/375)
- Improve deprecation warnings for `on_alias` and `on_package_loaded` ([d3e50db](https://github.com/mkdocstrings/griffe/commit/d3e50db055715d1a2b794d7e1cf47e6fdc1c305b) by TimothÃ©e Mazzucotelli).

## [1.13.0](https://github.com/mkdocstrings/griffe/releases/tag/1.13.0) - 2025-08-26

[Compare with 1.12.1](https://github.com/mkdocstrings/griffe/compare/1.12.1...1.13.0)

### Features

- Add `is_init_method` property ([5417b70](https://github.com/mkdocstrings/griffe/commit/5417b7040f8061696c380d9cd4ed2852bf96adf3) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Increase maximum recursion limit when calling as a CLI ([5f0d9e6](https://github.com/mkdocstrings/griffe/commit/5f0d9e61fbac89247bcae06a7010e28e381a5656) by TimothÃ©e Mazzucotelli). [Issue-402](https://github.com/mkdocstrings/griffe/issues/402)

## [1.12.1](https://github.com/mkdocstrings/griffe/releases/tag/1.12.1) - 2025-08-14

[Compare with 1.12.0](https://github.com/mkdocstrings/griffe/compare/1.12.0...1.12.1)

### Code Refactoring

- Reduce size of JSON dumps by removing keys with null values ([58227eb](https://github.com/mkdocstrings/griffe/commit/58227eb377fee66ef66237d7cbed35156ff1fed1) by TimothÃ©e Mazzucotelli). [Issue-403](https://github.com/mkdocstrings/griffe/issues/403)
- Add fields to aliases when serializing ([5c9fee2](https://github.com/mkdocstrings/griffe/commit/5c9fee2b0c6e4f4e63c7648fa41b2e540f2ecc7f) by TimothÃ©e Mazzucotelli).
- Also add the option to ignore missing type to the Sphinx parser ([8c9f803](https://github.com/mkdocstrings/griffe/commit/8c9f803e748a659905b06445a349a6cfea948c1c) by TimothÃ©e Mazzucotelli).

## [1.12.0](https://github.com/mkdocstrings/griffe/releases/tag/1.12.0) - 2025-08-14

[Compare with 1.11.1](https://github.com/mkdocstrings/griffe/compare/1.11.1...1.12.0)

### Features

- Allow disabling "missing type/annotation" warnings ([07564b4](https://github.com/mkdocstrings/griffe/commit/07564b43524220342c3078ece406459c08b80a86) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-437](https://github.com/mkdocstrings/mkdocstrings/issues/437)

## [1.11.1](https://github.com/mkdocstrings/griffe/releases/tag/1.11.1) - 2025-08-11

[Compare with 1.11.0](https://github.com/mkdocstrings/griffe/compare/1.11.0...1.11.1)

### Bug Fixes

- Fix type parameters loading ([ce41279](https://github.com/mkdocstrings/griffe/commit/ce41279cc8b7abc45c7b94316b24e87d4a1edc40) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Move private `_griffe` package under `griffe._internal` ([8f37158](https://github.com/mkdocstrings/griffe/commit/8f37158eb5617d2cf686f9a0a044f29c638598b2) by TimothÃ©e Mazzucotelli).

## [1.11.0](https://github.com/mkdocstrings/griffe/releases/tag/1.11.0) - 2025-08-07

[Compare with 1.10.0](https://github.com/mkdocstrings/griffe/compare/1.10.0...1.11.0)

### Features

- Add data to dict/json output ([9731afc](https://github.com/mkdocstrings/griffe/commit/9731afcbeab377e7f3f69a0d18d19677e790072e) by TimothÃ©e Mazzucotelli).

## [1.10.0](https://github.com/mkdocstrings/griffe/releases/tag/1.10.0) - 2025-08-06

[Compare with 1.9.0](https://github.com/mkdocstrings/griffe/compare/1.9.0...1.10.0)

### Features

- Allow adding `sys.path` to search paths when temporary visiting/inspecting package ([42983bc](https://github.com/mkdocstrings/griffe/commit/42983bc843fd9a63883e9c50ad5043b0f737b450) by TimothÃ©e Mazzucotelli).

## [1.9.0](https://github.com/mkdocstrings/griffe/releases/tag/1.9.0) - 2025-07-28

[Compare with 1.8.0](https://github.com/mkdocstrings/griffe/compare/1.8.0...1.9.0)

### Features

- Support PEP 695 generics ([be28e9c](https://github.com/mkdocstrings/griffe/commit/be28e9c9835a709fca0a78990c56e8d652a71a8c) by Victor Westerhuis). [Issue-342](https://github.com/mkdocstrings/griffe/issues/342), [PR-348](https://github.com/mkdocstrings/griffe/pull/348), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)

## [1.8.0](https://github.com/mkdocstrings/griffe/releases/tag/1.8.0) - 2025-07-23

[Compare with 1.7.3](https://github.com/mkdocstrings/griffe/compare/1.7.3...1.8.0)

### Features

- Add method to functions and classes to build and return a stringified signature ([8ef1486](https://github.com/mkdocstrings/griffe/commit/8ef1486e9b1f0872cca3b1cd2419144b702a0c1e) by ISOREX). [Discussion-376](https://github.com/mkdocstrings/griffe/discussions/376), [PR-381](https://github.com/mkdocstrings/griffe/pull/381), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Enhance Sphinx-style parameter parsing to handle invalid type info ([cbce5a2](https://github.com/mkdocstrings/griffe/commit/cbce5a2c2429dc92e15ac3a8fe53db55825ebd6c) by Edouard ChoiniÃ¨re). [PR-396](https://github.com/mkdocstrings/griffe/pull/396)
- Parse Sphinx parameter types as expressions ([70dda21](https://github.com/mkdocstrings/griffe/commit/70dda21d15dfdf5807dde370fb636d69eea6272b) by Edouard ChoiniÃ¨re). [PR-392](https://github.com/mkdocstrings/griffe/pull/392)

### Bug Fixes

- Avoid SyntaxError when loading modules encoded in UTF8 with BOM ([b346190](https://github.com/mkdocstrings/griffe/commit/b3461901ae08204ea6184025a006f5d34152d30d) by John Hennig). [Issue-386](https://github.com/mkdocstrings/griffe/issues/386), [PR-387](https://github.com/mkdocstrings/griffe/pull/387), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Correctly parenthesize expressions ([a8c5585](https://github.com/mkdocstrings/griffe/commit/a8c5585c8a45a4d6b67bd5dc36d7054478d3873d) by Abraham Cheung). [PR-389](https://github.com/mkdocstrings/griffe/pull/389), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)

### Code Refactoring

- Be more consistent regarding not overriding submodules with aliases ([be1963c](https://github.com/mkdocstrings/griffe/commit/be1963cca6d7d49bcc41fdf05570b1bfba934330) by TimothÃ©e Mazzucotelli).
- Allow `ExprName.parent` to be of type `griffe.Function` ([acafbd8](https://github.com/mkdocstrings/griffe/commit/acafbd8b6d97fe8370f3eb730e2154e19b2c1a54) by Edouard ChoiniÃ¨re). [Issue-391](https://github.com/mkdocstrings/griffe/discussions/391), [PR-395](https://github.com/mkdocstrings/griffe/pull/395)
- Normalize labels for attributes ([1b376cd](https://github.com/mkdocstrings/griffe/commit/1b376cd39ce99730910d8344abbfd5c53ce28300) by TimothÃ©e Mazzucotelli).

## [1.7.3](https://github.com/mkdocstrings/griffe/releases/tag/1.7.3) - 2025-04-23

[Compare with 1.7.2](https://github.com/mkdocstrings/griffe/compare/1.7.2...1.7.3)

### Bug Fixes

- Don't output color codes with GitHub format ([2666399](https://github.com/mkdocstrings/griffe/commit/2666399a2ca34644cabc265f803754ca8aef6aa7) by TimothÃ©e Mazzucotelli). [Issue-378](https://github.com/mkdocstrings/griffe/issues/378)

### Code Refactoring

- Log a debug message when inspecting a module raises an error ([4e73b3e](https://github.com/mkdocstrings/griffe/commit/4e73b3e4d85018f5523aa907246dad760723eb3c) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-753](https://github.com/mkdocstrings/mkdocstrings/issues/753)

## [1.7.2](https://github.com/mkdocstrings/griffe/releases/tag/1.7.2) - 2025-04-01

[Compare with 1.7.1](https://github.com/mkdocstrings/griffe/compare/1.7.1...1.7.2)

### Bug Fixes

- Override exports when merging module stubs ([94f23e7](https://github.com/mkdocstrings/griffe/commit/94f23e72e456310d37765ea2eecf29cf655d34d3) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-751](https://github.com/mkdocstrings/mkdocstrings/issues/751)
- Override attribute values when merging stubs ([b940c51](https://github.com/mkdocstrings/griffe/commit/b940c51ba729ce39465bd92a40b0f5464d7d346c) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-751](https://github.com/mkdocstrings/mkdocstrings/issues/751)

## [1.7.1](https://github.com/mkdocstrings/griffe/releases/tag/1.7.1) - 2025-03-29

[Compare with 1.7.0](https://github.com/mkdocstrings/griffe/compare/1.7.0...1.7.1)

### Bug Fixes

- Never raise alias resolution error when resolving a name from an `__init__` method scope ([949ff7d](https://github.com/mkdocstrings/griffe/commit/949ff7dd3916a96f52068ceefebeed9c2ac16cee) by TimothÃ©e Mazzucotelli). [Issue-374](https://github.com/mkdocstrings/griffe/issues/374)

## [1.7.0](https://github.com/mkdocstrings/griffe/releases/tag/1.7.0) - 2025-03-27

[Compare with 1.6.3](https://github.com/mkdocstrings/griffe/compare/1.6.3...1.7.0)

### Dependencies

- Remove dependency to `astunparse` (Python 3.8-) ([fd052b1](https://github.com/mkdocstrings/griffe/commit/fd052b1e6079ae1883ac3db43708b5cc17ae5cf6) by TimothÃ©e Mazzucotelli).

### Features

- Add `warnings` parameter to docstring parsers, allowing to disable all warning logs when parsing docstrings ([7ac01ba](https://github.com/mkdocstrings/griffe/commit/7ac01ba4da62176119fcf249c338eb3110d15513) by TimothÃ©e Mazzucotelli). [Issue-293](https://github.com/mkdocstrings/griffe/issues/293)

## [1.6.3](https://github.com/mkdocstrings/griffe/releases/tag/1.6.3) - 2025-03-26

[Compare with 1.6.2](https://github.com/mkdocstrings/griffe/compare/1.6.2...1.6.3)

### Bug Fixes

- Allow setting `lineno`, `endlineno` and `value` through aliases ([d038eaa](https://github.com/mkdocstrings/griffe/commit/d038eaa1eb96cab7e70a4ceebacd4246f6a1cfb4) by TimothÃ©e Mazzucotelli). [Issue-griffe-pydantic-29](https://github.com/mkdocstrings/griffe-pydantic/issues/29)
- Don't resolve attribute values to attribute with same name ([25cc58f](https://github.com/mkdocstrings/griffe/commit/25cc58fae55b6b34b2938fdce6acc80ea0e78aff) by TimothÃ©e Mazzucotelli). [Issue-367](https://github.com/mkdocstrings/griffe/issues/367)

### Code Refactoring

- Improve objects conversion to annotation during dynamic analysis ([716d27b](https://github.com/mkdocstrings/griffe/commit/716d27b0c9bdd798d35a23d999431b62b0b647da) by TimothÃ©e Mazzucotelli). [Issue-369](https://github.com/mkdocstrings/griffe/issues/369)

## [1.6.2](https://github.com/mkdocstrings/griffe/releases/tag/1.6.2) - 2025-03-20

[Compare with 1.6.1](https://github.com/mkdocstrings/griffe/compare/1.6.1...1.6.2)

### Code Refactoring

- Maintain exports order (`__all__`) ([ded36bf](https://github.com/mkdocstrings/griffe/commit/ded36bf94ed4b8b83797e9da4a3d034d0533a5bd) by TimothÃ©e Mazzucotelli).

## [1.6.1](https://github.com/mkdocstrings/griffe/releases/tag/1.6.1) - 2025-03-18

[Compare with 1.6.0](https://github.com/mkdocstrings/griffe/compare/1.6.0...1.6.1)

### Bug Fixes

- Extend exports from already expanded modules ([7e708cf](https://github.com/mkdocstrings/griffe/commit/7e708cf9ffe1845d310633e8486b99d32d5fca5c) by TimothÃ©e Mazzucotelli). [Issue-746](https://github.com/mkdocstrings/mkdocstrings/discussions/746)
- Update imports when merging stubs ([5a92379](https://github.com/mkdocstrings/griffe/commit/5a92379e42c5a8bebc9323aabbbc9df881463718) by TimothÃ©e Mazzucotelli). [Issue-746](https://github.com/mkdocstrings/mkdocstrings/discussions/746)
- Don't alias attributes when inspecting ([8063ba9](https://github.com/mkdocstrings/griffe/commit/8063ba9fd4b3d1f782515b81ba362c63d4ccd2bd) by TimothÃ©e Mazzucotelli). [Issue-366](https://github.com/mkdocstrings/griffe/issues/366)
- Register top-module in collection earlier ([2c389b5](https://github.com/mkdocstrings/griffe/commit/2c389b57781c3c24a21141ad3d0103458418ec51) by TimothÃ©e Mazzucotelli).
- Prevent recursion errors by not looking into inherited members when resolving base classes ([87cbaf8](https://github.com/mkdocstrings/griffe/commit/87cbaf87f09103b5972a47fdf5437e00df6e830a) by TimothÃ©e Mazzucotelli).

## [1.6.0](https://github.com/mkdocstrings/griffe/releases/tag/1.6.0) - 2025-03-01

[Compare with 1.5.7](https://github.com/mkdocstrings/griffe/compare/1.5.7...1.6.0)

### Features

- Allow passing literal docstring styles everywhere in the API, not just `Parser` enumeration values ([053bf20](https://github.com/mkdocstrings/griffe/commit/053bf20e8da49f6bc0171c1755ee4fde1fb401fa) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Follow symlinks when finding modules ([087832f](https://github.com/mkdocstrings/griffe/commit/087832f07dfb8dc529cf68438e7051bd8ce2ae1d) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings-python-258](https://github.com/mkdocstrings/python/issues/258)

## [1.5.7](https://github.com/mkdocstrings/griffe/releases/tag/1.5.7) - 2025-02-11

[Compare with 1.5.6](https://github.com/mkdocstrings/griffe/compare/1.5.6...1.5.7)

### Bug Fixes

- Don't conflate passed argument with class member (instance attribute) ([4791b0b](https://github.com/mkdocstrings/griffe/commit/4791b0b5739e64ab2d225b299aea723f3cfbdf00) by TimothÃ©e Mazzucotelli). [Issue-357](https://github.com/mkdocstrings/griffe/issues/357)

## [1.5.6](https://github.com/mkdocstrings/griffe/releases/tag/1.5.6) - 2025-01-30

[Compare with 1.5.5](https://github.com/mkdocstrings/griffe/compare/1.5.5...1.5.6)

### Bug Fixes

- Handle get/set descriptor objects as properties during dynamic analysis ([bc3c75a](https://github.com/mkdocstrings/griffe/commit/bc3c75acd440356fd7b91d221a8fca87231a6eab) by TimothÃ©e Mazzucotelli). [Issue-354](https://github.com/mkdocstrings/griffe/issues/354)

### Code Refactoring

- Remove Google parser support for Deprecated sections (previously never used) ([425aece](https://github.com/mkdocstrings/griffe/commit/425aeceb9935be446979b669c9d557db84a36873) by TimothÃ©e Mazzucotelli).

## [1.5.5](https://github.com/mkdocstrings/griffe/releases/tag/1.5.5) - 2025-01-16

[Compare with 1.5.4](https://github.com/mkdocstrings/griffe/compare/1.5.4...1.5.5)

### Bug Fixes

- Fix check command's Markdown output format not displaying parameter names ([5e7af22](https://github.com/mkdocstrings/griffe/commit/5e7af227792f602c8e1c40707bc7c058e272ce12) by TimothÃ©e Mazzucotelli).
- Don't output empty change for removed objects when using GitHub output format (check command) ([6842372](https://github.com/mkdocstrings/griffe/commit/68423726c625649dd35b5c8018c752dbb72e5be2) by TimothÃ©e Mazzucotelli). [Issue-349](https://github.com/mkdocstrings/griffe/issues/349)

## [1.5.4](https://github.com/mkdocstrings/griffe/releases/tag/1.5.4) - 2024-12-26

[Compare with 1.5.3](https://github.com/mkdocstrings/griffe/compare/1.5.3...1.5.4)

### Bug Fixes

- Append trailing comma to length-1 tuples ([4fccca7](https://github.com/mkdocstrings/griffe/commit/4fccca7dd8d8a3dd31ccc88930ca89f4f26d26b0) by TimothÃ©e Mazzucotelli). [Issue-343](https://github.com/mkdocstrings/griffe/issues/343)

### Performance Improvements

- Avoid dictionary creation when accessing members of non-classes with subscript syntax ([0279998](https://github.com/mkdocstrings/griffe/commit/027999881415bea9e890493d3ef20b96b8749c4a) by TimothÃ©e Mazzucotelli).

## [1.5.3](https://github.com/mkdocstrings/griffe/releases/tag/1.5.3) - 2024-12-26

[Compare with 1.5.2](https://github.com/mkdocstrings/griffe/compare/1.5.2...1.5.3)

### Code Refactoring

- Stop caching objects' inherited members, aliases' members and inherited members, classes' resolved bases ([e8db3a2](https://github.com/mkdocstrings/griffe/commit/e8db3a2d6c5c2a19a1fa3fc924f11c57d8e86a8e) by TimothÃ©e Mazzucotelli). [Issue-346](https://github.com/mkdocstrings/griffe/issues/346)

## [1.5.2](https://github.com/mkdocstrings/griffe/releases/tag/1.5.2) - 2024-12-26

[Compare with 1.5.1](https://github.com/mkdocstrings/griffe/compare/1.5.1...1.5.2)

### Bug Fixes

- Always resolve aliases when checking APIs ([0b4f0da](https://github.com/mkdocstrings/griffe/commit/0b4f0da1658a3c4877a2519447288c1247694a0d) by TimothÃ©e Mazzucotelli).
- Don't use same branch name when creating a worktree ([6d6c996](https://github.com/mkdocstrings/griffe/commit/6d6c99679976a18233ccda5e5cbfb4eb176312fd) by TimothÃ©e Mazzucotelli). [Issue-337](https://github.com/mkdocstrings/griffe/issues/337)
- Fetch attribute annotations from inherited members too when parsing docstrings ([88fb6b6](https://github.com/mkdocstrings/griffe/commit/88fb6b6abd286b5552887023faa1a22f30cb11e7) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings/python#175](https://github.com/mkdocstrings/python/issues/175)

## [1.5.1](https://github.com/mkdocstrings/griffe/releases/tag/1.5.1) - 2024-10-18

[Compare with 1.5.0](https://github.com/mkdocstrings/griffe/compare/1.5.0...1.5.1)

### Bug Fixes

- Sort Git tags using `creatordate` field, which works with both lightweight and annotated tags ([3bfa401](https://github.com/mkdocstrings/griffe/commit/3bfa4015c333dd7e56e535aa31bd2296701b6fa5) by TimothÃ©e Mazzucotelli). [Issue-327](https://github.com/mkdocstrings/griffe/issues/327)

## [1.5.0](https://github.com/mkdocstrings/griffe/releases/tag/1.5.0) - 2024-10-18

[Compare with 1.4.1](https://github.com/mkdocstrings/griffe/compare/1.4.1...1.5.0)

### Features

- Allow setting and deleting parameters within container ([19f354d](https://github.com/mkdocstrings/griffe/commit/19f354da6a331a12d80a61bd3005cdcc30a3c42c) by TimothÃ©e Mazzucotelli).

## [1.4.1](https://github.com/mkdocstrings/griffe/releases/tag/1.4.1) - 2024-10-12

[Compare with 1.4.0](https://github.com/mkdocstrings/griffe/compare/1.4.0...1.4.1)

### Code Refactoring

- Drop support for Python 3.8 ([f2d39b8](https://github.com/mkdocstrings/griffe/commit/f2d39b8ed40f2b90ac15fd7ad818b3c59b657a43) by TimothÃ©e Mazzucotelli).

## [1.4.0](https://github.com/mkdocstrings/griffe/releases/tag/1.4.0) - 2024-10-11

[Compare with 1.3.2](https://github.com/mkdocstrings/griffe/compare/1.3.2...1.4.0)

### Features

- Add Markdown and GitHub output formats to the `griffe check` command ([806805c](https://github.com/mkdocstrings/griffe/commit/806805c3970a7cf3f32eec436255ea1323a60e1a) by TimothÃ©e Mazzucotelli).

## [1.3.2](https://github.com/mkdocstrings/griffe/releases/tag/1.3.2) - 2024-10-01

[Compare with 1.3.1](https://github.com/mkdocstrings/griffe/compare/1.3.1...1.3.2)

### Bug Fixes

- Normalize paths of temporary Git worktrees ([0821e67](https://github.com/mkdocstrings/griffe/commit/0821e6784e5a3aeb56020867c8b46f9477621ed3) by TimothÃ©e Mazzucotelli). [Issue-324](https://github.com/mkdocstrings/griffe/issues/324)

## [1.3.1](https://github.com/mkdocstrings/griffe/releases/tag/1.3.1) - 2024-09-12

[Compare with 1.3.0](https://github.com/mkdocstrings/griffe/compare/1.3.0...1.3.1)

### Bug Fixes

- Refactor and fix logic again for fetching returns/yields/receives annotation from parents ([a80bd3c](https://github.com/mkdocstrings/griffe/commit/a80bd3c0cc14e5f6efc30fb804b8c7fccb319276) by TimothÃ©e Mazzucotelli). [Follow-up-of-PR-322](https://github.com/mkdocstrings/griffe/pull/322)
- Don't crash on invalid signature given "Receives" section ([1cb8f51](https://github.com/mkdocstrings/griffe/commit/1cb8f514eae9d588cfce8cbbfc3ef84d7deadb47) by TimothÃ©e Mazzucotelli).

## [1.3.0](https://github.com/mkdocstrings/griffe/releases/tag/1.3.0) - 2024-09-10

[Compare with 1.2.0](https://github.com/mkdocstrings/griffe/compare/1.2.0...1.3.0)

### Features

- Allow deselecting multiple or named items in Yields and Receives ([344df50](https://github.com/mkdocstrings/griffe/commit/344df50bfcd66ddb3b8d8250babb40012cbc82b5) by Marco Ricci). [Issue-263](https://github.com/mkdocstrings/griffe/issues/263)

### Bug Fixes

- Don't crash when trying to merge stubs into a compiled module that has no file path ([e1f3ed9](https://github.com/mkdocstrings/griffe/commit/e1f3ed9ad3b046bf137de22f855bb392a76ca116) by TimothÃ©e Mazzucotelli). [Issue-323](https://github.com/mkdocstrings/griffe/issues/323)
- Fix identity checks in inspector when handling attributes ([676cfb4](https://github.com/mkdocstrings/griffe/commit/676cfb44a79e059f74514ff492035e930ed57d03) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Extract common functionality in Returns, Yields and Receives parsing ([c768356](https://github.com/mkdocstrings/griffe/commit/c768356023e1fedaaa3f896b073457a0af34ce0e) by Marco Ricci). [Issue-263](https://github.com/mkdocstrings/griffe/issues/263)
- Remove useless branch in `resolve` method, add tests for it ([aa6c7e4](https://github.com/mkdocstrings/griffe/commit/aa6c7e4d3dbabef384193b778cfdafd05a7102c2) by TimothÃ©e Mazzucotelli).

## [1.2.0](https://github.com/mkdocstrings/griffe/releases/tag/1.2.0) - 2024-08-23

[Compare with 1.1.1](https://github.com/mkdocstrings/griffe/compare/1.1.1...1.2.0)

### Features

- Support attribute syntax in `__all__` values ([ad99794](https://github.com/mkdocstrings/griffe/commit/ad997940b136d315787fcb11c03fc70a40c7e8c2) by TimothÃ©e Mazzucotelli). [Issue-316](https://github.com/mkdocstrings/griffe/issues/316)

## [1.1.1](https://github.com/mkdocstrings/griffe/releases/tag/1.1.1) - 2024-08-20

[Compare with 1.1.0](https://github.com/mkdocstrings/griffe/compare/1.1.0...1.1.1)

### Bug Fixes

- Preemptively expand `__all__` values and wildcard imports before firing the `on_package_loaded` event ([21b3780](https://github.com/mkdocstrings/griffe/commit/21b3780b1a3f7ac62a3380089857a720b646dc4a) by TimothÃ©e Mazzucotelli).

## [1.1.0](https://github.com/mkdocstrings/griffe/releases/tag/1.1.0) - 2024-08-17

[Compare with 1.0.0](https://github.com/mkdocstrings/griffe/compare/1.0.0...1.1.0)

### Features

- Add `on_wildcard_expansion` event ([c6bc6fa](https://github.com/mkdocstrings/griffe/commit/c6bc6fa858a43ea2180f97fd270075d7ee7169e3) by TimothÃ©e Mazzucotelli). [Issue-282](https://github.com/mkdocstrings/griffe/issues/282)
- Add `on_alias` event ([a760a8c](https://github.com/mkdocstrings/griffe/commit/a760a8c684cae0da6b6cc83e37d1d374bfeed662) by TimothÃ©e Mazzucotelli). [Issue-282](https://github.com/mkdocstrings/griffe/issues/282)
- Pass `loader` to `on_package_loaded` hooks ([7f82dc3](https://github.com/mkdocstrings/griffe/commit/7f82dc382f1f20ee9e5f58a9ef7a775563894056) by TimothÃ©e Mazzucotelli).

## [1.0.0](https://github.com/mkdocstrings/griffe/releases/tag/1.0.0) - 2024-08-15

[Compare with 0.49.0](https://github.com/mkdocstrings/griffe/compare/0.49.0...1.0.0)

**V1!**

### Breaking changes

Highlights:

- Extensions inherit from `Extension`, (`VisitorExtension` and `InspectorExtension` are removed)
- Members are serialized (`as_dict`/JSON) as a dictionary instead of a list
- All objects are available in the top-level `griffe` module, nowhere else

Removed objects:

- all modules under the `griffe` package
- the `griffe.DocstringWarningCallable` class
- the `griffe.When` class
- the `griffe.ExtensionType` type
- the `griffe.InspectorExtension` class
- the `griffe.VisitorExtension` class
- the `griffe.HybridExtension` extension
- the `griffe.patch_logger` function
- the `griffe.JSONEncoder.docstring_parser` attribute
- the `griffe.JSONEncoder.docstring_options` attribute
- the `griffe.Extensions.attach_visitor` method
- the `griffe.Extensions.attach_inspector` method
- the `griffe.Extensions.before_visit` method
- the `griffe.Extensions.before_children_visit` method
- the `griffe.Extensions.after_children_visit` method
- the `griffe.Extensions.after_visit` method
- the `griffe.Extensions.before_inspection` method
- the `griffe.Extensions.before_children_inspection` method
- the `griffe.Extensions.after_children_inspection` method
- the `griffe.Extensions.after_inspection` method
- the `griffe.GriffeLoader.load_module` method
- the `has_special_name` and `has_private_name` properties on objects
- the `is_explicitely_exported` and `is_implicitely_exported` properties on objects
- the `member_is_exported` method on objects

Renamed/moved objects:

- `griffe.Function.setter` -> `griffe.Attribute.setter`
- `griffe.Function.deleter` -> `griffe.Attribute.deleter`

Signatures:

- `griffe.docstring_warning(name)` parameter was removed
- `griffe.GriffeLoader.load(module)` parameter was removed
- `griffe.load(module)` parameter was removed
- `griffe.load_git(module)` parameter was removed
- `griffe.find_breaking_changes(ignore_private)` parameter was removed
- see previous deprecations

### Code Refactoring

- Remove all legacy code for v1 ([86d321e](https://github.com/mkdocstrings/griffe/commit/86d321ed1303f7bde28950f14ea75412be1d6888) and [fd72083](https://github.com/mkdocstrings/griffe/commit/fd72083fa06c3eb4ef76fe74c5126eef308766c0)by TimothÃ©e Mazzucotelli). [PR-314](https://github.com/mkdocstrings/griffe/pull/314)

## [0.49.0](https://github.com/mkdocstrings/griffe/releases/tag/0.49.0) - 2024-08-14

[Compare with 0.48.0](https://github.com/mkdocstrings/griffe/compare/0.48.0...0.49.0)

âš¡ Imminent v1! âš¡ðŸš€ See [v0.46](#0460-2024-06-16).

### Deprecations

- Cancel deprecation of `get_logger` and `patch_loggers` (and deprecate `patch_logger` instead). Extensions need loggers too, distinct ones, and they were forgotten... Sorry for the back and forth ðŸ™‡
- Attributes `setter` and `deleter` on `Function` are deprecated. They were moved into the `Attribute` class since properties are instantiated as attributes, not functions.
- Extension hooks must accept `**kwargs` in their signature, to allow forward-compatibility. Accepting `**kwargs` also makes it possible to remove unused arguments from the signature.
- In version 1, Griffe will serialize object members as dictionaries instead of lists. Lists were initially used to preserve source order, but source order can be re-obtained thanks to the line number attributes (`lineno`, `endlineno`). Version 0.49 is able to load both lists and dictionaries from JSON dumps, and version 1 will maintain this ability. However external tools loading JSON dumps will need to be updated.

### Features

- Add `temporary_inspected_package` helper ([3c4ba16](https://github.com/mkdocstrings/griffe/commit/3c4ba160ca4c3407bc60d9125e0d93ae5e08d8f3) by TimothÃ©e Mazzucotelli).
- Accept alias resolution related parameters in `temporary_visited_package` ([7d5408a](https://github.com/mkdocstrings/griffe/commit/7d5408a3bf81d64841bbe620b883bc16cb633f82) by TimothÃ©e Mazzucotelli).
- Accept `inits` parameter in `temporary_visited_package` ([a4859b7](https://github.com/mkdocstrings/griffe/commit/a4859b74bf52ca29cbb46c147a2b6df4532297e1) by TimothÃ©e Mazzucotelli).
- Warn (DEBUG) when an object coming from a sibling, parent or external module instead of the current module or a submodule is exported (listed in `__all__`) ([f82317a](https://github.com/mkdocstrings/griffe/commit/f82317a00333e1b8971625f14e4452e93e9840ff) by TimothÃ©e Mazzucotelli). [Issue-249](https://github.com/mkdocstrings/griffe/issues/249), [Related-to-PR-251](https://github.com/mkdocstrings/griffe/pull/251)
- Pass down agent to extension hooks ([71acb01](https://github.com/mkdocstrings/griffe/commit/71acb018716031331bc26d79bc27fd45f67735c1) by TimothÃ©e Mazzucotelli). [Issue-312](https://github.com/mkdocstrings/griffe/issues/312)
- Add `source` property to docstrings, which return the docstring lines as written in the source ([3f6a71a](https://github.com/mkdocstrings/griffe/commit/3f6a71a34f503e95fad55038292e3c8ab2ce30b6) by TimothÃ©e Mazzucotelli). [Issue-90](https://github.com/mkdocstrings/griffe/issues/90)

### Bug Fixes

- Move `setter` and `deleter` to `Attribute` class instead of `Function`, since that's how properties are instantiated ([309c6e3](https://github.com/mkdocstrings/griffe/commit/309c6e34aded516dcfeab0dd81c2fbcecd2691ac) by TimothÃ©e Mazzucotelli). [Issue-311](https://github.com/mkdocstrings/griffe/issues/311)
- Reduce risk of recursion errors by excluding imported objects from `has_docstrings`, unless they're public ([9296ca7](https://github.com/mkdocstrings/griffe/commit/9296ca7273eb1e6b7255b92793a09b82fd3bc4a9) by TimothÃ©e Mazzucotelli). [Issue-302](https://github.com/mkdocstrings/griffe/issues/302)
- Fix retrieval of annotations from parent for Yields section in properties ([8a21f4d](https://github.com/mkdocstrings/griffe/commit/8a21f4db1743902c56875980a4aa2366609642c1) by TimothÃ©e Mazzucotelli). [Issue-298](https://github.com/mkdocstrings/griffe/issues/298)
- Fix parsing Yields section (Google-style) when yielded values are tuples, and the description has more lines than tuple values ([9091776](https://github.com/mkdocstrings/griffe/commit/90917761ef7ea71ccda8147b3e1ebbc4675d9685) by TimothÃ©e Mazzucotelli).
- Fix condition on objects kinds when merging stubs ([727f99b](https://github.com/mkdocstrings/griffe/commit/727f99b084c703937393d52e930aba4ee5739c3b) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Sort keys when dumping JSON from the command line ([8cdffe9](https://github.com/mkdocstrings/griffe/commit/8cdffe9a68383369f6598820ec867740bee58207) by TimothÃ©e Mazzucotelli). [Issue-310](https://github.com/mkdocstrings/griffe/issues/310)
- Handle both lists and dicts for members when loading JSON data in preparation of v1 ([f89050c](https://github.com/mkdocstrings/griffe/commit/f89050c3dced88d5295971ab019e5c9a5706f6cc) by TimothÃ©e Mazzucotelli). [Issue-310](https://github.com/mkdocstrings/griffe/issues/310)
- Accept `**kwargs` in extension hooks to allow forward-compatibility ([2621d52](https://github.com/mkdocstrings/griffe/commit/2621d52e4d1e89e043e022efb8eba087df5d321e) by TimothÃ©e Mazzucotelli). [Issue-312](https://github.com/mkdocstrings/griffe/issues/312)
- Revert deprecation of `patch_loggers` in favor of `patch_logger` ([a20796a](https://github.com/mkdocstrings/griffe/commit/a20796ac821ac72b22082fde2a68ad9dac735076) by TimothÃ©e Mazzucotelli).
- Expose dummy `load_pypi` in non-Insiders version ([a69cffd](https://github.com/mkdocstrings/griffe/commit/a69cffd89215dbe629cec892ccda3c259d5572ef) by TimothÃ©e Mazzucotelli).
- Don't emit deprecation warnings through own usage of deprecated API ([9922d74](https://github.com/mkdocstrings/griffe/commit/9922d741dc1f9538e5e5f00dd115b297665ac6f8) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings#676](https://github.com/mkdocstrings/mkdocstrings/issues/676)
- Finish preparing docstring style auto-detection feature ([03bdec6](https://github.com/mkdocstrings/griffe/commit/03bdec61bbba86b1fa1b98cb890c034bbfcd44c3) by TimothÃ©e Mazzucotelli). [Issue-5](https://github.com/mkdocstrings/griffe/issues/5)
- Add DocstringStyle literal type to prepare docstring style auto detection feature ([b7aaf64](https://github.com/mkdocstrings/griffe/commit/b7aaf6487f04876b498237726b36d08f8e35b905) by TimothÃ©e Mazzucotelli). [Issue-5](https://github.com/mkdocstrings/griffe/issues/5)
- Inherit from `str, Enum` instead of `StrEnum` which needs a backport ([77f1544](https://github.com/mkdocstrings/griffe/commit/77f15443540acd2d279e08675b41bd69470f76d9) by TimothÃ©e Mazzucotelli). [Issue-307](https://github.com/mkdocstrings/griffe/issues/307)

## [0.48.0](https://github.com/mkdocstrings/griffe/releases/tag/0.48.0) - 2024-07-15

[Compare with 0.47.0](https://github.com/mkdocstrings/griffe/compare/0.47.0...0.48.0)

âš¡ Imminent v1! âš¡ðŸš€ See [v0.46](#0460-2024-06-16).

### Deprecations

- All submodules are deprecated. All objects are now exposed in the top-level `griffe` module.
- All logger names are deprecated, and will be replaced with `"griffe"` in v1. In v1 our single `"griffe"` logger will provide a method to temporarily disable logging, logger.disable(), since that's the most common third-party use.
- The `get_logger` function is deprecated. Instead, we'll use a global `logger` internally, and users are welcome to use it too.
- The `patch_loggers` function is renamed `patch_logger`.
- Following the logging changes, the docstring_warning function can now directly log a warning message instead of returning a callable that does. Passing it a logger name (to get a callable) is deprecated in favor of passing it a docstring, message and offset directly.

### Features

- Support `FORCE_COLOR` environment variable ([e1b7bd9](https://github.com/mkdocstrings/griffe/commit/e1b7bd9c3a5be585815dc972a86a51cb1b63bfe7) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Don't take a shortcut to the end of an alias chain when getting/setting/deleting alias members ([1930609](https://github.com/mkdocstrings/griffe/commit/193060908aa1cecb9931553abbb0f9fa182c66a1) by TimothÃ©e Mazzucotelli).
- Short-circuit `__all__` convention when checking if a module is public ([5abf4e3](https://github.com/mkdocstrings/griffe/commit/5abf4e3343410dbd41760415cff7c5f9e8c2b6b8) by TimothÃ©e Mazzucotelli).
- Reuse existing loggers, preventing overwriting issues ([3c2825f](https://github.com/mkdocstrings/griffe/commit/3c2825f9cf34eb8b0dbedd9fb542e14af3d24c33) by TimothÃ©e Mazzucotelli).
- Ignore .pth files that are not utf-8 encoded ([ea299dc](https://github.com/mkdocstrings/griffe/commit/ea299dcb38ad78c9b3de961e88da214ccadd31be) by Andrew Sansom). [Issue-300](https://github.com/mkdocstrings/griffe/issues/300), [PR-301](https://github.com/mkdocstrings/griffe/pull/301)
- Attributes without annotations cannot be dataclass parameters ([c9b2e09](https://github.com/mkdocstrings/griffe/commit/c9b2e09344538778426c446dad306c4881a873b2) by Hassan Kibirige). [PR-297](https://github.com/mkdocstrings/griffe/pull/297)
- When deciding to alias an object or not during inspection, consider module paths to be equivalent even with arbitrary private components ([8c9f6e6](https://github.com/mkdocstrings/griffe/commit/8c9f6e609a1bb93d0c8c41962bb5a9f410862769) by TimothÃ©e Mazzucotelli). [Issue-296](https://github.com/mkdocstrings/griffe/issues/296)
- Fix target path computation: use qualified names to maintain classes in the path ([6e17def](https://github.com/mkdocstrings/griffe/commit/6e17def0759409c7d5148c1a2f7747d029f17594) by TimothÃ©e Mazzucotelli). [Issue-296](https://github.com/mkdocstrings/griffe/issues/296)

### Code Refactoring

- Prepare loggers for simplification ([381f10f](https://github.com/mkdocstrings/griffe/commit/381f10f9cc3c2e8b7e9f54db23c13334dacc1203) by TimothÃ©e Mazzucotelli).
- Add all previous modules for backward compatibility ([a86e44e](https://github.com/mkdocstrings/griffe/commit/a86e44e14b8f7be5b6fa9fb2e6a1614da65a3918) by TimothÃ©e Mazzucotelli).
- Add main public modules ([fb860b3](https://github.com/mkdocstrings/griffe/commit/fb860b3200699ae85fed52289f3a6136ea522618) by TimothÃ©e Mazzucotelli).
- Simplify "is imported" check in `is_public` property ([c2bbc10](https://github.com/mkdocstrings/griffe/commit/c2bbc10082da8e3b11d2fe4576db9719b25054e0) by TimothÃ©e Mazzucotelli).
- Use string and integer enumerations ([06b383b](https://github.com/mkdocstrings/griffe/commit/06b383b5d61bc5083c53745e2c19d0da75e55481) by TimothÃ©e Mazzucotelli).
- Renamed agents nodes modules ([ddc5b0c](https://github.com/mkdocstrings/griffe/commit/ddc5b0cc5bba3e0901fe6c7e9f9fe5b70bd2883c) by TimothÃ©e Mazzucotelli).
- Clean up and document internal API, mark legacy code ([92594a9](https://github.com/mkdocstrings/griffe/commit/92594a99fed42eb2daa3bbeb797edbf3507f3068) by TimothÃ©e Mazzucotelli).
- Renamed `dataclasses` internal modules to `models` ([5555de6](https://github.com/mkdocstrings/griffe/commit/5555de62426063483196888f1bc73757e7492ce8) by TimothÃ©e Mazzucotelli).
- Move sources under `_griffe` internal package ([cbce6a5](https://github.com/mkdocstrings/griffe/commit/cbce6a5c4740a5964f9b0eb605adbd6f554e99bc) by TimothÃ©e Mazzucotelli).

## [0.47.0](https://github.com/mkdocstrings/griffe/releases/tag/0.47.0) - 2024-06-18

[Compare with 0.46.1](https://github.com/mkdocstrings/griffe/compare/0.46.1...0.47.0)

âš¡ Imminent v1! âš¡ðŸš€ See [v0.46](#0460-2024-06-16).

### Deprecations

- The `has_private_name` and `has_special_name` properties on objects and aliases have been renamed `is_private` and `is_special`. The `is_private` property now only returns true if the name is *not* special.

### Features

- Add `deprecated` attribute and `is_deprecated` property to objects/aliases ([2a75d84](https://github.com/mkdocstrings/griffe/commit/2a75d84265b40983ce4a1eb148677efb803f78c6) by TimothÃ©e Mazzucotelli).
- Add `is_imported` property to objects/aliases ([de926cc](https://github.com/mkdocstrings/griffe/commit/de926cc4782d53b9b28a2f887890d7711dfbc667) by TimothÃ©e Mazzucotelli).
- Add `is_class_private` property to objects/aliases ([491b6c4](https://github.com/mkdocstrings/griffe/commit/491b6c4da086a68e8e1eee13f2d4b7840390b6b9) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Rename `has_private_name` and `has_special_name` to `is_private` and `is_special` ([ae7c7e7](https://github.com/mkdocstrings/griffe/commit/ae7c7e73e7bf7f02b86fc58503888113d98e8e39) by TimothÃ©e Mazzucotelli).

## [0.46.1](https://github.com/mkdocstrings/griffe/releases/tag/0.46.1) - 2024-06-17

[Compare with 0.46.0](https://github.com/mkdocstrings/griffe/compare/0.46.0...0.46.1)

âš¡ Imminent v1! âš¡ðŸš€ See [v0.46](#0460-2024-06-16).

### Bug Fixes

- Always consider special objects ("dunder" attributes/methods/etc.) to be public ([3319410](https://github.com/mkdocstrings/griffe/commit/331941029decd9d400b30ea1471b6bcc384fd54f) by TimothÃ©e Mazzucotelli). [Issue-294](https://github.com/mkdocstrings/griffe/issues/294), [Issue-295](https://github.com/mkdocstrings/griffe/issues/295)
- Don't consider imported objects as public ([ea90952](https://github.com/mkdocstrings/griffe/commit/ea909526f3a637849364544daff74cd49ccaf428) by TimothÃ©e Mazzucotelli). [Discussion-169](https://github.com/mkdocstrings/python/discussions/169)

## [0.46.0](https://github.com/mkdocstrings/griffe/releases/tag/0.46.0) - 2024-06-16

[Compare with 0.45.3](https://github.com/mkdocstrings/griffe/compare/0.45.3...0.46.0)

âš¡ Imminent v1! âš¡ðŸš€

We are working on v1, and it will come soon, so we recommend that you consider adding an upper bound on Griffe. Version 1 will remove all legacy code! There will be a couple more v0 before so that you get all the deprecation warnings needed to upgrade your code using Griffe before upgrading to v1. See breaking changes and deprecations for v0.46 below.

### Breaking Changes

We are still in v0, so no major bump yet.

- Calling objects' has_labels() method with a `labels` keyword argument is not supported anymore. The parameter became a variadic positional parameter, so it cannot be used as a keyword argument anymore. Passing a sequence instead of multiple positional arguments still works but will emit a deprecation warning.
- Calling the load_extensions() function with an `exts` keyword argument is not supported anymore. The parameter became a variadic positional parameter, so it cannot be used as a keyword argument anymore. Passing a sequence instead of multiple positional arguments still works but will emit a deprecation warning.

### Deprecations

- As seen above in the breaking changes section, the only parameters of Object.has_labels() and load_extensions() both became variadic positional parameters. Passing a sequence as single argument is deprecated in favor of passing multiple arguments. This is an ergonomic change: I myself often forgot to wrap extensions in a list. Passing sequences of labels (lists, sets, tuples) is also difficult from Jinja templates.
- The following methods and properties on objects and aliases are deprecated: `member_is_exported()`, `is_explicitely_exported`, `is_implicitely_exported`. Use the is_exported property instead. See [issue 281](https://github.com/mkdocstrings/griffe/issues/281).
- The is_exported() and is_public() methods became properties. They can still be called like methods, but will emit deprecation warnings when doing so. See [issue 281](https://github.com/mkdocstrings/griffe/issues/281).
- The `ignore_private` parameter of the find_breaking_changes() function is now deprecated and unused. With the reworked "exported" and "public" API, this parameter became useless. See [issue 281](https://github.com/mkdocstrings/griffe/issues/281).
- Using `stats()` instead of Stats will now emit a deprecation warning.

### Features

- Add `docstring` attribute to parameters ([e21eabe](https://github.com/mkdocstrings/griffe/commit/e21eabe8c48e3650d04fec805804683cb743ce12) by Hassan Kibirige). [Issue-286](https://github.com/mkdocstrings/griffe/issues/286), [Related-to-mkdocstrings/griffe#252](https://github.com/mkdocstrings/griffe/pull/252), [PR-288](https://github.com/mkdocstrings/griffe/pull/288), Co-authored-by: TimothÃ©e Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Provide line numbers for classes and functions when inspecting ([b6ddcc4](https://github.com/mkdocstrings/griffe/commit/b6ddcc4e6da42318961bb7cb7be59041a43c6451) by TimothÃ©e Mazzucotelli). [Issue-272](https://github.com/mkdocstrings/griffe/issues/272)
- Populate lines collection within helpers ([ab2e947](https://github.com/mkdocstrings/griffe/commit/ab2e9479c2b94dc7b6736e40024db87fb87b4e62) by TimothÃ©e Mazzucotelli). [GitHub-issue-270](https://github.com/mkdocstrings/griffe/issues/270), [Radicle-issue-0d6a513](https://app.radicle.xyz/nodes/seed.radicle.garden/rad:z23ZVuA1DWS99PDJ1rcarCtJi99x1/issues/0d6a51328f554f235c38a2a652b844c4ba21bba5)

### Bug Fixes

- Handle partials as functions while inspecting ([be29c32](https://github.com/mkdocstrings/griffe/commit/be29c3214680dc20c9c776d12a2a15ca690fa8d0) by TimothÃ©e Mazzucotelli).
- Populate lines collection before visiting/inspecting modules within helpers ([08c3f40](https://github.com/mkdocstrings/griffe/commit/08c3f409f3fc130f07b2d717cddff38d47d4dbca) by TimothÃ©e Mazzucotelli). [Issue-272](https://github.com/mkdocstrings/griffe/issues/272)
- Don't return all lines when line numbers are missing ([9e6dcaa](https://github.com/mkdocstrings/griffe/commit/9e6dcaa8f30132ebef59eb27b1f2f3ff7bc03bae) by TimothÃ©e Mazzucotelli). [Issue-271](https://github.com/mkdocstrings/griffe/issues/271)

### Code Refactoring

- Emit deprecation warning when accessing `stats` instead of `Stats` ([e5572d2](https://github.com/mkdocstrings/griffe/commit/e5572d2eb1dd8dbe8f9b43b33119bd9becc4a4d9) by TimothÃ©e Mazzucotelli).
- Rework "exported" and "public" logic ([b327b90](https://github.com/mkdocstrings/griffe/commit/b327b908d9546c8eb8f4ce5d3a216309937a6552) by TimothÃ©e Mazzucotelli). [Issue-281](https://github.com/mkdocstrings/griffe/issues/281)
- Allow passing multiple extensions to `load_extensions` instead of a sequence ([fadb72b](https://github.com/mkdocstrings/griffe/commit/fadb72b4b693f418ebc11aefba3be188a2522c7e) by TimothÃ©e Mazzucotelli). [Issue-268](https://github.com/mkdocstrings/griffe/issues/268)
- Allow passing multiple labels to `Object.has_labels` instead of set ([c4e3bf2](https://github.com/mkdocstrings/griffe/commit/c4e3bf2c1a6ff7a1a66f203ae7abec859cbdea44) by TimothÃ©e Mazzucotelli). [Issue-267](https://github.com/mkdocstrings/griffe/issues/267)

## [0.45.3](https://github.com/mkdocstrings/griffe/releases/tag/0.45.3) - 2024-06-09

[Compare with 0.45.2](https://github.com/mkdocstrings/griffe/compare/0.45.2...0.45.3)

### Bug Fixes

- Always call `on_package_loaded` hook on a package, and not any other object ([40db38d](https://github.com/mkdocstrings/griffe/commit/40db38d6d55c5a7926d39408e7fd51ec198b62b9) by TimothÃ©e Mazzucotelli). [Issue-283](https://github.com/mkdocstrings/griffe/issues/283)

## [0.45.2](https://github.com/mkdocstrings/griffe/releases/tag/0.45.2) - 2024-05-23

[Compare with 0.45.1](https://github.com/mkdocstrings/griffe/compare/0.45.1...0.45.2)

### Bug Fixes

- Support setuptools' new editable modules using type annotations ([14d45e8](https://github.com/mkdocstrings/griffe/commit/14d45e83d4a48c67b2347965351145cc78d7abe9) by TimothÃ©e Mazzucotelli). [Issue-273](https://github.com/mkdocstrings/griffe/issues/273)

## [0.45.1](https://github.com/mkdocstrings/griffe/releases/tag/0.45.1) - 2024-05-18

[Compare with 0.45.0](https://github.com/mkdocstrings/griffe/compare/0.45.0...0.45.1)

### Bug Fixes

- Fix loading of importable modules thanks to their `__path__` attribute ([56f5363](https://github.com/mkdocstrings/griffe/commit/56f5363063b54bc43a7e61da7ac6b177db2f158f) by TimothÃ©e Mazzucotelli). [Issue-269](https://github.com/mkdocstrings/griffe/issues/269)

## [0.45.0](https://github.com/mkdocstrings/griffe/releases/tag/0.45.0) - 2024-05-12

[Compare with 0.44.0](https://github.com/mkdocstrings/griffe/compare/0.44.0...0.45.0)

### Features

- Implement `-x`, `--force-inspection` CLI option ([776063d](https://github.com/mkdocstrings/griffe/commit/776063d971b059576c62f62fdd2e1199de033711) by TimothÃ©e Mazzucotelli).
- Implement `force_inspection` option in the loader API ([3266f22](https://github.com/mkdocstrings/griffe/commit/3266f2290637d3f46d782fe7ce222ff29f549043) by TimothÃ©e Mazzucotelli).
- Support inspecting packages (`__init__` modules) ([3f74f67](https://github.com/mkdocstrings/griffe/commit/3f74f679de15df098482fead505d0402bff84401) by TimothÃ©e Mazzucotelli).
- Add parameters for resolving aliases to `load` functions ([e418dee](https://github.com/mkdocstrings/griffe/commit/e418dee1563e2a02ec61c920842e8b8a13419448) by TimothÃ©e Mazzucotelli).
- Load private sibling modules by default when resolving aliases ([4806189](https://github.com/mkdocstrings/griffe/commit/4806189111572495466638bb7899cf906eeebfe9) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Pass down modules collection when inspecting ([bc0f74b](https://github.com/mkdocstrings/griffe/commit/bc0f74bef40a812e00765a7ab17507b0bfbd62c3) by TimothÃ©e Mazzucotelli).
- Catch loading errors when loading additional modules during wildcard expansion and alias resolution ([964e0d2](https://github.com/mkdocstrings/griffe/commit/964e0d2b78d3bc3530601009148fb4a5905b8721) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Improve stats code and performance ([eeb497f](https://github.com/mkdocstrings/griffe/commit/eeb497fa41acf50801cc6a7a240d079cc1592e79) by TimothÃ©e Mazzucotelli).
- Recurse immediately into non-discoverable submodules (no path on disk) during dynamic analysis ([d0b7a1d](https://github.com/mkdocstrings/griffe/commit/d0b7a1d96a4dd7513f34673b0ef6cd02aa7d0fca) by TimothÃ©e Mazzucotelli).
- Simplify the code that checks if an object should be aliased or not during dynamic analysis ([fc794c2](https://github.com/mkdocstrings/griffe/commit/fc794c24c578fe868900483b20601937db3f3d05) by TimothÃ©e Mazzucotelli).
- Avoid side-effect in inspector by checking early if an object is a cached property ([a6bfcfd](https://github.com/mkdocstrings/griffe/commit/a6bfcfdb9e2a0740d72abbd1480e0aa7e23c9af1) by TimothÃ©e Mazzucotelli).

## [0.44.0](https://github.com/mkdocstrings/griffe/releases/tag/0.44.0) - 2024-04-19

[Compare with 0.43.0](https://github.com/mkdocstrings/griffe/compare/0.43.0...0.44.0)

### Features

- Add `resolved` property on expression names, returning the corresponding Griffe object ([9b5ca45](https://github.com/mkdocstrings/griffe/commit/9b5ca4574250f847fd33a8cb92af56806db50c1b) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Fix enumeration properties on expression names ([6f22256](https://github.com/mkdocstrings/griffe/commit/6f22256ad02439d961bce2bb1afa32d4e9e10b10) by TimothÃ©e Mazzucotelli).

## [0.43.0](https://github.com/mkdocstrings/griffe/releases/tag/0.43.0) - 2024-04-18

[Compare with 0.42.2](https://github.com/mkdocstrings/griffe/compare/0.42.2...0.43.0)

### Features

- Add properties telling whether an expression name resolves to an enumeration class, instance or value ([fdb21d9](https://github.com/mkdocstrings/griffe/commit/fdb21d943f72fb10a4406930bf3e3bf7aceff6b0) by TimothÃ©e Mazzucotelli). [Issue-mkdocstrings/python#124](https://github.com/mkdocstrings/python/issues/124)

## [0.42.2](https://github.com/mkdocstrings/griffe/releases/tag/0.42.2) - 2024-04-15

[Compare with 0.42.1](https://github.com/mkdocstrings/griffe/compare/0.42.1...0.42.2)

### Bug Fixes

- Fix target path of aliases for multipart imports (`import a.b.c as x`) ([ee27ad9](https://github.com/mkdocstrings/griffe/commit/ee27ad97669a7321d18e6724e6c155cef601a289) by TimothÃ©e Mazzucotelli). [Issue-259](https://github.com/mkdocstrings/griffe/issues/259)

## [0.42.1](https://github.com/mkdocstrings/griffe/releases/tag/0.42.1) - 2024-03-19

[Compare with 0.42.0](https://github.com/mkdocstrings/griffe/compare/0.42.0...0.42.1)

### Bug Fixes

- Don't return class variables as parameters of dataclasses ([2729c22](https://github.com/mkdocstrings/griffe/commit/2729c22505d87b771ab7a70c91c9f8301275aa8c) by Hassan Kibirige). [PR-253](https://github.com/mkdocstrings/griffe/pull/253)
- Don't turn items annotated as InitVar into dataclass members ([6835ea3](https://github.com/mkdocstrings/griffe/commit/6835ea361325a205c0af69acabc66ca5193156c5) by Hassan Kibirige). [PR-252](https://github.com/mkdocstrings/griffe/pull/252)

## [0.42.0](https://github.com/mkdocstrings/griffe/releases/tag/0.42.0) - 2024-03-11

[Compare with 0.41.3](https://github.com/mkdocstrings/griffe/compare/0.41.3...0.42.0)

### Features

- Better support for dataclasses ([82a9d57](https://github.com/mkdocstrings/griffe/commit/82a9d5798b2eebddfd640b918415a0e3de2ca739) by TimothÃ©e Mazzucotelli). [Issue-33](https://github.com/mkdocstrings/griffe/issues/233), [Issue-34](https://github.com/mkdocstrings/griffe/issues/234), [Issue-38](https://github.com/mkdocstrings/griffe/issues/238), [Issue-39](https://github.com/mkdocstrings/griffe/issues/239), [PR-240](https://github.com/mkdocstrings/griffe/pull/240)

### Bug Fixes

- Don't return properties as parameters of dataclasses (again) ([8c48397](https://github.com/mkdocstrings/griffe/commit/8c48397e7301bbb296e2f2630405f2d22f7222e3) by Hassan Kibirige). [Issue-232](https://github.com/mkdocstrings/griffe/issues/232), [PR-248](https://github.com/mkdocstrings/griffe/pull/248)
- Fix getting return type from parent property when parsing Sphinx docstrings ([f314957](https://github.com/mkdocstrings/griffe/commit/f314957c9da7805a9eb1a23d1a7f3d47b0b1e4c0) by TimothÃ©e Mazzucotelli). [Issue-125](https://github.com/mkdocstrings/griffe/issues/125)

### Code Refactoring

- Warn (debug) when a submodule shadows a member with the same name ([cdc9e1c](https://github.com/mkdocstrings/griffe/commit/cdc9e1c5ee92a4c621314a9d9c6c465bfdd2ad92) by TimothÃ©e Mazzucotelli). [Issue-124](https://github.com/mkdocstrings/griffe/issues/124)

## [0.41.3](https://github.com/mkdocstrings/griffe/releases/tag/0.41.3) - 2024-03-04

[Compare with 0.41.2](https://github.com/mkdocstrings/griffe/compare/0.41.2...0.41.3)

### Code Refactoring

- Catch index errors when finding top module in case of search path misconfiguration ([46c56c7](https://github.com/mkdocstrings/griffe/commit/46c56c7ff505531f5422f526ad38095ed463cc1b) by TimothÃ©e Mazzucotelli). [Issue-#246](https://github.com/mkdocstrings/griffe/issues/246)

## [0.41.2](https://github.com/mkdocstrings/griffe/releases/tag/0.41.2) - 2024-03-03

[Compare with 0.41.1](https://github.com/mkdocstrings/griffe/compare/0.41.1...0.41.2)

### Bug Fixes

- Fix discovery of packages in the current working directory ([44f9617](https://github.com/mkdocstrings/griffe/commit/44f96173df188568bb1db54a20270ff0a08298c6) by TimothÃ©e Mazzucotelli). [Discussion-mkdocstrings#654](https://github.com/mkdocstrings/mkdocstrings/discussions/654)

## [0.41.1](https://github.com/mkdocstrings/griffe/releases/tag/0.41.1) - 2024-03-01

[Compare with 0.41.0](https://github.com/mkdocstrings/griffe/compare/0.41.0...0.41.1)

### Deprecations

- The `load_git` function moved from `griffe.git` to `griffe.loader`. It is still importable from `griffe.git`, but will emit a deprecation warning.

### Code Refactoring

- Expose Git utilities, move `load_git` into the `loader` module ([327cc5b](https://github.com/mkdocstrings/griffe/commit/327cc5b0f28f7236eaaf1c028674b6e0006611da) by TimothÃ©e Mazzucotelli).

## [0.41.0](https://github.com/mkdocstrings/griffe/releases/tag/0.41.0) - 2024-02-26

[Compare with 0.40.1](https://github.com/mkdocstrings/griffe/compare/0.40.1...0.41.0)

### Features

- Add option to append `sys.path` to search paths to the check command too ([d153fa0](https://github.com/mkdocstrings/griffe/commit/d153fa0aeaa248ae13101f189f887f9bfee27f04) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Special case NumpyDoc "warnings" and "notes" sections (plural) ([3b47cdb](https://github.com/mkdocstrings/griffe/commit/3b47cdb889e08106404bfcdbd3ce651f7eee6cdf) by Ethan Henderson). [PR #236](https://github.com/mkdocstrings/griffe/pull/236)
- Serialize line numbers even if zero ([55e6e0e](https://github.com/mkdocstrings/griffe/commit/55e6e0e6c01351aa832aaf934d001442f66c8598) by TimothÃ©e Mazzucotelli).
- Fix handling of lambda expressions ([598d08a](https://github.com/mkdocstrings/griffe/commit/598d08ae0dcd7d266194237211e6431ee65aee67) by TimothÃ©e Mazzucotelli).
- Fix building expressions (and string values) for `yield` and `yield from` statements ([439f65e](https://github.com/mkdocstrings/griffe/commit/439f65e3703c5cad7d68aa3b2da371599236f58b) by TimothÃ©e Mazzucotelli).
- Do not create aliases pointing to themselves ([356305f](https://github.com/mkdocstrings/griffe/commit/356305f69664c1d955f4dbf7c865cb4f553488fc) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Remove `get_call_keyword_arguments` utility function, as it is implemented with a single line and creates a cyclic dependency with expressions ([35cf170](https://github.com/mkdocstrings/griffe/commit/35cf170cc91ba740e6f997d76f99d6a07e8d4437) by TimothÃ©e Mazzucotelli).
- Further prevent cyclic dependency between node utils and expressions ([9614c83](https://github.com/mkdocstrings/griffe/commit/9614c83c037637d7823a4c06f115c3e2e4b6e10f) by TimothÃ©e Mazzucotelli).
- Avoid cyclic dependency between node utils and expressions ([aedf39c](https://github.com/mkdocstrings/griffe/commit/aedf39c3795197deb6067e039da8bdec182bd363) by TimothÃ©e Mazzucotelli).
- Move arguments node-parsing logic into its own module (used by visitor and lambda expressions) ([ad68e65](https://github.com/mkdocstrings/griffe/commit/ad68e65363c4338d7f38ccade2f9cc05d41f8100) by TimothÃ©e Mazzucotelli).
- Use canonical imports ([3091660](https://github.com/mkdocstrings/griffe/commit/3091660ae1b6253e481cedbdcc31b73c0ab334df) by TimothÃ©e Mazzucotelli).
- Use `ast.unparse` instead of our own unparser ([6fe1316](https://github.com/mkdocstrings/griffe/commit/6fe1316807870cbf93bba79f3d400cae6630ea73) by TimothÃ©e Mazzucotelli).
- Only return 0 for the line number of removed objects when the location is reworked as relative ([3a4d054](https://github.com/mkdocstrings/griffe/commit/3a4d054e993e8a53cce9e53057e81479ab5f6034) by TimothÃ©e Mazzucotelli).

## [0.40.1](https://github.com/mkdocstrings/griffe/releases/tag/0.40.1) - 2024-02-08

[Compare with 0.40.0](https://github.com/mkdocstrings/griffe/compare/0.40.0...0.40.1)

### Bug Fixes

- Don't return properties as parameters of dataclasses ([5a5c03b](https://github.com/mkdocstrings/griffe/commit/5a5c03b38366049f19fc2b65f09153e7df5748ce) by TimothÃ©e Mazzucotelli). [Issue #232](https://github.com/mkdocstrings/griffe/issues/232)

## [0.40.0](https://github.com/mkdocstrings/griffe/releases/tag/0.40.0) - 2024-01-30

[Compare with 0.39.1](https://github.com/mkdocstrings/griffe/compare/0.39.1...0.40.0)

### Features

- Store reference to function call in keyword expressions ([d72f9d3](https://github.com/mkdocstrings/griffe/commit/d72f9d3a425fee11f23f9f7b44814b6fda458e6e) by TimothÃ©e Mazzucotelli). [PR #231](https://github.com/mkdocstrings/griffe/pull/231)

## [0.39.1](https://github.com/mkdocstrings/griffe/releases/tag/0.39.1) - 2024-01-18

[Compare with 0.39.0](https://github.com/mkdocstrings/griffe/compare/0.39.0...0.39.1)

### Bug Fixes

- De-duplicate search paths in finder as they could lead to the same modules being yielded twice or more when scanning namespace packages ([80a158a](https://github.com/mkdocstrings/griffe/commit/80a158a2de8d53a054405c3e14113b09d73335a3) by TimothÃ©e Mazzucotelli).
- Fix logic for skipping already encountered modules when scanning namespace packages ([21a48d0](https://github.com/mkdocstrings/griffe/commit/21a48d0b9248467fe3c36440bee649ce8879f295) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings#646](https://github.com/mkdocstrings/mkdocstrings/issues/646)

## [0.39.0](https://github.com/mkdocstrings/griffe/releases/tag/0.39.0) - 2024-01-16

[Compare with 0.38.1](https://github.com/mkdocstrings/griffe/compare/0.38.1...0.39.0)

### Features

- Support editable installs dynamically exposing modules from other directories ([2c4ba75](https://github.com/mkdocstrings/griffe/commit/2c4ba751d7d47eb48b47179d316722315e5d4647) by TimothÃ©e Mazzucotelli). [Issue #229](https://github.com/mkdocstrings/griffe/issues/229)
- Support meson-python editable modules ([9123897](https://github.com/mkdocstrings/griffe/commit/9123897ad8d85e48bd3c435ffabcf9a36a0ed355) by TimothÃ©e Mazzucotelli).
- Support admonitions in Numpydoc docstrings ([1e311a4](https://github.com/mkdocstrings/griffe/commit/1e311a4eb935c58d488c928a86493ab3f3368f06) by Michael Chow). [Issue #214](https://github.com/mkdocstrings/griffe/issues/214), [PR #219](https://github.com/mkdocstrings/griffe/pull/219), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Expose module properties on all objects ([123f8c5](https://github.com/mkdocstrings/griffe/commit/123f8c5ba1826435e90dafffbfe304bd6ab8e187) by TimothÃ©e Mazzucotelli). [Issue #226](https://github.com/mkdocstrings/griffe/issues/226)

### Bug Fixes

- Consider space-only lines to be empty, never break Numpydoc sections on blank lines ([8c57354](https://github.com/mkdocstrings/griffe/commit/8c5735497578417e1dd723625590539016e7b7a5) by TimothÃ©e Mazzucotelli). [PR #220](https://github.com/mkdocstrings/griffe/pull/220), [Related to PR #219](https://github.com/mkdocstrings/griffe/pull/219), [Numpydoc discussion](https://github.com/numpy/numpydoc/issues/463)
- Allow merging stubs into alias targets ([3cf7958](https://github.com/mkdocstrings/griffe/commit/3cf795871a0549b901d9374705d6a1eb84700128) by TimothÃ©e Mazzucotelli).
- Insert the right directory in front of import paths before inspecting a module (dynamically imported) ([7d75c71](https://github.com/mkdocstrings/griffe/commit/7d75c71477ccb208e071bfe3c3204a0490274b44) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Set lineno to 0 for removed objects when checking API ([b660c34](https://github.com/mkdocstrings/griffe/commit/b660c346feb3a95fbe54a6dad460e988a9a41774) by TimothÃ©e Mazzucotelli).
- Prepare support for new output formats (styles) of the check command ([f2ece1e](https://github.com/mkdocstrings/griffe/commit/f2ece1e602b0fb3d888a60d892089a55fdcf60f0) by TimothÃ©e Mazzucotelli).
- Transform finder's package and namespace package classes into dataclasses ([16be6a4](https://github.com/mkdocstrings/griffe/commit/16be6a4a7660d8ed13ccdcf9c571eda647e078f0) by TimothÃ©e Mazzucotelli).

## [0.38.1](https://github.com/mkdocstrings/griffe/releases/tag/0.38.1) - 2023-12-06

[Compare with 0.38.0](https://github.com/mkdocstrings/griffe/compare/0.38.0...0.38.1)

### Bug Fixes

- Support absolute Windows paths for extensions ([4e67d8f](https://github.com/mkdocstrings/griffe/commit/4e67d8fa5f0e9f23c1df2e1d772fc0f1e4e6c2e0) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings-python#116](https://github.com/mkdocstrings/python/issues/116)

## [0.38.0](https://github.com/mkdocstrings/griffe/releases/tag/0.38.0) - 2023-11-13

[Compare with 0.37.0](https://github.com/mkdocstrings/griffe/compare/0.37.0...0.38.0)

### Features

- Allow passing load parameters to the temporary package visit helper ([3a7854f](https://github.com/mkdocstrings/griffe/commit/3a7854fb180e34392fd520d9d25a6298d4b80830) by TimothÃ©e Mazzucotelli).

## [0.37.0](https://github.com/mkdocstrings/griffe/releases/tag/0.37.0) - 2023-11-12

[Compare with 0.36.9](https://github.com/mkdocstrings/griffe/compare/0.36.9...0.37.0)

### Deprecations

- The loader `load_module` method was renamed `load`, Its `module` parameter was renamed `objspec` and is now positional-only. This method always returned the specified object, not just modules, so it made more sense to rename it `load` and to rename the parameter specifying the object. Old usages (`load_module` and `module=...`) will continue to work for some time (a few months, a year, more), and will emit deprecation warnings.

### Features

- Add option to warn about unknown parameters in Sphinx docstrings ([8b11d77](https://github.com/mkdocstrings/griffe/commit/8b11d77315ca7a5e15da519db1663d05805dd075) by Ashwin Vinod). [Issue #64](https://github.com/mkdocstrings/griffe/issues/64), [PR #210](https://github.com/mkdocstrings/griffe/pull/210), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Add `on_package_loaded` event ([a5cf654](https://github.com/mkdocstrings/griffe/commit/a5cf6543b43db06c4d0f24d2631ddc86b1fee41e) by TimothÃ©e Mazzucotelli).
- Add option to find, load and merge stubs-only packages ([6e55f3b](https://github.com/mkdocstrings/griffe/commit/6e55f3bd0838e3f229fcd37d3aeced0146d33ff1) by Romain). [PR #221](https://github.com/mkdocstrings/griffe/pull/221), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

### Bug Fixes

- Report attributes who lost their value as "unset" ([dfffa4b](https://github.com/mkdocstrings/griffe/commit/dfffa4b96a8a70f93b899bd41aefeaa9939819e9) by Geethakrishna-Puligundla). [Issue #218](https://github.com/mkdocstrings/griffe/issues/218), [PR #225](https://github.com/mkdocstrings/griffe/pull/225)
- Don't crash when computing MRO for a class that is named after its parent ([a2dd8a6](https://github.com/mkdocstrings/griffe/commit/a2dd8a6bc3f95679e1c2e79ce05d175fb8f89ccc) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Rename loader `load_module` method to `load` ([2bfe206](https://github.com/mkdocstrings/griffe/commit/2bfe206b57f607b56f7bcb5a85a7e2a25fe3bf47) by TimothÃ©e Mazzucotelli).

## [0.36.9](https://github.com/mkdocstrings/griffe/releases/tag/0.36.9) - 2023-10-27

[Compare with 0.36.8](https://github.com/mkdocstrings/griffe/compare/0.36.8...0.36.9)

### Bug Fixes

- Fix accessing alias members with `__getitem__` ([8929409](https://github.com/mkdocstrings/griffe/commit/8929409d4703c6b684084e88aae0d99423e05dbf) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings-python#111](https://github.com/mkdocstrings/python/issues/111)

### Code Refactoring

- Expose parser enumeration and parser functions in top-level module ([785baa0](https://github.com/mkdocstrings/griffe/commit/785baa04e3081fcf80756f56dddb95a00cb9b025) by TimothÃ©e Mazzucotelli).

## [0.36.8](https://github.com/mkdocstrings/griffe/releases/tag/0.36.8) - 2023-10-25

[Compare with 0.36.7](https://github.com/mkdocstrings/griffe/compare/0.36.7...0.36.8)

### Bug Fixes

- Use already parsed docstring sections when dumping full data ([311807b](https://github.com/mkdocstrings/griffe/commit/311807b8fa1716dabe5ba18d3e12c947286afd8e) by TimothÃ©e Mazzucotelli). [Discussion griffe-typingdoc#6](https://github.com/mkdocstrings/griffe-typingdoc/discussions/6)

## [0.36.7](https://github.com/mkdocstrings/griffe/releases/tag/0.36.7) - 2023-10-17

[Compare with 0.36.6](https://github.com/mkdocstrings/griffe/compare/0.36.6...0.36.7)

### Bug Fixes

- Add missing proxies (methods/properties) to aliases ([7320640](https://github.com/mkdocstrings/griffe/commit/7320640d42ebb4546f787fe458d5032a67ea20b7) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Use final target in alias proxies ([731d662](https://github.com/mkdocstrings/griffe/commit/731d66237252e754b7a935ca4d0344f554edb5ff) by TimothÃ©e Mazzucotelli).

## [0.36.6](https://github.com/mkdocstrings/griffe/releases/tag/0.36.6) - 2023-10-16

[Compare with 0.36.5](https://github.com/mkdocstrings/griffe/compare/0.36.5...0.36.6)

### Code Refactoring

- Only consider presence/absence for docstrings truthiness, not emptiness of their value ([4c49611](https://github.com/mkdocstrings/griffe/commit/4c496117880d2166bfc2bc8c40a235c23cef8527) by TimothÃ©e Mazzucotelli).

## [0.36.5](https://github.com/mkdocstrings/griffe/releases/tag/0.36.5) - 2023-10-09

[Compare with 0.36.4](https://github.com/mkdocstrings/griffe/compare/0.36.4...0.36.5)

### Bug Fixes

- Force extension import path to be a string (coming from MkDocs' `!relative` tag) ([34e21a9](https://github.com/mkdocstrings/griffe/commit/34e21a9545a38b61a1b80192af312d70f6c607f2) by TimothÃ©e Mazzucotelli).
- Fix crash when trying to get a decorator callable path (found thanks to pysource-codegen) ([e57f08e](https://github.com/mkdocstrings/griffe/commit/e57f08eb5770eb3a9ed12e97da3076b87f109224) by TimothÃ©e Mazzucotelli).
- Fix crash when trying to get docstring after assignment (found thanks to pysource-codegen) ([fb0a0c1](https://github.com/mkdocstrings/griffe/commit/fb0a0c1a8558c9d04855b75e4a9f579b46e2edd8) by TimothÃ©e Mazzucotelli).
- Fix type errors in expressions and value extractor, don't pass duplicate arguments (found thanks to pysource-codegen) ([7e53288](https://github.com/mkdocstrings/griffe/commit/7e53288586bd90198cfd6a898002850c67213209) by TimothÃ©e Mazzucotelli).

## [0.36.4](https://github.com/mkdocstrings/griffe/releases/tag/0.36.4) - 2023-09-28

[Compare with 0.36.3](https://github.com/mkdocstrings/griffe/compare/0.36.3...0.36.4)

### Bug Fixes

- Fix visiting relative imports in non-init modules ([c1138c3](https://github.com/mkdocstrings/griffe/commit/c1138c34b89965fd780d669c7dd6b12f245d8cd9) by TimothÃ©e Mazzucotelli).

## [0.36.3](https://github.com/mkdocstrings/griffe/releases/tag/0.36.3) - 2023-09-28

[Compare with 0.36.2](https://github.com/mkdocstrings/griffe/compare/0.36.2...0.36.3)

### Bug Fixes

- Fix parsing of choices in Numpy parameters ([5f2d997](https://github.com/mkdocstrings/griffe/commit/5f2d99776e326679d2c0d1d9cb6b06d6436971c6) by TimothÃ©e Mazzucotelli). [Issue #212](https://github.com/mkdocstrings/griffe/issues/212)

### Code Refactoring

- Add `repr` methods to function parameters ([9442234](https://github.com/mkdocstrings/griffe/commit/94422349483a25db627921dfe13c7a89b81e700e) by TimothÃ©e Mazzucotelli).

## [0.36.2](https://github.com/mkdocstrings/griffe/releases/tag/0.36.2) - 2023-09-10

[Compare with 0.36.1](https://github.com/mkdocstrings/griffe/compare/0.36.1...0.36.2)

### Bug Fixes

- Fix warnings for docstrings in builtin modules ([6ba3e04](https://github.com/mkdocstrings/griffe/commit/6ba3e0461647c2c76d0fd68889d37bbada686259) by TimothÃ©e Mazzucotelli).
- Fix dumping `filepath` to a dict when it is a list ([066a4a7](https://github.com/mkdocstrings/griffe/commit/066a4a7f22827783c930feacd6a339ed3d00ec27) by davfsa). [PR #207](https://github.com/mkdocstrings/griffe/pull/207)

## [0.36.1](https://github.com/mkdocstrings/griffe/releases/tag/0.36.1) - 2023-09-04

[Compare with 0.36.0](https://github.com/mkdocstrings/griffe/compare/0.36.0...0.36.1)

### Bug Fixes

- Fix iterating non-flat expressions (some nodes were skipped) ([3249155](https://github.com/mkdocstrings/griffe/commit/324915507c1100e04ffed6d926143f66f0016870) by TimothÃ©e Mazzucotelli).

## [0.36.0](https://github.com/mkdocstrings/griffe/releases/tag/0.36.0) - 2023-09-01

[Compare with 0.35.2](https://github.com/mkdocstrings/griffe/compare/0.35.2...0.36.0)

### Features

- Add option to read return type of properties in their summary (Google-style) ([096970f](https://github.com/mkdocstrings/griffe/commit/096970ffa66f491ef34ae1121e8b907f2da4c742) by TimothÃ©e Mazzucotelli). [Issue #137](https://github.com/mkdocstrings/griffe/issues/137), [PR #206](https://github.com/mkdocstrings/griffe/pull/206)
- Add option to make parentheses around the type of returned values optional (Google-style) ([b0620f8](https://github.com/mkdocstrings/griffe/commit/b0620f86e1767183d776771992ce12f961efe395) by TimothÃ©e Mazzucotelli). [Issue #137](https://github.com/mkdocstrings/griffe/issues/137)
- Get class parameters from parent's `__init__` method ([e8a9fdc](https://github.com/mkdocstrings/griffe/commit/e8a9fdcce1cffdc7db5a216f833d10da6116db5a) by TimothÃ©e Mazzucotelli). [Issue #205](https://github.com/mkdocstrings/griffe/issues/205)

### Bug Fixes

- Use all members (declared and inherited) when checking for breakages, avoid false-positives when a member of a class is moved into a parent class ([1c4340b](https://github.com/mkdocstrings/griffe/commit/1c4340b09b111313a5a242caa986a2fa3fdef852) by TimothÃ©e Mazzucotelli). [Issue #203](https://github.com/mkdocstrings/griffe/issues/203)
- Skip early submodules with dots in their path ([5e81b8a](https://github.com/mkdocstrings/griffe/commit/5e81b8afef4e6ce8294cdbaf348f4f1a05add1d8) by TimothÃ©e Mazzucotelli). [Issue #185](https://github.com/mkdocstrings/griffe/issues/185)

### Code Refactoring

- Allow iterating on expressions in both flat and nested ways ([3957fa7](https://github.com/mkdocstrings/griffe/commit/3957fa70abf3f2d8af1a4ab4b1041b873bc724e0) by TimothÃ©e Mazzucotelli).

## [0.35.2](https://github.com/mkdocstrings/griffe/releases/tag/0.35.2) - 2023-08-27

[Compare with 0.35.1](https://github.com/mkdocstrings/griffe/compare/0.35.1...0.35.2)

### Code Refactoring

- Be more strict when parsing sections in Google docstrings ([6a8a228](https://github.com/mkdocstrings/griffe/commit/6a8a2280f8910d4268380400d7888cb8d72b4296) by TimothÃ©e Mazzucotelli). [Issue #204](https://github.com/mkdocstrings/griffe/issues/204)

## [0.35.1](https://github.com/mkdocstrings/griffe/releases/tag/0.35.1) - 2023-08-26

[Compare with 0.35.0](https://github.com/mkdocstrings/griffe/compare/0.35.0...0.35.1)

### Bug Fixes

- Preserve inherited attribute on alias inherited members ([1e19e7b](https://github.com/mkdocstrings/griffe/commit/1e19e7b2c3f2bb10c822c7d8b63b04a76024b4f7) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#102](https://github.com/mkdocstrings/python/issues/102)

## [0.35.0](https://github.com/mkdocstrings/griffe/releases/tag/0.35.0) - 2023-08-24

[Compare with 0.34.0](https://github.com/mkdocstrings/griffe/compare/0.34.0...0.35.0)

### Features

- Add an `is_public` helper method to guess if an object is public ([b823639](https://github.com/mkdocstrings/griffe/commit/b8236391f4ac8b16e9ee861c322e75ea10d6a39b) by TimothÃ©e Mazzucotelli).
- Add option to Google parser allowing to parse Returns sections with or without multiple items ([65fee70](https://github.com/mkdocstrings/griffe/commit/65fee70cf87399b7da92f054180791de0eb4f22d) by Antoine Dechaume). [PR #196](https://github.com/mkdocstrings/griffe/pull/196)

### Bug Fixes

- Allow passing `warn_unknown_params` option to Google and Numpy parsers ([5bf0746](https://github.com/mkdocstrings/griffe/commit/5bf07468d38a158f8e58e3e1c562e8d886d83321) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Preserve alias members path by re-aliasing members instead of returning target's members ([d400cb1](https://github.com/mkdocstrings/griffe/commit/d400cb13c8b7c250ff1e6b6c8ec9be1c7b6ff989) by TimothÃ©e Mazzucotelli).

## [0.34.0](https://github.com/mkdocstrings/griffe/releases/tag/0.34.0) - 2023-08-20

[Compare with 0.33.0](https://github.com/mkdocstrings/griffe/compare/0.33.0...0.34.0)

### Features

- Allow checking if docstring section is empty or not with `if section` ([f6cf559](https://github.com/mkdocstrings/griffe/commit/f6cf559db50718e86cde40eae9d14489cabd9ed8) by TimothÃ©e Mazzucotelli).
- Implement Functions (or Methods), Classes and Modules docstring sections ([929e615](https://github.com/mkdocstrings/griffe/commit/929e6158c093b021ba80773e17613406b38fbf0c) by TimothÃ©e Mazzucotelli).
- Allow passing a docstring parser name instead of its enumeration value ([ce59b7d](https://github.com/mkdocstrings/griffe/commit/ce59b7dca69e3a9946a0735405535e296e0ec9c9) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Explicit checks for subprocess runs ([cc3ca2e](https://github.com/mkdocstrings/griffe/commit/cc3ca2e18877c17fe23e2ceeb1c13e10c9fe46d2) by TimothÃ©e Mazzucotelli).

## [0.33.0](https://github.com/mkdocstrings/griffe/releases/tag/0.33.0) - 2023-08-16

[Compare with 0.32.3](https://github.com/mkdocstrings/griffe/compare/0.32.3...0.33.0)

### Breaking Changes

- Removed `griffe.expressions.Expression` in favor of griffe.Expr and subclasses
- Removed `griffe.expressions.Name` in favor of griffe.ExprName

### Features

- Add `-V`, `--version` CLI flag to show version ([a41515f](https://github.com/mkdocstrings/griffe/commit/a41515f39e6e5e2e28d68980c44cc07a7e0ebbe0) by jgart). [Issue #186](https://github.com/mkdocstrings/griffe/issues/186), [PR #187](https://github.com/mkdocstrings/griffe/pull/187), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

### Code Refactoring

- Improve expressions ([66c8ad5](https://github.com/mkdocstrings/griffe/commit/66c8ad5074e1475aa88a51d8652b5e197760d774) and [0fe8f91](https://github.com/mkdocstrings/griffe/commit/0fe8f9155b571714b0fe2a1bd7aef0b9b0738b08) by TimothÃ©e Mazzucotelli).

## [0.32.3](https://github.com/mkdocstrings/griffe/releases/tag/0.32.3) - 2023-07-17

[Compare with 0.32.2](https://github.com/mkdocstrings/griffe/compare/0.32.2...0.32.3)

### Bug Fixes

- Fix detecting whether an object should be an alias during inspection ([6a63b37](https://github.com/mkdocstrings/griffe/commit/6a63b375db7d639dd05589c56a2f89d1be9d66a8) by TimothÃ©e Mazzucotelli). [Issue #180](https://github.com/mkdocstrings/griffe/issues/180)

### Code Refactoring

- Improve log message when trying to stubs-merge objects of different kinds ([d34a3ba](https://github.com/mkdocstrings/griffe/commit/d34a3ba4bbd15c3fafe9cc5e2e82a2281cf3e094) by TimothÃ©e Mazzucotelli).
- De-duplicate stubs merging log message ([cedc062](https://github.com/mkdocstrings/griffe/commit/cedc062cd4035a4ad0f3a14b4ef31bea4e39374d) by TimothÃ©e Mazzucotelli).

## [0.32.2](https://github.com/mkdocstrings/griffe/releases/tag/0.32.2) - 2023-07-17

[Compare with 0.32.1](https://github.com/mkdocstrings/griffe/compare/0.32.1...0.32.2)

### Bug Fixes

- Keep parentheses around tuples, except within subscripts ([df6e636](https://github.com/mkdocstrings/griffe/commit/df6e636c3ecfaa6befdfdaf26e898e1a71218675) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#88](https://github.com/mkdocstrings/python/issues/88)

## [0.32.1](https://github.com/mkdocstrings/griffe/releases/tag/0.32.1) - 2023-07-15

[Compare with 0.32.0](https://github.com/mkdocstrings/griffe/compare/0.32.0...0.32.1)

### Bug Fixes

- Fix aliases for direct nested imports ([e9867f7](https://github.com/mkdocstrings/griffe/commit/e9867f78044a2a33b575e274224d3a4c16b62439) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#32](https://github.com/mkdocstrings/python/issues/32)

### Code Refactoring

- Simplify AST imports, stop using deprecated code from `ast` ([21d5832](https://github.com/mkdocstrings/griffe/commit/21d5832ba6db051b9754f515f1d7125126dd801f) by TimothÃ©e Mazzucotelli). [Issue #179](https://github.com/mkdocstrings/griffe/issues/179)

## [0.32.0](https://github.com/mkdocstrings/griffe/releases/tag/0.32.0) - 2023-07-13

[Compare with 0.31.0](https://github.com/mkdocstrings/griffe/compare/0.31.0...0.32.0)

### Deprecations

- Classes `InspectorExtension` and `VisitorExtension` are deprecated in favor of Extension. As a side-effect, the `hybrid` extension is also deprecated. See [how to use and write extensions](../guide/users/extending/).

### Breaking Changes

- Module `griffe.agents.base` was removed
- Module `griffe.docstrings.markdown` was removed
- Class `ASTNode` was removed
- Class `BaseInspector` was removed
- Class `BaseVisitor` was removed
- Function `get_parameter_default` was removed
- Function `load_extension` was removed (made private)
- Function `patch_ast` was removed
- Function `tmp_worktree` was removed (made private)
- Type Extension is now a class

### Features

- Numpy parser: handle return section items with just type, or no name and no type ([bdec37d](https://github.com/mkdocstrings/griffe/commit/bdec37dd32a5d4e089ee5e14e5a66be645bb8360) by Michael Chow). [Issue #173](https://github.com/mkdocstrings/griffe/issues/173), [PR #174](https://github.com/mkdocstrings/griffe/pull/174), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Rework extension system ([dea4c83](https://github.com/mkdocstrings/griffe/commit/dea4c830e3bfa0bf7c9f307975cb53e1314c50eb) by TimothÃ©e Mazzucotelli).
- Parse attribute values, parameter defaults and decorators as expressions ([7b653b3](https://github.com/mkdocstrings/griffe/commit/7b653b31bd9c38bf8d960baa5ab75dd56c62fbcb) by TimothÃ©e Mazzucotelli).
- Add loader option to avoid storing source code, reducing memory footprint ([d592edf](https://github.com/mkdocstrings/griffe/commit/d592edf477d9e7a5f9723c96cc259db65b1cae71) by TimothÃ©e Mazzucotelli).
- Add `extra` attribute to objects ([707a348](https://github.com/mkdocstrings/griffe/commit/707a34833f56cf4a1aa302cb1201ad96ff361252) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Numpy-style: don't strip spaces from the left of indented lines ([f13fc0a](https://github.com/mkdocstrings/griffe/commit/f13fc0a7edc7c8ac14c8c482b58735a5f7301bd6) by TimothÃ©e Mazzucotelli). [Discussion #587](https://github.com/mkdocstrings/mkdocstrings/discussions/587)
- Fix relative paths for old versions when checking API ([96fd45b](https://github.com/mkdocstrings/griffe/commit/96fd45b41186eb503d6a2ff4e587cae427aea013) by TimothÃ©e Mazzucotelli).

### Performance Improvements

- Don't store source when dumping as JSON ([d7f314a](https://github.com/mkdocstrings/griffe/commit/d7f314a62dd40c38c8c76ec7102233a588c1e64a) by TimothÃ©e Mazzucotelli).
- Stop caching properties on Object methods ([15bdd74](https://github.com/mkdocstrings/griffe/commit/15bdd744db1f089f4448b952f9acf184c43289ea) by TimothÃ©e Mazzucotelli).
- Stop patching AST, use functions instead ([7302f17](https://github.com/mkdocstrings/griffe/commit/7302f178392c70890d083a1617f1cf4e72395be3) by TimothÃ©e Mazzucotelli). [Issue #171](https://github.com/mkdocstrings/griffe/issues/171)

### Code Refactoring

- Privatize/remove objects ([fdeb16f](https://github.com/mkdocstrings/griffe/commit/fdeb16f61cb5ae7db2394ef2a8ec31843b7ae85b) by TimothÃ©e Mazzucotelli).
- Document public objects with `__all__` ([db0e0e3](https://github.com/mkdocstrings/griffe/commit/db0e0e340efcd48904f448a6e4397a9df36ac50f) by TimothÃ©e Mazzucotelli).
- Remove base visitor and inspector ([bc446e4](https://github.com/mkdocstrings/griffe/commit/bc446e4ac9445636be7fdadbfc0b056cbc1d73e3) by TimothÃ©e Mazzucotelli).
- Auto-register module in collection within loading helpers ([591bacc](https://github.com/mkdocstrings/griffe/commit/591bacc6c46d91beb30f6e01e0ae96f8e3102cf8) by TimothÃ©e Mazzucotelli). [Issue #177](https://github.com/mkdocstrings/griffe/issues/177)

## [0.31.0](https://github.com/mkdocstrings/griffe/releases/tag/0.31.0) - 2023-07-04

[Compare with 0.30.1](https://github.com/mkdocstrings/griffe/compare/0.30.1...0.31.0)

### Breaking Changes

- Drop support for Python 3.7
- API changes:
  - GriffeLoader.resolve_aliases(only_exported): Deprecated parameter was removed and replaced by `implicit` (inverse semantics)
  - GriffeLoader.resolve_aliases(only_known_modules): Deprecated parameter was removed and replaced by `external` (inverse semantics)
  - LinesCollection.tokens: Public object was removed (Python 3.7)
  - `ASTNode.end_lineno`: Public object was removed (Python 3.7)
  - `griffe.agents.extensions`: Deprecated module was removed and replaced by `griffe.extensions`

### Features

- Add `--color`, `--no-color` options to check subcommand ([eac783c](https://github.com/mkdocstrings/griffe/commit/eac783c2df5a0ba57612b71b0797a74cf7fc8e39) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Report removed public modules ([68906cb](https://github.com/mkdocstrings/griffe/commit/68906cb6083e5f7cad3a1cb5a74878d6e74f9c69) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Improve check output ([6b0a1f0](https://github.com/mkdocstrings/griffe/commit/6b0a1f0397d153a95d1b6c69d109ce141e39e1f1) by TimothÃ©e Mazzucotelli).
- Remove deprecated `griffe.agents.extensions` module ([b555c78](https://github.com/mkdocstrings/griffe/commit/b555c788b624fa5aa0c871e2c199079868252f22) by TimothÃ©e Mazzucotelli).
- Remove deprecated parameters from loader's `resolve_aliases` method ([dd98acd](https://github.com/mkdocstrings/griffe/commit/dd98acd5f0c85661c7a00002805c92caa4c11a21) by TimothÃ©e Mazzucotelli).
- Drop Python 3.7 support ([e4be30a](https://github.com/mkdocstrings/griffe/commit/e4be30a4c1025fd2f99f088c76f8e263714d8e33) by TimothÃ©e Mazzucotelli).

## [0.30.1](https://github.com/mkdocstrings/griffe/releases/tag/0.30.1) - 2023-07-02

[Compare with 0.30.0](https://github.com/mkdocstrings/griffe/compare/0.30.0...0.30.1)

### Bug Fixes

- Prevent duplicate yields of breaking changes ([9edef90](https://github.com/mkdocstrings/griffe/commit/9edef90d6c54b330046582e2a52ad88b5798d32c) by TimothÃ©e Mazzucotelli). [Issue #162](https://github.com/mkdocstrings/griffe/issues/162)
- Prevent alias resolution errors when checking for API breaking changes ([93c964a](https://github.com/mkdocstrings/griffe/commit/93c964a4cc3f759d101db45af5816a4d3b07c85e) by TimothÃ©e Mazzucotelli). [Issue #145](https://github.com/mkdocstrings/griffe/issues/145)
- Handle Git errors when checking for API breaking changes ([f9e8ba3](https://github.com/mkdocstrings/griffe/commit/f9e8ba381b75f650cfeb7bc96c976fec2251ac7a) by TimothÃ©e Mazzucotelli). [Issue #144](https://github.com/mkdocstrings/griffe/issues/144)

### Code Refactoring

- Force remove worktree branch when done checking ([45332ba](https://github.com/mkdocstrings/griffe/commit/45332ba89e213b4f9490ea7d2507d972267bed73) by TimothÃ©e Mazzucotelli).
- Change command to obtain latest tag ([f70f630](https://github.com/mkdocstrings/griffe/commit/f70f630ef7c67589d60c17ef4fb19c90127b2e06) by TimothÃ©e Mazzucotelli).

## [0.30.0](https://github.com/mkdocstrings/griffe/releases/tag/0.30.0) - 2023-06-30

[Compare with 0.29.1](https://github.com/mkdocstrings/griffe/compare/0.29.1...0.30.0)

### Features

- Add `allow_section_blank_line` option to the Numpy parser ([245845e](https://github.com/mkdocstrings/griffe/commit/245845ecaabedf4abb0af80d783702e55ea83883) by Michael Chow). [Issue #167](https://github.com/mkdocstrings/griffe/issues/167), [PR #168](https://github.com/mkdocstrings/griffe/pull/168)
- Support inheritance ([08bbe09](https://github.com/mkdocstrings/griffe/commit/08bbe09879dfa5440a359c8b2ad0b896c20c1dfc) by TimothÃ©e Mazzucotelli). [PR #170](https://github.com/mkdocstrings/griffe/pull/170)

### Bug Fixes

- Handle semi-colons in pth files ([e2ec661](https://github.com/mkdocstrings/griffe/commit/e2ec661e614df6c5f4fda1444468363777985b7c) by Michael Chow). [Issue #172](https://github.com/mkdocstrings/griffe/issues/172), [PR #175](https://github.com/mkdocstrings/griffe/pull/175)

### Code Refactoring

- Split members API in two parts: producer and consumer ([2269449](https://github.com/mkdocstrings/griffe/commit/226944983a9073d643ed09b47e7d3f99c76d3d5e) by TimothÃ©e Mazzucotelli). [PR #170](https://github.com/mkdocstrings/griffe/pull/170)

## [0.29.1](https://github.com/mkdocstrings/griffe/releases/tag/0.29.1) - 2023-06-19

[Compare with 0.29.0](https://github.com/mkdocstrings/griffe/compare/0.29.0...0.29.1)

### Bug Fixes

- Fix detection of optional and default in Numpydoc-style parameters ([3509106](https://github.com/mkdocstrings/griffe/commit/3509106399c5475ef71bb074dfa8f885e6759058) by TimothÃ©e Mazzucotelli). [Issue #165](https://github.com/mkdocstrings/griffe/issues/165)
- Fallback to string literal when parsing fails with syntax error ([53827c8](https://github.com/mkdocstrings/griffe/commit/53827c8c073e55a7f6d8ef61b36e9baf51f1c2bc) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#80](https://github.com/mkdocstrings/python/issues/80)
- Don't mutate finder's import paths ([a9e025a](https://github.com/mkdocstrings/griffe/commit/a9e025a16571b83713ce44f2be2356e498a847a2) by TimothÃ©e Mazzucotelli).
- Respect `external` when expanding wildcards ([8ef92c8](https://github.com/mkdocstrings/griffe/commit/8ef92c873db175dbd35e6d09277f6023a8fde32d) by TimothÃ©e Mazzucotelli).
- Extract actual type for yielded/received values ([3ea37ba](https://github.com/mkdocstrings/griffe/commit/3ea37ba2bcafea47f4b28bab6ae916ecb921b5ce) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#75](https://github.com/mkdocstrings/python/issues/75)

### Code Refactoring

- Improve error handling when importing a module ([a732e21](https://github.com/mkdocstrings/griffe/commit/a732e217622cc5ab2161479b9dde0ce59e2361af) by TimothÃ©e Mazzucotelli).
- Improve tests helpers (accept all visit/inspection parameters) ([6da5869](https://github.com/mkdocstrings/griffe/commit/6da586963cddff4dceadcd4b485dbb805830b6ea) by TimothÃ©e Mazzucotelli).
- Allow passing a modules collection to the inspector, for consistency with the visitor ([5f73a28](https://github.com/mkdocstrings/griffe/commit/5f73a28a09a4b445fa253356034c5ef40b9ecfec) by TimothÃ©e Mazzucotelli).
- Always add import path of module to inspect when it has a file path ([4021e6f](https://github.com/mkdocstrings/griffe/commit/4021e6fe9f5e06543f9709e7ae42f6ad8cd0b093) by TimothÃ©e Mazzucotelli).

## [0.29.0](https://github.com/mkdocstrings/griffe/releases/tag/0.29.0) - 2023-05-26

[Compare with 0.28.2](https://github.com/mkdocstrings/griffe/compare/0.28.2...0.29.0)

### Features

- Provide test helpers and pytest fixtures ([611ed58](https://github.com/mkdocstrings/griffe/commit/611ed5868e22ac3ada6467ba25c6dab606f5dee7) by TimothÃ©e Mazzucotelli).

## [0.28.2](https://github.com/mkdocstrings/griffe/releases/tag/0.28.2) - 2023-05-24

[Compare with 0.28.1](https://github.com/mkdocstrings/griffe/compare/0.28.1...0.28.2)

### Bug Fixes

- Correctly resolve full expressions ([fa57f4f](https://github.com/mkdocstrings/griffe/commit/fa57f4ff6495679b4e7e70d72d5adb80bd8ebc56) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/autorefs#23](https://github.com/mkdocstrings/autorefs/issues/23)
- Use `full` attribute instead of `canonical` for expressions ([4338ccc](https://github.com/mkdocstrings/griffe/commit/4338ccc9234f0c4df0ea302a81092a4f3d29f0bf) by Michael Chow). [Issue #163](https://github.com/mkdocstrings/griffe/issues/163), [PR #164](https://github.com/mkdocstrings/griffe/pull/164)

## [0.28.1](https://github.com/mkdocstrings/griffe/releases/tag/0.28.1) - 2023-05-22

[Compare with 0.28.0](https://github.com/mkdocstrings/griffe/compare/0.28.0...0.28.1)

### Bug Fixes

- Return docstring warnings as warnings, not attributes ([7bd51ba](https://github.com/mkdocstrings/griffe/commit/7bd51ba7c9c268a1cc378d38fdff3a891adc520c) by Matthew Anderson). [PR #161](https://github.com/mkdocstrings/griffe/pull/161)

### Code Refactoring

- Refactor AST nodes parsers ([7e53127](https://github.com/mkdocstrings/griffe/commit/7e5312744cd7f6ad3baba54fe8194d15896f5e6d) by TimothÃ©e Mazzucotelli). [Issue #160](https://github.com/mkdocstrings/griffe/issues/160)
- Full expressions use canonical names ([65c7184](https://github.com/mkdocstrings/griffe/commit/65c7184b5462b70debce1195c69449935cb0a0b1) by TimothÃ©e Mazzucotelli).

## [0.28.0](https://github.com/mkdocstrings/griffe/releases/tag/0.28.0) - 2023-05-17

[Compare with 0.27.5](https://github.com/mkdocstrings/griffe/compare/0.27.5...0.28.0)

### Features

- Support scikit-build-core editable modules (partially) ([eb64779](https://github.com/mkdocstrings/griffe/commit/eb64779cb5408553bd4923ab9cdfc72d0b5e6103) by TimothÃ©e Mazzucotelli). [Issue #154](https://github.com/mkdocstrings/griffe/issues/154)

### Bug Fixes

- Parse complex, stringified annotations ([f743616](https://github.com/mkdocstrings/griffe/commit/f74361684a2cd5db153875b8880788c254828e95) by TimothÃ©e Mazzucotelli). [Issue #159](https://github.com/mkdocstrings/griffe/issues/159)

## [0.27.5](https://github.com/mkdocstrings/griffe/releases/tag/0.27.5) - 2023-05-12

[Compare with 0.27.4](https://github.com/mkdocstrings/griffe/compare/0.27.4...0.27.5)

### Code Refactoring

- Represent function using their names when inspecting default values ([9116c1f](https://github.com/mkdocstrings/griffe/commit/9116c1fbb562c894547d72207921c02259147958) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#180](https://github.com/mkdocstrings/mkdocstrings/issues/180)

## [0.27.4](https://github.com/mkdocstrings/griffe/releases/tag/0.27.4) - 2023-05-10

[Compare with 0.27.3](https://github.com/mkdocstrings/griffe/compare/0.27.3...0.27.4)

### Bug Fixes

- Don't recurse through targets, get directly to final target and handle alias-related errors ([c5bc197](https://github.com/mkdocstrings/griffe/commit/c5bc1973975951389501addf567622c0e3eb71c6) by TimothÃ©e Mazzucotelli). [Issue #155](https://github.com/mkdocstrings/griffe/issues/155)

### Code Refactoring

- Follow `.pth` files to extend search paths with editable modules ([79bf724](https://github.com/mkdocstrings/griffe/commit/79bf72498150588d05ccdfc80a898c0330e08247) by TimothÃ©e Mazzucotelli). [Issue #154](https://github.com/mkdocstrings/griffe/issues/154)
- Add default values to `_load_packages` helper ([f104c20](https://github.com/mkdocstrings/griffe/commit/f104c20304dcf24c5d2e39220302a941db4161eb) by TimothÃ©e Mazzucotelli).

## [0.27.3](https://github.com/mkdocstrings/griffe/releases/tag/0.27.3) - 2023-05-05

[Compare with 0.27.2](https://github.com/mkdocstrings/griffe/compare/0.27.2...0.27.3)

### Bug Fixes

- Allow setting docstring through alias ([2e0f553](https://github.com/mkdocstrings/griffe/commit/2e0f553c833e9b27f5e97c05065c2127212b603c) by TimothÃ©e Mazzucotelli).
- Prevent infinite recursion ([0e98546](https://github.com/mkdocstrings/griffe/commit/0e985460eb886ea832e7cbefca261620eedb0e56) by TimothÃ©e Mazzucotelli). [Issue #155](https://github.com/mkdocstrings/griffe/issues/155)

## [0.27.2](https://github.com/mkdocstrings/griffe/releases/tag/0.27.2) - 2023-05-03

[Compare with 0.27.1](https://github.com/mkdocstrings/griffe/compare/0.27.1...0.27.2)

### Dependencies

- Remove async extra (aiofiles) ([70d9b93](https://github.com/mkdocstrings/griffe/commit/70d9b9305370f03c221876838aaad9b72dc388d3) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Support walrus operator ([bf721f4](https://github.com/mkdocstrings/griffe/commit/bf721f4dd2bb7f1a6695b5c880df821920b994a6) by TimothÃ©e Mazzucotelli). [Issue #152](https://github.com/mkdocstrings/griffe/issues/152)
- Respect `ClassVar` annotation ([60e01c1](https://github.com/mkdocstrings/griffe/commit/60e01c126df4e0529fe3806f9c2637a5a45dd138) by Victor Westerhuis). [PR #150](https://github.com/mkdocstrings/griffe/pull/150), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Add missing "other args" section aliases ([f5c0a0e](https://github.com/mkdocstrings/griffe/commit/f5c0a0ee70c34063ea38a8e76dcba4923f9673cb) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Move utils from cli to respective modules ([c6ce49e](https://github.com/mkdocstrings/griffe/commit/c6ce49eb75c1799982b40a7862a1a7888f0fab93) by TimothÃ©e Mazzucotelli).

## [0.27.1](https://github.com/mkdocstrings/griffe/releases/tag/0.27.1) - 2023-04-16

[Compare with 0.27.0](https://github.com/mkdocstrings/griffe/compare/0.27.0...0.27.1)

### Bug Fixes

- Actually parse warnings sections ([bc00da5](https://github.com/mkdocstrings/griffe/commit/bc00da5e9dfe4b2aee906000759e0c1e0a2f893b) by TimothÃ©e Mazzucotelli).
- Allow Raises and Warns items to start with a newline ([f3b088c](https://github.com/mkdocstrings/griffe/commit/f3b088c02b3be86934125b142876b0dfb3702677) by Victor Westerhuis). [PR #149](https://github.com/mkdocstrings/griffe/pull/149), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

## [0.27.0](https://github.com/mkdocstrings/griffe/releases/tag/0.27.0) - 2023-04-10

[Compare with 0.26.0](https://github.com/mkdocstrings/griffe/compare/0.26.0...0.27.0)

### Features

- Implement basic handling of Alias for breaking changes ([aa8ce00](https://github.com/mkdocstrings/griffe/commit/aa8ce009c8d69f7830bc46bc80dac34907b8ae83) by Yurii). [PR #140](https://github.com/mkdocstrings/griffe/pull/140), Co-authored-by: TimothÃ©e Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

### Bug Fixes

- Support `Literal` imported from `typing_extensions` ([3a16e58](https://github.com/mkdocstrings/griffe/commit/3a16e5858649f7d786ef8a60b9dfd588f406cd9d) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#545](https://github.com/mkdocstrings/mkdocstrings/issues/545)
- Fix parameter default checking logic and diff tests ([1b940fd](https://github.com/mkdocstrings/griffe/commit/1b940fd270b3e51dc0f62edb500a6a3e85908953) by TimothÃ©e Mazzucotelli).

## [0.26.0](https://github.com/mkdocstrings/griffe/releases/tag/0.26.0) - 2023-04-03

[Compare with 0.25.5](https://github.com/mkdocstrings/griffe/compare/0.25.5...0.26.0)

### Breaking Changes

- `AliasResolutionError` instances don't have a `target_path` attribute anymore. It is instead replaced by an `alias` attribute which is a reference to an `Alias` instance.
- Lots of positional-or-keyword parameters were changed to keyword-only parameters.

### Deprecations

- The `griffe.agents.extensions` module was moved to `griffe.extensions`. The old path is deprecated.

### Features

- Support newer versions of `editables` ([ab7a3be](https://github.com/mkdocstrings/griffe/commit/ab7a3be3902af5f4af1d1e762b2b6e532826569f) by TimothÃ©e Mazzucotelli): the names of editable modules have changed from `__editables_*` to `_editable_impl_*`.
- Provide a JSON schema ([7dfed39](https://github.com/mkdocstrings/griffe/commit/7dfed391c7714a9d1aea9223e1f8c9403d47e8bb) by TimothÃ©e Mazzucotelli).
- Allow hybrid extension to filter objects and run multiple inspectors ([f8ff53a](https://github.com/mkdocstrings/griffe/commit/f8ff53a69a3a131998649d1a9ba272827b7f2adc) by TimothÃ©e Mazzucotelli).
- Allow loading extension from file path ([131454e](https://github.com/mkdocstrings/griffe/commit/131454eece81da33cd7f1a8bf2ae030950df8441) by TimothÃ©e Mazzucotelli).
- Add back `relative_filepath` which now really returns the filepath relative to the current working directory ([40fe0c5](https://github.com/mkdocstrings/griffe/commit/40fe0c53be8ff72f254bd88e9c9cf6df36d3bcb9) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Fix JSON schema for ending line numbers (and add test) ([318c6b4](https://github.com/mkdocstrings/griffe/commit/318c6b41c0160070de1b10118d210cacd5f2e711) by TimothÃ©e Mazzucotelli).
- Prevent cyclic aliases by not overwriting a module member with an indirect alias to itself ([c188a95](https://github.com/mkdocstrings/griffe/commit/c188a95b823e876f89ba9046df2cb06348f92459) by TimothÃ©e Mazzucotelli). [Issue #122](https://github.com/mkdocstrings/griffe/issues/122)
- Prevent alias resolution errors when copying docstring or labels from previously existing attribute ([48747b6](https://github.com/mkdocstrings/griffe/commit/48747b6d14bdf1be03cfa5bbf849771e3e6801b0) by TimothÃ©e Mazzucotelli).
- Fix Google admonition regular expression ([ef0be5f](https://github.com/mkdocstrings/griffe/commit/ef0be5f8f276a5ef2397ad89c0cfce0e1b41020e) by TimothÃ©e Mazzucotelli).
- Add back `griffe.agents.extensions` module (deprecated) ([7129477](https://github.com/mkdocstrings/griffe/commit/7129477184f0b88d3bf165dfe8e1f6158c30914a) by TimothÃ©e Mazzucotelli).
- Forward class attribute docstrings to instances ([7bf4952](https://github.com/mkdocstrings/griffe/commit/7bf49528541e211af37c2ac5c1a74a4523699c65) by Rodrigo GirÃ£o SerrÃ£o). [Issue #128](https://github.com/mkdocstrings/griffe/issues/128), [PR #135](https://github.com/mkdocstrings/griffe/pull/135)
- Prevent errors related to getting attributes in the inspector ([5d15d27](https://github.com/mkdocstrings/griffe/commit/5d15d276259a4b9a70fbe490d86234e667711180) by TimothÃ©e Mazzucotelli).
- Catch "member does not exist" errors while expanding wildcards ([a966022](https://github.com/mkdocstrings/griffe/commit/a9660220c0b5e9e786877efa228452a643e93c76) by TimothÃ©e Mazzucotelli).
- Catch more inspection errors ([4f6eef9](https://github.com/mkdocstrings/griffe/commit/4f6eef9b0fbcdf56d61ac4bec9dc4ef3b90dd116) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Log final path after resolving alias ([c7ec7f7](https://github.com/mkdocstrings/griffe/commit/c7ec7f7ca029492ced68737851d66256c5035f70) by TimothÃ©e Mazzucotelli).
- Move extensions one level up ([67ebd71](https://github.com/mkdocstrings/griffe/commit/67ebd71f9b0933f08b263d0b21520dc0b1a5c4ff) by TimothÃ©e Mazzucotelli).
- Set default `when` value on extension base classes ([e8ad889](https://github.com/mkdocstrings/griffe/commit/e8ad8893aaad2549bff134a7bf3dfe5a86bfc960) by TimothÃ©e Mazzucotelli).
- Rename `relative_filepath` to `relative_package_filepath` to better express what it does ([6148f85](https://github.com/mkdocstrings/griffe/commit/6148f85c56848c6bb3e7df8986f1bb208e7083cf) by TimothÃ©e Mazzucotelli).
- Show file name and line number in alias resolution error messages ([c48928d](https://github.com/mkdocstrings/griffe/commit/c48928df4a75be35771d39bf96699d801485b31d) by TimothÃ©e Mazzucotelli).

## [0.25.5](https://github.com/mkdocstrings/griffe/releases/tag/0.25.5) - 2023-02-16

[Compare with 0.25.4](https://github.com/mkdocstrings/griffe/compare/0.25.4...0.25.5)

### Bug Fixes

- Fix parsing empty lines with indentation in Google docstrings ([705edff](https://github.com/mkdocstrings/griffe/commit/705edff6c208281bdab387a464799de613b087b5) by TimothÃ©e Mazzucotelli). [Issue #129](https://github.com/mkdocstrings/griffe/issues/129)

## [0.25.4](https://github.com/mkdocstrings/griffe/releases/tag/0.25.4) - 2023-01-19

[Compare with 0.25.3](https://github.com/mkdocstrings/griffe/compare/0.25.3...0.25.4)

### Bug Fixes

- Fix creation of aliases to modules when inspecting ([54242cb](https://github.com/mkdocstrings/griffe/commit/54242cbdbbcb68785942fa327113cd6508815fa9) by TimothÃ©e Mazzucotelli).
- Support (setuptools) editable packages with multiple roots ([bd37dfb](https://github.com/mkdocstrings/griffe/commit/bd37dfb16b43fac53207b426ee02218e57a5d5d1) by Gilad). [PR #126](https://github.com/mkdocstrings/griffe/pull/126)

## [0.25.3](https://github.com/mkdocstrings/griffe/releases/tag/0.25.3) - 2023-01-04

[Compare with 0.25.2](https://github.com/mkdocstrings/griffe/compare/0.25.2...0.25.3)

### Bug Fixes

- Fix parsing of annotations in Numpy attributes sections ([18fa396](https://github.com/mkdocstrings/griffe/commit/18fa39612b828e2892665b7367f7cdf76908970c) by TimothÃ©e Mazzucotelli). [Issue #72](https://github.com/mkdocstrings/griffe/issues/72)

## [0.25.2](https://github.com/mkdocstrings/griffe/releases/tag/0.25.2) - 2022-12-24

[Compare with 0.25.1](https://github.com/mkdocstrings/griffe/compare/0.25.1...0.25.2)

### Bug Fixes

- Make sure passage through aliases is reset ([79733f4](https://github.com/mkdocstrings/griffe/commit/79733f4d03f3f66b948dc17c57404349d9e72c9a) by TimothÃ©e Mazzucotelli). [Issue #123](https://github.com/mkdocstrings/griffe/issues/123)
- Ignore cyclic alias errors when updating target aliases ([bb62b2f](https://github.com/mkdocstrings/griffe/commit/bb62b2f744d221efedeba1cb33151b3787d2ee57) by TimothÃ©e Mazzucotelli). [Issue #123](https://github.com/mkdocstrings/griffe/issues/123)

## [0.25.1](https://github.com/mkdocstrings/griffe/releases/tag/0.25.1) - 2022-12-20

[Compare with 0.25.0](https://github.com/mkdocstrings/griffe/compare/0.25.0...0.25.1)

### Bug Fixes

- Pass through aliases earlier to prevent infinite recursion ([e533f29](https://github.com/mkdocstrings/griffe/commit/e533f29258838a1e171dea702fb033bfa68ed089) by TimothÃ©e Mazzucotelli). [Issue #83](https://github.com/mkdocstrings/griffe/issues/83), [#122](https://github.com/mkdocstrings/griffe/issues/122)

## [0.25.0](https://github.com/mkdocstrings/griffe/releases/tag/0.25.0) - 2022-12-11

[Compare with 0.24.1](https://github.com/mkdocstrings/griffe/compare/0.24.1...0.25.0)

### Breaking changes

- Parameter `only_known_modules` was renamed `external` in the expand_wildcards() method of the loader.
- Exception `UnhandledEditablesModuleError` was renamed `UnhandledEditableModuleError` since we now support editable installation from other packages than `editables`.

### Highlights

- Properties are now fetched as attributes rather than functions, since that is how they are used. This was asked by users, and since Griffe generates signatures for Python APIs (emphasis on **APIs**), it makes sense to return data that matches the interface provided to users. Such property objects in Griffe's output will still have the associated `property` labels of course.
- Lots of bug fixes. These bugs were discovered by running Griffe on *many* major packages as well as the standard library (again). Particularly, alias resolution should be more robust now, and should generate less issues like cyclic aliases, meaning indirect/wildcard imports should be better understood. We still highly discourage the use of wildcard imports

### Features

- Support `setuptools` editable modules ([abc18f7](https://github.com/mkdocstrings/griffe/commit/abc18f7b94cea7b7850bb9f14ebc4822beb1d27c) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#463](https://github.com/mkdocstrings/mkdocstrings/issues/463)
- Support merging stubs on wildcard imported objects ([0ed9c36](https://github.com/mkdocstrings/griffe/commit/0ed9c363b6b064361d311acee1732e757899291b) by TimothÃ©e Mazzucotelli). [Issue #116](https://github.com/mkdocstrings/griffe/issues/116)

### Bug Fixes

- Prevent cyclic alias creation when expanding wildcards ([a77e4e8](https://github.com/mkdocstrings/griffe/commit/a77e4e8bbba8a24d9f604eaff4cc57c6851c14c3) by TimothÃ©e Mazzucotelli).
- Don't crash and show hint when wildcard expansion fails ([336faf6](https://github.com/mkdocstrings/griffe/commit/336faf6dff679c970e594151a7a5d2bd99f52af6) by TimothÃ©e Mazzucotelli).
- Register top module after inspection ([86454ec](https://github.com/mkdocstrings/griffe/commit/86454ececfa8e88b0f1024bde49e6dd0cb8542d0) by TimothÃ©e Mazzucotelli).
- Set alias attributes early ([2ac1a9b](https://github.com/mkdocstrings/griffe/commit/2ac1a9bafb632daa491b3d26f2c39d74c9b31e3d) by TimothÃ©e Mazzucotelli).
- Allow writing attributes on aliases ([c8f736e](https://github.com/mkdocstrings/griffe/commit/c8f736efcee354d2c47675413955390e80e77425) by TimothÃ©e Mazzucotelli).
- Don't crash on inspection of functions signatures ([051e337](https://github.com/mkdocstrings/griffe/commit/051e337306006a60b4ae0da030a6fb912db1f05c) by TimothÃ©e Mazzucotelli).
- Don't crash on inspection of method descriptors' docstrings ([09571bb](https://github.com/mkdocstrings/griffe/commit/09571bb6ffebe041ac9fdd143fc4a1cb239dda63) by TimothÃ©e Mazzucotelli).
- Fix stats computing (handle stubs and namespace packages) ([a81f8dc](https://github.com/mkdocstrings/griffe/commit/a81f8dcf9e8eedc3a42cfdaaaaa28ec9379e2c4b) by TimothÃ©e Mazzucotelli).
- Support documenting multiple items for optional tuples ([727456d](https://github.com/mkdocstrings/griffe/commit/727456deba90ac01a04119371b72c011755360b6) by TimothÃ©e Mazzucotelli). [Issue #117](https://github.com/mkdocstrings/griffe/issues/117)
- Fix comparing names with strings ([37ae0a2](https://github.com/mkdocstrings/griffe/commit/37ae0a2f37c7e446c890d9e1204edddfb3591dc7) by TimothÃ©e Mazzucotelli). [Issue #114](https://github.com/mkdocstrings/griffe/issues/114)
- Fix deepcopy crashing because of `__getattr__` ([11b023b](https://github.com/mkdocstrings/griffe/commit/11b023b8bc0575313a9aea1f6ef99944c8b02537) by TimothÃ©e Mazzucotelli). [Issue #73](https://github.com/mkdocstrings/griffe/issues/73), [PR #119](https://github.com/mkdocstrings/griffe/pull/119)

### Code Refactoring

- Prevent reloading of failed modules ([8ef14ab](https://github.com/mkdocstrings/griffe/commit/8ef14ab6389bb06e1903c7628dd1d811f2af101a) by TimothÃ©e Mazzucotelli).
- Rename `only_known_modules` parameter to `external` ([5f816c6](https://github.com/mkdocstrings/griffe/commit/5f816c67222f9aa1bd008782430501a2de26d5a4) by TimothÃ©e Mazzucotelli).
- Rework alias creation decision in the inspector ([f434943](https://github.com/mkdocstrings/griffe/commit/f434943579e02fb02c28f7e2be65293f6ab6b657) by TimothÃ©e Mazzucotelli).
- Resolve alias chain recursively ([6cdd3b2](https://github.com/mkdocstrings/griffe/commit/6cdd3b2ed4170347282118c06407b587cd65fd36) by TimothÃ©e Mazzucotelli).
- Don't try to stubs-merge identical modules ([7099971](https://github.com/mkdocstrings/griffe/commit/7099971e441d5dd804c0304f010343a558685f9a) by TimothÃ©e Mazzucotelli).
- Load properties as attributes ([5c97a45](https://github.com/mkdocstrings/griffe/commit/5c97a45087e0ba8c39a9745d9c5248c4c35909a8) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#9](https://github.com/mkdocstrings/python/issues/9)
- Use a cyclic relationship map for inspection ([9a2a711](https://github.com/mkdocstrings/griffe/commit/9a2a7117d2d9d7b8327e640e8760594349531627) by TimothÃ©e Mazzucotelli). [PR #115](https://github.com/mkdocstrings/griffe/pull/115)

## [0.24.1](https://github.com/mkdocstrings/griffe/releases/tag/0.24.1) - 2022-11-18

[Compare with 0.24.0](https://github.com/mkdocstrings/griffe/compare/0.24.0...0.24.1)

### Bug Fixes

- Support nested namespace packages ([d571f8f](https://github.com/mkdocstrings/griffe/commit/d571f8f726d50b34c84fbdaa6db3b2059cfe9dec) by TimothÃ©e Mazzucotelli).

## [0.24.0](https://github.com/mkdocstrings/griffe/releases/tag/0.24.0) - 2022-11-13

[Compare with 0.23.0](https://github.com/mkdocstrings/griffe/compare/0.23.0...0.24.0)

The "Breaking Changes" and "Deprecations" sections are proudly written with the help of our new API breakage detection feature ! Many thanks to Talley Lambert ([@tlambert03](https://github.com/tlambert03)) for the initial code allowing to compare two Griffe trees.

### Breaking Changes

- All parameters of the load_git function, except `module`, are now keyword-only.
- Parameter `try_relative_path` of the load_git function was removed.
- Parameter `commit` was renamed `ref` in the load_git function.
- Parameter `commit` was renamed `ref` in the `tmp_worktree` helper, which will probably become private later.
- Parameters `ref` and `repo` switched positions in the `tmp_worktree` helper.
- All parameters of the resolve_aliases method are now keyword-only.
- Parameters `only_exported` and `only_known_modules` of the resolve_module_aliases method were removed. This method is most probably not used by anyone, and will probably be made private in the future.

### Deprecations

- Parameters `only_exported` and `only_known_modules` of the resolve_aliases method are deprecated in favor of their inverted counter-part `implicit` and `external` parameters.

  - Example before: `loader.resolve_aliases(only_exported=True, only_known_modules=True)`
  - Example after: `loader.resolve_aliases(implicit=False, external=False)`

### Features

- Add CLI command to check for API breakages ([90bded4](https://github.com/mkdocstrings/griffe/commit/90bded46ccaab0417ed57ed11d3b67597f3845ba) by TimothÃ©e Mazzucotelli). [Issue #75](https://github.com/mkdocstrings/griffe/issues/75), [PR #105](https://github.com/mkdocstrings/griffe/pull/105)
- Add function to find API breaking changes ([a4f1280](https://github.com/mkdocstrings/griffe/commit/a4f1280a2b65fabc4caa4448d556ac3e83b2f0d0) by Talley Lambert and TimothÃ©e Mazzucotelli). [Issue #75](https://github.com/mkdocstrings/griffe/issues/75), [PR #105](https://github.com/mkdocstrings/griffe/pull/105)

### Bug Fixes

- Fix labels mismatch staticmethod-classmethod in inspector ([25060f6](https://github.com/mkdocstrings/griffe/commit/25060f6dad686c73bd32203dc1b3ac789fdc4aef) by TimothÃ©e Mazzucotelli). [Issue #111](https://github.com/mkdocstrings/griffe/issues/111)
- Prevent infinite loop while looking for package's parent folder ([f297f1a](https://github.com/mkdocstrings/griffe/commit/f297f1a6550ecadf77c34effe45802327340b1c4) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#72](https://github.com/mkdocstrings/mkdocstrings/issues/72)
- Fix comparing names and expressions ([07bffff](https://github.com/mkdocstrings/griffe/commit/07bffff71845d3c9e66007a6a7de269f17312d2b) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Rename some parameters in Git module ([9ad7a2c](https://github.com/mkdocstrings/griffe/commit/9ad7a2c1abde97556d9b4657bef4231e1ef6fa19) by TimothÃ©e Mazzucotelli).
- Set parameters as keyword-only ([44c01be](https://github.com/mkdocstrings/griffe/commit/44c01bec147add34ba3f5ac716ac6722540e3ba7) by TimothÃ©e Mazzucotelli).
- Remove stars from parameters names ([91dce14](https://github.com/mkdocstrings/griffe/commit/91dce14d7fa3c8c2075a3319fdd7636443fe6cbc) by TimothÃ©e Mazzucotelli).
- Refactor CLI to use subcommands ([760b091](https://github.com/mkdocstrings/griffe/commit/760b0918c60911386932cec720418af8d3360c1b) by TimothÃ©e Mazzucotelli). [PR #110](https://github.com/mkdocstrings/griffe/pull/110)
- Rename parameters used when resolving aliases ([3d3a4eb](https://github.com/mkdocstrings/griffe/commit/3d3a4eb99e587bd9dd7bfadca4c45737fb886139) by TimothÃ©e Mazzucotelli).

## [0.23.0](https://github.com/mkdocstrings/griffe/releases/tag/0.23.0) - 2022-10-26

[Compare with 0.22.2](https://github.com/mkdocstrings/griffe/compare/0.22.2...0.23.0)

### Features

- Support `typing_extensions.overload` ([c29fad5](https://github.com/mkdocstrings/griffe/commit/c29fad58c721399badfc93ff8e0f10a6f92c359e) by Nyuan Zhang). [PR #108](https://github.com/mkdocstrings/griffe/pull/108)

### Bug Fixes

- Log debug instead of errors when failing to parse NumPy annotations for additional sections ([568ff60](https://github.com/mkdocstrings/griffe/commit/568ff60621c0b5cc35ac0e0d0209fa3bc1b2ba8a) by Sigurd Spieckermann). [Issue #93](https://github.com/mkdocstrings/griffe/issues/93), [PR #109](https://github.com/mkdocstrings/griffe/pull/109)
- Don't strip too many parentheses around a call node ([bb5c5e7](https://github.com/mkdocstrings/griffe/commit/bb5c5e71f95c537ca2d19299b157a0bbf59e5279) by TimothÃ©e Mazzucotelli). [PR #107](https://github.com/mkdocstrings/griffe/pull/107)
- Guard against more alias resolution errors ([2be135d](https://github.com/mkdocstrings/griffe/commit/2be135d8ab88d6f97175c958e31e76b0d7d8f934) by TimothÃ©e Mazzucotelli). [Issue #83](https://github.com/mkdocstrings/griffe/issues/83), [PR #103](https://github.com/mkdocstrings/griffe/pull/103)

## [0.22.2](https://github.com/mkdocstrings/griffe/releases/tag/0.22.2) - 2022-09-24

[Compare with 0.22.1](https://github.com/mkdocstrings/griffe/compare/0.22.1...0.22.2)

### Bug Fixes

- Log debug instead of errors when failing to parse Numpy annotations ([75eeeda](https://github.com/mkdocstrings/griffe/commit/75eeeda2f1181ae680b3d47df3814bad200220d3) by TimothÃ©e Mazzucotelli). [Issue #93](https://github.com/mkdocstrings/griffe/issues/93)
- Don't crash on unsupported module names (containing dots) ([6a57194](https://github.com/mkdocstrings/griffe/commit/6a571949000a3d2910990337f96751c0cac7e815) by TimothÃ©e Mazzucotelli). [Issue #94](https://github.com/mkdocstrings/griffe/issues/94)
- Show correct docstring line numbers on Python 3.7 ([edd4b6d](https://github.com/mkdocstrings/griffe/commit/edd4b6d23f4399960db4e16a8c269318aef033d6) by TimothÃ©e Mazzucotelli). [Issue #98](https://github.com/mkdocstrings/griffe/issues/98)
- Fix parsing of Numpy docstring with an Examples section at the end ([3114727](https://github.com/mkdocstrings/griffe/commit/3114727296891fdd5cacecf487652774ee6e4fc8) by TimothÃ©e Mazzucotelli). [Issue #97](https://github.com/mkdocstrings/griffe/issues/97)
- Don't crash on unsupported item in `__all__` (log a warning instead) ([9e5df0a](https://github.com/mkdocstrings/griffe/commit/9e5df0aea8e615217554e5204221a35c9df25938) by TimothÃ©e Mazzucotelli). [Issue #92](https://github.com/mkdocstrings/griffe/issues/92)
- Prevent infinite recursion while expanding exports ([68446f7](https://github.com/mkdocstrings/griffe/commit/68446f7ab94536596dccb690fb2cac613cd32460) by TimothÃ©e Mazzucotelli).
- Add missing check while expanding wildcards ([7e816ed](https://github.com/mkdocstrings/griffe/commit/7e816ed141d6f13bf1ae7c758c32e68cc663fe0e) by TimothÃ©e Mazzucotelli).

## [0.22.1](https://github.com/mkdocstrings/griffe/releases/tag/0.22.1) - 2022-09-10

[Compare with 0.22.0](https://github.com/mkdocstrings/griffe/compare/0.22.0...0.22.1)

### Bug Fixes

- Always use `encoding="utf8"` when reading text files ([3b279bf](https://github.com/mkdocstrings/griffe/commit/3b279bf61afabc7312e9e58745fd19a53d97ac74) by Rudolf Byker). [Issue #99](https://github.com/mkdocstrings/griffe/issues/99), [PR #100](https://github.com/mkdocstrings/griffe/pull/100)

## [0.22.0](https://github.com/mkdocstrings/griffe/releases/tag/0.22.0) - 2022-06-28

[Compare with 0.21.0](https://github.com/mkdocstrings/griffe/compare/0.21.0...0.22.0)

### Features

- Support forward references ([245daea](https://github.com/mkdocstrings/griffe/commit/245daeabc8130bd7ecab86f55c4906d9161b9e73) by TimothÃ©e Mazzucotelli). [Issue #86](https://github.com/mkdocstrings/griffe/issues/86)

### Code Refactoring

- Safely parse annotations and values ([b023e2b](https://github.com/mkdocstrings/griffe/commit/b023e2be509f3ac39dbe1ed9adf21247e4416e53) by TimothÃ©e Mazzucotelli).

## [0.21.0](https://github.com/mkdocstrings/griffe/releases/tag/0.21.0) - 2022-06-25

[Compare with 0.20.0](https://github.com/mkdocstrings/griffe/compare/0.20.0...0.21.0)

### Features

- Add `load_git` function allowing to load data from a specific git ref ([b2c3946](https://github.com/mkdocstrings/griffe/commit/b2c39467630c33edc914dd7e6dc96fb611267905) by Talley Lambert). [Issue #75](https://github.com/mkdocstrings/griffe/issues/75), [PR #76](https://github.com/mkdocstrings/griffe/pull/76)

### Bug Fixes

- Fix detecting and merging stubs for single-file packages ([6a82542](https://github.com/mkdocstrings/griffe/commit/6a825423a9dfd86343532c2872980240f2e98b74) by Talley Lambert). [Issue #77](https://github.com/mkdocstrings/griffe/issues/77), [PR #78](https://github.com/mkdocstrings/griffe/pull/78)
- Fix parsing ExtSlice nodes when getting values ([b2fe968](https://github.com/mkdocstrings/griffe/commit/b2fe9684f274786decdf9fb395bebc5057235eda) by TimothÃ©e Mazzucotelli). [Issue #87](https://github.com/mkdocstrings/griffe/issues/87)
- Don't trigger alias resolution when merging stubs ([2b88627](https://github.com/mkdocstrings/griffe/commit/2b88627862b8db50045cc97ae5644abd36f36b5a) by TimothÃ©e Mazzucotelli). [Issue #89](https://github.com/mkdocstrings/griffe/issues/89)
- Fix handling of .pth files ([f212dd3](https://github.com/mkdocstrings/griffe/commit/f212dd3b92f51a64795fdbb30aefd0a730393523) by Gabriel Dugny). [Issue #84](https://github.com/mkdocstrings/griffe/issues/84), [PR #85](https://github.com/mkdocstrings/griffe/pull/85)

## [0.20.0](https://github.com/mkdocstrings/griffe/releases/tag/0.20.0) - 2022-06-03

[Compare with 0.19.3](https://github.com/mkdocstrings/griffe/compare/0.19.3...0.20.0)

### Features

- Add `as_json` and `from_json` convenience methods on objects ([5c3d751](https://github.com/mkdocstrings/griffe/commit/5c3d7511d2465e16805fa564c3d60d44618410d8) by Talley Lambert). [PR #74](https://github.com/mkdocstrings/griffe/pull/74)

### Bug Fixes

- Fix unparsing of f-strings ([9ca74bd](https://github.com/mkdocstrings/griffe/commit/9ca74bd144167de9506cf5b0725a784e52f5e67a) by TimothÃ©e Mazzucotelli). [Issue #80](https://github.com/mkdocstrings/griffe/issues/80)
- Don't crash when overwriting a submodule with a wildcard imported attribute ([bfad1cc](https://github.com/mkdocstrings/griffe/commit/bfad1ccf079e69fa0161754d9f1f7edd5819f943) by TimothÃ©e Mazzucotelli). [Issue #72](https://github.com/mkdocstrings/griffe/issues/72), [#79](https://github.com/mkdocstrings/griffe/issues/79), [mkdocstrings/mkdocstrings#438](https://github.com/mkdocstrings/mkdocstrings/issues/438)

## [0.19.3](https://github.com/mkdocstrings/griffe/releases/tag/0.19.3) - 2022-05-26

[Compare with 0.19.2](https://github.com/mkdocstrings/griffe/compare/0.19.2...0.19.3)

### Bug Fixes

- Support USub and UAdd nodes in annotations ([1169c51](https://github.com/mkdocstrings/griffe/commit/1169c51bd6ae04f491fa5e50cae93d99e8ce920d) by TimothÃ©e Mazzucotelli). [Issue #71](https://github.com/mkdocstrings/griffe/issues/71)

## [0.19.2](https://github.com/mkdocstrings/griffe/releases/tag/0.19.2) - 2022-05-18

[Compare with 0.19.1](https://github.com/mkdocstrings/griffe/compare/0.19.1...0.19.2)

### Bug Fixes

- Don't crash on single line docstrings with trailing whitespace (Google) ([8d9ccd5](https://github.com/mkdocstrings/griffe/commit/8d9ccd531dd91c6fbfa0922a0133680f881733b0) by TimothÃ©e Mazzucotelli).

## [0.19.1](https://github.com/mkdocstrings/griffe/releases/tag/0.19.1) - 2022-05-07

[Compare with 0.19.0](https://github.com/mkdocstrings/griffe/compare/0.19.0...0.19.1)

### Bug Fixes

- Don't crash on nested functions in `__init__` methods ([cd5af43](https://github.com/mkdocstrings/griffe/commit/cd5af43f3a98d54d822015818b7aa0ef15159286) by TimothÃ©e Mazzucotelli). [Issue #68](https://github.com/mkdocstrings/griffe/issues/68)

## [0.19.0](https://github.com/mkdocstrings/griffe/releases/tag/0.19.0) - 2022-05-06

[Compare with 0.18.0](https://github.com/mkdocstrings/griffe/compare/0.18.0...0.19.0)

### Features

- Add `load` shortcut function for convenience ([f38a42d](https://github.com/mkdocstrings/griffe/commit/f38a42ddd7ac9d58f36627d9f2a69f4acd65df50) by TimothÃ©e Mazzucotelli).
- Support loading (and merging) `*.pyi` files ([41518f4](https://github.com/mkdocstrings/griffe/commit/41518f4aa9e00756a910067cf6f01f07ca7327da) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#404](https://github.com/mkdocstrings/mkdocstrings/issues/404)
- Improve support for call nodes in annotations ([45e5bf5](https://github.com/mkdocstrings/griffe/commit/45e5bf53d509344b3f28118836d356903c64bbf3) by TimothÃ©e Mazzucotelli). [Issue #66](https://github.com/mkdocstrings/griffe/issues/66)
- Support `dataclass` decorators on classes ([f579431](https://github.com/mkdocstrings/griffe/commit/f579431474cc4db687e4264f5062074654dec2f3) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Handle absence of values ([190585d](https://github.com/mkdocstrings/griffe/commit/190585d3482bfc3a72694910529b7a0aac35444c) by TimothÃ©e Mazzucotelli).
- Simplify decorators to labels function ([04e768f](https://github.com/mkdocstrings/griffe/commit/04e768fb621898faf7a96cc7e7170f10da876664) by TimothÃ©e Mazzucotelli).
- Always sort labels when serializing ([bd2504b](https://github.com/mkdocstrings/griffe/commit/bd2504bdb43df3e290c88bd8d25903823f5fc2d6) by TimothÃ©e Mazzucotelli).

## [0.18.0](https://github.com/mkdocstrings/griffe/releases/tag/0.18.0) - 2022-04-19

[Compare with 0.17.0](https://github.com/mkdocstrings/griffe/compare/0.17.0...0.18.0)

### Features

- Add CLI option to disallow inspection ([8f71a07](https://github.com/mkdocstrings/griffe/commit/8f71a07c17de4cfb2b519dc2b4086f102de4d325) by TimothÃ©e Mazzucotelli).
- Support complex `__all__` assignments ([9a2128b](https://github.com/mkdocstrings/griffe/commit/9a2128b8d4533119b705ec47fc1eca404b4282ef) by TimothÃ©e Mazzucotelli). [Issue #40](https://github.com/mkdocstrings/griffe/issues/40)
- Inherit class parameters from `__init__` method ([e195593](https://github.com/mkdocstrings/griffe/commit/e195593b181690313c9e447c8bc2befa72fd6e09) by FranÃ§ois Rozet). [Issue mkdocstrings/python#19](https://github.com/mkdocstrings/python/issues/19), [PR #65](https://github.com/mkdocstrings/python/pull/65). It allows to write "Parameters" sections in the docstring of the class itself.

### Performance Improvements

- Avoid using `__len__` as boolean method ([d465493](https://github.com/mkdocstrings/griffe/commit/d4654930577186fb6d3e89ea1561a2daf15b3a65) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Don't crash on unhandle `__all__` assignments ([cbc103c](https://github.com/mkdocstrings/griffe/commit/cbc103c91836db2e235a46a0f9048c1230de507d) by TimothÃ©e Mazzucotelli).
- Handle empty packages names in CLI ([52b51c4](https://github.com/mkdocstrings/griffe/commit/52b51c49a14783c986beb851abd33cbcd0ab8729) by TimothÃ©e Mazzucotelli).
- Don't crash on Google parameters sections found in non-function docstrings ([4a417bc](https://github.com/mkdocstrings/griffe/commit/4a417bc6c0e83b42fe1a74a4a8b0881d3955075f) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#19](https://github.com/mkdocstrings/python/issues/19)

### Code Refactoring

- Improve "unknown parameter" messages ([7191799](https://github.com/mkdocstrings/griffe/commit/7191799c92d7544f949c5870cf2867e02d406c57) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#423](https://github.com/mkdocstrings/mkdocstrings/issues/423)
- Set property label on `@cached_property`-decorated methods ([bc068f8](https://github.com/mkdocstrings/griffe/commit/bc068f8123c5bcbe4dce272dda52840019141b06) by TimothÃ©e Mazzucotelli).

## [0.17.0](https://github.com/mkdocstrings/griffe/releases/tag/0.17.0) - 2022-04-15

[Compare with 0.16.0](https://github.com/mkdocstrings/griffe/compare/0.16.0...0.17.0)

### Features

- Handle properties setters and deleters ([50a4490](https://github.com/mkdocstrings/griffe/commit/50a449069de89bb83da854b1bbd1681ec68f0395) by TimothÃ©e Mazzucotelli).
- Handle `typing.overload` decorator ([927bbd9](https://github.com/mkdocstrings/griffe/commit/927bbd9fe7712e8d0fc9763fb51d89bef3173350) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#308](https://github.com/mkdocstrings/mkdocstrings/issues/308)
- Set labels on functions using decorators ([1c1feb2](https://github.com/mkdocstrings/griffe/commit/1c1feb264c748f4a78ffebf3b9ea1966f2533522) by TimothÃ©e Mazzucotelli). [Issue #47](https://github.com/mkdocstrings/griffe/issues/47)
- Add `runtime` attribute to objects/aliases and handle type guarded objects ([2f2a04e](https://github.com/mkdocstrings/griffe/commit/2f2a04ea498aa50133b1404f3bc3498a25648545) by TimothÃ©e Mazzucotelli). [Issue #42](https://github.com/mkdocstrings/griffe/issues/42)
- Support pkg-style namespace packages ([efba0c6](https://github.com/mkdocstrings/griffe/commit/efba0c6a5e1dc185e96e5a09c05e94c751abc4cb) by TimothÃ©e Mazzucotelli). [Issue #58](https://github.com/mkdocstrings/griffe/issues/58)

### Code Refactoring

- Remove useless attribute ([c4a92b7](https://github.com/mkdocstrings/griffe/commit/c4a92b7e2cbe240a376d5d6944b7b0d23255648b) by TimothÃ©e Mazzucotelli).
- Improve Google warnings ([641089a](https://github.com/mkdocstrings/griffe/commit/641089aed53423894df8733941e404f7e6505b94) by TimothÃ©e Mazzucotelli).
- Remove useless import nodes generic visits ([f83fc8e](https://github.com/mkdocstrings/griffe/commit/f83fc8e629451abd4f4eadfe34b448fb3b77b9b6) by TimothÃ©e Mazzucotelli).

## [0.16.0](https://github.com/mkdocstrings/griffe/releases/tag/0.16.0) - 2022-04-09

[Compare with 0.15.1](https://github.com/mkdocstrings/griffe/compare/0.15.1...0.16.0)

### Features

- Warn about unknown parameters in Numpy docstrings ([23f63f2](https://github.com/mkdocstrings/griffe/commit/23f63f255eef5aa2dbaa1765f93634ecaf94dbb3) by TimothÃ©e Mazzucotelli).
- Warn about unknown parameters in Google docstrings ([72be993](https://github.com/mkdocstrings/griffe/commit/72be993c95460a6465a4e70a95b79ae4095db541) by Kevin Musgrave). [Issue mkdocstrings/mkdocstrings#408](https://github.com/mkdocstrings/mkdocstrings/issues/408), [PR #63](https://github.com/mkdocstrings/griffe/issues/63)

### Bug Fixes

- Don't crash on unhandled AST nodes while parsing text annotations ([f3be3a6](https://github.com/mkdocstrings/griffe/commit/f3be3a68141e24a9c0c6b9a87e3f22e75a168d80) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#416](https://github.com/mkdocstrings/mkdocstrings/issues/416)

## [0.15.1](https://github.com/mkdocstrings/griffe/releases/tag/0.15.1) - 2022-04-08

[Compare with 0.15.0](https://github.com/mkdocstrings/griffe/compare/0.15.0...0.15.1)

### Bug Fixes

- Don't overwrite existing (lower) members when expanding wildcards ([9ff86e3](https://github.com/mkdocstrings/griffe/commit/9ff86e369d8fb3a6eeb7d94cd60c87fa26bf74b4) by TimothÃ©e Mazzucotelli).
- Don't insert admonition before current section (Google parser) ([8d8a46f](https://github.com/mkdocstrings/griffe/commit/8d8a46fca7df917c4bba979128d94d3b79252ff5) by TimothÃ©e Mazzucotelli).
- Handle aliases chains in `has_docstrings` method ([77c6943](https://github.com/mkdocstrings/griffe/commit/77c69430ddc74fedaa33fa65afd59ac546900829) by TimothÃ©e Mazzucotelli).
- Actually check for docstrings recursively ([15f4193](https://github.com/mkdocstrings/griffe/commit/15f4193b764f85dcab042ab193e984bebf151029) by TimothÃ©e Mazzucotelli).

## [0.15.0](https://github.com/mkdocstrings/griffe/releases/tag/0.15.0) - 2022-04-03

[Compare with 0.14.1](https://github.com/mkdocstrings/griffe/compare/0.14.1...0.15.0)

### Features

- Support `ignore_init_summary` in Numpy parser ([f8cd147](https://github.com/mkdocstrings/griffe/commit/f8cd14734603d29e6e72c9a350f663dccdeb36b4) by TimothÃ©e Mazzucotelli). [Issue #44](https://github.com/mkdocstrings/griffe/issues/44)
- Enable cross-references for Numpy docstrings annotations ([e32a73c](https://github.com/mkdocstrings/griffe/commit/e32a73c9e100cf0778768c4a1f76152d9aecc451) by TimothÃ©e Mazzucotelli). Issues [#11](https://github.com/mkdocstrings/griffe/issues/11), [#12](https://github.com/mkdocstrings/griffe/issues/12), [#13](https://github.com/mkdocstrings/griffe/issues/13), [#14](https://github.com/mkdocstrings/griffe/issues/14), [#15](https://github.com/mkdocstrings/griffe/issues/15), [#16](https://github.com/mkdocstrings/griffe/issues/16), [#17](https://github.com/mkdocstrings/griffe/issues/17), [#18](https://github.com/mkdocstrings/griffe/issues/18)
- Retrieve annotations from parent in Numpy parser ([8d4eae3](https://github.com/mkdocstrings/griffe/commit/8d4eae353cbd42f47fe6f8101e6e1f8be4054c84) by TimothÃ©e Mazzucotelli). Issues [#29](https://github.com/mkdocstrings/griffe/issues/29), [#30](https://github.com/mkdocstrings/griffe/issues/30), [#31](https://github.com/mkdocstrings/griffe/issues/31), [#32](https://github.com/mkdocstrings/griffe/issues/32)
- Parse annotations in Iterator/Generator for Google docstrings ([f0129ef](https://github.com/mkdocstrings/griffe/commit/f0129efa2046089355ee62c48f23eb0189b054ce) by TimothÃ©e Mazzucotelli). [Issue #28](https://github.com/mkdocstrings/griffe/issues/28)

### Bug Fixes

- Fix missing "receives" entry in Google parser ([35d63fb](https://github.com/mkdocstrings/griffe/commit/35d63fbd566fa439a255c3f44ffeb4a9474db7f9) by TimothÃ©e Mazzucotelli).
- Fix serialization of Windows paths ([b7e8da8](https://github.com/mkdocstrings/griffe/commit/b7e8da868cd6ec8230f2d58a8f3c38248f7c97b2) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Be less strict on spacing around ":" in Numpy docstrings ([aa592b5](https://github.com/mkdocstrings/griffe/commit/aa592b5f38b71e6eadd883257d2239fceec43752) by TimothÃ©e Mazzucotelli).
- Be less strict in Numpy regular expressions ([603dc0e](https://github.com/mkdocstrings/griffe/commit/603dc0e21aa12754ec4f76ffc40869bf8519935d) by TimothÃ©e Mazzucotelli).
- Rename variables in Numpy module ([4407244](https://github.com/mkdocstrings/griffe/commit/4407244a2e4b59c988c61e4c7b9f07532cad5b3c) by TimothÃ©e Mazzucotelli).

## [0.14.1](https://github.com/mkdocstrings/griffe/releases/tag/0.14.1) - 2022-04-01

[Compare with 0.14.0](https://github.com/mkdocstrings/griffe/compare/0.14.0...0.14.1)

### Bug Fixes

- Retrieve default value for non-string parameters ([15952ed](https://github.com/mkdocstrings/griffe/commit/15952ed72f6f5db3a4dec2fc60cb256c838be6a3) by ThomasPJ). [Issue #59](https://github.com/mkdocstrings/griffe/issues/59), [issue mkdocstrings/python#8](https://github.com/mkdocstrings/python/issues/8), [PR #60](https://github.com/mkdocstrings/griffe/pull/60)
- Prevent infinite recursion while expanding wildcards ([428628f](https://github.com/mkdocstrings/griffe/commit/428628f423192611529b9b346cd295999d0dad25) by TimothÃ©e Mazzucotelli). [Issue #57](https://github.com/mkdocstrings/griffe/issues/57)

## [0.14.0](https://github.com/mkdocstrings/griffe/releases/tag/0.14.0) - 2022-03-06

[Compare with 0.13.2](https://github.com/mkdocstrings/griffe/compare/0.13.2...0.14.0)

### Features

- Ignore `__doc__` from parent classes ([10aa59e](https://github.com/mkdocstrings/griffe/commit/10aa59ef2fbf1db2c8829e0905bea88406495c41) by Will Da Silva). [Issue #55](https://github.com/mkdocstrings/griffe/issues/55), [PR #56](https://github.com/mkdocstrings/griffe/pull/56)

## [0.13.2](https://github.com/mkdocstrings/griffe/releases/tag/0.13.2) - 2022-03-01

[Compare with 0.13.1](https://github.com/mkdocstrings/griffe/compare/0.13.1...0.13.2)

### Bug Fixes

- Fix type regex in Numpy parser ([3a10fda](https://github.com/mkdocstrings/griffe/commit/3a10fda89c2e32e2d8acd89eb1ce8ab20a0fc251) by TimothÃ©e Mazzucotelli).
- Current module must not be available in its members' scope ([54f9688](https://github.com/mkdocstrings/griffe/commit/54f9688c11a1f7d3893ca774a07afe876f0b809c) by TimothÃ©e Mazzucotelli).
- Allow named sections after numpydoc examples ([a44d9c6](https://github.com/mkdocstrings/griffe/commit/a44d9c65cf24d2820e805d23365f38aab82c8c07) by Lucina). [PR #54](https://github.com/mkdocstrings/griffe/pull/54)

## [0.13.1](https://github.com/mkdocstrings/griffe/releases/tag/0.13.1) - 2022-02-24

[Compare with 0.13.0](https://github.com/mkdocstrings/griffe/compare/0.13.0...0.13.1)

### Bug Fixes

- Don't cut through wildcard-expanded aliases chains ([65dafa4](https://github.com/mkdocstrings/griffe/commit/65dafa4660e8c95687cad4d5c5145a56f126ae61) by TimothÃ©e Mazzucotelli).
- Fix docstrings warnings when there's no parent module ([e080549](https://github.com/mkdocstrings/griffe/commit/e080549e3eaf887a0f037a4457329eab35bd6409) by TimothÃ©e Mazzucotelli). [Issue #51](https://github.com/mkdocstrings/griffe/issues/51)

### Code Refactoring

- Use proper classes for docstrings sections ([46eddac](https://github.com/mkdocstrings/griffe/commit/46eddac0b847eeb75e4964a3186069f7698235b0) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/python#3](https://github.com/mkdocstrings/python/issues/3), [PR #52](https://github.com/mkdocstrings/griffe/pull/52)

## [0.13.0](https://github.com/mkdocstrings/griffe/releases/tag/0.13.0) - 2022-02-23

[Compare with 0.12.6](https://github.com/mkdocstrings/griffe/compare/0.12.6...0.13.0)

### Features

- Implement `trim_doctest_flags` for Google and Numpy ([8057153](https://github.com/mkdocstrings/griffe/commit/8057153823711d8f486b1c52469090ce404771cb) by Jeremy Goh). [Issue mkdocstrings/mkdocstrings#386](https://github.com/mkdocstrings/mkdocstrings/issues/386), [PR #48](https://github.com/mkdocstrings/griffe/pull/48)

### Bug Fixes

- Rename keyword parameters to keyword arguments ([ce3eb6b](https://github.com/mkdocstrings/griffe/commit/ce3eb6b5d7caad6df41496dd300924535d92dc7f) by Jeremy Goh).

## [0.12.6](https://github.com/mkdocstrings/griffe/releases/tag/0.12.6) - 2022-02-18

[Compare with 0.12.5](https://github.com/mkdocstrings/griffe/compare/0.12.5...0.12.6)

### Bug Fixes

- Support starred parameters in Numpy docstrings ([27f0fc2](https://github.com/mkdocstrings/griffe/commit/27f0fc21299a41a3afc07b46afbe8f37757c3918) by TimothÃ©e Mazzucotelli). [Issue #43](https://github.com/mkdocstrings/griffe/issues/43)

## [0.12.5](https://github.com/mkdocstrings/griffe/releases/tag/0.12.5) - 2022-02-17

[Compare with 0.12.4](https://github.com/mkdocstrings/griffe/compare/0.12.4...0.12.5)

### Bug Fixes

- Fix getting line numbers on aliases ([351750e](https://github.com/mkdocstrings/griffe/commit/351750ea70d0ab3f10c2766846c10d00612cda1d) by TimothÃ©e Mazzucotelli).

## [0.12.4](https://github.com/mkdocstrings/griffe/releases/tag/0.12.4) - 2022-02-16

[Compare with 0.12.3](https://github.com/mkdocstrings/griffe/compare/0.12.3...0.12.4)

### Bug Fixes

- Update target path when changing alias target ([5eda646](https://github.com/mkdocstrings/griffe/commit/5eda646f7bc2fdb112887fdeaa07f8a2f4635c12) by TimothÃ©e Mazzucotelli).
- Fix relative imports to absolute with wildcards ([69500dd](https://github.com/mkdocstrings/griffe/commit/69500dd0ce06f4acc91eb60ff20ac8d79303a281) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#382](https://github.com/mkdocstrings/mkdocstrings/issues/382)
- Fix accessing members using tuples ([87ff1df](https://github.com/mkdocstrings/griffe/commit/87ff1dfae93d9eb6f735f9c1290092d61cac7591) by TimothÃ©e Mazzucotelli).
- Fix recursive wildcard expansion ([60e6edf](https://github.com/mkdocstrings/griffe/commit/60e6edf9dcade104b069946380a0d1dcc22bce9a) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#382](https://github.com/mkdocstrings/mkdocstrings/issues/382)
- Only export submodules if they were imported ([98c72db](https://github.com/mkdocstrings/griffe/commit/98c72dbab114fd7782efd6f2f9bbf78e3f4ccb27) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#382](https://github.com/mkdocstrings/mkdocstrings/issues/382)

## [0.12.3](https://github.com/mkdocstrings/griffe/releases/tag/0.12.3) - 2022-02-15

[Compare with 0.12.2](https://github.com/mkdocstrings/griffe/compare/0.12.2...0.12.3)

### Bug Fixes

- Always decode source as UTF8 ([563469b](https://github.com/mkdocstrings/griffe/commit/563469b4cf320ea38096846312dc757a614d8094) by TimothÃ©e Mazzucotelli).
- Fix JSON encoder and decoder ([3e768d6](https://github.com/mkdocstrings/griffe/commit/3e768d6574a45624237e0897c1d6a6c87e446016) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Improve error handling ([7b15a51](https://github.com/mkdocstrings/griffe/commit/7b15a51fb9dd4722757f272f00402ce29ef2bd3f) by TimothÃ©e Mazzucotelli).

## [0.12.2](https://github.com/mkdocstrings/griffe/releases/tag/0.12.2) - 2022-02-13

[Compare with 0.12.1](https://github.com/mkdocstrings/griffe/compare/0.12.1...0.12.2)

### Bug Fixes

- Fix JSON unable to serialize docstring kind values ([91e6719](https://github.com/mkdocstrings/griffe/commit/91e67190fc4f69911ad6ea3eb239a74fc1f15ba6) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Make attribute labels more explicit ([19eac2e](https://github.com/mkdocstrings/griffe/commit/19eac2e5a13d77175849c199ba3337a66e3824a2) by TimothÃ©e Mazzucotelli).

## [0.12.1](https://github.com/mkdocstrings/griffe/releases/tag/0.12.1) - 2022-02-12

[Compare with 0.11.7](https://github.com/mkdocstrings/griffe/compare/0.11.7...0.12.1)

### Features

- Add `ignore_init_summary` option to the Google parser ([81f0333](https://github.com/mkdocstrings/griffe/commit/81f0333b1691955f6020095051b2cf869f0c2c24) by TimothÃ©e Mazzucotelli).
- Add `is_KIND` properties on objects ([17a08cd](https://github.com/mkdocstrings/griffe/commit/17a08cd7142bdee041577735d5e5ac246c181ec9) by TimothÃ©e Mazzucotelli).

## [0.11.7](https://github.com/mkdocstrings/griffe/releases/tag/0.11.7) - 2022-02-12

[Compare with 0.11.6](https://github.com/mkdocstrings/griffe/compare/0.11.6...0.11.7)

### Bug Fixes

- Keep only first assignment in conditions ([0104440](https://github.com/mkdocstrings/griffe/commit/010444018ca6ba437e70166e0da3e2d2ca6bbbe8) by TimothÃ©e Mazzucotelli).
- Support invert unary op in annotations ([734ef55](https://github.com/mkdocstrings/griffe/commit/734ef551f5c5b2b4b48de32033d4c2e7cff0a124) by TimothÃ©e Mazzucotelli).
- Fix handling of missing modules during dynamic imports ([7a3b383](https://github.com/mkdocstrings/griffe/commit/7a3b38349712c5b66792da1a8a9efae1b6f663a7) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings/mkdocstrings#380](https://github.com/mkdocstrings/mkdocstrings/issues/380)
- Fix getting lines of compiled modules ([899461b](https://github.com/mkdocstrings/griffe/commit/899461b2f48622f334ceeaa6d73c935bacb540ea) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Get annotation with the same property on functions ([ecc7bba](https://github.com/mkdocstrings/griffe/commit/ecc7bba8880f90417a21830e0e9cccf30f582399) by TimothÃ©e Mazzucotelli).

## [0.11.6](https://github.com/mkdocstrings/griffe/releases/tag/0.11.6) - 2022-02-10

[Compare with 0.11.5](https://github.com/mkdocstrings/griffe/compare/0.11.5...0.11.6)

### Bug Fixes

- Fix infinite loop in Google parser ([8b7b97b](https://github.com/mkdocstrings/griffe/commit/8b7b97b6f507dc91b957592e1d247d79bd3e9a5b) by TimothÃ©e Mazzucotelli). [Issue #38](https://github.com/mkdocstrings/griffe/issues/38)

## [0.11.5](https://github.com/mkdocstrings/griffe/releases/tag/0.11.5) - 2022-02-08

[Compare with 0.11.4](https://github.com/mkdocstrings/griffe/compare/0.11.4...0.11.5)

### Bug Fixes

- Fix building title and kind of Google admonitions ([87ab56c](https://github.com/mkdocstrings/griffe/commit/87ab56cfe5458b313527bc2eb47ea418fcb231ab) by TimothÃ©e Mazzucotelli). [Issue mkdocstrings#379](https://github.com/mkdocstrings/mkdocstrings/issues/379)

## [0.11.4](https://github.com/mkdocstrings/griffe/releases/tag/0.11.4) - 2022-02-07

[Compare with 0.11.3](https://github.com/mkdocstrings/griffe/compare/0.11.3...0.11.4)

### Bug Fixes

- Don't trigger alias resolution while checking docstrings presence ([dda72ea](https://github.com/mkdocstrings/griffe/commit/dda72ea56b091d1c9bc1b7aa369548328894da29) by TimothÃ©e Mazzucotelli). [Issue #37](https://github.com/mkdocstrings/griffe/issues/37)

## [0.11.3](https://github.com/mkdocstrings/griffe/releases/tag/0.11.3) - 2022-02-05

[Compare with 0.11.2](https://github.com/mkdocstrings/griffe/compare/0.11.2...0.11.3)

### Bug Fixes

- Fix getting params defaults on Python 3.7 ([0afd867](https://github.com/mkdocstrings/griffe/commit/0afd8675d2d24302d68619f31adbe5ac5d8ff5a7) by TimothÃ©e Mazzucotelli).

## [0.11.2](https://github.com/mkdocstrings/griffe/releases/tag/0.11.2) - 2022-02-03

[Compare with 0.11.1](https://github.com/mkdocstrings/griffe/compare/0.11.1...0.11.2)

### Code Refactoring

- Factorize docstring annotation parser ([19609be](https://github.com/mkdocstrings/griffe/commit/19609bede6227998a1322dbed6fcc1ae2e924bc8) by TimothÃ©e Mazzucotelli).

## [0.11.1](https://github.com/mkdocstrings/griffe/releases/tag/0.11.1) - 2022-02-01

[Compare with 0.11.0](https://github.com/mkdocstrings/griffe/compare/0.11.0...0.11.1)

### Code Refactoring

- Rename RST parser to Sphinx ([a612cb1](https://github.com/mkdocstrings/griffe/commit/a612cb1c8d52fabe5a1ebaf892e9b82c67d15a30) by TimothÃ©e Mazzucotelli).

## [0.11.0](https://github.com/mkdocstrings/griffe/releases/tag/0.11.0) - 2022-01-31

[Compare with 0.10.0](https://github.com/mkdocstrings/griffe/compare/0.10.0...0.11.0)

### Features

- Support matrix multiplication operator in visitor ([6129e17](https://github.com/mkdocstrings/griffe/commit/6129e17c86ff49a8e539039dcd04a58b30e3648e) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Fix name resolution for inspected data ([ed3e7e5](https://github.com/mkdocstrings/griffe/commit/ed3e7e5fa8a9d702c92f47e8244635cf11a923f2) by TimothÃ©e Mazzucotelli).
- Make importer actually able to import any nested object ([d007219](https://github.com/mkdocstrings/griffe/commit/d00721971c7b820e16e463408f04cc3e81a14db6) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Always use search paths to import modules ([a9a378f](https://github.com/mkdocstrings/griffe/commit/a9a378fc6e47678e08a22383879e4d01acd16b54) by TimothÃ©e Mazzucotelli).
- Split out module finder ([7290642](https://github.com/mkdocstrings/griffe/commit/7290642e36341e64b8ed770e237e9f232e05eada) by TimothÃ©e Mazzucotelli).

## [0.10.0](https://github.com/mkdocstrings/griffe/releases/tag/0.10.0) - 2022-01-14

[Compare with 0.9.0](https://github.com/mkdocstrings/griffe/compare/0.9.0...0.10.0)

### Bug Fixes

- Fix infinite recursion errors in alias resolver ([133b4e4](https://github.com/mkdocstrings/griffe/commit/133b4e4bf721fc7536a1ca957f13f7c9f83bf07a) by TimothÃ©e Mazzucotelli).
- Fix inspection of nodes children (aliases or not) ([bb354f2](https://github.com/mkdocstrings/griffe/commit/bb354f21e7b079f4c1e8dd50297d53810c18450e) by TimothÃ©e Mazzucotelli).
- Fix relative to absolute import conversion ([464c39e](https://github.com/mkdocstrings/griffe/commit/464c39eaa812a927190469b18bd910e95e3c1d3c) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Rename some CLI options ([1323268](https://github.com/mkdocstrings/griffe/commit/13232685b0f2752d92428ab786d428d0af11743b) by TimothÃ©e Mazzucotelli).
- Return the loader the to main function ([9c6317e](https://github.com/mkdocstrings/griffe/commit/9c6317e5afa25dd11d18906503b8010046878868) by TimothÃ©e Mazzucotelli).
- Improve logging messages ([b8eb16e](https://github.com/mkdocstrings/griffe/commit/b8eb16e0fedfe50f2c3ad65e326f4dc6e6918ac0) by TimothÃ©e Mazzucotelli).
- Skip inspection of some debug packages ([4ee8968](https://github.com/mkdocstrings/griffe/commit/4ee896864f1227e32d40571da03f7894c9404579) by TimothÃ©e Mazzucotelli).
- Return ... instead of Ellipsis ([f9ae31d](https://github.com/mkdocstrings/griffe/commit/f9ae31d0f4c904a89c7f581aaa031692740edaef) by TimothÃ©e Mazzucotelli).
- Catch attribute errors when cross-referencing docstring annotations ([288803a](https://github.com/mkdocstrings/griffe/commit/288803a3be93c4e077576ed36dded2a76ce33955) by TimothÃ©e Mazzucotelli).
- Support dict methods in lines collection ([1b0cb94](https://github.com/mkdocstrings/griffe/commit/1b0cb945dba619df7ce1358f7961e4bd80f70218) by TimothÃ©e Mazzucotelli).

### Features

- Compute and show some stats ([1b8d0a1](https://github.com/mkdocstrings/griffe/commit/1b8d0a1c91e03dfa5f92ad9c6dff02863a43fc01) by TimothÃ©e Mazzucotelli).
- Add CLI options for alias resolution ([87a59cb](https://github.com/mkdocstrings/griffe/commit/87a59cb7af5f8e7df9ddba41fb4a4b65cb264481) by TimothÃ©e Mazzucotelli).
- Support Google raises annotations cross-refs ([8006ae1](https://github.com/mkdocstrings/griffe/commit/8006ae13bc27d117ce6b8fdc8ac91dc8541a670f) by TimothÃ©e Mazzucotelli).

## [0.9.0](https://github.com/mkdocstrings/griffe/releases/tag/0.9.0) - 2022-01-04

[Compare with 0.8.0](https://github.com/mkdocstrings/griffe/compare/0.8.0...0.9.0)

### Features

- Loader option to only follow aliases in known modules ([879d91b](https://github.com/mkdocstrings/griffe/commit/879d91b4c50832620ce6ee7bdcc85107a6df9a1f) by TimothÃ©e Mazzucotelli).
- Use aliases when inspecting too ([60439ee](https://github.com/mkdocstrings/griffe/commit/60439eefb4635e58e4bd898e5565eab48a5c91d0) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Handle more errors when loading modules ([1aa571a](https://github.com/mkdocstrings/griffe/commit/1aa571a112e3b2ca955c23f2eef97b36f34bcd8c) by TimothÃ©e Mazzucotelli).
- Handle more errors when getting signature ([2db85e7](https://github.com/mkdocstrings/griffe/commit/2db85e7f655c1e383ba310f40195844c2867e1b9) by TimothÃ©e Mazzucotelli).
- Fix checking parent truthfulness ([6129e50](https://github.com/mkdocstrings/griffe/commit/6129e50331f6e36bcbee2e07b871abee45f7e872) by TimothÃ©e Mazzucotelli).
- Fix getting subscript value ([1699f12](https://github.com/mkdocstrings/griffe/commit/1699f121adc13fcc48f81f46dfca85946e2fb74f) by TimothÃ©e Mazzucotelli).
- Support yield nodes ([7d536d5](https://github.com/mkdocstrings/griffe/commit/7d536d58ffc0faa4caf43f09194d88c35fc47704) by TimothÃ©e Mazzucotelli).
- Exclude some special low-level members that cause cyclic issues ([b54ab34](https://github.com/mkdocstrings/griffe/commit/b54ab346308bb24cba66be9c8f1ee8599481381d) by TimothÃ©e Mazzucotelli).
- Fix transforming elements of signatures to annotations ([e278c11](https://github.com/mkdocstrings/griffe/commit/e278c1102b2762b74bf6b83a2e97a5f87b566e2e) by TimothÃ©e Mazzucotelli).
- Detect cyclic aliases and prevent resolution errors ([de5dd12](https://github.com/mkdocstrings/griffe/commit/de5dd12240acf8a203a86b04e458ce33b67ced9e) by TimothÃ©e Mazzucotelli).
- Don't crash while trying to get the representation of an attribute value ([77ac55d](https://github.com/mkdocstrings/griffe/commit/77ac55d5033e83790c79f3303fdbd05ea66ab729) by TimothÃ©e Mazzucotelli).
- Fix building value for joined strings ([6154b69](https://github.com/mkdocstrings/griffe/commit/6154b69b6da5d63c508ec5095aebe487e491b553) by TimothÃ©e Mazzucotelli).
- Fix prevention of cycles while building objects nodes ([48062ac](https://github.com/mkdocstrings/griffe/commit/48062ac1f8356099b8e0e1069e4321a467073d33) by TimothÃ©e Mazzucotelli).
- Better handle relative imports ([91b42de](https://github.com/mkdocstrings/griffe/commit/91b42dea73c035b2dc20db1e328a53960c51a645) by TimothÃ©e Mazzucotelli).
- Fix Google parser missing lines ending with colon ([2f7969c](https://github.com/mkdocstrings/griffe/commit/2f7969ccbf91b63ae22deb742250068c114fe1a9) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Improve alias resolution robustness ([e708139](https://github.com/mkdocstrings/griffe/commit/e708139c9bd19be320bdb279310560212872326f) by TimothÃ©e Mazzucotelli).
- Remove async loader for now ([acc5ecf](https://github.com/mkdocstrings/griffe/commit/acc5ecf2bb45dcebdd56d763a657a1075c4a3002) by TimothÃ©e Mazzucotelli).
- Improve handling of Google admonitions ([8aa5ed0](https://github.com/mkdocstrings/griffe/commit/8aa5ed0be4f1902dbdfbce9b4a9c7ac619418d43) by TimothÃ©e Mazzucotelli).
- Better handling of import errors and system exits while inspecting modules ([7ba1589](https://github.com/mkdocstrings/griffe/commit/7ba1589552fb37fba3c2f3093058e135a6e48a27) by TimothÃ©e Mazzucotelli).
- Empty generic visit/inspect methods in base classes ([338760e](https://github.com/mkdocstrings/griffe/commit/338760ea2189e74577250b8c3f4ffe91f81e6b6e) by TimothÃ©e Mazzucotelli).

## [0.8.0](https://github.com/mkdocstrings/griffe/releases/tag/0.8.0) - 2022-01-02

[Compare with 0.7.1](https://github.com/mkdocstrings/griffe/compare/0.7.1...0.8.0)

### Features

- Support getting attribute annotation from parent in RST docstring parser ([25db61a](https://github.com/mkdocstrings/griffe/commit/25db61ab01042ad797ac5cdea0b2f7e2382191c1) by TimothÃ©e Mazzucotelli).
- Handle relative imports ([62b0927](https://github.com/mkdocstrings/griffe/commit/62b0927516ca345de61aa3cc03e977d4d37220de) by TimothÃ©e Mazzucotelli).
- Support wildcard imports ([77a3cb7](https://github.com/mkdocstrings/griffe/commit/77a3cb7e4198dc2e2cea953c5f621544b564552c) by TimothÃ©e Mazzucotelli).
- Support configuring log level (CLI/env var) ([839d78e](https://github.com/mkdocstrings/griffe/commit/839d78ea302df004fba1b6fad9eb84d861f0f4aa) by TimothÃ©e Mazzucotelli).
- Support loading `*.py[cod]` and `*.so` modules ([cd98a6f](https://github.com/mkdocstrings/griffe/commit/cd98a6f3afbbf8f6a176aa7780a8b916a9ee64f2) by TimothÃ©e Mazzucotelli).
- Support inspecting builtin functions/methods ([aa1fce3](https://github.com/mkdocstrings/griffe/commit/aa1fce330ce3e2af4dd9a3c43827637d1e220dde) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Handle extensions errors ([11278ca](https://github.com/mkdocstrings/griffe/commit/11278caea27e9f91a1dc9cc160414f01b24f5354) by TimothÃ©e Mazzucotelli).
- Don't always try to find a module as a relative path ([e6df277](https://github.com/mkdocstrings/griffe/commit/e6df2774bfd631fd9a09913480b4d61d137bc0c6) by TimothÃ©e Mazzucotelli).
- Improve loggers patching ([f4b262a](https://github.com/mkdocstrings/griffe/commit/f4b262ab5a3d874591324adc2b5ffff214c7e7da) by TimothÃ©e Mazzucotelli).
- Improve dynamic imports ([2998195](https://github.com/mkdocstrings/griffe/commit/299819519b7eb9b07b938d22bfb3a27e3b05095d) by TimothÃ©e Mazzucotelli).

## [0.7.1](https://github.com/mkdocstrings/griffe/releases/tag/0.7.1) - 2021-12-28

[Compare with 0.7.0](https://github.com/mkdocstrings/griffe/compare/0.7.0...0.7.1)

### Code Refactoring

- Only log warning if async mode is used ([356e848](https://github.com/mkdocstrings/griffe/commit/356e848c8e233334401461b02a0188731b71a8cf) by TimothÃ©e Mazzucotelli).

## [0.7.0](https://github.com/mkdocstrings/griffe/releases/tag/0.7.0) - 2021-12-28

[Compare with 0.6.0](https://github.com/mkdocstrings/griffe/compare/0.6.0...0.7.0)

### Features

- Support more nodes on Python 3.7 ([7f2c4ec](https://github.com/mkdocstrings/griffe/commit/7f2c4ec3bf610ade7305e19ab220a4b447bed41d) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Don't crash on syntax errors and log an error ([10bb6b1](https://github.com/mkdocstrings/griffe/commit/10bb6b15bb9b132626c525b81f3ee33c3bb5746f) by TimothÃ©e Mazzucotelli).

## [0.6.0](https://github.com/mkdocstrings/griffe/releases/tag/0.6.0) - 2021-12-27

[Compare with 0.5.0](https://github.com/mkdocstrings/griffe/compare/0.5.0...0.6.0)

### Features

- Support more AST nodes ([cd1b305](https://github.com/mkdocstrings/griffe/commit/cd1b305932832ad5347ce829a48a311e3c44d542) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Use annotation getter for base classes ([8b1a7ed](https://github.com/mkdocstrings/griffe/commit/8b1a7edc11a72f679689fa9ba9e632907f9304f8) by TimothÃ©e Mazzucotelli).

## [0.5.0](https://github.com/mkdocstrings/griffe/releases/tag/0.5.0) - 2021-12-20

[Compare with 0.4.0](https://github.com/mkdocstrings/griffe/compare/0.4.0...0.5.0)

### Features

- Add support for Python 3.7 ([4535adc](https://github.com/mkdocstrings/griffe/commit/4535adce19edbe7e9cde90f3b1075a8245a6ebc8) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Don't propagate aliases of an alias ([8af48f8](https://github.com/mkdocstrings/griffe/commit/8af48f87e2e6bb0f2cf1531fa10287a069f67289) by TimothÃ©e Mazzucotelli).
- Don't reassign members defined in except clauses ([d918b4e](https://github.com/mkdocstrings/griffe/commit/d918b4efcedcedbec6db214ade8cde921d7e97b2) by TimothÃ©e Mazzucotelli).

## [0.4.0](https://github.com/mkdocstrings/griffe/releases/tag/0.4.0) - 2021-11-28

[Compare with 0.3.0](https://github.com/mkdocstrings/griffe/compare/0.3.0...0.4.0)

### Features

- Add a prototype 'hybrid' extension ([8cb3c16](https://github.com/mkdocstrings/griffe/commit/8cb3c1661223378a2511fd42a0693d0fbfe924d8) by TimothÃ©e Mazzucotelli).
- Allow passing extensions config as JSON on the CLI ([9a7fa8b](https://github.com/mkdocstrings/griffe/commit/9a7fa8bd88752ca1a074179db3a4c7fc41b68028) by TimothÃ©e Mazzucotelli).
- Support names for returns, yields and receives sections items ([1c5a4c9](https://github.com/mkdocstrings/griffe/commit/1c5a4c95738615ea9bb6a816c61d078e6133100a) by TimothÃ©e Mazzucotelli).
- Store aliases on each object ([91ba643](https://github.com/mkdocstrings/griffe/commit/91ba643b3e8e9a8f56f3280f699a18b1e654ccd7) by TimothÃ©e Mazzucotelli).
- Support inspection/introspection ([3a0587d](https://github.com/mkdocstrings/griffe/commit/3a0587dbf26f288722c7d27e781d0887c5cdf641) by TimothÃ©e Mazzucotelli).
- Support multiple return, yield and receive items ([0fc70cb](https://github.com/mkdocstrings/griffe/commit/0fc70cbcc07c63ecf1026e4bef30bd0ff3f73958) by TimothÃ©e Mazzucotelli).
- Support namespace packages ([2414c8e](https://github.com/mkdocstrings/griffe/commit/2414c8e24b7ba7ee986d95b301662fd06ef350fe) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Fix extensions loader ([78fb70b](https://github.com/mkdocstrings/griffe/commit/78fb70b77076b68fa30592caa5e92a91f0ce2caa) by TimothÃ©e Mazzucotelli).
- Avoid visiting/inspecting multiple times ([75a8a8b](https://github.com/mkdocstrings/griffe/commit/75a8a8b7145e1872cbecf93f8e33749b51b5b77b) by TimothÃ©e Mazzucotelli).
- Set modules collection attribute earlier ([592c0bd](https://github.com/mkdocstrings/griffe/commit/592c0bde6b6959615bc56030758098c8e45119a2) by TimothÃ©e Mazzucotelli).
- Support inequality nodes ([b0ed247](https://github.com/mkdocstrings/griffe/commit/b0ed247c9fe42a324a4e8e4a972676afbaa26976) by TimothÃ©e Mazzucotelli).
- Handle Div nodes for values ([272e4d6](https://github.com/mkdocstrings/griffe/commit/272e4d64b5ca557732af903d35aefbe405bd3ac0) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Set log level to INFO ([718e73e](https://github.com/mkdocstrings/griffe/commit/718e73ebb6767c0b10c03482d6f92cf135778ec7) by TimothÃ©e Mazzucotelli).
- Add target setter ([7f0064c](https://github.com/mkdocstrings/griffe/commit/7f0064c154459b4f4da7fc25bc49f8dd1e4fd2c0) by TimothÃ©e Mazzucotelli).
- Reorganize conditions ([15ab876](https://github.com/mkdocstrings/griffe/commit/15ab8763acc92d9160b847dc878f8bdad7f0b705) by TimothÃ©e Mazzucotelli).
- Avoid recursion loops ([ea6acec](https://github.com/mkdocstrings/griffe/commit/ea6acec10c0a805a9ae4e03ae0b92fb2a54cf79b) by TimothÃ©e Mazzucotelli).
- Update aliases when replacing a member ([99a0f8b](https://github.com/mkdocstrings/griffe/commit/99a0f8b9a425251ddcde853f2ad9ee95504b2127) by TimothÃ©e Mazzucotelli).
- Reorganize code ([31fcdb1](https://github.com/mkdocstrings/griffe/commit/31fcdb1cbe0eceedc59cc7c1c692dc4ef210ef53) by TimothÃ©e Mazzucotelli).
- Replace DocstringException with DocstringRaise ([d5ed87a](https://github.com/mkdocstrings/griffe/commit/d5ed87a478411aeb8248e948dbb6c228b80f5fbe) by TimothÃ©e Mazzucotelli).
- Refactor loaders ([d9b94bb](https://github.com/mkdocstrings/griffe/commit/d9b94bbcb55c29268ab1e077420e2b0d5297638c) by TimothÃ©e Mazzucotelli).
- Improve typing ([e08bcfa](https://github.com/mkdocstrings/griffe/commit/e08bcfac68aa22dc4bc58914b3340c1743f87ee7) by TimothÃ©e Mazzucotelli).

## [0.3.0](https://github.com/mkdocstrings/griffe/releases/tag/0.3.0) - 2021-11-21

[Compare with 0.2.0](https://github.com/mkdocstrings/griffe/compare/0.2.0...0.3.0)

### Features

- Handle aliases and their resolution ([67ae903](https://github.com/mkdocstrings/griffe/commit/67ae9034ac25061bc7d5c6def63715209643ca20) by TimothÃ©e Mazzucotelli).
- Resolve annotations in docstrings ([847384a](https://github.com/mkdocstrings/griffe/commit/847384a322017ca94bd40d4342eb4b8b42858f91) by TimothÃ©e Mazzucotelli).
- Resolve annotations ([6451eff](https://github.com/mkdocstrings/griffe/commit/6451effa01aa09cd3db1584fe111152de649e525) by TimothÃ©e Mazzucotelli).
- Add lines property to objects ([7daf7db](https://github.com/mkdocstrings/griffe/commit/7daf7db9ae58fb13985d1adacbde5d0bec2a35e4) by TimothÃ©e Mazzucotelli).
- Allow setting docstring parser and options on each object ([07a1d2e](https://github.com/mkdocstrings/griffe/commit/07a1d2e83c12bfa0f7b0dd35149b5cc0d0f600d6) by TimothÃ©e Mazzucotelli).
- Get attributes annotations from parent ([003b990](https://github.com/mkdocstrings/griffe/commit/003b99020f45b350d29329690d18f6c6cb3821f9) by TimothÃ©e Mazzucotelli).
- Draft extensions loader ([17ccd03](https://github.com/mkdocstrings/griffe/commit/17ccd03cadc5cbb230071e78beab96a0b97456a1) by TimothÃ©e Mazzucotelli).
- Add properties to objects ([0ec301a](https://github.com/mkdocstrings/griffe/commit/0ec301a5e97bee6556b62cb6ee35af9976f8410b) by TimothÃ©e Mazzucotelli).
- Handle .pth files when searching modules ([2a2e182](https://github.com/mkdocstrings/griffe/commit/2a2e1826fe0235c5bd47b5d6b1b64a30a81a3f4b) by TimothÃ©e Mazzucotelli).
- Add `default` property to docstring parameters ([6298ba3](https://github.com/mkdocstrings/griffe/commit/6298ba34d4e769568e519e21549137df3649e01b) by TimothÃ©e Mazzucotelli).
- Accept RST and Numpy parsers ([1cf147d](https://github.com/mkdocstrings/griffe/commit/1cf147d8df0491104efd084ce3308da77fc2c817) by TimothÃ©e Mazzucotelli).
- Support data (attributes/variables) ([dce84d1](https://github.com/mkdocstrings/griffe/commit/dce84d106cf067f11305f804a24cfd7d5643d902) by TimothÃ©e Mazzucotelli).
- Add Numpy-style parser ([ad5b72d](https://github.com/mkdocstrings/griffe/commit/ad5b72d174433764e85f937ea1096c0f458532f8) by TimothÃ©e Mazzucotelli).
- Support more section kinds in Google-style ([9d3d047](https://github.com/mkdocstrings/griffe/commit/9d3d0472d0bb55352b371de3da0816419fcf59e0) by TimothÃ©e Mazzucotelli).
- Add docstring section kinds ([b270483](https://github.com/mkdocstrings/griffe/commit/b2704833bc74131269306b9947ea2b46edafd349) by TimothÃ©e Mazzucotelli).
- Accept initial arguments when creating container ([90c5956](https://github.com/mkdocstrings/griffe/commit/90c59568bb6cdbf18efe182bd821973f2a133663) by TimothÃ©e Mazzucotelli).
- Add an RST-style docstring parser ([742e7b2](https://github.com/mkdocstrings/griffe/commit/742e7b2e2101d0679571645584c5a6d3077a9764) by TimothÃ©e Mazzucotelli).

### Performance Improvements

- Improve JSON encoder perfs ([6a78eb0](https://github.com/mkdocstrings/griffe/commit/6a78eb0b707a148356fb5bc69d9d0c2115239074) by TimothÃ©e Mazzucotelli).

### Bug Fixes

- Handle serialization of Posix paths ([3a66b95](https://github.com/mkdocstrings/griffe/commit/3a66b95a4c91e6160d161acc457c66196adaa4fe) by TimothÃ©e Mazzucotelli).
- Fix list annotation getter ([5ae800a](https://github.com/mkdocstrings/griffe/commit/5ae800a8902a28b5241192c0905b1914e2bfe906) by TimothÃ©e Mazzucotelli).
- Show accurate line number in Google warnings ([2953590](https://github.com/mkdocstrings/griffe/commit/29535902d53b553906f59295104690c9417eb79f) by TimothÃ©e Mazzucotelli).
- Fix assignment names getters ([6990846](https://github.com/mkdocstrings/griffe/commit/69908460b4fe47d1dc3d8d9f6b43d49dee5823aa) by TimothÃ©e Mazzucotelli).
- Fix async loader (passing parent) ([57e866e](https://github.com/mkdocstrings/griffe/commit/57e866e4c48f4646142a26c6d2537f4da10e3a2c) by TimothÃ©e Mazzucotelli).
- Fix exception name ([4b8b85d](https://github.com/mkdocstrings/griffe/commit/4b8b85dde72a552091534b3293399b844523786f) by TimothÃ©e Mazzucotelli).
- Fix Google sections titles logic ([87dd329](https://github.com/mkdocstrings/griffe/commit/87dd32988a9164c47dadf96c0c74a0da8af16bd8) by TimothÃ©e Mazzucotelli).
- Prepend current module to base classes (still needs resolution) ([a4b1dee](https://github.com/mkdocstrings/griffe/commit/a4b1deef4beb0e9e79adc920d80232f04ddfdc31) by TimothÃ©e Mazzucotelli).
- Fix Google admonition regex ([3902e74](https://github.com/mkdocstrings/griffe/commit/3902e7497ef8b388c3d232a8116cb3bd27fdaad2) by TimothÃ©e Mazzucotelli).
- Fix docstring getter ([1442eba](https://github.com/mkdocstrings/griffe/commit/1442eba93479f24a4d90cd9b25f57d304a65cd6c) by TimothÃ©e Mazzucotelli).
- Fix getting arguments defaults in the Google-style parser ([67adbaf](https://github.com/mkdocstrings/griffe/commit/67adbafe04de1c8effc124b26565bef59adfb393) by TimothÃ©e Mazzucotelli).
- Fix getting arguments annotations in the Google-style parser ([8bcbfba](https://github.com/mkdocstrings/griffe/commit/8bcbfbae861be4c3f9c2b8841c8bc86f39611168) by TimothÃ©e Mazzucotelli).

### Code Refactoring

- Export parsers and main function in docstrings module ([96469da](https://github.com/mkdocstrings/griffe/commit/96469dab63a28c061e1d064528f8e07f394c2d81) by TimothÃ©e Mazzucotelli).
- Remove top exports ([cd76694](https://github.com/mkdocstrings/griffe/commit/cd7669481a272d7c939b61f6ff2df1cb55eab39e) by TimothÃ©e Mazzucotelli).
- Reorganize exceptions ([7f9b805](https://github.com/mkdocstrings/griffe/commit/7f9b8055aa069816b3b55fd02730e97e37a6bea4) by TimothÃ©e Mazzucotelli).
- Avoid circular import ([ef27dcd](https://github.com/mkdocstrings/griffe/commit/ef27dcd6cc85590d1982ee14b7f520d379d658b8) by TimothÃ©e Mazzucotelli).
- Rename index to [new] offset ([c07cc7d](https://github.com/mkdocstrings/griffe/commit/c07cc7d916d613545073e1159d86c65d58d98b37) by TimothÃ©e Mazzucotelli).
- Reorganize code ([5f4fff2](https://github.com/mkdocstrings/griffe/commit/5f4fff21d1da7e1b33554cfb8017b23955999ad5) by TimothÃ©e Mazzucotelli).
- Use keyword only parameters ([d34edd6](https://github.com/mkdocstrings/griffe/commit/d34edd629589796d53dbc29d77c5f7041acea5ab) by TimothÃ©e Mazzucotelli).
- Default to no parsing for serialization ([8fecd9e](https://github.com/mkdocstrings/griffe/commit/8fecd9ef63f773220bb85379537c4ad25ea0e4fd) by TimothÃ©e Mazzucotelli).
- Always extend AST ([c227ae6](https://github.com/mkdocstrings/griffe/commit/c227ae62ee5a3cc764f2c6fc9185400f0c9c48e7) by TimothÃ©e Mazzucotelli).
- Set default for kwargs parameters ([7a0b85e](https://github.com/mkdocstrings/griffe/commit/7a0b85e5fd255db743c122e1a13916cdc3eb46ff) by TimothÃ©e Mazzucotelli).
- Rename visitor method ([3e0c43c](https://github.com/mkdocstrings/griffe/commit/3e0c43cbed6cec563367f80e86f245b3ba89694c) by TimothÃ©e Mazzucotelli).
- Improve typing ([ac86f17](https://github.com/mkdocstrings/griffe/commit/ac86f17bfbfc98d3c41f1830e4356fecc2ed76fc) by TimothÃ©e Mazzucotelli).
- Fix typo ([a9ed6e9](https://github.com/mkdocstrings/griffe/commit/a9ed6e95992381df41554a895ed6304ca61048f7) by TimothÃ©e Mazzucotelli).
- Rewrite ParameterKind ([90249df](https://github.com/mkdocstrings/griffe/commit/90249df0b478f147fc50a18dfb56ad96ad09e78c) by TimothÃ©e Mazzucotelli).
- Add bool methods to docstrings and objects ([548f72e](https://github.com/mkdocstrings/griffe/commit/548f72ed5289aa531c125e4da6ff72a1ff34124d) by TimothÃ©e Mazzucotelli).
- Allow setting docstring parser and options on each docstring ([752e084](https://github.com/mkdocstrings/griffe/commit/752e0843bc7388c9a2c7ce9ae2dce03ffa9243e3) by TimothÃ©e Mazzucotelli).
- Skip attribute assignments ([e9cc2cd](https://github.com/mkdocstrings/griffe/commit/e9cc2cdd8cae1d15b98ffaa60e777b679ac55e23) by TimothÃ©e Mazzucotelli).
- Improve visitor getters ([2ea88c0](https://github.com/mkdocstrings/griffe/commit/2ea88c020481e78060c90d8307a4f6a68047eaa2) by TimothÃ©e Mazzucotelli).
- Use relative filepath in docstring warnings ([e894df7](https://github.com/mkdocstrings/griffe/commit/e894df767262623720a45c0b5c16fed544fae106) by TimothÃ©e Mazzucotelli).
- Set submodules parent earlier ([53767c0](https://github.com/mkdocstrings/griffe/commit/53767c0c4ef90bfe405dcffd6087e365b98efafc) by TimothÃ©e Mazzucotelli).
- Rename Data to Attribute ([febc12e](https://github.com/mkdocstrings/griffe/commit/febc12e5e33bbbdd448298f2cc277a45fd986204) by TimothÃ©e Mazzucotelli).
- Rename arguments to parameters ([957856c](https://github.com/mkdocstrings/griffe/commit/957856cf22772584bcced30141afb8ca6a2ac378) by TimothÃ©e Mazzucotelli).
- Improve annotation support ([5b2262f](https://github.com/mkdocstrings/griffe/commit/5b2262f9cacce4044716661e6de49a1773ea3aa8) by TimothÃ©e Mazzucotelli).
- Always set parent ([cae85de](https://github.com/mkdocstrings/griffe/commit/cae85def4af1f67b537daabdb1e8ae9830dcaec7) by TimothÃ©e Mazzucotelli).
- Factorize function handling ([dfece1c](https://github.com/mkdocstrings/griffe/commit/dfece1c0c73076c7d87d4df551f0994b4c2e3b69) by TimothÃ©e Mazzucotelli).
- Privatize stuff, fix loggers ([5513ed5](https://github.com/mkdocstrings/griffe/commit/5513ed5345db185e7c08890ca08de17932b34f51) by TimothÃ©e Mazzucotelli).
- Use keyword only arguments ([e853fe9](https://github.com/mkdocstrings/griffe/commit/e853fe9188fd2cd2ccc90e5fa1f52443bb00bab7) by TimothÃ©e Mazzucotelli).
- Set default values for Argument arguments ([d5cccaa](https://github.com/mkdocstrings/griffe/commit/d5cccaa6ee73e14ca4456b974fba6d01d40bf848) by TimothÃ©e Mazzucotelli).
- Swallow extra parsing options ([3d9ebe7](https://github.com/mkdocstrings/griffe/commit/3d9ebe775e1b936e89115d166144610b3a90290c) by TimothÃ©e Mazzucotelli).
- Rename `start_index` argument to `offset` ([dd88358](https://github.com/mkdocstrings/griffe/commit/dd88358d8db78636ba5f39fcad92ff5192791852) by TimothÃ©e Mazzucotelli).
- Reuse parsers warn function ([03dfdd3](https://github.com/mkdocstrings/griffe/commit/03dfdd38c5977ee83383f95acda1280b3f9ac86b) by TimothÃ©e Mazzucotelli).

## [0.2.0](https://github.com/mkdocstrings/griffe/releases/tag/0.2.0) - 2021-09-25

[Compare with 0.1.0](https://github.com/mkdocstrings/griffe/compare/0.1.0...0.2.0)

### Features

- Add Google-style docstring parser ([cdefccc](https://github.com/mkdocstrings/griffe/commit/cdefcccff2cb8236003736545cffaf0bd6f46539) by TimothÃ©e Mazzucotelli).
- Support all kinds of functions arguments ([c177562](https://github.com/mkdocstrings/griffe/commit/c177562c358f89da8c541b51d86f9470dd849c8f) by TimothÃ©e Mazzucotelli).
- Initial support for class decorators and bases ([8e229aa](https://github.com/mkdocstrings/griffe/commit/8e229aa5f04d21bde108dca517166d291fd2147a) by TimothÃ©e Mazzucotelli).
- Add functions decorators support ([fee304d](https://github.com/mkdocstrings/griffe/commit/fee304d44ce33286dedd6bb13a9b7200ea3d4dfa) by TimothÃ©e Mazzucotelli).
- Add async loader ([3218bd0](https://github.com/mkdocstrings/griffe/commit/3218bd03fd754a04a4280c29319e6b8d55aac015) by TimothÃ©e Mazzucotelli).
- Add relative file path and package properties ([d26ee1f](https://github.com/mkdocstrings/griffe/commit/d26ee1f3f09337af925c8071b4f24b8ae69b01d3) by TimothÃ©e Mazzucotelli).
- Add search and output option to the CLI ([3b37692](https://github.com/mkdocstrings/griffe/commit/3b3769234aed87e100ef917fa2db550e650bff0d) by TimothÃ©e Mazzucotelli).
- Load docstrings and functions arguments ([cdf29a3](https://github.com/mkdocstrings/griffe/commit/cdf29a3b12b4c04235dfeba1c8ef7461cc05248f) by TimothÃ©e Mazzucotelli).
- Support paths in loader ([8f4df75](https://github.com/mkdocstrings/griffe/commit/8f4df7518ee5164e695e27fc9dcedae7a8b05133) by TimothÃ©e Mazzucotelli).

### Performance Improvements

- Avoid name lookups in visitor ([00de148](https://github.com/mkdocstrings/griffe/commit/00de1482891e0c0091e79c14fdc318c6a95e4f6f) by TimothÃ©e Mazzucotelli).
- Factorize and improve main and extensions visitors ([9b27b56](https://github.com/mkdocstrings/griffe/commit/9b27b56c0fc17d94144fd0b7e3783d3f6f572d3d) by TimothÃ©e Mazzucotelli).
- Delegate children computation at runtime ([8d54c87](https://github.com/mkdocstrings/griffe/commit/8d54c8792f2a98c744374ae290bcb31fa81141b4) by TimothÃ©e Mazzucotelli).
- Cache dataclasses properties ([2d7447d](https://github.com/mkdocstrings/griffe/commit/2d7447db05c2a3227e6cb66be46d374dac5fdf19) by TimothÃ©e Mazzucotelli).
- Optimize node linker ([03f955e](https://github.com/mkdocstrings/griffe/commit/03f955ee698adffb7217528c03691876f299f8ca) by TimothÃ©e Mazzucotelli).
- Optimize docstring getter ([4a05516](https://github.com/mkdocstrings/griffe/commit/4a05516de320473b5defd70f208b4e90763f2208) by TimothÃ©e Mazzucotelli).

## [0.1.0](https://github.com/mkdocstrings/griffe/releases/tag/0.1.0) - 2021-09-09

[Compare with first commit](https://github.com/mkdocstrings/griffe/compare/7ea73adcc6aebcbe0eb64982916220773731a6b3...0.1.0)

### Features

- Add initial code ([8cbdf7a](https://github.com/mkdocstrings/griffe/commit/8cbdf7a49202dcf3cd617ae905c0f04cdfe053dd) by TimothÃ©e Mazzucotelli).
- Generate project from copier-pdm template ([7ea73ad](https://github.com/mkdocstrings/griffe/commit/7ea73adcc6aebcbe0eb64982916220773731a6b3) by TimothÃ©e Mazzucotelli).
