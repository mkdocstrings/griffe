# Griffe

> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.

# Usage

# Welcome

> Griffe, pronounced "grif" (`/ɡʁif/`), is a french word that means "claw", but also "signature" in a familiar way. "On reconnaît bien là sa griffe."

- **Getting started**

  ______________________________________________________________________

  Learn how to quickly install and use Griffe.

  [Installation](installation/) [Introduction](introduction/)

- **Deep dive**

  ______________________________________________________________________

  Learn everything you can do with Griffe.

  [Guide](guide/users/) [API reference](reference/api/)

## What is Griffe?

Griffe is a Python tool and library that gives you signatures for entire Python programs. It extracts the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.

Griffe can be used as a Python library. For example, the [Python handler](https://mkdocstrings.github.io/python) of [mkdocstrings](https://mkdocstrings.github.io/) uses Griffe to collect API data and render API documentation in HTML. Griffe can also be used on the command-line, to load and serialize your API data to JSON, or find breaking changes in your API since the previous version of your library.

Serializing as JSON

```
$ griffe dump griffe -ssrc -r 2>/dev/null | head -n29
{
  "griffe": {
    "deprecated": null,
    "docstring": {
      "endlineno": 161,
      "lineno": 5,
      "value": "Griffe package.\n\nSignatures for entire Python programs.\nExtract the structure, the frame, the skeleton of your project,\nto generate API documentation or find breaking changes in your API.\n\nThe entirety of the public API is exposed here, in the top-level `griffe` module.\n\nAll messages written to standard output or error are logged using the `logging` module.\nOur logger's name is set to `\"griffe\"` and is public (you can rely on it).\nYou can obtain the logger from the standard `logging` module: `logging.getLogger(\"griffe\")`.\nActual logging messages are not part of the public API (they might change without notice).\n\nRaised exceptions throughout the package are part of the public API (you can rely on them).\nTheir actual messages are not part of the public API (they might change without notice).\n\nThe following paragraphs will help you discover the package's content.\n\n## CLI entrypoints\n\nGriffe provides a command-line interface (CLI) to interact with the package. The CLI entrypoints can be called from Python code.\n\n- [`griffe.main`][]: Run the main program.\n- [`griffe.check`][]: Check for API breaking changes in two versions of the same package.\n- [`griffe.dump`][]: Load packages data and dump it as JSON.\n\n## Loaders\n\nTo load API data, Griffe provides several high-level functions.\n\n- [`griffe.load`][]: Load and return a Griffe object.\n- [`griffe.load_git`][]: Load and return a module from a specific Git reference.\n- [`griffe.load_pypi`][]: Load and return a module from a specific package version downloaded using pip.\n\n## Models\n\nThe data loaded by Griffe is represented by several classes.\n\n- [`griffe.Module`][]: The class representing a Python module.\n- [`griffe.Class`][]: The class representing a Python class.\n- [`griffe.Function`][]: The class representing a Python function or method.\n- [`griffe.Attribute`][]: The class representing a Python attribute.\n- [`griffe.Alias`][]: This class represents an alias, or indirection, to an object declared in another module.\n\nAdditional classes are available to represent other concepts.\n\n- [`griffe.Decorator`][]: This class represents a decorator.\n- [`griffe.Parameters`][]: This class is a container for parameters.\n- [`griffe.Parameter`][]: This class represent a function parameter.\n\n## Agents\n\nGriffe is able to analyze code both statically and dynamically, using the following \"agents\".\nHowever most of the time you will only need to use the loaders above.\n\n- [`griffe.visit`][]: Parse and visit a module file.\n- [`griffe.inspect`][]: Inspect a module.\n\n## Serializers\n\nGriffe can serizalize data to dictionary and JSON.\n\n- [`griffe.Object.as_json`][griffe.Object.as_json]\n- [`griffe.Object.from_json`][griffe.Object.from_json]\n- [`griffe.JSONEncoder`][]: JSON encoder for Griffe objects.\n- [`griffe.json_decoder`][]: JSON decoder for Griffe objects.\n\n## API checks\n\nGriffe can compare two versions of the same package to find breaking changes.\n\n- [`griffe.find_breaking_changes`][]: Find breaking changes between two versions of the same API.\n- [`griffe.Breakage`][]: Breakage classes can explain what broke from a version to another.\n\n## Extensions\n\nGriffe supports extensions. You can create your own extension by subclassing the `griffe.Extension` class.\n\n- [`griffe.load_extensions`][]: Load configured extensions.\n- [`griffe.Extension`][]: Base class for Griffe extensions.\n\n## Docstrings\n\nGriffe can parse docstrings into structured data.\n\nMain class:\n\n- [`griffe.Docstring`][]: This class represents docstrings.\n\nDocstring section and element classes all start with `Docstring`.\n\nDocstring parsers:\n\n- [`griffe.parse`][]: Parse the docstring.\n- [`griffe.parse_auto`][]: Parse a docstring by automatically detecting the style it uses.\n- [`griffe.parse_google`][]: Parse a Google-style docstring.\n- [`griffe.parse_numpy`][]: Parse a Numpydoc-style docstring.\n- [`griffe.parse_sphinx`][]: Parse a Sphinx-style docstring.\n\n## Exceptions\n\nGriffe uses several exceptions to signal errors.\n\n- [`griffe.GriffeError`][]: The base exception for all Griffe errors.\n- [`griffe.LoadingError`][]: Exception for loading errors.\n- [`griffe.NameResolutionError`][]: Exception for names that cannot be resolved in a object scope.\n- [`griffe.UnhandledEditableModuleError`][]: Exception for unhandled editables modules, when searching modules.\n- [`griffe.UnimportableModuleError`][]: Exception for modules that cannot be imported.\n- [`griffe.AliasResolutionError`][]: Exception for aliases that cannot be resolved.\n- [`griffe.CyclicAliasError`][]: Exception raised when a cycle is detected in aliases.\n- [`griffe.LastNodeError`][]: Exception raised when trying to access a next or previous node.\n- [`griffe.RootNodeError`][]: Exception raised when trying to use siblings properties on a root node.\n- [`griffe.BuiltinModuleError`][]: Exception raised when trying to access the filepath of a builtin module.\n- [`griffe.ExtensionError`][]: Base class for errors raised by extensions.\n- [`griffe.ExtensionNotLoadedError`][]: Exception raised when an extension could not be loaded.\n- [`griffe.GitError`][]: Exception raised for errors related to Git.\n\n# Expressions\n\nGriffe stores snippets of code (attribute values, decorators, base class, type annotations) as expressions.\nExpressions are basically abstract syntax trees (AST) with a few differences compared to the nodes returned by [`ast`][].\nGriffe provides a few helpers to extract expressions from regular AST nodes.\n\n- [`griffe.get_annotation`][]: Get a type annotation as expression.\n- [`griffe.get_base_class`][]: Get a base class as expression.\n- [`griffe.get_condition`][]: Get a condition as expression.\n- [`griffe.get_expression`][]: Get an expression from an AST node.\n- [`griffe.safe_get_annotation`][]: Get a type annotation as expression, safely (returns `None` on error).\n- [`griffe.safe_get_base_class`][]: Get a base class as expression, safely (returns `None` on error).\n- [`griffe.safe_get_condition`][]: Get a condition as expression, safely (returns `None` on error).\n- [`griffe.safe_get_expression`][]: Get an expression from an AST node, safely (returns `None` on error).\n\nThe base class for expressions.\n\n- [`griffe.Expr`][]\n\nExpression classes all start with `Expr`.\n\n# Loggers\n\nIf you want to log messages from extensions, get a logger with `get_logger`.\nThe `logger` attribute is used by Griffe itself. You can use it to temporarily disable Griffe logging.\n\n- [`griffe.logger`][]: Our global logger, used throughout the library.\n- [`griffe.get_logger`][]: Create and return a new logger instance.\n\n# Helpers\n\nTo test your Griffe extensions, or to load API data from code in memory, Griffe provides the following helpers.\n\n- [`griffe.temporary_pyfile`][]: Create a Python file containing the given code in a temporary directory.\n- [`griffe.temporary_pypackage`][]: Create a package containing the given modules in a temporary directory.\n- [`griffe.temporary_visited_module`][]: Create and visit a temporary module with the given code.\n- [`griffe.temporary_visited_package`][]: Create and visit a temporary package.\n- [`griffe.temporary_inspected_module`][]: Create and inspect a temporary module with the given code.\n- [`griffe.temporary_inspected_package`][]: Create and inspect a temporary package."
    },
    "exports": [
      "DEFAULT_LOG_LEVEL",
      "Alias",
      "AliasResolutionError",
      "Attribute",
      "AttributeChangedTypeBreakage",
      "AttributeChangedValueBreakage",
      "Breakage",
      "BreakageKind",
      "BuiltinModuleError",
      "Class",
      "ClassRemovedBaseBreakage",
      "CyclicAliasError",
      "DataclassesExtension",
      "Decorator",
      "DelMembersMixin",
      "Docstring",
      "DocstringAdmonition",
      "DocstringAttribute",
      "DocstringClass",
      "DocstringDeprecated",

```

Checking for API breaking changes

```
$ griffe check griffe -ssrc -b0.46.0.1.2.0 -a0.45.0.1.2.0 --verbose
src/griffe/mixins.py:303: ObjectAliasMixin.is_exported:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/mixins.py:353: ObjectAliasMixin.is_public:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/dataclasses.py:520: Object.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/diff.py:571: find_breaking_changes(ignore_private):
Parameter default was changed:
  Old: True
  New: _sentinel

src/griffe/extensions/base.py:463: load_extensions(exts):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/dataclasses.py:1073: Alias.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

```

[Playground](playground/) [Join our Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im)

# Getting started

To begin using Griffe, refer to [Installation](../installation/) and take a look at our [short introduction](../introduction/). If you'd like to experiment with Griffe without installing it, try our [playground](../playground/) directly in your browser.

If you have questions, need help, or want to contribute, feel free to reach out to the community! You can open [new discussions on GitHub](https://github.com/mkdocstrings/griffe/discussions) or join our [Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im) for a quick chat.

- [Installation](../installation/)
- [Introduction (short tour)](../introduction/)
- [Guide (advanced tour)](../guide/)
- [Getting help](../getting-help/)

# Installation

Griffe is a Python package, so you can install it with your favorite Python package installer or dependency manager.

[Griffe Insiders](../insiders/), a version with [*more features*](../insiders/#whats-in-it-for-me), is also available to sponsors

## Install as a tool & library

```
pip install griffe

```

[pip](https://pip.pypa.io/en/stable/) is the main package installer for Python.

```
pdm add griffe

```

[PDM](https://pdm-project.org/en/latest/) is an all-in-one solution for Python project management.

```
poetry add griffe

```

[Poetry](https://python-poetry.org/) is an all-in-one solution for Python project management.

```
rye add griffe

```

[Rye](https://rye.astral.sh/) is an all-in-one solution for Python project management, written in Rust.

```
uv add griffe

```

[uv](https://docs.astral.sh/uv/) is an extremely fast Python package and project manager, written in Rust.

## Install as a tool only

```
pip install --user griffe

```

[pip](https://pip.pypa.io/en/stable/) is the main package installer for Python.

```
pipx install griffe

```

[pipx](https://pipx.pypa.io/stable/) allows to install and run Python applications in isolated environments.

```
rye install griffe

```

[Rye](https://rye.astral.sh/) is an all-in-one solution for Python project management, written in Rust.

```
uv tool install griffe

```

[uv](https://docs.astral.sh/uv/) is an extremely fast Python package and project manager, written in Rust.

# Introduction

Griffe is able to read Python source code and inspect objects at runtime to extract information about the API of a Python package. This information is then stored into data models (Python classes), and these model instances together form a tree that statically represent the package's API: starting with the top-level module, then descending into submodules, classes, functions, attributes and type aliases. From there, it's possible to explore and exploit this API representation in various ways.

## Command line tool

Griffe is both a command line tool and a Python library. The command line tool offers a few commands to, for example, serialize API data to JSON and check for API breaking changes between two versions of your project.

```
# Load API of `my_package`, serialize it to JSON,
# print it to standard output.
griffe dump my_package

```

```
# Check for API breaking changes
# between current version and version 1.0 (Git reference).
griffe check my_package --against 1.0

```

Both commands accept a `-h`, `--help` argument to show all the available options. For a complete reference of the command line interface, see [Reference / Command line interface](../reference/cli/).

## Python library

As a library, Griffe exposes all its public API directly in the top-level module. It means you can simply import `griffe` to access all its API.

```
import griffe

griffe.load(...)
griffe.find_breaking_changes(...)
griffe.main(...)
griffe.visit(...)
griffe.inspect(...)

```

To start exploring your API within Griffe data models, use the load function to load your package and access its various objects:

```
import griffe

my_package = griffe.load("my_package")

some_method = my_package["some_module.SomeClass.some_method"]
print(some_method.docstring.value)
print(f"Is `some_method` public? {'yes' if some_method.is_public else 'no'}")

```

Use the load_git function to load your API at a particular moment in time, specified with a Git reference (commit hash, branch name, tag name):

```
import griffe

my_package_v2_1 = griffe.load_git("my_package", ref="2.1")

```

For more advanced usage, see our guide on [loading and navigating data](../guide/users/loading/).

For a complete reference of the application programming interface, see [Reference / Python API](../reference/api/).

# User guide

Welcome to the Griffe user guide!

## Manipulating APIs

The following topics will guide you through the various methods Griffe offers for exploring and exploiting Python APIs.

- **Loading**

  ______________________________________________________________________

  Griffe can find packages and modules to scan them statically or dynamically and extract API-related information.

  [Learn how to load data](loading/)

- **Navigating**

  ______________________________________________________________________

  Griffe exposes the extracted API information into data models, making it easy to navigate your API.

  [Learn how to navigate data](navigating/)

- **Serializing**

  ______________________________________________________________________

  Griffe can serialize your API data into JSON, for other tools to navigate or manipulate it.

  [Learn how to serialize data](serializing/)

- **Checking**

  ______________________________________________________________________

  Griffe can compare snapshots of the same API to find breaking changes.

  [Learn how to detect and handle breaking changes](checking/)

- **Extending**

  ______________________________________________________________________

  API data can be augmented or modified thanks to Griffe's extension system.

  [Learn how to write and use extensions](extending/)

## Recommendations

These topics explore the user side: how to write code to better integrate with Griffe.

- **Public API**

  ______________________________________________________________________

  See our recommendations for exposing public APIs to your users.

  [See our public API recommendations](recommendations/public-apis/)

- **Python code best practices**

  ______________________________________________________________________

  See our best practices for writing Python code.

  [See our best practices](recommendations/python-code/)

- **Docstrings**

  ______________________________________________________________________

  Griffe supports multiple docstring styles. Learn about these different styles, and see our recommendations to write docstrings.

  [See our docstring recommendations](recommendations/docstrings/)

## How-to

These how-tos will show you how to achieve specific things with Griffe.

- **Parse docstrings**

  ______________________________________________________________________

  Griffe can be used as a docstring-parsing library.

  [See how to parse docstrings](how-to/parse-docstrings/)

- **@ Support custom decorators**

  ______________________________________________________________________

  Griffe will rarely support custom decorators through static analysis, but you can easily write extensions to do so.

  [See how to support custom decorators](how-to/support-decorators/)

- **Selectively inspect objects**

  ______________________________________________________________________

  Sometimes static analysis is not enough, so you might want to use dynamic analysis (inspection) on certain objects.

  [See how to selectively inspect objects](how-to/selectively-inspect/)

- **Set objects' docstring style**

  ______________________________________________________________________

  Sometimes the wrong docstring styles are attached to objects. You can fix this with a few different methods.

  [See how to set the correct docstring styles on objects](how-to/set-docstring-styles/)

# Loading APIs

Griffe can load API data from both source code (static analysis) and objects at runtime through introspection (dynamic analysis). Both static and dynamic analysis can be used at the same time: Griffe will first try to find sources, and will fall back to introspection if it cannot find any. When Griffe finds compiled modules within a packages, it uses introspection again to extract API information. There are various options to configure how Griffe loads data, for example to force or disallow dynamic analysis, but first let see the interface.

## The `load` function

The main interface to load API data is Griffe's load function:

```
import griffe

my_package = griffe.load("my_package")

```

You can ask to load a specific object rather than a package:

```
import griffe

my_method = griffe.load("my_package.MyClass.my_method")

```

Griffe will load the whole package anyway, but return the specified object directly, so that you don't have to access it manually. To manually access the object representing the method called `my_method`, you would have used the `my_package` variable instantiated before, like this:

```
my_method = my_package["MyClass.my_method"]

```

The [Navigating](../navigating/) topic will show you all the ways Griffe objects can be navigated.

Finally, you can even load packages or modules by passing absolute or relative file paths. This is useful when the module or package is not installed within the current Python environment and therefore cannot be found in the default search paths (see [Search paths](#search-paths) below).

```
import griffe

griffe.load("src/my_package")
griffe.load("some_script.py")

```

In case of ambiguity, you can instruct Griffe to ignore existing relative file paths with `try_relative_paths=False`. For example, when using [the flat layout (in contrast to the src-layout)](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/), your Python package is in the root of the repository.

```
📁 ./
├── 📁 my_package/
│   └──  __init__.py
└──  pyproject.toml

```

Here if you ask Griffe to load `my_package`, it will find it as a relative path, in `./my_package`. If you want Griffe to use the version installed in your environment's site packages instead, set `try_relative_path` to false:

```
import griffe

my_installed_package = griffe.load("my_package", try_relative_path=False)

```

## The `GriffeLoader` class

The load function is a shortcut for instantiating the GriffeLoader class and calling its load method. Calling the load function multiple times will instantiate a new Griffe loader each time. If you care about efficiency, it is better to instantiate the loader yourself and use its `load` method:

```
import griffe

loader = GriffeLoader()
my_package = loader.load("my_package")
my_other_package = loader.load("my_other_package")

```

Keeping a reference to the loader will reduce the number of IO operations on the file-system, as the contents of the directories that the loader searches into will be cached (only the lists of files and directories will be cached, not the file contents).

Reusing the same loader will also help resolving aliases across different packages. See [Alias resolution](#alias-resolution) below.

## Search paths

To specify in which directories Griffe should search for packages and modules, you can use the `search_paths` parameter on both the load function and the GriffeLoader class.

```
import griffe

my_package = griffe.load("my_package", search_paths=["src"])

```

```
import griffe

loader = GriffeLoader(search_paths=["src"])
my_package = loader.load("my_package")

```

By default it will search in the paths found in sys.path, which can be influenced through the PYTHONPATH environment variable.

If Griffe cannot find sources for the specified object in the given search paths, it will try to import the specified object and use dynamic analysis on it (introspection). See [Forcing dynamic analysis](#forcing-dynamic-analysis) and [Disallowing dynamic analysis](#disallowing-dynamic-analysis).

## Forcing dynamic analysis

Griffe always tries first to find sources for the specified object. Then, unless told otherwise, it uses static analysis to load API data, i.e. it parses the sources and visits the AST (Abstract Syntax Tree) to extract information. If for some reason you want Griffe to use dynamic analysis instead (importing and inspecting runtime objects), you can pass the `force_inspection=True` argument:

```
import griffe

my_package = griffe.load("my_package", force_inspection=True)

```

Forcing inspection can be useful when your code is highly dynamic, and static analysis has trouble keeping up.

**However we don't recommend forcing inspection**, for a few reasons:

- dynamic analysis requires that you either mock your dependencies, or install them
- dynamic analysis will **execute code**, possibly ***arbitrary code*** if you import third-party dependencies, putting you at risk
- dynamic analysis will potentially consume more resources (CPU, RAM) since it executes code
- dynamic analysis will sometimes give you less precise or incomplete information
- it's possible to write Griffe extensions that will *statically handle* the highly dynamic parts of your code (like custom decorators) that Griffe doesn't understand by default
- if really needed, it's possible to [handle only a subset of objects with dynamic analysis](../how-to/selectively-inspect/), while the rest is loaded with static analysis, again thanks to Griffe extensions

The [Extending](../extending/) topic will explain how to write and use extensions for Griffe.

## Disallowing dynamic analysis

If you want to be careful about what gets executed in the current Python process, you can choose to disallow dynamic analysis by passing the `allow_inspection=False` argument. If Griffe cannot find sources for a package, it will not try to import it and will instead fail with a `ModuleNotFoundError` directly.

```
import griffe

# Here Griffe will fall back on dynamic analysis and import `itertools`.
griffe.load("itertools")

# While here it will raise `ModuleNotFoundError`.
griffe.load("itertools", allow_inspection=False)

```

## Alias resolution

What's that?

In Griffe, indirections to objects are called *aliases*. These indirections, or aliases, represent two kinds of objects: imported objects and inherited objects. Indeed, an imported object is "aliased" in the module that imports it, while its true location is in the module it was imported from. Similarly, a method inherited from a parent class is "aliased" in the subclass, while its true location is in the parent class.

The name "alias" comes from the fact that imported objects can be aliased under a different name: `from X import A as B`. In the case of inherited members, this doesn't really apply, but we reuse the concept for conciseness.

An Alias instance is therefore a pointer to another object. It has its own name, parent, line numbers, and stores the path to the target object. Thanks to this path, we can access the actual target object and all its metadata, such as name, parent, line numbers, docstring, etc.. Obtaining a reference to the target object is what we call "alias resolution".

**To summarize, alias resolution is a post-process task that resolves imports after loading everything.**

To resolve an alias, i.e. obtain a reference to the object it targets, we have to wait for this object to be loaded. Indeed, during analysis, objects are loaded in breadth-first order (in the object hierarchy, highest objects are loaded first, deepest ones are loaded last), so when we encounter an imported object, we often haven't loaded this object yet.

Once a whole package is loaded, we are ready to try and resolve all aliases. But we don't *have* to resolve them. First, because the user might not need aliases to be resolved, and second, because each alias can be resolved individually and transparently when accessing its target object properties.

Therefore, alias resolution is optional and enabled with the `resolve_aliases` parameter.

Lets take an example.

File layout

```
📁 ./
└── 📁 my_package/
    ├──  __init__.py
    └──  my_module.py

```

my_package/__init__.py

```
from my_package.my_module import my_function

```

my_package/my_module.py

```
def my_function():
    print("hello")

```

When loading this package, `my_package.my_function` will be an alias pointing at `my_package.my_module.my_function`:

```
import griffe

my_package = griffe.load("my_package")
my_package["my_function"].resolved  # False

```

```
import griffe

my_package = griffe.load("my_package", resolve_aliases=True)
my_package["my_function"].resolved  # True
my_package["my_function"].target is my_package["my_module.my_function"]  # True

```

The [Navigating](../navigating/) topic will tell you more about aliases and how they behave.

### Modules collection

In the first section of this page, we briefly mentioned that Griffe always loads the entire package containing the object you requested. One of the reasons it always loads entire packages and not just single, isolated objects, is that alias resolution requires all objects of a package to be loaded. Which means that if an alias points to an object that is part of *another* package, it can only be resolved if the *other* package is *also loaded*. For example:

File layout

```
📁 ./
├── 📁 package1/
│   └──  __init__.py
└── 📁 package2/
    └──  __init__.py

```

package1/__init__.py

```
X = 0

```

package2/__init__.py

```
from package1 import X

```

```
>>> import griffe
>>> package2 = griffe.load("package2", resolve_aliases=True)
>>> package2["X"].target_path
'package1.X'
>>> package2["X"].resolved
False
>>> package2["X"].target
Traceback (most recent call last):
  File "griffe/_internal/models.py", line 1375, in _resolve_target
    resolved = self.modules_collection.get_member(self.target_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "griffe/_internal/mixins.py", line 84, in get_member
    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]
           ~~~~~~~~~~~~^^^^^^^^^^
KeyError: 'package1'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "griffe/_internal/dataclasses.py", line 1310, in target
    self.resolve_target()
  File "griffe/_internal/dataclasses.py", line 1369, in resolve_target
    self._resolve_target()
  File "griffe/_internal/dataclasses.py", line 1377, in _resolve_target
    raise AliasResolutionError(self) from error
griffe._internal.exceptions.AliasResolutionError: Could not resolve alias package2.X pointing at package1.X (in package2/__init__.py:1)

```

As you can see in the interpreter session above, Griffe did not resolve the `X` alias. When we tried to access its target object anyway, it failed with a `KeyError`, which was raised again as an AliasResolutionError.

Lets try again, but this time by loading both packages.

```
>>> import griffe
>>> package1 = griffe.load("package1")  # nothing to resolve
>>> package2 = griffe.load("package2", resolve_aliases=True)
>>> package2["X"].target_path
'package1.X'
>>> package2["X"].resolved
False  # Hmm?
>>> package2["X"].target
Traceback (most recent call last):
...
griffe._internal.exceptions.AliasResolutionError: Could not resolve alias package2.X pointing at package1.X (in package2/__init__.py:1)

```

The same exception again? What happened here? We loaded both packages, but Griffe still failed to resolve the alias. That is expected; here is the explanation.

If you look closely at the first exception traceback, you will see that Griffe searched the target path in `self.modules_collection`. So what is this modules collection?

Each instance of GriffeLoader holds a reference to an instance of ModulesCollection. If you don't create such a collection manually to pass it to the loader, it will instantiate one itself. All objects loaded with this loader are added to this very modules collection, and gain a reference to it.

Since the load function is just a shortcut for creating a loader and calling its load method, when we called `griffe.load(...)` twice, it actually created two distinct collections of modules. When Griffe tried to resolve aliases of `package2`, it looked for `package1` in `package2`'s collection, and couldn't find it. Indeed, `package1` was in another modules collection.

Therefore, to resolve aliases *across different packages*, these packages must be loaded within the same modules collection. In order to do that, you have a few options:

- instantiate a single loader, and use it to load both packages
- create your own modules collection, and pass it to the load function each time you call it
- create your own modules collection, and pass it to the different instances of GriffeLoader you create

```
>>> import griffe
>>> loader = griffe.GriffeLoader()
>>> package1 = loader.load("package1")
>>> package2 = loader.load("package2")
>>> loader.resolve_aliases()
>>> package2["X"].resolved
True
>>> package2["X"].target
Attribute('X', lineno=1, endlineno=1)

```

```
>>> import griffe
>>> collection = griffe.ModulesCollection()
>>> package1 = griffe.load("package1", modules_collection=collection)
>>> package2 = griffe.load("package2", modules_collection=collection, resolve_aliases=True)
>>> package2["X"].resolved
True
>>> package2["X"].target
Attribute('X', lineno=1, endlineno=1)

```

```
>>> import griffe
>>> collection = griffe.ModulesCollection()
>>> loader1 = griffe.GriffeLoader(modules_collection=collection, ...)
>>> package1 = loader1.load("package1")
>>> loader2 = griffe.GriffeLoader(modules_collection=collection, ...)  # different parameters
>>> package2 = loader2.load("package2")
>>> package2["X"].resolved
True
>>> package2["X"].target
Attribute('X', lineno=1, endlineno=1)

```

There is no preferred way, it depends on whether you need to instantiate different loaders with different parameters (search paths for example) while keeping every loaded module in the same collection, or if a single loader is enough, or if you explicitly need a reference to the collection, etc..

### Loading external packages automatically

By default, when resolving aliases, Griffe loaders will not be able to resolve aliases pointing at objects from "external" packages. By external, we mean that these packages are external to the current modules collection: they are not loaded. But sometimes users don't know in advance which packages need to be loaded in order to resolve aliases (and compute class inheritance). For these cases, Griffe loaders can be instructed to automatically load external packages. If we take the previous example again:

```
import griffe

package2 = griffe.load("package2", resolve_aliases=True, resolve_external=True)
print(package2["X"].target.name)  # X

```

Here Griffe automatically loaded `package1` while resolving aliases, even though we didn't explicitly load it ourselves.

While automatically resolving aliases pointing at external packages can be convenient, we advise cautiousness: this can trigger the loading of *a lot* of external packages, *recursively*.

One special case that we must mention is that Griffe will by default automatically load *private sibling packages*. For example, when resolving aliases for the `ast` module, Griffe will automatically try and load `_ast` too (if dynamic analysis is allowed, since this is a builtin module), even without `resolve_external=True`. If you want to prevent this behavior, you can pass `resolve_external=False` (it is `None` by default).

## Next steps

Now that the API is loaded, you can start [navigating it](../navigating/), [serializing it](../serializing/) or [checking for API breaking changes](../checking/). If you find out that the API data is incorrect or incomplete, you might want to learn how to [extend it](../extending/).

# Navigating APIs

Griffe loads API data into data models. These models provide various attributes and methods to access or update specific fields. The different models are:

- Module, representing Python modules;
- Class, representing Python classes;
- Function, representing Python functions and class methods;
- Attribute, representing object attributes that weren't identified as modules, classes or functions;
- Type Alias, representing Python type aliases;
- Alias, representing indirections such as imported objects or class members inherited from parent classes.

When [loading an object](../loading/), Griffe will give you back an instance of one of these models. A few examples:

```
>>> import griffe
>>> type(griffe.load("markdown"))
<class 'griffe._internal.models.Module'>
>>> type(griffe.load("markdown.core.Markdown"))
<class 'griffe._internal.models.Class'>
>>> type(griffe.load("markdown.Markdown"))
<class 'griffe._internal.models.Alias'>
>>> type(griffe.load("markdown.core.markdown"))
<class 'griffe._internal.models.Function'>
>>> type(griffe.load("markdown.markdown"))
<class 'griffe._internal.models.Alias'>
>>> type(griffe.load("markdown.Markdown.references"))
<class 'griffe._internal.models.Attribute'>

```

However deep the object is, Griffe loads the entire package. It means that in all the cases above, Griffe loaded the whole `markdown` package. The model instance Griffe gives you back is therefore part of a tree that you can navigate.

## Moving up: parents

Each object holds a reference to its parent (except for the top-level module, for which the parent is `None`). Shortcuts are provided to climb up directly to the parent module, or the top-level package. As we have seen in the [Loading chapter](../loading/), Griffe stores all loaded modules in a modules collection; this collection can be accessed too, through the modules_collection attribute.

## Moving down: members

To access an object's members, there are a few options:

- Access to regular members through the members attribute, which is a dictionary. The keys are member names, the values are Griffe models.

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown.members["Markdown"]
  Alias('Markdown', 'markdown.core.Markdown')
  >>> markdown.members["core"].members["Markdown"]
  Class('Markdown', 46, 451)

  ```

- Access to both regular and inherited members through the all_members attribute, which is a dictionary again. See [Inherited members](#inherited-members).

- Convenient dictionary-like item access, thanks to the subscript syntax `[]`. With this syntax, you will not only be able to chain accesses, but also merge them into a single access by using dot-separated paths to objects:

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown["core"]["Markdown"]  # chained access
  Class('Markdown', 46, 451)
  >>> markdown["core.Markdown"]  # merged access
  Class('Markdown', 46, 451)

  ```

  The dictionary-like item access also accepts tuples of strings. So if for some reason you don't have a string equal to `"core.Markdown"` but a tuple equal to `("core", "Markdown")` (for example obtained from splitting another string), you can use it too:

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown[("core", "Markdown")]  # tuple access
  Class('Markdown', 46, 451)
  >>> # Due to the nature of the subscript syntax,
  >>> # you can even use implicit tuples.
  >>> markdown["core", "Markdown"]
  Class('Markdown', 46, 451)

  ```

- Less convenient, but safer access to members while the object tree is being built (while a package is still being loaded), using the get_member() method.

  ```
  >>> import griffe
  >>> markdown = griffe.load("markdown")
  >>> markdown.get_member("core.Markdown")
  Class('Markdown', 46, 451)

  ```

  In particular, Griffe extensions should always use `get_member` instead of the subscript syntax `[]`. The `get_member` method only looks into regular members, while the subscript syntax looks into inherited members too (for classes), which cannot be correctly computed until a package is fully loaded (which is generally not the case when an extension is running).

- In addition to this, models provide the attributes, functions, classes, type_aliases or modules attributes, which return only members of the corresponding kind. These attributes are computed dynamically each time (they are Python properties).

The same way members are accessed, they can also be set:

- Dictionary-like item assignment: `markdown["thing"] = ...`, also supporting dotted-paths and string tuples. This will (re)assign only regular members: inherited members (classes only) are re-computed everytime they are accessed.
- Safer method for extensions: `markdown.set_member("thing", ...)`, also supporting dotted-paths and string tuples.
- Regular member assignment: `markdown.members["thing"] = ...`. **This is not recommended, as the assigned member's `parent` attribute will not be automatically updated.**

...and deleted:

- Dictionary-like item deletion: `del markdown["thing"]`, also supporting dotted-paths and string tuples. This will delete only regular members: inherited members (classes only) are re-computed everytime they are accessed.
- Safer method for extensions: `markdown.del_member("thing")`, also supporting dotted-paths and string tuples.
- Regular member deletion: `del markdown.members["thing"]`. **This is not recommended, as the aliases attribute of other objects in the tree will not be automatically updated.**

### Inherited members

Griffe supports class inheritance, both when visiting and inspecting modules.

To access members of a class that are inherited from base classes, use the inherited_members attribute. Everytime you access inherited members, the base classes of the given class will be resolved, then the MRO (Method Resolution Order) will be computed for these base classes, and a dictionary of inherited members will be built. Make sure to store the result in a variable to avoid re-computing it everytime (you are responsible for the caching part). Also make sure to only access `inherited_members` once everything is loaded by Griffe, to avoid computing things too early. Don't try to access inherited members in extensions, while visiting or inspecting modules.

Inherited members are aliases that point at the corresponding members in parent classes. These aliases will have their inherited attribute set to true.

**Important:** only classes from already loaded packages will be used when computing inherited members. This gives users control over how deep into inheritance to go, by pre-loading packages from which you want to inherit members. For example, if `package_c.ClassC` inherits from `package_b.ClassB`, itself inheriting from `package_a.ClassA`, and you want to load `ClassB` members only:

```
import griffe

loader = griffe.GriffeLoader()
# note that we don't load package_a
loader.load("package_b")
loader.load("package_c")

```

If a base class cannot be resolved during computation of inherited members, Griffe logs a DEBUG message.

If you want to access all members at once (both declared and inherited), use the all_members attribute. If you want to access only declared members, use the members attribute.

Accessing the attributes, functions, classes, type_aliases or modules attributes will trigger inheritance computation, so make sure to only access them once everything is loaded by Griffe. Don't try to access inherited members in extensions, while visiting or inspecting modules.

#### Limitations

Currently, there are three limitations to our class inheritance support:

1. when visiting (static analysis), some objects are not yet properly recognized as classes, for example named tuples. If you inherit from a named tuple, its members won't be added to the inherited members of the inheriting class.

   ```
   MyTuple = namedtuple("MyTuple", "attr1 attr2")


   class MyClass(MyTuple):
       ...

   ```

1. when visiting (static analysis), subclasses using the same name as one of their parent classes will prevent Griffe from computing the MRO and therefore the inherited members. To circumvent that, give a different name to your subclass:

   ```
   from package import SomeClass


   # instead of
   class SomeClass(SomeClass):
       ...


   # do
   class SomeOtherClass(SomeClass):
       ...

   ```

1. when inspecting (dynamic analysis), ephemeral base classes won't be resolved, and therefore their members won't appear in child classes. To circumvent that, assign these dynamic classes to variables:

   ```
   # instead of
   class MyClass(namedtuple("MyTuple", "attr1 attr2")):
       ...


   # do
   MyTuple = namedtuple("MyTuple", "attr1 attr2")


   class MyClass(MyTuple):
       ...

   ```

We will try to lift these limitations in the future.

## Aliases

Aliases represent indirections, such as objects imported from elsewhere, attributes, or methods inherited from parent classes. They are pointers to the object they represent. The path of the object they represent is stored in their target_path attribute. Once they are resolved, the target object can be accessed through their target attribute.

Aliases can be found in objects' members. Each object can also access its own aliases (the aliases pointing at it) through its aliases attribute. This attribute is a dictionary whose keys are the aliases paths and values are the aliases themselves.

Most of the time, aliases simply act as proxies to their target objects. For example, accessing the `docstring` of an alias will simply return the docstring of the object it targets.

Accessing fields on aliases will trigger their resolution. If they are already resolved (their `target` attribute is set to the target object), the field is returned. If they are not resolved, their target path will be looked up in the modules collection, and if it is found, the object at this location will be assigned to the alias' `target` attribute. If it isn't found, an AliasResolutionError exception will be raised.

Since merely accessing an alias field can raise an exception, it is often useful to check if an object is an alias before accessing its fields. There are multiple ways to check if an object is an alias:

- using the `is_alias` boolean (Object.is_alias, Alias.is_alias), which won't trigger resolution
- using `isinstance` to check if the object is an instance of Alias

```
>>> import griffe
>>> load = griffe.load("griffe.load")
>>> load.is_alias
True
>>> isinstance(load, griffe.Alias)
True

```

The kind of an alias will only return ALIAS if the alias is not resolved and cannot be resolved within the current modules collection.

You can of course also catch any raised exception with a regular try/except block:

```
try:
    print(obj.source)
except griffe.AliasResolutionError:
    pass

```

To check if an alias is already resolved, you can use its resolved attribute.

### Alias chains

Aliases can be chained. For example, if module `a` imports `X` from module `b`, which itself imports `X` from module `c`, then `a.X` is an alias to `b.X` which is an alias to `c.X`: `a.X` -> `b.X` -> `c.X`. To access the final target directly, you can use the final_target attribute. Most alias properties that act like proxies actually fetch the final target rather than the next one to return the final field.

Sometimes, when a package makes use of complicated imports (wildcard imports from parents and submodules), or when runtime objects are hard to inspect, it is possible to end up with a cyclic chain of aliases. You could for example end up with a chain like `a.X` -> `b.X` -> `c.X` -> `a.X`. In this case, the alias *cannot* be resolved, since the chain goes in a loop. Griffe will raise a CyclicAliasError when trying to resolve such cyclic chains.

Aliases chains are never partially resolved: either they are resolved down to their final target, or none of their links are resolved.

## Object kind

The kind of an object (module, class, function, attribute, type alias or alias) can be obtained in several ways.

- With the kind attribute and the Kind enumeration: `obj.kind is Kind.MODULE`.

- With the is_kind() method:

  - `obj.is_kind(Kind.MODULE)`
  - `obj.is_kind("class")`
  - `obj.is_kind({"function", Kind.ATTRIBUTE})`

  When given a set of kinds, the method returns true if the object is of one of the given kinds.

- With the is_module, is_class, is_function, is_attribute, is_type_alias, and is_alias attributes.

Additionally, it is possible to check if an object is a sub-kind of module, with the following attributes:

- is_init_module, for `__init__.py` modules
- is_package, for top-level packages
- is_subpackage, for non-top-level packages
- is_namespace_package, for top-level [namespace packages](https://packaging.python.org/en/latest/guides/packaging-namespace-packages/)
- is_namespace_subpackage, for non-top-level namespace packages

Finally, additional labels are attached to objects to further specify their kind. The has_labels() method can be used to check if an object has several specific labels.

## Object location

An object is identified by its path, which is its location in the object tree. The path is composed of all the parent names and the object name, separated by dots, for example `mod.Class.meth`. This `path` is the canonical_path on regular objects. For aliases however, the `path` is *where they are imported* while the canonical path is *where they come from*. Example:

```
# pkg1.py
from pkg2 import A as B

```

```
>>> import griffe
>>> B = griffe.load("pkg1.B")
>>> B.path
'pkg1.B'
>>> B.canonical_path
'pkg2.A'

```

### Source

Information on the actual source code of objects is available through the following attributes:

- filepath, the absolute path to the module the object appears in, for example `~/project/src/pkg/mod.py`
- relative_filepath, the relative path to the module, compared to the current working directory, for example `src/pkg/mod.py`
- relative_package_filepath, the relative path to the module, compared to the parent of the top-level package, for example `pkg/mod.py`
- lineno and endlineno, the starting and ending line numbers of the object in the source
- lines, the lines of code defining the object (or importing the alias)
- source, the source lines concatenated as a single multiline string

Each object holds a reference to a lines_collection. Similar to the modules collection, this lines collection is a dictionary whose keys are module file-paths and values are their contents as list of lines. The lines collection is populated by the loader.

## Object visibility

Each object has fields that are related to their visibility within the API.

- is_public: whether this object is public (destined to be consumed by your users). For module-level objects, Griffe considers that the object is public if:

  - it is listed in its parent module's `__all__` attribute
  - or if its parent module does not declare `__all__`, and the object doesn't have a private name, and the object is not imported from elsewhere

  ```
  # package1/__init__.py
  from package2 import A  # not public
  from package1 import submodule  # not public

  b = 0  # public
  _c = 1  # not public
  __d = 2  # not public

  def __getattr__(name: str):  # public
      ...

  ```

  For class-level objects, Griffe considers that the object is public if the object doesn't have a private name, and the object is not imported from elsewhere.

  ```
  # package1/__init__.py
  class A:
      from package1.module import X  # not public
      from package2 import Y  # not public

      b = 0  # public
      _c = 1  # not public
      __d = 2  # not public

      def __eq__(self, other):  # public
          ...

  ```

- is_deprecated: whether this object is deprecated and shouldn't be used.

- is_special: whether this object has a special name like `__special__`

- is_private: whether this object has a private name like `_private` or `__private`, but not `__special__`

- is_class_private: whether this object has a class-private name like `__private` and is a member of a class

Since `is_private` only checks the name of the object, it is not mutually exclusive with `is_public`. It means an object can return true for both `is_public` and `is_private`. We invite Griffe users to mostly rely on `is_public` and `not is_public`.

It is possible to force `is_public` and `is_deprecated` to return true or false by setting the public and deprecated fields respectively. These fields are typically set by extensions that support new ways of marking objects as public or deprecated.

## Imports/exports

Modules and classes populate their imports field with names that were imported from other modules. Similarly, modules populate their exports field with names that were exported by being listed into the module's `__all__` attribute. Each object then provides then is_imported and is_exported fields, which tell if an object was imported or exported respectively. Additionally, objects also provide an is_wildcard_exposed field that tells if an object is exposed to wildcard imports, i.e. will be imported when another module does `from this_module import *`.

## Docstrings

Each object has an optional docstring attached to it. To check whether it has one without comparing against `None`, the two following fields can be used:

- has_docstring: whether this object has a docstring (even empty)
- has_docstrings: same thing, but recursive; whether this object or any of its members has a docstring (even empty)

Docstrings provide their cleaned-up value (de-indented string, stripped from leading and trailing newlines), as well as their starting and ending line numbers with lineno and endlineno.

Docstrings can be parsed against several [docstring-styles](../../../reference/docstrings/), which are micro-formats that allow documenting things such as parameters, returned values, raised exceptions, etc..

When loading a package, it is possible to specify the docstring style to attach to every docstring (see the `docstring_parser` parameter of griffe.load). Accessing the parsed field of a docstring will use this style to parse the docstring and return a list of docstring sections. Each section has a `value` whose shape depends on the section kind. For example, parameter sections have a list of parameter representations as value, while a text section only has a string as value.

After a package is loaded, it is still possible to change the style used for specific docstrings by either overriding their parser and parser_options attributes, or by calling their parse() method with a different style:

```
>>> import griffe
>>> markdown = griffe.load("markdown", docstring_parser="google")
>>> markdown["Markdown"].docstring.parse("numpy")
[...]

```

Do note, however, that the `parsed` attribute is cached, and won't be reset when overriding the `parser` or `parser_options` values.

Docstrings have a parent field too, that is a reference to their respective module, class, function, attribute or type alias.

## Model-specific fields

Models have most fields in common, but also have specific fields.

### Modules

- imports_future_annotations: Whether the module imports [future annotations](https://peps.python.org/pep-0563/), which changes the way we parse type annotations.
- overloads: A dictionary to store overloads for module-level functions.

### Classes

- bases: A list of class bases in the form of expressions.
- resolved_bases: A list of class bases, in the form of Class objects. Only the bases that were loaded are returned, the others are discarded.
- mro(): A method to compute the Method Resolution Order in the form of a list of Class objects.
- overloads: A dictionary to store overloads for class-level methods.
- decorators: The decorators applied to the class.
- parameters: The parameters of the class' `__init__` method, if any.
- type_parameters: The type parameters of the class.

### Functions

- decorators: The decorators applied to the function.
- overloads: The overloaded signatures of the function.
- parameters: The parameters of the function.
- returns: The type annotation of the returned value, in the form of an expression. The `annotation` field can also be used, for compatibility with attributes.
- type_parameters: The type parameters of the function.

### Attributes

- annotation: The type annotation of the attribute, in the form of an expression.
- value: The value of the attribute, in the form of an expression.
- deleter: The property deleter.
- setter: The property setter.

### Type aliases

- value: The value of the type alias, in the form of an expression.
- type_parameters: The type parameters of the type alias.

### Alias

- alias_lineno: The alias line number (where the object is imported).
- alias_endlineno: The alias ending line number (where the object is imported).
- target: The alias target (a module, class, function or attribute).
- target_path: The path of the alias target, as a string.
- wildcard: Whether this alias represents a wildcard import, and if so from which module.
- resolve_target(): A method that resolves the target when called.

## Expressions

When parsing source code, Griffe builds enhanced ASTs for type annotations, decorators, parameter defaults, attribute values, etc.

These "expressions" are very similar to what Python's ast module gives you back when parsing source code, with a few differences: attributes like `a.b.c.` are flattened, and names like `a` have a parent object attached to them, a Griffe object, allowing to resolve this name to its full path given the scope of its parent.

You can write some code below and print annotations or attribute values with [Rich](https://rich.readthedocs.io/en/stable/)'s pretty printer to see how expressions look like.

Editor (session: default) Run

```
from griffe import temporary_visited_module
from rich.pretty import pprint

code = """
    from dataclasses import dataclass
    from random import randint

    @dataclass
    class Bar:
        baz: int

    def get_some_baz() -> int:
        return randint(0, 10)

    foo: Bar = Bar(baz=get_some_baz())
"""        

with temporary_visited_module(code) as module:
    pprint(module["foo"].annotation)
    pprint(module["foo"].value)
```

Output Clear

Ultimately, these expressions are what allow downstream tools such as [mkdocstrings' Python handler](https://mkdocstrings.github.io/python) to render cross-references to every object it knows of, coming from the current code base or loaded from object inventories (objects.inv files).

During static analysis, these expressions also allow analyzing decorators, dataclass fields, and many more things in great detail, and in a robust manner, to build third-party libraries support in the form of [Griffe extensions](../extending/).

To learn more about expressions, read their [API reference](../../../reference/api/expressions/).

### Modernization

[Sponsors only](../../../insiders/) — [Insiders 1.2.0](../../../insiders/changelog/#1.2.0)

The Python language keeps evolving, and often library developers must continue supporting a few minor versions of Python. Therefore they cannot use some features that were introduced in the latest versions.

Yet this doesn't mean they can't enjoy latest features in their own docs: Griffe allows to "modernize" expressions, for example by replacing `typing.Union` with PEP 604 type unions `|`. Thanks to this, downstream tools like [mkdocstrings](https://mkdocstrings.github.io/python) can automatically transform type annotations into their modern equivalent. This improves consistency in your docs, and shows users how to use your code with the latest features of the language.

To modernize an expression, simply call its modernize() method. It returns a new, modernized expression. Some parts of the expression might be left unchanged, so be careful if you decide to mutate them.

Modernizations applied:

- `typing.Dict[A, B]` becomes `dict[A, B]`
- `typing.List[A]` becomes `list[A]`
- `typing.Set[A]` becomes `set[A]`
- `typing.Tuple[A]` becomes `tuple[A]`
- `typing.Union[A, B]` becomes `A | B`
- `typing.Optional[A]` becomes `A | None`

## Next steps

In this chapter we saw many of the fields that compose our models, and how and why to use them. Now you might be interested in [extending](../extending/) or [serializing](../serializing/) the API data, or [checking for API breaking changes](../checking/).

# Serializing APIs

Griffe can be used to load API data and output it as JSON on standard output or in writable files. An example of what real data looks like can be found here: [Griffe's full JSON dump](../../../griffe.json). We also provide a [JSON schema](../../../schema.json).

## Command-line

The easiest way to load and serialize API data is to use the command-line tool:

```
$ griffe dump httpx fastapi
{
  "httpx": {
    "name": "httpx",
    ...
  },
  "fastapi": {
    "name": "fastapi",
    ...
  }
}

```

It will output a JSON-serialized version of the package's API data.

Try it out on Griffe itself:

```
$ griffe dump griffe
{
  "griffe": {
    "name": "griffe",
    ...
  }
}

```

To output in a file instead of standard output, use the `-o`, `--output` option:

```
$ griffe dump griffe -o griffe.json

```

If you load multiple packages' signatures, you can dump each in its own file with a templated filepath:

```
$ griffe dump griffe -o './dumps/{package}.json'

```

By default, Griffe will search in `sys.path`, so if you installed it through *pipx*, there are few chances it will find your packages. To explicitly specify search paths, use the `-s, --search <PATH>` option. You can use it multiple times. You can also add the search paths to the `PYTHONPATH` environment variable. If Griffe can't find the packages, it will fail with a `ModuleNotFoundError`.

See all the options for the `dump` command in the [CLI reference](../../../reference/cli/).

## Python API

If you have read through the [Navigating](../navigating/) chapter, you know about our six data models for modules, classes, functions, attributes, type aliases and aliases. Each one of these model provide the two following methods:

- as_json, which allows to serialize an object into JSON,
- from_json, which allows loading JSON back into a model instance.

These two methods are convenient wrappers around our JSON encoder and JSON decoder. The JSON encoder and decoder will give you finer-grain control over what you serialize or load, as the methods above are only available on data models, and not on sub-structures like decorators or parameters.

Under the hood, `as_json` just calls as_dict, which converts the model instance into a dictionary, and then serializes this dictionary to JSON.

When serializing an object, by default the JSON will only contain the fields required to load it back to a Griffe model instance. If you are not planning on loading back the data into our data models, or if you want to load them in a different implementation which is not able to infer back all the other fields, you can choose to serialize every possible field. We call this a full dump, and it is enabled with the `full` option of the encoder or the as_json method.

## Schema

For anything automated, we suggest relying on our [JSON schema](../../../schema.json).

When serializing multiple packages with the `dump` command, you get a map with package names as keys. Map values are the serialized objects (modules, classes, functions, etc.). They are maps too, with field names and values as key-value pairs.

For example:

```
{
  "kind": "class",
  "name": "Expr",
  "lineno": 82,
  "endlineno": 171,
  "docstring": {
    "value": "Base class for expressions.",
    "lineno": 84,
    "endlineno": 84
  },
  "labels": [
    "dataclass"
  ],
  "members": [
    ...
  ],
  "bases": [],
  "decorators": [
    {
      "value": {
        "name": "dataclass",
        "cls": "ExprName"
      },
      "lineno": 82,
      "endlineno": 82
    }
  ]
}

```

The `members` value, truncated here, just repeats the pattern: it's an array of maps. We use an array for members instead of a map to preserve order, which could be important to downstream tools.

The other fields do not require explanations, except maybe for expressions. You will sometimes notice deeply nested structures with `cls` keys. These are serialized Griffe [expressions](../../../reference/api/expressions/). They represent actual code.

## Next steps

That's it! There is not much to say about serialization. We are interested in getting your feedback regarding serialization as we didn't see it being used a lot. Next you might be interested in learning how to [check](../checking/) or [extend](../extending/) your API data.

# Checking APIs

Griffe is able to compare two snapshots of your project to detect API breakages between the old and the new snapshot. By snapshot we mean a specific point in your Git history. For example, you can ask Griffe to compare your current code against a specific tag.

## Command-line

### Using Git

By default, Griffe will compare the current code to the latest tag:

```
$ griffe check mypackage

```

To specify another Git reference to check against, use the `--against` or `-a` option:

```
$ griffe check mypackage -a 0.2.0

```

You can specify a Git tag, commit (hash), or even a branch: Griffe will create a worktree at this reference in a temporary directory, and clean it up after finishing.

If you want to also specify the *base* reference to use (instead of the current code), use the `--base` or `-b` option. Some examples:

```
$ griffe check mypackage -b HEAD -a 2.0.0
$ griffe check mypackage -b 2.0.0 -a 1.0.0
$ griffe check mypackage -b fix-issue-90 -a 1.2.3 
$ griffe check mypackage -b 8afcfd6e 

```

Important:

Remember that the base is the most recent reference, and the one we compare it against is the oldest one.

The package name you pass to `griffe check` must be found relative to the repository root. For Griffe to find packages in subfolders, pass the parent subfolder to the `--search` or `-s` option. Example for `src`-layouts:

```
$ griffe check -s src griffe

```

Example in a monorepo, within a deeper file tree:

```
$ griffe check -s back/services/identity-provider/src identity_provider

```

### Using PyPI

[Sponsors only](../../../insiders/) — [Insiders 1.1.0](../../../insiders/changelog/#1.1.0)

It's also possible to directly **check packages from PyPI.org** (or other indexes configured through `PIP_INDEX_URL`). This feature is [available to sponsors only](../../../insiders/) and requires that you install Griffe with the `pypi` extra:

```
$ pip install griffe[pypi]

```

The command syntax is:

```
$ griffe check package_name -b project-name==2.0 -a project-name==1.0

```

You can let Griffe guess the package name by passing an empty string:

```
$ griffe check "" -b project-name==2.0 -a project-name==1.0

```

[PEP 508 version specifiers](https://peps.python.org/pep-0508/) are supported (`<`, `<=`, `!=`, `==`, `>=`, `>`, `~=`). For example, to compare v2 against the version just before it:

```
$ griffe check "" -b project-name==2.0 -a project-name<2.0

```

Without a version specifier on the base reference, or without a base reference at all, Griffe will use the latest available version. The two following commands compare the latest version against v1:

```
$ griffe check "" -b project-name -a project-name==1.0
$ griffe check "" -a project-name==1.0

```

Griffe will actually install packages in a cache directory. It means a few things: source distributions are supported, and only packages that are compatible with your current environment can be checked.

## Python API

To programmatically check for API breaking changes, you have to load two snapshots of your code base, for example using our load_git() utility, and then passing them both to the find_breaking_changes() function. This function will yield instances of Breakage. It's up to you how you want to use these breakage instances.

```
import griffe

my_pkg_v1 = griffe.load_git("my_pkg", ref="v1")
my_pkg_v2 = griffe.load_git("my_pkg", ref="v2")

for breaking_change in find_breaking_changes(my_pkg_v1, my_pkg_v2):
    print(breaking_change.explain())

```

## In CI

It is of course possible to Griffe in CI (Continuous Integration) to make sure no breaking changes are introduced in pull/merge requests.

### GitHub

Here is a quick example on how to use Griffe in a GitHub workflow:

```
jobs:
  check-api:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    # Griffe requires that Git tags are available.
    - run: git fetch --depth=1 --tags

    - uses: actions/setup-python@v5
      with:
        python-version: "3.11"

    # Install Griffe (use your preferred dependency manager).
    - run: pip install griffe

    - run: griffe check -ssrc your_package

```

The last step will fail the workflow if any breaking change is found. If you are part of [Insiders](../../../insiders/), you can format the output for GitHub, to enjoy GitHub annotations in PRs. See [GitHub format](#github) below.

## Detected breakages

In this section, we will describe the breakages that Griffe detects, giving some code examples and hints on how to properly communicate breakages with deprecation messages before actually releasing them.

Obviously, these explanations and the value of the hints we provide depend on your definition of what is a public Python API. There is no clear and generally agreed upon definition of "public Python API". A public Python API might vary from one project to another. In essence, your public API is what you say it is.

However, we do have conventions like prefixing objects with an underscore to tell users these objects are part of the private API, or internals, and therefore should not be used. For the rest, Griffe can detect changes that *will* trigger immediate errors in your users code', and changes that *might* cause issues in your users' code. Although the latter sound less impactful, they do have a serious impact, because they can *silently* change the behavior of your users' code, leading to issues that are hard to detect, understand and fix.

[Knowing that every change is a breaking change](https://xkcd.com/1172/), the more we detect and document (potentially) breaking changes in our changelogs, the better.

### Parameter moved

> Positional parameter was moved.

Moving the order of positional parameters can *silently* break your users' code.

before

```
# your code
def greet(prefix, name):
    print(prefix + " " + name)

# user's code
greet("hello", "world")

```

after

```
# your code
def greet(name, prefix):
    print(prefix + " " + name)

# user's code: no immediate error, broken behavior
greet("hello", "world")

```

Note

Moving required parameters around is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. The function expects a number of arguments, and the developer passes it this same number of arguments: the contract is fulfilled. But parameters very often have specific meaning, and changing their order will *silently lead* (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

Hint

If you often add, move or remove parameters, consider making them keyword-only, so that their order doesn't matter.

before

```
def greet(*, prefix, name):
    print(prefix + " " + name)

greet(prefix="hello", name="world")

```

after

```
def greet(*, name, prefix):
    print(prefix + " " + name)

# still working as expected
greet(prefix="hello", name="world")

```

### Parameter removed

> Parameter was removed.

Removing a parameter can immediately break your users' code.

before

```
# your code
def greet(prefix, name):
    print(prefix + " " + name)

# user's code
greet("hello", "world")

```

after

```
# your code
def greet(name):
    print("hello " + name)

# user's code: immediate error
greet("hello", "world")

# even with keyword parameters: immediate error
greet(prefix="hello", name="world")

```

Hint

Allow a deprecation period for the removed parameter by swallowing it in a variadic positional parameter, a variadic keyword parameter, or both.

before

```
# your parameters are positional-only parameters (difficult deprecation)
def greet(prefix, name, /):
    print(prefix + " " + name)

greet("hello", "world")

```

after

```
# swallow prefix using a variadic positional parameter
def greet(*args):
    if len(args) == 2:
        prefix, name = args
    elif len(args) == 1:
        prefix = None
        name = args[0]
    else:
        raise ValueError("missing parameter 'name'")
    if prefix is not None:
        warnings.warn(DeprecationWarning, "prefix is deprecated")
    print("hello " + name)

# still working as expected
greet("hello", "world")

```

before

```
# your parameters are keyword-only parameters (easy deprecation)
def greet(*, prefix, name):
    print(prefix + " " + name)

greet(prefix="hello", name="world")

```

after

```
# swallow prefix using a variadic keyword parameter
def greet(name, **kwargs):
    prefix = kwargs.get("prefix", None)
    if prefix is not None:
        warnings.warn(DeprecationWarning, "prefix is deprecated")
    print("hello " + name)

# still working as expected
greet(prefix="hello", name="world")

```

before

```
# your parameters are positional or keyword parameters (very difficult deprecation)
def greet(prefix, name):
    print(prefix + " " + name)

greet("hello", name="world")

```

after

```
# no other choice than swallowing both forms...
# ignoring the deprecated parameter becomes quite complex
def greet(*args, **kwargs):
    if len(args) == 2:
        prefix, name = args
    elif len(args) == 1:
        prefix = None
        name = args[0]
    if "name" in kwargs:
        name = kwargs["name"]
    if "prefix" in kwargs:
        prefix = kwargs["prefix"]
    if prefix is not None:
        warnings.warn(DeprecationWarning, "prefix is deprecated")
    print("hello " + name)

# still working as expected
greet("hello", "world")
greet("hello", name="world")
greet(prefix="hello", name="world")

```

### Parameter changed kind

> Parameter kind was changed

Changing the kind of a parameter to another (positional-only, keyword-only, positional or keyword, variadic positional, variadic keyword) can immediately break your users' code.

before

```
# your code
def greet(name):
    print("hello " + name)

def greet2(name):
    print("hello " + name)

# user's code: all working fine
greet("tim")
greet(name="tim")
greet2("tim")
greet2(name="tim")

```

after

```
# your code
def greet(name, /):
    print("hello " + name)

def greet2(*, name):
    print("hello " + name)

# user's code: working as expected
greet("tim")
greet2(name="tim")

# immediate error
greet(name="tim")
greet2("tim")

```

Hint

Although it actually is a breaking change, changing your positional or keyword parameters' kind to keyword-only makes your public function more robust to future changes (forward-compatibility).

For functions with lots of optional parameters, and a few (one or two) required parameters, it can be a good idea to accept the required parameters as positional or keyword, while accepting the optional parameters as keyword-only parameters:

```
def greet(name, *, punctuation=False, bold=False, italic=False):
    ...

# simple cases are easy to write
greet("tim")
greet("tiff")

# complex cases are never ambiguous
greet("tim", italic=True, bold=True)
greet(name="tiff", bold=True, punctuation=True)

```

Positional-only parameters are useful in some specific cases, such as when a function takes two or more numeric values, and their order does not matter, and naming the parameters would not make sense:

```
def multiply3(a, b, c, /):
    return a * b * c

# all the following are equivalent
multiply3(4, 2, 3)
multiply3(4, 3, 2)
multiply3(2, 3, 4)
# etc.

```

### Parameter changed default

> Parameter default was changed

Changing the default value of a parameter can *silently* break your users' code.

before

```
# your code
def compute_something(value: int, to_float=True):
    value = ...
    if to_float:
        return float(value)
    return value

# user's code: condition is entered
if isinstance(compute_something(7), float):
    ...

```

after

```
# your code
def compute_something(value: int, to_float=False):
    value = ...
    if to_float:
        return float(value)
    return value

# user's code: condition is not entered anymore
if isinstance(compute_something(7), float):
    ...

```

Note

Changing default value of parameters is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. Not using the parameter still provides the argument with a default value: the contract is fulfilled. But default values very often have specific meaning, and changing them will *silently lead* (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

Hint

Allow a deprecation period for the old default value by using a sentinel value to detect when the parameter wasn't used by the user:

in the coming release

```
_sentinel = object()

def compute_something(value: int, to_float=_sentinel):
    value = ...
    if to_float is _sentinel:
        to_float = True
        warnings.warn(
            DeprecationWarning,
            "default value of 'to_float' will change from True to False, "
            "please provide 'to_float=True' if you want to retain the current behavior"
        )
    if to_float:
        return float(value)
    return value

```

In a later release you can remove the sentinel, the deprecation warning, and set `False` as default to `to_float`.

in a later release

```
def compute_something(value: int, to_float=False):
    value = ...
    if to_float:
        return float(value)
    return value

```

### Parameter changed required

> Parameter is now required

Changing an optional parameter to a required one (by removing its default value) can immediately break your users' code.

before

```
# your code
def greet(name, prefix="hello"):
    print(prefix + " " + name)

# user's code
greet("tiff")

```

after

```
# your code
def greet(name, prefix):
    print(prefix + " " + name)

# user's code: immediate error
greet("tiff")

```

Hint

Allow a deprecation period for the default value by using a sentinel value to detect when the parameter wasn't used by the user:

in the coming release

```
_sentinel = object()

def greet(name, prefix=_sentinel):
    if prefix is _sentinel:
        prefix = "hello"
        warnings.warn(DeprecationWarning, "'prefix' will become required in the next release")
    print(prefix + " " + name)

```

In a later release you can remove the sentinel, the deprecation warning, and the default value of `prefix`.

in a later release

```
def greet(name, prefix):
    print(prefix + " " + name)

```

### Parameter added required

> Parameter was added as required

Adding a new, required parameter can immediately break your users' code.

before

```
# your code
def greet(name):
    print("hello " + name)

# user's code
greet("tiff")

```

after

```
# your code
def greet(name, prefix):
    print(prefix + " " + name)

# user's code: immediate error
greet("tiff")

```

Hint

You can delay (or avoid) and inform your users about the upcoming breakage by temporarily (or permanently) providing a default value for the new parameter:

in the coming release

```
def greet(name, prefix="hello"):
    print(prefix + " " + name)

```

### Return changed type

> Return types are incompatible

Not yet supported!

Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.

### Object removed

> Public object was removed

Removing a public object from a module can immediately break your users' code.

before

```
# your/module.py
special_thing = "hey"

# user/module.py
from your.module import special_thing

# other/user/module.py
from your import module
print(module.special_thing)

```

after

```
# user/module.py: import error
from your.module import special_thing

# other/user/module.py: attribute error
from your import module
print(module.special_thing)

```

Hint

Allow a deprecation period by declaring a module-level `__getattr__` function that returns the given object while warning about its deprecation:

```
def __getattr__(name):
    if name == "special_thing":
        warnings.warn(DeprecationWarning, "'special_thing' is deprecated and will be removed")
        return "hey"

```

### Object changed kind

> Public object points to a different kind of object

Changing the kind (type alias, attribute, function, class, module) of a public object can *silently* break your users' code.

before

```
# your code
class Factory:
    def __call__(self, ...):
        ...

factory = Factory(...)

# user's code: condition is entered
if isinstance(factory, Factory):
    ...

```

after

```
# your code
class Factory:
    ...

def factory(...):
    ...

# user's code: condition is not entered anymore
if isinstance(factory, Factory):
    ...

```

Note

Changing the kind of an object is not really an API breakage, depending on our definition of API, since this won't always raise immediate errors like `TypeError`. The object is still here and accessed: the contract is fulfilled. But developers sometimes rely on the kind of an object, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

### Attribute changed type

> Attribute types are incompatible

Not yet supported!

Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.

### Attribute changed value

> Attribute value was changed

Changing the value of an attribute can *silently* break your users' code.

before

```
# your code
PY_VERSION = os.getenv("PY_VERSION")

# user's code: condition is entered
if PY_VERSION is None:
    ...

```

after

```
# your code
PY_VERSION = os.getenv("PY_VERSION", "3.8")

# user's code: condition is not entered anymore
if PY_VERSION is None:
    ...

```

Note

Changing the value of an attribute is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. The attribute is still here and accessed: the contract is fulfilled. But developers heavily rely on the value of public attributes, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

Hint

Make sure to document the change of value of the attribute in your changelog, particularly the previous and new range of values it can take.

### Class removed base

> Base class was removed

Removing a class from another class' bases can *silently* break your users' code.

before

```
# your code
class A: ...
class B: ...
class C(A, B): ...

# user's code: condition is entered
if B in klass.__bases__:
    ...

```

after

```
# your code
class A: ...
class B: ...
class C(A): ...

# user's code: condition is not entered anymore
if B in klass.__bases__:
    ...

```

Note

Unless inherited members are lost in the process, removing a class base is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like `TypeError`. The class is here, its members as well: the contract is fulfilled. But developers sometimes rely on the actual bases of a class, so changing them will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.

## Output style

Griffe supports writing detected breakages in multiple formats, or styles.

### One-line

- **CLI**: `-f oneline` / no flags
- **API**: `check(...)` / `check(..., style="oneline")` / `check(..., style=ExplanationStyle.ONE_LINE)`

This is the default format. Griffe will print each detected breakage on a single line:

```
$ griffe check griffe -ssrc -b0.46.0.1.2.0 -a0.45.0.1.2.0
src/griffe/mixins.py:303: ObjectAliasMixin.is_exported: Public object points to a different kind of object: function -> attribute
src/griffe/mixins.py:353: ObjectAliasMixin.is_public: Public object points to a different kind of object: function -> attribute
src/griffe/dataclasses.py:520: Object.has_labels(labels): Parameter kind was changed: positional or keyword -> variadic positional
src/griffe/diff.py:571: find_breaking_changes(ignore_private): Parameter default was changed: True -> _sentinel
src/griffe/extensions/base.py:463: load_extensions(exts): Parameter kind was changed: positional or keyword -> variadic positional
src/griffe/dataclasses.py:1073: Alias.has_labels(labels): Parameter kind was changed: positional or keyword -> variadic positional

```

### Verbose

- **CLI**: `-f verbose` / `-v`
- **API**: `check(..., style="verbose")` / `check(..., style=ExplanationStyle.VERBOSE)` / `check(..., verbose=True)`

Depending on the detected breakages, the lines might be hard to read (being too compact), so `griffe check` also accepts a `--verbose` or `-v` option to add some space to the output:

```
$ griffe check griffe -ssrc -b0.46.0.1.2.0 -a0.45.0.1.2.0 --verbose
src/griffe/mixins.py:303: ObjectAliasMixin.is_exported:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/mixins.py:353: ObjectAliasMixin.is_public:
Public object points to a different kind of object:
  Old: function
  New: attribute

src/griffe/dataclasses.py:520: Object.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/diff.py:571: find_breaking_changes(ignore_private):
Parameter default was changed:
  Old: True
  New: _sentinel

src/griffe/extensions/base.py:463: load_extensions(exts):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

src/griffe/dataclasses.py:1073: Alias.has_labels(labels):
Parameter kind was changed:
  Old: positional or keyword
  New: variadic positional

```

### Markdown

[Insiders 1.0.0](../../../insiders/changelog/#1.0.0)

- **CLI**: `-f markdown`
- **API**: `check(..., style="markdown")` / `check(..., style=ExplanationStyle.MARKDOWN)`

The Markdown format is adapted for changelogs. It doesn't show the file and line number, and instead prints out the complete path of your API objects. With a bit of automation, you will be able to automatically insert a summary of breaking changes in your changelog entries.

```
- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(max_iterations)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_exported)`: *Parameter was removed*
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_known_modules)`: *Parameter was removed*
- `griffe.git.tmp_worktree(commit)`: *Parameter was removed*
- `griffe.git.tmp_worktree(repo)`: *Positional parameter was moved*: position: from 2 to 1 (-1)
- `griffe.git.load_git(commit)`: *Parameter was removed*
- `griffe.git.load_git(repo)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(submodules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(try_relative_path)`: *Parameter was removed*
- `griffe.git.load_git(extensions)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(search_paths)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_parser)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_options)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(lines_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(modules_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(allow_inspection)`: *Parameter kind was changed*: positional or keyword -> keyword-only

```

- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_exported)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_aliases(only_known_modules)`: *Parameter default was changed*: `True` -> `None`
- `griffe.loader.GriffeLoader.resolve_aliases(max_iterations)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_exported)`: *Parameter was removed*
- `griffe.loader.GriffeLoader.resolve_module_aliases(only_known_modules)`: *Parameter was removed*
- `griffe.git.tmp_worktree(commit)`: *Parameter was removed*
- `griffe.git.tmp_worktree(repo)`: *Positional parameter was moved*: position: from 2 to 1 (-1)
- `griffe.git.load_git(commit)`: *Parameter was removed*
- `griffe.git.load_git(repo)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(submodules)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(try_relative_path)`: *Parameter was removed*
- `griffe.git.load_git(extensions)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(search_paths)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_parser)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(docstring_options)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(lines_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(modules_collection)`: *Parameter kind was changed*: positional or keyword -> keyword-only
- `griffe.git.load_git(allow_inspection)`: *Parameter kind was changed*: positional or keyword -> keyword-only

### GitHub

[Insiders 1.0.0](../../../insiders/changelog/#1.0.0)

- **CLI**: `-f github`
- **API**: `check(..., style="github")` / `check(..., style=ExplanationStyle.GITHUB)`

When running `griffe check` in CI, you can enable GitHub's annotations thanks to the GitHub output style. Annotations are displayed on specific lines of code. They are visible in the Checks tab. When you create an annotation for a file that is part of the pull request, the annotations are also shown in the Files changed tab.

```
% python -m griffe check -fgithub -ssrc griffe
::warning file=src/griffe/finder.py,line=58,title=Package.name::Attribute value was changed: `name` -> unset
::warning file=src/griffe/finder.py,line=60,title=Package.path::Attribute value was changed: `path` -> unset
::warning file=src/griffe/finder.py,line=62,title=Package.stubs::Attribute value was changed: `stubs` -> `None`
::warning file=src/griffe/finder.py,line=75,title=NamespacePackage.name::Attribute value was changed: `name` -> unset
::warning file=src/griffe/finder.py,line=77,title=NamespacePackage.path::Attribute value was changed: `path` -> unset

```

## Next steps

If you are using a third-party library to mark objects as public, or if you follow conventions different than the one Griffe understands, you might get false-positives, or breaking changes could go undetected. In that case, you might be interested in [extending](../extending/) how Griffe loads API data to support these third-party libraries or other conventions.

# Extending APIs

Griffe has an extension system that can be used to enhance or customize the data that Griffe collects. Extensions are written in Python.

## Using extensions

Extensions can be specified both on the command-line (in the terminal), and programmatically (in Python).

### On the command-line

On the command-line, you can specify extensions to use with the `-e`, `--extensions` option. This option accepts a single positional argument which can take two forms:

- a comma-separated list of extensions
- a JSON list of extensions

Extensions can accept options: the comma-separated list does not allow to specify options, while the JSON list does. See examples below.

With both forms, each extension refers to one of these three things:

- the name of a built-in extension's module, for example `dynamic_docstrings` (this is just an example, this built-in extension does not exist)
- the Python dotted-path to a module containing one or more extensions, or to an extension directly, for example `package.module` and `package.module.ThisExtension`
- the file path to a Python script, and an optional extension name, separated by a colon, for example `scripts/griffe_exts.py` and `scripts/griffe_exts.py:ThisExtension`

The specified extension modules can contain more than one extension: Griffe will pick up and load every extension declared or imported within the modules. If options are specified for a module that contains multiple extensions, the same options will be passed to all the extensions, so extension writers must make sure that all extensions within a single module accept the same options. If they don't, Griffe will abort with an error.

To specify options in the JSON form, use a dictionary instead of a string: the dictionary's only key is the extension identifier (built-in name, Python path, file path) and its value is a dictionary of options.

Some examples:

```
griffe dump griffe -e pydantic,scripts/exts.py:DynamicDocstrings,griffe_attrs

```

```
griffe check --search src griffe -e '[
  {"pydantic": {"schema": true}},
  {
    "scripts/exts.py:DynamicDocstrings": {
      "paths": ["mypkg.mymod.myobj"]
    }
  },
  "griffe_attrs"
]'

```

In the above two examples, `pydantic` would be a built-in extension, `scripts/exts.py:DynamicDocstrings` the file path plus name of a local extension, and `griffe_attrs` the name of a third-party package that exposes one or more extensions.

### Programmatically

Within Python code, extensions can be specified with the `extensions` parameter of the GriffeLoader class or load function.

The parameter accepts an instance of the Extensions class. Such an instance is created with the help of the load_extensions function, which itself accepts a list of strings, dictionaries, extension classes and extension instances.

Strings and dictionaries are used the same way as [on the command-line](#on-the-command-line). Extension instances are used as such, and extension classes are instantiated without any options.

Example:

```
import griffe

from mypackage.extensions import ThisExtension, ThisOtherExtension

extensions = griffe.load_extensions(
    {"pydantic": {"schema": true}},
    {"scripts/exts.py:DynamicDocstrings": {"paths": ["mypkg.mymod.myobj"]}},
    "griffe_attrs",
    ThisExtension(option="value"),
    ThisOtherExtension,
)

data = griffe.load("mypackage", extensions=extensions)

```

### In MkDocs

MkDocs and its mkdocstrings plugin can be configured to use Griffe extensions:

mkdocs.yml

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - pydantic: {schema: true}
          - scripts/exts.py:DynamicDocstrings:
              paths: [mypkg.mymod.myobj]
          - griffe_attrs

```

The `extensions` key accepts a list that is passed to the load_extensions function. See [how to use extensions programmatically](#programmatically) to learn more.

## Writing extensions

In the next section we give a bit of context on how Griffe works, to show how extensions can integrate into the data collection process. Feel free to skip to the [Events and hooks](#events-and-hooks) section or the [Full example](#full-example) section if you'd prefer to see concrete examples first.

### How it works

To extract information from your Python sources, Griffe tries to build Abstract Syntax Trees by parsing the sources with ast utilities.

If the source code is not available (the modules are built-in or compiled), Griffe imports the modules and builds object trees instead.

Griffe then follows the [Visitor pattern](https://www.wikiwand.com/en/Visitor_pattern) to walk the tree and extract information. For ASTs, Griffe uses its Visitor agent and for object trees, it uses its Inspector agent.

Sometimes during the walk through the tree (depth-first order), both the visitor and inspector agents will trigger events. These events can be hooked on by extensions to alter or enhance Griffe's behavior. Some hooks will be passed just the current node being visited, others will be passed both the node and an instance of an Object subclass, such as a Module, a Class, a Function, an Attribute, or a Type Alias. Extensions will therefore be able to modify these instances.

The following flow chart shows an example of an AST visit. The tree is simplified: actual trees have a lot more nodes like `if/elif/else` nodes, `try/except/else/finally` nodes, and many more.

```
flowchart TB
M(Module definition) --- C(Class definition) & F(Function definition)
C --- m(Function definition) & A(Variable assignment)
```

The following flow chart shows an example of an object tree inspection. The tree is simplified as well: many more types of objects are handled.

```
flowchart TB
M(Module) --- C(Class) & F(Function)
C --- m(Method) & A(Attribute)
```

For a more concrete example, let say that we visit (or inspect) an AST (or object tree) for a given module, and that this module contains a single class, which itself contains a single method:

- the agent (visitor or inspector) will walk through the tree by starting with the module node
- it will instantiate a Module, then walk through its members, continuing with the class node
- it will instantiate a Class, then walk through its members, continuing with the function node
- it will instantiate a Function
- then it will go back up and finish walking since there are no more nodes to walk through

Every time the agent enters a node, creates an object instance, or finishes handling members of an object, it will trigger an event.

The flow of events is drawn in the following flowchart:

```
flowchart TB
visit_mod{{enter module node}}
event_mod_node{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_node'><b><code style='color: var(--md-accent-fg-color)'>on_node</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_module_node'><b><code style='color: var(--md-accent-fg-color)'>on_module_node</code></b></a> event"}}
create_mod{{create module instance}}
event_mod_instance{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_instance'><b><code style='color: var(--md-accent-fg-color)'>on_instance</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_module_instance'><b><code style='color: var(--md-accent-fg-color)'>on_module_instance</code></b></a> event"}}
visit_mod_members{{visit module members}}
visit_cls{{enter class node}}
event_cls_node{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_node'><b><code style='color: var(--md-accent-fg-color)'>on_node</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_class_node'><b><code style='color: var(--md-accent-fg-color)'>on_class_node</code></b></a> event"}}
create_cls{{create class instance}}
event_cls_instance{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_instance'><b><code style='color: var(--md-accent-fg-color)'>on_instance</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_class_instance'><b><code style='color: var(--md-accent-fg-color)'>on_class_instance</code></b></a> event"}}
visit_cls_members{{visit class members}}
visit_func{{enter func node}}
event_func_node{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_node'><b><code style='color: var(--md-accent-fg-color)'>on_node</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_function_node'><b><code style='color: var(--md-accent-fg-color)'>on_function_node</code></b></a> event"}}
create_func{{create function instance}}
event_func_instance{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_instance'><b><code style='color: var(--md-accent-fg-color)'>on_instance</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_function_instance'><b><code style='color: var(--md-accent-fg-color)'>on_function_instance</code></b></a> event"}}
event_cls_members{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_members'><b><code style='color: var(--md-accent-fg-color)'>on_members</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_class_members'><b><code style='color: var(--md-accent-fg-color)'>on_class_members</code></b></a> event"}}
event_mod_members{{"<a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_members'><b><code style='color: var(--md-accent-fg-color)'>on_members</code></b></a> event<br><a href='/griffe/reference/griffe/extensions/#griffe.Extension.on_module_members'><b><code style='color: var(--md-accent-fg-color)'>on_module_members</code></b></a> event"}}

start{start} --> visit_mod
visit_mod --> event_mod_node
event_mod_node --> create_mod
create_mod --> event_mod_instance
event_mod_instance --> visit_mod_members
visit_mod_members --1--> visit_cls
visit_cls --> event_cls_node
event_cls_node --> create_cls
create_cls --> event_cls_instance
event_cls_instance --> visit_cls_members
visit_cls_members --1--> visit_func
visit_func --> event_func_node
event_func_node --> create_func
create_func --> event_func_instance
event_func_instance --> visit_cls_members
visit_cls_members --2--> event_cls_members
event_cls_members --> visit_mod_members
visit_mod_members --2--> event_mod_members
event_mod_members --> finish{finish}

class event_mod_node event
class event_mod_instance event
class event_cls_node event
class event_cls_instance event
class event_func_node event
class event_func_instance event
class event_cls_members event
class event_mod_members event
classDef event stroke:#3cc,stroke-width:2
```

Hopefully this flowchart gives you a pretty good idea of what happens when Griffe collects data from a Python module. The next section will explain in more details the different events that are triggered, and how to hook onto them in your extensions.

### Events and hooks

There are two kinds of events in Griffe: **load events** and **analysis events**. Load events are scoped to the Griffe loader. Analysis events are scoped to the visitor and inspector agents (triggered during static and dynamic analysis).

#### Load events

There are two **load events**:

- on_package_loaded: The "on package loaded" event is triggered when the loader has finished loading a package entirely, i.e. when all its submodules were scanned and loaded. This event can be hooked by extensions which require the whole package to be loaded, to be able to navigate the object tree without raising lookup errors or alias resolution errors.
- on_wildcard_expansion: The "on wildcard expansion" event is triggered for each alias that is created by expanding wildcard imports (`from ... import *`).

#### Analysis events

There are 3 generic **analysis events**:

- on_node: The "on node" events are triggered when the agent (visitor or inspector) starts handling a node in the tree (AST or object tree).
- on_instance: The "on instance" events are triggered when the agent just created an instance of Module, Class, Function, Attribute, or Type Alias, and added it as a member of its parent. The "on instance" event is **not** triggered when an Alias is created.
- on_members: The "on members" events are triggered when the agent just finished handling all the members of an object. Functions, attributes and type aliases do not have members, so there are no "on members" events for these kinds.

There are also specific **analysis events** for each object kind:

- on_module_node
- on_module_instance
- on_module_members
- on_class_node
- on_class_instance
- on_class_members
- on_function_node
- on_function_instance
- on_attribute_node
- on_attribute_instance
- on_type_alias_node
- on_type_alias_instance

And a special event for aliases:

- on_alias: The "on alias" event is triggered when an Alias was just created and added as a member of its parent object.

______________________________________________________________________

**Hooks** are methods that are called when a particular event is triggered. To target a specific event, the hook must be named after it.

**Extensions** are classes that inherit from Griffe's Extension base class and define some hooks as methods:

```
import ast
import griffe


class MyExtension(griffe.Extension):
    def on_instance(
        self,
        node: ast.AST | griffe.ObjectNode,
        obj: griffe.Object,
        agent: griffe.Visitor | griffe.Inspector,
        **kwargs,
    ) -> None:
        """Do something with `node` and/or `obj`."""

```

Hooks are always defined as methods of a class inheriting from Extension, never as standalone functions. IDEs should autocomplete the signature when you start typing `def` followed by a hook name.

Since hooks are declared in a class, feel free to also declare state variables (or any other variable) in the `__init__` method:

```
import ast
from griffe import Extension, Object, ObjectNode


class MyExtension(Extension):
    def __init__(self) -> None:
        super().__init__()
        self.state_thingy = "initial stuff"
        self.list_of_things = []

    def on_instance(
        self,
        node: ast.AST | griffe.ObjectNode,
        obj: griffe.Object,
        agent: griffe.Visitor | griffe.Inspector,
        **kwargs,
    ) -> None:
        """Do something with `node` and/or `obj`."""

```

### Static/dynamic support

Extensions can support both static and dynamic analysis of modules. If a module is scanned statically, your extension hooks will receive AST nodes (from the ast module of the standard library). If the module is scanned dynamically, your extension hooks will receive object nodes. Similarly, your hooks will receive a reference to the analysis agent that calls them, either a Visitor or an Inspector.

To support static analysis, dynamic analysis, or both, you can therefore check the type of the received node or agent:

```
import ast
import griffe


class MyExtension(griffe.Extension):
    def on_instance(
        self,
        node: ast.AST | griffe.ObjectNode,
        obj: griffe.Object,
        agent: griffe.Visitor | griffe.Inspector,
        **kwargs,
    ) -> None:
        """Do something with `node` and/or `obj`."""
        if isinstance(node, ast.AST):
            ...  # Apply logic for static analysis.
        else:
            ...  # Apply logic for dynamic analysis.

```

```
import ast
import griffe


class MyExtension(Extension):
    def on_instance(
        self,
        node: ast.AST | griffe.ObjectNode,
        obj: griffe.Object,
        agent: griffe.Visitor | griffe.Inspector,
        **kwargs,
    ) -> None:
        """Do something with `node` and/or `obj`."""
        if isinstance(agent, griffe.Visitor):
            ...  # Apply logic for static analysis.
        else:
            ...  # Apply logic for dynamic analysis.

```

The preferred method is to check the type of the received node rather than the agent.

Since hooks also receive instantiated modules, classes, functions, attributes and type aliases, most of the time you will not need to use the `node` argument other than for checking its type and deciding what to do based on the result. And since we always add `**kwargs` to the hooks' signatures, you can drop any parameter you don't use from the signature:

```
import griffe


class MyExtension(Extension):
    def on_instance(self, obj: griffe.Object, **kwargs) -> None:
        """Do something with `obj`."""
        ...

```

### Visiting trees

Extensions provide basic functionality to help you visit trees:

- visit: call `self.visit(node)` to start visiting an abstract syntax tree.
- generic_visit: call `self.generic_visit(node)` to visit each subnode of a given node.
- inspect: call `self.inspect(node)` to start visiting an object tree. Nodes contain references to the runtime objects, see ObjectNode.
- generic_inspect: call `self.generic_inspect(node)` to visit each subnode of a given node.

Calling `self.visit(node)` or `self.inspect(node)` will do nothing unless you actually implement methods that handle specific types of nodes:

- for ASTs, methods must be named `visit_<node_type>` where `<node_type>` is replaced with the lowercase name of the node's class. For example, to allow visiting ClassDef nodes, you must implement the `visit_classdef` method:

  ```
  import ast
  from griffe import Extension


  class MyExtension(Extension):
      def visit_classdef(node: ast.ClassDef) -> None:
          # Do something with the node...
          ...
          # ...then visit the subnodes
          # (it only makes sense if you implement other methods
          # such as visit_functiondef or visit_assign for example).
          self.generic_visit(node)

  ```

  See the [list of existing AST classes](#ast-nodes) to learn what method you can implement.

- for object trees, methods must be named `inspect_<node_type>`, where `<node_type>` is replaced with the string value of the node's kind. The different kinds are listed in the ObjectKind enumeration. For example, to allow inspecting coroutine nodes, you must implement the `inspect_coroutine` method:

  ```
  from griffe import Extension, ObjectNode


  class MyExtension(Extension):
      def inspect_coroutine(node: ObjectNode) -> None:
          # Do something with the node...
          ...
          # ...then visit the subnodes if it makes sense.
          self.generic_inspect(node)

  ```

### Triggering other extensions

If your extension creates new objects, you might want to trigger the other enabled extensions on these object instances. To do this you can use agent.extensions.call:

```
import ast
import griffe


class MyExtension(griffe.Extension):
    def on_node(self, node: ast.AST | griffe.ObjectNode, agent: griffe.Visitor | griffe.Inspector, **kwargs) -> None:
        # New object created for whatever reason.
        function = griffe.Function(...)

        # Trigger other extensions.
        agent.extensions.call("on_function_instance", node=node, agent=agent, func=function, **kwargs)

```

### Extra data

All Griffe objects (modules, classes, functions, attributes, type aliases) can store additional (meta)data in their `extra` attribute. This attribute is a dictionary of dictionaries. The first layer is used as namespacing: each extension writes into its own namespace, or integrates with other projects by reading/writing in their namespaces, according to what they support and document.

```
import griffe

self_namespace = "my_extension"


class MyExtension(griffe.Extension):
    def on_instance(self, obj: griffe.Object, **kwargs) -> None:
        obj.extra[self_namespace]["some_key"] = "some_value"

```

For example, [mkdocstrings-python](https://mkdocstrings.github.io/python) looks into the `mkdocstrings` namespace for a `template` key. Extensions can therefore provide a custom template value by writing into `extra["mkdocstrings"]["template"]`:

```
import griffe

self_namespace = "my_extension"
mkdocstrings_namespace = "mkdocstrings"


class MyExtension(griffe.Extension):
    def on_class_instance(self, cls: griffe.Class, **kwargs) -> None:
        obj.extra[mkdocstrings_namespace]["template"] = "my_custom_template"

```

[Read more about mkdocstrings handler extensions.](https://mkdocstrings.github.io/usage/handlers/#handler-extensions)

### Options

Extensions can be made to support options. These options can then be passed from the [command-line](#on-the-command-line) using JSON, from Python directly, or from other tools like MkDocs, in `mkdocs.yml`.

```
import griffe


class MyExtension(griffe.Extension):
    def __init__(self, option1: str, option2: bool = False) -> None:
        super().__init__()
        self.option1 = option1
        self.option2 = option2

    def on_attribute_instance(self, attr: griffe.Attribute, **kwargs) -> None:
        if self.option2:
            ...  # Do something.

```

### Logging

To better integrate with Griffe and other tools in the ecosystem (notably MkDocs), use Griffe loggers to log messages:

```
import griffe

logger = griffe.get_logger(__name__)


class MyExtension(griffe.Extension):
    def on_module_members(self, mod: griffe.Module, **kwargs) -> None:
        logger.info("Doing some work on module %s and its members", mod.path)

```

### Full example

The following example shows how one could write a "dynamic docstrings" extension that dynamically imports objects that declare their docstrings dynamically, to improve support for such docstrings. The extension is configurable to run only on user-selected objects.

Package structure (or just write your extension in a local script):

```
📁 ./
├──  pyproject.toml
└── 📁 src/
    └── 📁 dynamic_docstrings/
        ├──  __init__.py
        └──  extension.py

```

./src/dynamic_docstrings/extension.py

```
import ast
import inspect
import griffe

logger = griffe.get_logger(__name__)


class DynamicDocstrings(griffe.Extension):
    def __init__(self, object_paths: list[str] | None = None) -> None:
        self.object_paths = object_paths

    def on_instance(
        self,
        node: ast.AST | griffe.ObjectNode,
        obj: griffe.Object,
        agent: griffe.Visitor | griffe.Inspector,
        **kwargs,
    ) -> None:
        if isinstance(node, griffe.ObjectNode):
            return  # Skip runtime objects, their docstrings are already right.

        if self.object_paths and obj.path not in self.object_paths:
            return  # Skip objects that were not selected.

        # Import object to get its evaluated docstring.
        try:
            runtime_obj = griffe.dynamic_import(obj.path)
            docstring = runtime_obj.__doc__
        except ImportError:
            logger.debug(f"Could not get dynamic docstring for {obj.path}")
            return
        except AttributeError:
            logger.debug(f"Object {obj.path} does not have a __doc__ attribute")
            return

        # Update the object instance with the evaluated docstring.
        docstring = inspect.cleandoc(docstring)
        if obj.docstring:
            obj.docstring.value = docstring
        else:
            obj.docstring = griffe.Docstring(
                docstring,
                parent=obj,
                docstring_parser=agent.docstring_parser,
                docstring_options=agent.docstring_options,
            )

```

You can then expose this extension in the top-level module of your package:

./src/dynamic_docstrings/__init__.py

```
from dynamic_docstrings.extension import DynamicDocstrings

__all__ = ["DynamicDocstrings"]

```

This will allow users to load and use this extension by referring to it as `dynamic_docstrings` (your Python package name).

See [how to use extensions](#using-extensions) to learn more about how to load and use your new extension.

## AST nodes

> |     |
> | --- |
> |     |
>
> - Add
> - alias
> - And
> - AnnAssign
> - arg
> - arguments
> - Assert
> - Assign
> - AsyncFor
> - AsyncFunctionDef
> - AsyncWith
> - Attribute
> - AugAssign
> - Await
> - BinOp
> - BitAnd
> - BitOr
> - BitXor
> - BoolOp
> - Break
> - `Bytes`[1](#fn:1)
> - Call
> - ClassDef
> - Compare
> - comprehension
> - Constant
> - Continue
> - Del
> - Delete
> - Dict
>
> |
>
> - DictComp
> - Div
> - `Ellipsis`[1](#fn:1)
> - Eq
> - ExceptHandler
> - Expr
> - `Expression`[1](#fn:1)
> - `ExtSlice`[2](#fn:2)
> - FloorDiv
> - For
> - FormattedValue
> - FunctionDef
> - GeneratorExp
> - Global
> - Gt
> - GtE
> - If
> - IfExp
> - Import
> - ImportFrom
> - In
> - `Index`[2](#fn:2)
> - `Interactive`[3](#fn:3)
> - Invert
> - Is
> - IsNot
> - JoinedStr
> - keyword
> - Lambda
> - List
>
> |
>
> - ListComp
> - Load
> - LShift
> - Lt
> - LtE
> - Match
> - MatchAs
> - match_case
> - MatchClass
> - MatchMapping
> - MatchOr
> - MatchSequence
> - MatchSingleton
> - MatchStar
> - MatchValue
> - MatMult
> - Mod
> - `Module`[3](#fn:3)
> - Mult
> - Name
> - `NameConstant`[1](#fn:1)
> - NamedExpr
> - Nonlocal
> - Not
> - NotEq
> - NotIn
> - `Num`[1](#fn:1)
> - Or
> - ParamSpec
> - Pass
>
> |
>
> - `pattern`[3](#fn:3)
> - Pow
> - `Print`[4](#fn:4)
> - Raise
> - Return
> - RShift
> - Set
> - SetComp
> - Slice
> - Starred
> - Store
> - `Str`[1](#fn:1)
> - Sub
> - Subscript
> - Try
> - `TryExcept`[5](#fn:5)
> - `TryFinally`[6](#fn:6)
> - Tuple
> - TypeAlias
> - TypeVar
> - TypeVarTuple
> - UAdd
> - UnaryOp
> - USub
> - While
> - With
> - withitem
> - Yield
> - YieldFrom

## Next steps

Extensions are a powerful mechanism to customize or enhance the data loaded by Griffe. But sometimes, all you need to do to improve the data is to make Griffe happy by following a few conventions. We therefore invite you to read our recommendations on [public APIs](../recommendations/public-apis/), [Python code best practices](../recommendations/python-code/) and [docstrings](../recommendations/docstrings/).

______________________________________________________________________

1. Deprecated since Python 3.8. [↩](#fnref:1 "Jump back to footnote 1 in the text")[↩](#fnref2:1 "Jump back to footnote 1 in the text")[↩](#fnref3:1 "Jump back to footnote 1 in the text")[↩](#fnref4:1 "Jump back to footnote 1 in the text")[↩](#fnref5:1 "Jump back to footnote 1 in the text")[↩](#fnref6:1 "Jump back to footnote 1 in the text")
1. Deprecated since Python 3.9. [↩](#fnref:2 "Jump back to footnote 2 in the text")[↩](#fnref2:2 "Jump back to footnote 2 in the text")
1. Not documented. [↩](#fnref:3 "Jump back to footnote 3 in the text")[↩](#fnref2:3 "Jump back to footnote 3 in the text")[↩](#fnref3:3 "Jump back to footnote 3 in the text")
1. `print` became a builtin (instead of a keyword) in Python 3. [↩](#fnref:4 "Jump back to footnote 4 in the text")
1. Now `ExceptHandler`, in the `handlers` attribute of `Try` nodes. [↩](#fnref:5 "Jump back to footnote 5 in the text")
1. Now a list of expressions in the `finalbody` attribute of `Try` nodes. [↩](#fnref:6 "Jump back to footnote 6 in the text")
# Recommendations

# Docstrings

Here are explanations on what docstrings are, and a few recommendations on how to write them. This guide uses the [Google-style](../../../../reference/docstrings/#google-style), because that is our preferred and recommended style, but you can also use any other supported style. Skip to the [Styles](#styles) section to learn about the existing docstring styles. We invite you to read their own style guides as they are full of examples and good advice.

## Definition

A docstring is a line or block of text describing objects such as modules, classes, functions, attributes and type aliases. They are written below the object signature or assignment, or appear as first expression in a module:

module.py

```
"""This is the module docstring."""

type X = dict[str, int]
"""This is a type alias docstring."""

a = 0
"""This is an attribute docstring."""


def b():
    """This is a function docstring."""


class C:
    """This is a class docstring."""

    def d(self):
        """This is a method docstring."""

```

## Multi-line docstrings

Each docstring can span multiple lines if it is wrapped in triple double-quotes (which is generally the case and the official recommendation even for single-line docstrings):

```
def function():
    """This is a longer docstring.

    It spans on multiple lines.
    Blank lines are allowed, too.
    """

```

When writing multi-line docstrings, it is recommended to write a short description on the first line, then separate the rest of the docstring with a blank line. The first line is called the **summary**, and the rest of docstring is called the **body**. The summary is useful to documentation generators and other tools to show the short description of an object.

## Markup

Docstrings are just text, so you can use any markup you want. The markup you choose will generally depend on what you decide to do with your docstrings: if you generate API documentation from your docstrings, and the documentation renderer expects Markdown, then you should write your docstrings in Markdown.

Examples of markups are [Markdown](https://daringfireball.net/projects/markdown/) (which has many different implementations and many different "flavors"), [reStructuredText](https://docutils.sourceforge.io/rst.html), [AsciiDoc](https://asciidoc.org/), and [Djot](https://djot.net/).

For example, if you are using [MkDocs](https://www.mkdocs.org) and [mkdocstrings](https://mkdocstrings.github.io/) to generate your API documentation, you should write your docstrings in Markdown. If you are using [Sphinx](https://www.sphinx-doc.org/en/master/), you should probably write your docstrings in reStructuredText, unless you are also using the [MyST](https://myst-parser.readthedocs.io/en/latest/index.html) extension.

Whatever markup you choose, try to stay consistent within your code base.

## Styles

Docstrings can be written for modules, classes, functions, attributes, and type aliases. But there are other aspects of a Python API that need to be documented, such as function parameters, returned values, and raised exceptions, to name a few. We could document everything in natural language, but that would make it hard for downstream tools such as documentation generators to extract information in a structured way, to allow dedicated rendering such as tables for parameters.

To compensate for the lack of structure in natural languages, docstring "styles" emerged. A docstring style is a micro-format for docstrings, allowing to structure the information by following a specific format. With the most popular Google and Numpydoc styles, information in docstrings is decomposed into **sections** of different kinds, for example "parameter" sections or "return" sections. Some kinds of section then support documenting multiple items, or support a single block of markup. For example, we can document multiple parameters in "parameter" sections, but a "note" section is only composed of a text block.

Structuring the information in sections and items allows documentation-related tools to extract and provide this information in a structured way, by parsing the docstrings according to the style they follow. Griffe has parsers for [Google-style](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings), [Numpydoc-style](https://numpydoc.readthedocs.io/en/latest/format.html), and [Sphinx-style](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html) docstrings. See the complete reference for these parsers and styles in the [Docstrings reference](../../../../reference/docstrings/). We recommend that you read the style guides mentioned here as they are full of examples and good advice too.

Google-style

```
def greet(name: str, end: str = "!") -> None:
    """Greet someone.

    Parameters:
        name: The name to greet.
        end: The punctuation mark at the end.

    Note:
        Greetings are cool!
    """
    print(f"Hey {name}{end}")



‎

```

Numpydoc-style

```
def greet(name: str, end: str = "!") -> None:
    """Greet someone.

    Parameters
    ----------
    name
        The name to greet.
    end
        The punctuation mark at the end.

    Note
    ----
    Greetings are cool!
    """
    print(f"Hey {name}{end}")

```

Our preferred style for docstrings is the **Google-style**, because it is in our opinion the most markup-agnostic style: it is based on any kind of markup or documentation generator. Our second choice would be the Numpydoc-style, for its readability.

For the adventurers, have a look at [PEP 727](https://peps.python.org/pep-0727/) (draft) and [griffe-typingdoc](https://mkdocstrings.github.io/griffe-typingdoc/), a Griffe extension to support PEP 727. PEP 727 proposes an alternative way to provide information in a structured way, that does not rely on a docstring micro-format. It takes advantage of `typing.Annotated` to attach documentation to any type-annotated object, like attributes, parameters and returned values. With PEP 727, docstrings styles and their sections aren't required anymore, and docstrings can be written in plain markup, without following any particular style. This makes it easier for tools like Griffe who then don't have to parse docstrings *at all*. The PEP is a bit controversial (lots of different opinions), so we invite you to make your own opinion by looking at real-world projects using it, such as [FastAPI](https://github.com/tiangolo/fastapi/blob/master/fastapi/applications.py), or by reading the (very-long) [discussion on discuss.python.org](https://discuss.python.org/t/pep-727-documentation-metadata-in-typing/32566/17). The PEP was actually written by FastAPI's author, Sebastián Ramírez.

PEP 727

```
from typing_extensions import Annotated, Doc


def greet(
    name: Annotated[str, Doc("The name to greet."),
    end: Annotated[str, Doc("The punctuation mark at the end.")] = "!",
) -> None:
    """Greet someone.

    > [!NOTE]
    > Greetings are cool!
    """ # (1)!
    print(f"Hey {name}{end}")

```

1. Here we use the [GitHub syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts) for a "note" callout. It assumes our documentation renderer supports this syntax. The point is that we rely purely on Markdown rather than docstrings styles.

## General tips

Your docstrings will typically be used to document your API, either on a deployed (static) website, or locally, on the command line or in a Python interpreter. Therefore, when writing your docstrings, you should address the right audience: the users of your code. Try to stay succinct and give clear examples. Docstrings are not really the place to explain architectural or technical decisions made while developing the project: this information, while extremely valuable, is better written in *code comments*, where the audience is other developers working on the code base.

Your docstrings will typically again be read online (HTML) or other types of documents such as manual pages or PDFs. Make sure to write complete sentences, with correct punctuation. That means for example, to start each parameter description with a capital letter, and to end it with a period.

When documenting objects acting as namespaces (modules, classes, enumerations), prefer documenting each attribute separately than with an Attributes section in the namespace object docstring. For example, add a docstring to each enumeration value rather than describing each value in the docstring of the enumeration class.

## Modules

Module docstrings should briefly explain what the module contains, and for what purposes these objects can be used. If the documentation generator you chose does not support generating member summaries automatically, you might want to add docstrings sections for attributes, functions, classes, type aliases and submodules.

package/__init__.py

```
"""A generic package to demonstrate docstrings.

This package does not really exist, and is only used as a demonstration purpose for docstrings.
Anyway, this package contains the following API, exposed directly at the top-level,
meaning you can import everything from `package` directly.

Attributes:
    ghost: A ghost wandering in this desolated land.
    dummy: A dummy you can practice on. Not for ghosts.

Classes:
    Ghost: Ah, so this is where our ghost comes from.
        Maybe create some additional ghosts so they can pass the time together?

Functions:
    deploy(): Deploy something on the web (we're not sure what exactly).
"""

```

Do the same thing for every other module of the package, except if you are [hiding your module layout](../public-apis/#module-layout).

## Classes, methods, properties

Class docstrings follow the same logic as module docstrings. Explain what the class is used for, and maybe show a few of its attributes and methods thanks to sections of the same name. A class is already more concrete than a module, so we can maybe start adding usage examples too. Such examples should only show how to create instances of the class. Examples of use for methods can be written in each respective method.

```
class Ghost:
    """Ghosts that wander the earth.

    Ghosts are meant to... we're actually unsure.
    All we know is that, as a user, you might find it amusing to instantiate
    a few of them and put them together to see what they do.

    Methods:
        wander: Wander the earth.
        spook: Spook living organisms.
        pass_through: Pass through anything.

    Examples:
        Create a new ghost with a cool nickname:

        >>> ghost = Ghost(nickname="Rattlesnake")
    """

    def wander(self) -> None:
        """Wander the earth.

        That's it, really.

        Examples:
            >>> ghost.wander()
        """
        ...

    @property
    def weight(self) -> int:
        """The ghost's weight (spoiler: it's close to 0)."""
        ...

```

Note that blocks of lines starting with `>>>` or `...` are automatically parsed as code blocks by Griffe, until a blank line is found. This only works in Examples (plural!) sections. If you rely on [Python-Markdown](https://python-markdown.github.io/) to convert Markdown to HTML (which is the case for MkDocs), you can use the [markdown-pycon](https://pawamoy.github.io/markdown-pycon/) extension to recognize such `pycon` code blocks anywhere, without having to wrap them in fences. You can also choose to use explicit fences everywhere:

````
    """
    Examples:
        Create a new ghost with a cool nickname:

        ```pycon
        >>> ghost = Ghost(nickname="Rattlesnake")
        ```
    """

````

## Functions

Function and method docstrings will typically describe their parameters and return values. For generators, it's also possible to describe what the generator yields and what it can receive, though the latter is not often used.

```
import datetime
from typing import Generator, Iterator


class GhostOlympicGames:
    ...


class GOGTicket:
    ...


def organize_gog(date: datetime.date) -> GhostOlympicGames:
    """Organize Olympic Games for Ghosts.

    The ghost world is much simpler than the living world,
    so it's super easy to organize big events like this.

    Parameters:
        date: The date of the games.

    Returns:
        The prepared games.
    """
    ...


def yield_athletes(quantity: int) -> Iterator[Ghost]:
    """Yield a certain quantity of athletes.

    Parameters:
        quantity: How many ghost athletes you want.

    Yields:
        Ghost athletes. They're just regular ghosts.
    """
    ...



def gog_tickets_factory() -> Generator[GOGTicket, int, None]:
    """Generate tickets for the GOG.

    We value fairness: tickets are priced randomly.
    Unless we send a specific price to the generator.

    Yields:
        Tickets for the games.

    Receives:
        Price for the next ticket, in ghost money (???).
    """
    ...

```

## Attributes

Attribute docstrings are written below their assignment. As usual, they should have a short summary, and an optional, longer body.

```
GHOST_MASS_CONSTANT: float = 1e-100
"""The ghost mass constant.

This is a very small number. Use it scientifically
for all ghost-related things.

Note:
    There is actually nothing scientific about any of this.
""" # (1)!

```

1. Our `Note` section here is parsed as an admonition. See [Google-style admonitions](../../../../reference/docstrings/#google-admonitions) for reference.

Class and instance attributes can be documented the same way:

```
class GhostTown:
    instances: str
    """All the existing towns."""

    def __init__(self, name: str, size: int) -> None:
        self.name = name
        """The town's name."""

        self.size = size
        """The town's size."""

```

## Type aliases

Type alias docstrings are written below their assignment. As usual, they should have a short summary, and an optional, longer body.

```
type Callback = typing.Callable[[int, str], typing.Any]
"""Callback type for Frobnicators.

The first argument is the number of rounds to run, the second argument
is the name of the widget being frobnicated.
"""

```

## Exceptions, warnings

Callables that raise exceptions or emit warnings can document each of these exceptions and warnings. Documenting them informs your users that they could or should catch the raised exceptions, or that they could filter or configure warnings differently. The description next to each exception or warning should explain how or when they are raised or emitted.

```
def verify_spirit_chest():
    """Do a verification routine on the spirit chest.

    Raises:
        OverflowError: When the verification failed
            and all the ghosts escaped from the spirit chest.
    """
    ...


def negotiate_return_to_the_spirit_chest():
    """Negotiate with ghost for them to return in the spirit chest.

    Warns:
        ResourceWarning: When the ghosts refuse to go back in the chest
            because the chest is too tight.
    """
    ...

```

## Going further

There are more sections and more features to discover and use. For a complete reference on docstring styles syntax, see our [reference](../../../../reference/docstrings/).

# Public APIs

## What is a public API?

An API (Application Programming Interface) in the interface with which developers interact with your software. In the Python world, the API of your Python library is the set of modules, classes, functions and other attributes made available to your users. For example, users can do `from your_library import this_function`: `this_function` is part of the API of `your_library`.

Oftentimes, when you develop a library, you create functions, classes, etc. that are only useful internally: they are not supposed to be used by your users. Python does not provide easy or standard ways to actually *prevent* users from using internal objects, so, to distinguish public objects from internal objects, we usually rely on conventions, such as prefixing internal objects' names with an underscore, for example `def _internal_function(): ...`, to mark them as "internal".

Prefixing an object's name with an underscore still does not prevent users from importing and using this object, but it *informs* them that they are not supposed to import and use it, and that this object might change or even disappear in the future, *without notice*.

On the other hand, public objects are supposed to stay compatible with previous versions of your library for at least a definite amount of time, to prevent downstream code from breaking. Any change that could break downstream code is supposed to be communicated *before* it is actually released. Maintainers of the library usually allow a period of time where the public object can still be used as before, but will emit deprecation warnings when doing so, hinting users that they should upgrade their use of the object (or use another object that will replace it). This period of time is usually called a deprecation period.

So, how do we mark an object as public? How do we inform our users which objects can safely be used, and which ones are subject to unnotified changes? Usually, we rely again on the underscore prefix convention: if an object isn't prefixed with an underscore, it means that it is public. But essentially, your public API is what you say it is. If you clearly document that a single function of your package is public, and that all others are subject to unnotified changes and whose usage by users is not supported, then your public API is composed of this single function, and nothing else. **Public APIs are a matter of communication.** Concretely, it's about deciding what parts of your code base are public, and communicating that clearly.

Some components are obviously considered for the public API of a Python package:

- the module layout
- functions and their signature
- classes (their inheritance), their methods and signatures
- the rest of the module or class attributes, their types and values

Other components *should* be considered for the public API but are often forgotten:

- CLI options: see [The CLI is API too](#the-cli-is-api-too) section
- logger names: users might rely on them to filter logs (see [Logger names](#logger-names))
- exceptions raised: users definitely rely on them to catch errors

Other components *could* be considered for the public API, but usually require too much maintenance:

- logging messages: users might rely on them to grep the logs
- exception messages: users might rely on them for various things

Besides, logging and exception messages simply cannot allow deprecation periods where both old and new messages are emitted. Maintainers could however consider adding unique, short codes to messages for more robust consumption.

Our recommendation — Communicate your public API, verify what you can.

Take the time to learn about and use ways to declare, communicate and deprecate your public API. Your users will have an easier time using your library. On the maintenance side, you won't get bug reports for uses that are not supported, or you will be able to quickly close them by pointing at the documentation explaining what your public API is, or why something was deprecated, for how long, and how to upgrade.

Automate verifications around your public API with tools like Griffe. Currently Griffe doesn't support checking CLI configuration options, logger names or raised exceptions. If you have the capacity to, verify these manually before each release. [Griffe checks](../../checking/) and [API rules enforcement](#ensuring-api-rules) are a very good starting point.

## Conventions

Python does not provide any standard way to declare public APIs. However we do have official recommendations and a few conventions.

### Underscore prefix

In the Python ecosystem we very often prefix objects with an underscore to mark them as internal, or private. Objects that are not prefixed are then implicitly considered public. For example:

```
def public_function():
    ...

def _internal_function():
    ...

```

The exception to this rule is that imported objects are not considered public. For example:

```
from elsewhere import something

```

Even though `something` doesn't start with an underscore, it was imported so it is not considered public.

### `__all__` list

There is another convention that lets you do the opposite: explicitly mark objects as public. This convention uses the `__all__` module-level attribute, which is a list of strings containing the names of the public objects.

package/module.py

```
__all__ [
    "this_function",
    "ThisClass",
]

def this_function():
    ...

def this_other_function():
    ...

class ThisClass:
    ...

class ThisOtherClass:
    ...

```

Here, even though `this_other_function` and `ThisOtherClass` are *not* prefixed with underscores, they are not considered public, because we explicitly and only marked `this_function` and `ThisClass` as public.

Declaring `__all__` has another beneficial effect: it affects wildcard imports. When your users use wildcard imports to import things from one of your modules, Python will only import the objects that are listed in `__all__`. Without `__all__`, it would import all objects that are not prefixed with an underscore, *including objects already imported from elsewhere*. This can cause serious namespace pollution, and even slow down Python code when wildcard imports are chained. [We actually recommend avoiding wildcard imports](../python-code/#avoid-wildcard-imports).

By declaring `__all__`, your public API becomes explicit, and explicit is better than implicit. But `__all__` only works for module-level objects. Within classes, you will still have to rely on the underscore prefix convention to mark methods or attributes as internal/private.

```
class Thing:
    def public_method(self):
        ...

    def _internal_method(self):
        ...

```

### Redundant aliases

When you expose your public API in `__init__` modules by importing most objects from the underlying modules, it can be a bit tedious to import everything, and then list everything again in the `__all__` list attribute. For this reason, another convention emerged where objects imported and aliased with the same name are considered public.

my_package/__init__.py

```
from elsewhere import something as something
from my_package._internal_module import Thing as Thing

```

Here `Thing` and `something` are considered public even though they were imported. If `__all__` was defined, it would take precedence and redundant aliases wouldn't apply.

### Wildcard imports

Same as for redundant aliases, this convention says that all objects imported thanks to wildcard imports are public. This can again be useful in `__init__` modules where you expose lots of objects declared in submodules.

my_package/__init__.py

```
from my_package._internal_module1 import *
from my_package._internal_module2 import *

```

Note that the wildcard imports logic stays the same, and imports either all objects that do not start with an underscore (imported objects included!), or all objects listed in `__all__` if it is defined. It doesn't care about other conventions such as redundant aliases, or the wildcard imports convention itself.

______________________________________________________________________

Our recommendation — Use the underscore prefix and `__all__` conventions.

Use both the underscore prefix convention for consistent naming at module and class levels, and the `__all__` convention for declaring your public API. We do not recommend using the redundant aliases convention, because it doesn't provide any information at runtime. We do not recommend the wildcard import convention either, for the same reason and [for additional reasons mentioned here](../python-code/#avoid-wildcard-imports). We still provide the [`griffe-public-redundant-aliases`](https://mkdocstrings.github.io/griffe-public-redundant-aliases/) and [`griffe-public-wildcard-imports`](https://mkdocstrings.github.io/griffe-public-wildcard-imports/) extensions for those who would still like to rely on these conventions.

Our recommendation matches [PEP 8](https://peps.python.org/pep-0008/#public-and-internal-interfaces):

> To better support introspection, modules should explicitly declare the names in their public API using the `__all__` attribute. Setting `__all__` to an empty list indicates that the module has no public API.
>
> Even with `__all__` set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore.

Concatenating `__all__` for easier maintenance of `__init__` modules.

If you worry about maintenance of your `__init__` modules, know that you can very well concatenate `__all__` lists from submodules into the current one:

```
📁 my_package/
├──  __init__.py
├──  module.py
├── 📁 subpackage1/
│   ├──  __init__.py
│   └──  _module1a.py
└── 📁 subpackage2/
    ├──  __init__.py
    └──  _module2a.py

```

my_package/subpackage1/__init__.py

```
from my_package.subpackage1.module1a import this1a, that1a

__all__ = ["this1a", "that1a"]

```

my_package/subpackage2/__init__.py

```
from my_package.subpackage2.module2a import this2a, that2a

__all__ = ["this2a", "that2a"]

```

my_package/__init__.py

```
from my_package.module import this
from my_package.subpackage1 import this1a, that1a, __all__ as subpackage1_all
from my_package.subpackage2 import this2a, that2a, __all__ as subpackage2_all

__all__ = ["this", *subpackage1_all, *subpackage2_all]

# Griffe supports the `+` and `+=` operators too:
# __all__ = ["this"] + subpackage1_all + subpackage2_all
# __all__ = ["this"]; __all__ += subpackage1_all; __all__ += subpackage2_all 

```

However we would argue that `this1a`, `that1a`, `this2a` and `that2a` should not be exposed publicly in more than one location. See our section on [unique names and public locations](#unique-names-and-public-locations).

## Module layout

We usually split the code of our packages into different modules. The code can be split according to domains, types of objects, logic, etc.: we don't have any recommendation on that. However, your package layout is part of your API, so it should be taken into account when deciding what you expose as your public API.

Most of the time, packages implicitly expose their module layout in their public API. Indeed, when you start a new project, you create new modules but don't immediately think about making them private. Then the project grows organically, you add more modules, and users start actually relying on their layout, importing specific objects from specific modules. Now when you want to move objects around, to reorganize your layout, you introduce breaking changes. So you have to create a deprecation period where objects that moved around are still importable in the old locations, but emit deprecation warnings. A module-level `__getattr__` function is commonly used for that.

package/old_module.py

```
import warnings
from typing import Any

def __getattr__(name: str) -> Any:
    if name == "my_object":
        warnings.warn(
            "Importing `my_object` from `old_module` is deprecated, import it from `new_module` instead.",
            DeprecationWarning,
            stacklevel=2,
        )

        from package.new_module import my_object

        return my_object

    raise AttributeError(f"module 'old_module' has no attribute '{name}'")

```

Such changes sometimes go unnoticed before the breaking change is released, because users don't enable deprecation warnings. These changes can also be confusing to users when they do notice the warnings: maybe they don't use the deprecated import themselves, and are not sure where to report the deprecated use. These changes also require time to upgrade, and time to maintain.

What if we could make this easier?

By hiding your module layout from your public API, you're removing all these pain points at once. Any object can freely move around without ever impacting users. Maintainers do not need to set deprecation periods where old and new uses are supported, or bump the major part of their semantic version when they stop supporting the old use. Hiding the module layout also removes the ambiguity of whether a submodule is considered public or not: [PEP 8](https://peps.python.org/pep-0008/#public-and-internal-interfaces) doesn't mention anything about it, and it doesn't look like the `__all__` convention expects developers to list their submodules too. In the end it looks like submodules are only subject to the underscore prefix convention.

So, how do we hide the module layout from the public API?

The most common way to hide the module layout is to make all your modules private, by prefixing their name with an underscore:

```
📁 my_package/
├──  __init__.py
├──  _combat.py
├──  _exploration.py
└──  _sorcery.py

```

Then, you expose public objects in the top-level `__init__` module thanks to its `__all__` attribute:

my_package/__init__.py

```
from my_package._combat import Combat
from my_package._exploration import navigate
from my_package._sorcery import cast_spell

__all__ [
    "Combat",
    "navigate",
    "cast_spell",
]

```

Now, if you want to move `cast_spell` into the `_combat` module, you can do so without impacting users. You can even rename your modules. All you have to do when doing so is update your top-level `__init__` module to import the objects from the right locations.

If you have more than one layer of submodules, you don't have to make the next layer private: only the first one is enough, as it informs users that they shouldn't import from this layer anyway:

```
📁 my_package/
├──  __init__.py
├──  _combat.py
├──  _exploration.py
└── 📁 _sorcery/
    ├──  __init__.py
    ├──  dark.py
    └──  light.py

```

If you don't want to bother prefixing every module with an underscore, you could go one step further and do one of these two things:

- move everything into an `_internal` directory:

  ```
  📁 my_package/
  ├──  __init__.py
  └── 📁 _internal/
      ├──  __init__.py
      ├──  combat.py
      ├──  exploration.py
      └── 📁 sorcery/
          ├──  __init__.py
          ├──  dark.py
          └──  light.py

  ```

- or move everything into a private package:

  ```
  📁 my_package/
  └──  __init__.py
  📁 _my_package/
  ├──  __init__.py
  ├──  combat.py
  ├──  exploration.py
  └── 📁 sorcery/
      ├──  __init__.py
      ├──  dark.py
      └──  light.py

  ```

Whatever *hidden* layout you choose (private modules, internals, private package), it is not very important, as you will be able to switch from one to another easily. In Griffe we chose to experiment and go with the private package approach. This highlighted a few shortcomings that we were able to address in both Griffe and mkdocstrings-python. We later moved the private package under an internal folder.

Top-level-only exposition doesn't play well with large packages.

The *fully* hidden layout plays well with small to medium projects. If you maintain a large project, it can become very impractical for both you and your users to expose every single object in the top-level `__init__` module. For large projects, it therefore makes sense to keep at least one or two additional public layers in your module layout. Sometimes packages also implement many variations of the same abstract class, using the same name in many different modules: in these cases, the modules are effective namespaces that could be kept in the public API.

Our recommendation — Hide your module layout early.

Start hiding your module layout early! It is much easier to (partially) expose the layout later than to hide it after your users started relying on it. It will also make code reorganizations much easier.

## Unique names and public locations

Whether or not you are planning to hide your module layout, as recommended in the previous section, one thing that will help both you and your users is making sure your object names are unique across your code base. Having unique names ensures that you can expose everything at the top-level module of your package without having to alias objects (using `from ... import x as y`). It will also ensure that your users don't end up importing multiple different objects with the same name, again having to alias them. Finally, it forces you to use meaningful names for your objects, names that don't need the context of the above namespaces (generally modules) to understand what they mean. For example, in Griffe we previously exposed `griffe.docstrings.utils.warning`. Exposing `warning` at the top-level made it very vague: what does it do? So we renamed it `docstring_warning`, which is much clearer.

Ensuring unique names across a code base is sometimes not feasible, or not desirable; in this case, try to use namespacing while still hiding the module layout the best you can.

In accordance with our recommendation on module layouts, it is also useful to ensure that a single public object is exposed in a single location. Ensuring a unique public location for each object removes any ambiguity on the user side as to where to import the object from. It also helps documentation generators that try to cross-reference objects: with several locations, they cannot know for sure which one is the best to reference (which path is best to use and display in the generated documentation). With a fully hidden layout, all objects are *only* exposed in the top-level module, so there is no ambiguity. With partially hidden layouts, or completely public layouts, make sure to declare your public API so that each object is only exposed in a single location. Example:

```
📁 my_package/
├──  __init__.py
└──  module.py

```

Here the `Hello` class is exposed in both `my_package.module` and `my_package`.

my_package/module.py

```
__all__ ["Hello"]

class Hello:
    ...

```

my_package/__init__

```
from my_package.module import Hello

__all__ = ["Hello"]

```

Here the `Hello` class is only exposed in `my_package.module`.

my_package/module.py

```
__all__ ["Hello"]

class Hello:
    ...

```

my_package/__init__

```
# Nothing to see here.

```

If you wanted to expose it in the top-level `__init__` module instead, then you should hide your module layout by making `module.py` private, renaming it `_module.py`, or using other hiding techniques such as described in the [Module layout](#module-layout) section.

Here the `Hello` class is only exposed in `package`.

my_package/module.py

```
__all__ = []

class Hello:
    ...

```

my_package/__init__

```
from my_package.module import Hello

__all__ = ["Hello"]

```

It feels weird to "unpublicize" the `Hello` class in `my_package.module` by declaring an empty `__all__`, so maybe the module should be made private instead: `my_package/_module.py`. See other hiding techniques in the [Module layout](#module-layout) section.

Our recommendation — Expose public objects in single locations, use meaningful names.

We recommend making sure that each public object is exposed in a single location. Ensuring unique names might be more tricky depending on the code base, so we recommend ensuring meaningful names at least, not requiring the context of modules above to understand what the objects are for.

## Logger names

The documentation of the standard `logging` library recommends to use `__name__` as logger name when obtaining a logger with `logging.getLogger()`, *unless we have a specific reason for not doing that*. Unfortunately, no examples of such specific reasons are given. So let us give one.

Using `__name__` as logger names means that your loggers have the same name as your module paths. For example, the module `package/module.py`, whose path and `__name__` value are `package.module`, will have a logger with the same name, i.e. `package.module`. If your module layout is public, that's fine: renaming the module or moving it around is already a breaking change that you must document.

However if your module layout is hidden, or if this particular module is private, then even though renaming it or moving it around is *not* breaking change, the change of name of its logger *is*. Indeed, by renaming your module (or moving it), you changed its `__name__` value, and therefore you changed its logger name.

Now, users that were relying on this name (for example to silence WARNING-level logs and below coming from this particular module) will see their logic break without any error and without any deprecation warning.

```
# For example, the following would have zero effect if `_module` was renamed `_other_module`.
package_module_logger = logging.getLogger("package._module")
package_module_logger.setLevel(logging.ERROR)

```

Could we emit a deprecation warning when users obtain the logger with the old name? Unfortunately, there is no standard way to do that. This would require patching `logging.getLogger`, which means it would only work when users actually use this method, in a Python interpreter, and not for all the other ways logging can be configured (configuration files, configuration dicts, etc.).

Since it is essentially impossible to deprecate a logger name, we recommend to avoid using `__name__` as logger name, at the very least in private modules.

Our recommendation — Use a single logger.

Absolutely avoid using `__name__` as logger name in private modules. If your module layout is hidden, or does not matter for logging purposes, just use the same logger everywhere by using your package name as logger name. Example: `logger = logging.getLogger("griffe")`. Show your users how to temporarily alter your global logger (typically with context managers) so that altering subloggers becomes unnecessary. Maybe even provide the utilities to do that.

## Documentation

Obviously, your public API should be documented. Each object should have a docstring that explains why the object is useful and how it is used. More on that in our [docstrings recommendations](../docstrings/). Docstrings work well for offline documentation; we recommend exposing your public API online too, for example with [MkDocs](https://www.mkdocs.org/) and [mkdocstrings' Python handler](https://mkdocstrings.github.io/python/), or with other SSGs (Static Site Generators). Prefer a tool that is able to create a [Sphinx-like](https://sphobjinv.readthedocs.io/en/stable/syntax.html) inventory of objects (an `objects.inv` file) that will allow other projects to easily cross-reference your API from their own documentation. Make sure each and every object of your public API is documented in your web docs and therefore added to the objects inventory (and maybe that nothing else is added to this inventory as "public API").

Our recommendation — Document your public API extensively.

Write docstrings for each and every object of your public API. Deploy online documentation where each object is documented and added to an object inventory that can be consumed by third-party projects. If you find yourself reluctant to document a public object, it means that this object should maybe be internal instead.

Our documentation framework of choice is of course [MkDocs](https://www.mkdocs.org) combined with our [mkdocstrings](https://mkdocstrings.github.io/) plugin.

## Ensuring API rules

If you already follow some of these recommendations, or if you decide to start following them, it might be a good idea to make sure that these recommendations keep being followed as your code base evolves. The intent of these recommendations, or "rules", can be captured in tests relatively easily thanks to Griffe.

We invite you to check out our own test file: [`test_internals.py`](https://github.com/mkdocstrings/griffe/blob/main/tests/test_internals.py). This test module asserts several things:

- all public objects are exposed in the top-level `griffe` module
- all public objects have unique names
- all public objects have single locations
- all public objects are added to the inventory (which means they are documented in our API docs)
- no private object is added to the inventory

Our recommendation — Test your API declaration early.

The sooner you test your API declaration, the better your code base will evolve. This will force you to really think about how your API is exposed to your users. This will prevent mistakes like leaving a new object as public while you don't want users to start relying on it, or forgetting to expose a public object in your top-level module or to document it in your API docs.

## Linters

Depending on their configuration, many popular Python linters will warn you that you access or import private objects. This doesn't play well with hidden module layouts, where modules are private or moved under a private (sub-)package. Sometimes it doesn't even play well with private methods

Our recommendation — Ignore "protected access" warnings for your own package, or make the warnings smarter.

To users of linters, we recommend adding `# noqa` comments on the relevant code lines, or globally disabling warnings related to "private object access" if per-line exclusion requires too much maintenance.

To authors of linters, we recommend (if possible) making these warnings smarter: they shouldn't be triggered when private objects are accessed from within the *same package*. Marking objects as private is meant to prevent downstream code from using them, not to prevent the developers of the current package themselves from using them: they know what they are doing and should be allowed to use their own private objects without warnings. At the same time, they don't want to disable these warnings *globally*, so the warnings should be derived in multiple versions, or made smarter.

## The CLI is API too

This section deserves an entire article, but we will try to stay succinct here.

Generally, we distinguish the API (Application Programming Interface) from the CLI (Command Line Interface), TUI (Textual User Interface) or GUI (Graphical User Interface). Contrary to TUIs or GUIs which are not likely to be controlled programmatically (they typically work with keyboard and mouse inputs), the CLI can easily be called by various scripts or programs, including from Python programs.

Even if a project was not designed to be used programmatically (doesn't expose a public API), it is *a certainty* that with enough popularity, it *will* be used programmatically. And the CLI will even more so be used programmatically if there is no API. Even if there is an API, sometimes it makes more sense to hook into the CLI rather than the API (cross-language integrations, wrappers, etc.).

Therefore, we urge everyone to consider their CLI as an API too. We urge everyone to always design their project as library-first APIs rather than CLI-first tools.

The first user of your CLI as API is... you. When you declare your project's CLI entrypoint in pyproject.toml:

```
[project.scripts]
griffe = "griffe:main"

```

...this entrypoint ends up as a Python script in the `bin` directory of your virtual environment:

```
#!/media/data/dev/griffe/.venv/bin/python
# -*- coding: utf-8 -*-
import re
import sys
from griffe import main
if __name__ == "__main__":
    sys.argv[0] = re.sub(r"(-script\.pyw|\.exe)?$", "", sys.argv[0])
    sys.exit(main())

```

In this script, we find our entrypoint, `griffe.main`, used programmatically.

______________________________________________________________________

The second user of your CLI as API is... you again. When you write tests for your CLI, you import your entrypoints and call them by passing CLI options and arguments, maybe asserting the exit code raised with a `SystemExit` or the standard output/error thanks to [pytest's capture fixtures](https://docs.pytest.org/en/6.2.x/capture.html). Some simplified examples from our own test suite:

tests/test_cli.py

```
import pytest
import griffe


def test_main() -> None:
    assert griffe.main(["dump", "griffe", "-s", "src", "-o/dev/null"]) == 0


def test_show_help(capsys: pytest.CaptureFixture) -> None:
    with pytest.raises(SystemExit):
        griffe.main(["-h"])
    captured = capsys.readouterr()
    assert "griffe" in captured.out


def test_show_version(capsys: pytest.CaptureFixture) -> None:
    with pytest.raises(SystemExit):
        griffe.main(["-V"])
    captured = capsys.readouterr()
    assert griffe.get_version() in captured.out

```

Now, when you start testing the logic of your CLI subcommands, such as our `dump` subcommand above, you might feel like passing again and again through the command-line arguments parser (here `argparse`) is wasteful and redundant. It is important to test that your arguments are parsed correctly (as you expect them to be parsed), but they shouldn't *have* to be parsed when you are testing the underlying logic.

It's a hint that your command-line arguments parsing (and command-line handling generally) should be *decoupled* from the logic below it: write functions with proper parameters! Then call these functions from your main CLI entrypoint, with the arguments obtained from parsing the command-line arguments and options. It will make testing and debugging much, much easier:

```
import argparse
import sys


def dump(...):
    ...


def main(args: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(...)
    opts = parser.parse_args(args)
    if opts.subcommand == "dump":
        return dump(opts.arg1, opts.arg2, ...)
    elif ...

    print(f"Unknown subcommand {opts.subcommand}", file=sys.stderr)
    return 1

```

Now instead of having to call `main(["dump", "..."])` in your tests, you can directly call `dump(...)`, with all the benefits from static-typing and your IDE features, such as autocompletion, linting, etc..

______________________________________________________________________

The third and next users of your CLI as API are your users: just as you made your own life easier, you made their life easier for when they want to call some subcommands of your tool programmatically. No more messing with lists of strings without autocompletion or linting, no more patching of `sys.argv`, no more following the maze of transformations applied by this fancy CLI framework before finally reaching the crux of the subcommand you want to call, no more trying to replicate these transformations yourself with the CLI framework's API to avoid copy-pasting the dozens of lines you're only interested in.

Our recommendation — Decouple command-line parsing from your CLI entrypoints.

Do not tie the command parsing logic with your program's logic. Create functions early, make them accept arguments using basic types (`int`, `str`, `list`, etc.) so that your users can call your main command or subcommands with a single import and single statement. Do not encode all the logic in a single big `main` function. Decoupling the CLI-parsing logic from your entrypoints will make them much easier to test and use programmatically. Consider your entrypoints part of your API!

Our CLI framework of choice is [Cappa](https://pypi.org/project/cappa/).

## Deprecations

With time, the code base of your project evolves. You add features, you fix bugs, and you generally reorganize code. Some of these changes might make your project's public API incompatible with previous versions. In that case, you usually have to "deprecate" previous usage in favor of the new usage. That means you have to support both, and emit deprecation warnings when old usage is detected.

There are many different ways of deprecating previous usage of code, which depend on the change itself. We invite you to read our [Checking APIs](../../checking/) chapter, which describes all the API changes Griffe is able to detect, and provides hints on how to allow deprecation periods for each kind of change.

In addition to emitting deprecation warnings, you should also update the docstrings and documentation for the old usage to point at the new usage, add "deprecated" labels where possible, and mark objects as deprecated when possible.

Our recommendation — Allow a deprecation period, document deprecations.

Try allowing deprecation periods for every breaking change. Most changes can be made backward-compatible at the cost of writing legacy code. Use tools like [Yore](https://pawamoy.github.io/yore) to manage legacy code, and standard utilities like warnings.deprecated to mark objects as deprecated. Griffe extensions such as [griffe-warnings-deprecated](https://mkdocstrings.github.io/griffe-warnings-deprecated/) can help you by dynamically augmenting docstrings for your API documentation.

## Third-party libraries

A few third-party libraries directly or indirectly related to public APIs deserve to be mentioned here.

[public](https://pypi.org/project/public/) lets you decorate objects with `@public.add` to dynamically add them to `__all__`, so that you don't have to build a list of strings yourself. The "public visibility" marker is closer to each object, and might help avoid mistakes like forgetting to update `__all__` when an object is removed or renamed.

[modul](https://pypi.org/project/modul/), from Frost Ming, the author of [PDM](https://pdm-project.org/en/latest/), goes one step further and actually hides attributes that are not marked "exported" from users: they won't be able to access un-exported attributes, leaving *only* the public API visible.

[Deprecated](https://pypi.org/project/Deprecated/), which was probably a source of inspiration for [PEP 702](https://peps.python.org/pep-0702/), allows decorating objects with `@deprecated` to mark them as deprecated. Such decorated callables will emit deprecation warnings when called. PEP 702's `warnings.deprecated` could be seen as its successor, bringing the feature directly into the standard library so that type checkers and other static analysis tools can converge on this way to mark objects as deprecated.

[slothy](https://pypi.org/project/slothy/), which is less directly related to public APIs, but useful for the case where you are hiding your modules layout and exposing all your public API from the top-level `__init__` module. Depending on the size of your public API, and the time it takes to import everything (memory initializations, etc.), it might be interesting to make all these imports *lazy*. With a lazily imported public API, users who are only interested in a few objects of your public API won't have to pay the price of importing everything.

# Python code best practices

This document describes some best practices to adopt when using Griffe, or when writing Python code that will be analyzed by Griffe.

## Avoid member-submodule name shadowing

Sometimes we find that an `__init__` module defines or imports an object which has the same name as a submodule of the parent package.

**Case 1**

```
📁 package/
├──  __init__.py
└── 📁 subpackage/
    ├──  __init__.py
    └──  thing.py

```

package/subpackage/__init__.py

```
thing = "thing from init module"

```

package/subpackage/thing.py

```
other_thing = "other thing from thing submodule"

```

We recommend not doing that.

Why? Because the `package.subpackage.thing` submodule can eventually **shadow** the `package.subpackage.thing` attribute. Try this:

```
# Replicate the file tree from above.
mkdir -p package/subpackage
echo 'thing = "thing from init module"' > package/subpackage/__init__.py
echo 'other_thing = "other thing from thing submodule"' > package/subpackage/thing.py
# Run a Python interpreter.
python

```

```
>>> from package import subpackage
>>> subpackage.thing
'thing from init module'
>>> # OK, but...
>>> from package.subpackage.thing import other_thing
>>> subpackage.thing
<module 'package.subpackage.thing' from 'package/subpackage/thing.py'>

```

By simply importing from the `thing` submodule, the `thing` attribute of `subpackage` was overwritten by the `thing` submodule.

**Case 2**

In a particular case though, the situation improves: if we *import* `thing` in the init module instead of declaring it, then further imports will not overwrite anything:

package/subpackage/__init__.py

```
from package.subpackage.thing import thing

```

package/subpackage/thing.py

```
thing = "thing from thing submodule"

```

```
# Update the modules.
echo 'from package.subpackage.thing import thing' > package/subpackage/__init__.py
echo 'thing = "thing from thing submodule"' > package/subpackage/thing.py
# Run a Python interpreter.
python

```

```
>>> from package import subpackage
>>> subpackage.thing
'thing from thing'
>>> # OK
>>> from package.subpackage.thing import thing
>>> subpackage.thing
'thing from thing'
>>> # Still OK

```

From an API perspective, and given that both cases are very similar but differ in behavior, we recommend not doing that either.

If the goal is to isolate a single object into its own module, to then expose it in the parent module, then it would make sense that this object is the only object of the submodule to be exposed in the public API, and therefore the submodule could be marked as private by prefixing its name with an underscore:

```
📁 package/
├──  __init__.py
└── 📁 subpackage/
    ├──  __init__.py
    └──  _thing.py

```

With this, there is no ambiguity as to what `subpackage.thing` points to.

For the reasons mentioned above, **Griffe does not support this kind of name shadowing.** During static analysis, the submodule will take precedence over the attribute. During dynamic analysis, Griffe's behavior is undefined.

## Avoid wildcard imports

Wildcard imports allow importing from a module all objects that do not start with an underscore `_`, or all objects that are listed in the module's `__all__` attribute, if it is defined.

```
📁 package/
├──  __init__.py
└──  module.py

```

**Explicitly exposed to wildcard imports**

package/module.py

```
__all__ = [
    "SomeClass",
    "some_function",
    "some_attribute",
]

class SomeClass: ...
class SomeOtherClass: ...

def some_function(): ...
def some_other_function(): ...

some_attribute = 0
some_other_attribute = 1

```

**Implicitly exposed to wildcard imports**

package/module.py

```
class SomeClass: ...
class _SomeOtherClass: ...

def some_function(): ...
def _some_other_function(): ...

some_attribute = 0
_some_other_attribute = 1

```

In both cases, using a wildcard import will only import `SomeClass`, `some_function` and `some_attribute`, and not their "other" counterparts:

package/__init__.py

```
from package.module import *

```

While we recommend declaring your public API with `__all__` lists, we do not recommend using wildcard imports.

In the implicit case, any other object imported in `module.py` will also be exported by the wildcard:

package/module.py

```
from somewhere_else import this, that

class SomeClass: ...
class _SomeOtherClass: ...

def some_function(): ...
def _some_other_function(): ...

some_attribute = 0
_some_other_attribute = 1

```

Here, `this` and `that` will also be imported when we do `from package.module import *`. To prevent that, we would have to alias these names as such:

package/module.py

```
from somewhere_else import this as _this, that as _that

```

...which is not ideal.

It gets even worse if `module.py` itself uses wildcard imports:

package/module.py

```
from somewhere_else import *

```

Now using `from package.module import *` will import all objects that do not start with an underscore declared in the module, but also all the objects imported by it that do not start with an underscore, and also all the objects imported by the modules of the imported objects that do not start with an underscore, etc., recursively. Soon enough, we end up with dozens and dozens of objects exposed in `package`, while just a few of them are useful/meaningful to users.

Not only that, but it also increases the risk of creating cycles in imports. Python can handle some of these cycles, but static analysis tools such as Griffe can have a much harder time trying to resolve them.

In the explicit case, the situation improves, as only the objects listed in `__all__` will be exported to the modules that wildcard imports them. It effectively stops namespace pollution, but it does not remove the risk of cyclic imports, only decreases it.

We have seen code bases where parent modules wildcard imports from submodules, while these submodules also wildcard imports from the parent modules... Python somehow handles this, but it is *hell* to handle statically, and it is just too error prone (cyclic imports, name shadowing, namespaces become dependent on the order of imports, etc.).

For these reasons, we recommend not using wildcard imports. Instead, we recommend declaring your public API explicitly with `__all__`, and combining `__all__` lists together if needed:

```
📁 package/
├──  __init__.py
├──  module.py
└──  other_module.py

```

Completely explicit:

package/__init__.py

```
from package.module import only, needed, objects
from package.other_module import some, more

__all__ = [
    "only",
    "needed",
    "some",
    "function",
]

def function(): ...

```

Combining `__all__` lists:

package/__init__.py

```
from package.module import only, needed, objects, __all__ as module_all
from package.other_module import some, more, __all__ as other_module_all

__all__ = [
    *module_all,
    *other_module_all,
    "function",
]

def function(): ...

```

Most Python linting tools allow you to forbid the use of wildcard imports.

## Prefer canonical imports

Within your own code base, we recommend using canonical imports. By canonical, we mean importing objects from the module they are declared in, and not from another module that also imports them.

Given the following tree:

```
📁 package/
├──  __init__.py
├──  module_a.py
└──  module_b.py

```

package/module_a.py

```
from package.module_b import thing

```

package/module_b.py

```
thing = True

```

Don't do that:

package/__init__.py

```
from package.module_a import thing  # Indirect import, bad.

```

Instead, do this:

package/__init__.py

```
from package.module_b import thing  # Canonical import, good.

```

______________________________________________________________________

We especially recommend canonical imports over indirect imports from sibling modules passing through the parent:

package/__init__.py

```
from package.module_a import thing  # Canonical import, good.

```

package/module_a.py

```
thing = True

```

package/module_b.py

```
from package import thing  # Indirect import passing through parent, bad.

# Do this instead:
from package.module_a import thing  # Canonical import, good.

```

______________________________________________________________________

Similarly, avoid exposing the API of external packages from your own package and recommending to use this indirect API.

package.py

```
import numpy as np

__all__ = ["np"]  # Bad.

# Recommending users to do `from package import np`
# or `import package; package.np.etc`: bad.

```

Instead, let users import Numpy themselves, with `import numpy as np`. This will help other analysis tools, for example to detect that Numpy is used directly and should therefore be listed as a dependency. To quote [PEP 8](https://peps.python.org/pep-0008/#public-and-internal-interfaces):

> Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module’s API, such as os.path or a package’s `__init__` module that exposes functionality from submodules.

Emphasis on *exposes functionality from submodules*: PEP 8 does not state *exposing functionality from external packages*.

______________________________________________________________________

Using canonical imports provides several benefits:

- it can reduce the risk of cyclic imports
- it can increase performance by reducing hoops and importing less things (for example by not passing through a parent module that imports many things from siblings modules)
- it makes the code more readable and easier to refactor (less indirections)
- it makes the life of static analysis tools easier (less indirections)

We recommend using the [canonical-imports](https://github.com/15r10nk/canonical-imports) tool to automatically rewrite your imports as canonical.

Note however that we recommend using public imports (importing from the "public" locations rather than the canonical ones) when:

- importing from other packages
- importing from your own package within your tests suite

Apply these recommendations at your discretion: there may be other special cases where it might not make sense to use canonical imports.

## Make your compiled objects tell their true location

Python modules can be written in other languages (C, C++, Rust) and compiled. To extract information from such compiled modules, we have to use dynamic analysis, since sources are not available.

A practice that seems common in projects including compiled modules in their distributions is to make the compiled modules private (prefix their names with an underscore), and to expose their objects from a public module higher-up in the module layout, for example by wildcard importing everything from it.

```
📁 package/
├──  __init__.py
├──  module.py
└──  _module.cpython-312-x86_64-linux-gnu.so

```

package/module.py

```
from package._module import *

```

Since the objects are exposed in `package.module` instead of `package._module`, developers sometimes decide to make their compiled objects lie about their location, and make them say that they are defined in `package.module` instead of `package._module`. Example:

```
>>> from package._module import MyObject
>>> MyObject.__module__
'package.module'

```

**Don't do that.**

When using dynamic analysis and inspecting modules, Griffe must distinguish objects that were declared in the inspected module from objects that were imported from other modules. The reason is that if we didn't care where objects come from, we could end up inspecting the same objects and their members again and again, since they can be imported in many places. This could lead to infinite loops, recursivity errors, and would generally decrease performance.

So, when Griffe inspects a member of the compiled `_module`, and this member lies and says it comes from `package.module`, Griffe thinks it was imported. It means that Griffe will record the object as an indirection, or alias, instead of visiting it in-place. But that is wrong: the object was actually declared in the module, and should not have been recorded as an indirection.

Fortunately, we were able to put some guard-rails in place, which means that the case above where the compiled and public modules have the same name, except for the leading underscore, is supported, and will not trigger errors. But other cases where modules have different names will trigger issues, and we have to special case them in Griffe itself, after issues are reported.

Please, use your framework features to correctly set the `__module__` attribute of your objects (functions, classes and their methods too) as their *canonical location*, not their public location or any other location in the final package.

For example with [PyO3](https://github.com/PyO3/pyo3):

```
// Your module is compiled and added as `_module` into `package`,
// but its objects are exposed in `package` or `package.module`.
// Set `module = "package._module"`, not `module = "package"` or `module = "package.module"`!
#[pyclass(name = "MyClass", module = "package._module")]
struct MyClass {
    // ...
}

```

Some modules of the standard library are guilty of this too, and do so inconsistently (`ast` and `_ast`, `io` and `_io`, depending on the Python version...). For this reason, when checking if an object was declared in the currently inspected module, Griffe ultimately considers that any qualified name is equal to itself with each component stripped from leading underscores:

```
a.b.c == _a.b.c
a.b.c == _a._b._c
a.__b._c == __a.b.c
...

```

When the qualified name of the object's parent module and the currently inspected module match like above, the object is inspected in-place (added as a member of the currently inspected module) instead of created as an alias.

## Avoid forward references in base classes

Python's type system will let you use forward references in generic types when they are used as base classes. For example:

```
from typing import TypeVar, Generic

T = TypeVar('T')


class Foo(Generic[T]):
    ...


class FooBar(Foo['Bar']):
    ...


class Bar:
    ...

```

```
class Foo[T]:
    ...


class FooBar(Foo['Bar']):
    ...


class Bar:
    ...

```

While Griffe will load this code without error, the `'Bar'` forward reference won't be resolved to the actual `Bar` class. As a consequence, downstream tools like documentation renderers won't be able to output a link to the `Bar` class. We therefore recommend to avoid using forward references in base classes, if possible.

Instead, you can try one of the following approach:

- declare or import the `Bar` class earlier

- declare a proper type:

  ```
  class Foo[T]:
      ...


  type TBar = Bar


  class FooBar(Foo[TBar]):
      ...


  class Bar:
      ...

  ```

- make `FooBar` generic again but with a default type:

  ```
  class Foo[T]:
      ...


  class FooBar[T=Bar](Foo[T]):
      ...


  class Bar:
      ...

  ```
# How-to

# Using Griffe as a docstring-parsing library

You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You just need to import the Docstring class. Then you can build a `Docstring` instance and call its `parse` method, choosing the parsing-style to use:

```
from griffe import Docstring

text = "Hello I'm a docstring!"
docstring = Docstring(text, lineno=1)
parsed = docstring.parse("google")

```

If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring:

```
from griffe import Docstring, Function, Parameters, Parameter, ParameterKind

function = Function(
    "func",
    parameters=Parameters(
        Parameter("param1", annotation="str", kind=ParameterKind.positional_or_keyword),
        Parameter("param2", annotation="int", kind=ParameterKind.keyword_only),
    ),
)
text = """
Hello I'm a docstring!

Parameters:
    param1: Description.
    param2: Description.
"""
docstring = Docstring(text, lineno=1, parent=function)
parsed = docstring.parse("google")

```

With this the parser will fetch the `str` and `int` annotations from the parent function's parameters.

# Inspecting specific objects

Griffe by default parses and visits your code (static analysis) instead of importing it and inspecting objects in memory (dynamic analysis). There are various reasons why static analysis is generally a better approach, but sometimes it is insufficient to handle particularly dynamic objects. When this happens and Griffe cannot handle specific objects, you have a few solutions:

1. enable dynamic analysis for the whole package
1. write a Griffe extension that dynamically handles just the problematic objects
1. write a Griffe extension that statically handles the objects

This document will help you achieve point 2.

Enabling dynamic analysis for whole packages is not recommended, but it can be useful to do it once and check the results, to see if our dynamic analysis agent is able to handle your code natively. Whether it is or not is not very important, you will be able to move onto creating an extension that will selectively inspect the relevant objects in any case. It could just be a bit more difficult in the latter case, and if you have trouble writing the extension we invite you to create a [Q&A discussion](https://github.com/mkdocstrings/griffe/discussions/categories/q-a) to get guidance.

______________________________________________________________________

Start by creating an extensions module (a simple Python file) somewhere in your repository, if you don't already have one. Within it, create an extension class:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

```

Make it accept configuration options by declaring an `__init__` method:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

```

Here we choose to store a list of strings, where each string is an object path, like `module.Class.method`. Feel free to store different values to help you filter objects according to your needs. For example, maybe you want to inspect all functions with a given label, in that case you could accept a single string which is the label name. Or you may want to inspect all functions decorated with a specific decorator, etc.

With this `__init__` method, users (or simply yourself) will be able to configure the extension by passing a list of object paths. You could also hard-code everything in the extension if you don't want or need to configure it.

Now that our extension accepts options, we implement its core functionality. We assume that the static analysis agent is able to see the objects we are interested in, and will actually create instances that represent them (Griffe objects). Therefore we hook onto the `on_instance` event, which runs each time a Griffe object is created.

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        ...

```

Check out the available hooks to see if there more appropriate hooks for your needs.

Lets now use our configuration option to decide whether to do something or skip:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

```

Now we know that only the objects we're interested in will be handled, so lets handle them.

```
import griffe

logger = griffe.get_logger("griffe_inspect_specific_objects")  # (1)!


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        try:
            runtime_obj = griffe.dynamic_import(obj.path)
        except ImportError as error:
            logger.warning(f"Could not import {obj.path}: {error}")  # (2)!
            return

```

1. We integrate with Griffe's logging (which also ensures integration with MkDocs' logging) by creating a logger. The name should look like a package name, with underscores.
1. We decide to log the exception as a warning (causing MkDocs builds to fail in `--strict` mode), but you could also log an error, or a debug message.

Now that we have a reference to our runtime object, we can use it to alter the Griffe object.

For example, we could use the runtime object's `__doc__` attribute, which could have been declared dynamically, to fix the Griffe object docstring:

```
import griffe

logger = griffe.get_logger("griffe_inspect_specific_objects")


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        try:
            runtime_obj = griffe.dynamic_import(obj.path)
        except ImportError as error:
            logger.warning(f"Could not import {obj.path}: {error}")
            return

        if obj.docstring:
            obj.docstring.value = runtime_obj.__doc__
        else:
            obj.docstring = griffe.Docstring(runtime_obj.__doc__)

```

Or we could alter the Griffe object parameters in case of functions, which could have been modified by a signature-changing decorator:

```
import inspect
import griffe

logger = griffe.get_logger("griffe_inspect_specific_objects")


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        try:
            runtime_obj = griffe.dynamic_import(obj.path)
        except ImportError as error:
            logger.warning(f"Could not import {obj.path}: {error}")
            return

        # Update default values modified by decorator.
        signature = inspect.signature(runtime_obj)
        for param in signature.parameters:
            if param.name in obj.parameters:
                obj.parameters[param.name].default = repr(param.default)

```

We could also entirely replace the Griffe object obtained from static analysis by the same one obtained from dynamic analysis:

```
import griffe


class InspectSpecificObjects(griffe.Extension):
    """An extension to inspect just a few specific objects."""

    def __init__(self, objects: list[str]) -> None:
        self.objects = objects

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path not in self.objects:
            return

        inspected_module = griffe.inspect(obj.module.path, filepath=obj.filepath)
        obj.parent.set_member(obj.name, inspected_module[obj.name])  # (1)!

```

1. This assumes the object we're interested in is declared at the module level.

# Setting the right docstring style for every docstring

Griffe attaches the specified docstring style and parsing options to each object in the tree of the package(s) you load. If your package(s) use several docstring styles, some of these objects will have the wrong style attached to them. This is problematic because other Griffe extensions rely on this attached style to parse docstrings and modify them. We plan to alleviate this limitation in the future (see [issue-340](https://github.com/mkdocstrings/griffe/issues/340)), but the most robust thing you can do is to make sure each object has the *right style* attached, as easly as possible, so that other extensions can work without issue.

There are currently two ways to make sure objects have the right docstring style attached as early as possible:

1. Use the [`auto` docstring style](https://mkdocstrings.github.io/griffe/reference/docstrings/#auto-style) (currently only available to sponsors). Griffe will use regular expressions to infer the docstring style used. 100% accuracy is impossible to achieve, so it's possible that you get incorrect styles for some objects.
1. Write and use a custom Griffe extension.

This how-to provides a few extension-based solutions to correctly set docstring styles in your packages. **Just make sure to enable these extensions in first position.**

## Markup comment

Depending on the markup you use in docstrings, you can add a comment that tells Griffe which docstring style to use.

```
def function():
    """Summary.

    Body.

    <!-- style: google -->
    """

```

```
def function():
    """Summary.

    Body.

    .. style: google
    """

```

Your Griffe extension can then use regular expressions to search for such comments. For example with Markdown (HTML) comments:

```
import re
import griffe


class ApplyDocstringStyle(griffe.Extension):
    def __init__(self, regex: str = "<!-- style: (google|numpy|sphinx) -->") -> None:
         self.regex = re.compile(regex)

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.docstring:
            if match := self.regex.search(obj.docstring.value):
                obj.docstring.parser = match.group(1)

```

## Python comment

You could also decide to add a trailing comment to your docstrings to indicate which style to use.

```
def function():
    """Summary.

    Body.
    """  # style: google

```

Your extension can then pick up this comment to assign the right style:

```
import re
import griffe


class ApplyDocstringStyle(griffe.Extension):
    def __init__(self, regex: str = ".*# style: (google|numpy|sphinx)$") -> None:
         self.regex = re.compile(regex)

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.docstring:
            if match := self.regex.search(obj.docstring.source):
                obj.docstring.parser = match.group(1)

```

## Explicit configuration

Finally, you could decide to map a list of objects to the docstring style they should use. Your extension can either accept options, or it could hard-code that list:

```
import griffe
from fnmatch import fnmatch

class ApplyDocstringStyle(griffe.Extension):
    def __init__(self, config: dict[str, str]):
        self.instances = {}
        self.globs = {}
        for key, value in config.items():
            if "*" in key:
                self.globs[key] = value
            else:
                self.instances[key] = value

    def on_instance(self, *, obj: griffe.Object, **kwargs) -> None:
        if obj.path in self.instances:
            if obj.docstring:
                obj.docsring.parser = self.instances[obj.path]
         else:
             for pattern, style in self.globs:
                 if fnmatch(obj.path, pattern):
                     if obj.docstring:
                         obj.docstring.parser = style

```

Example configuration in MkDocs:

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - your_griffe_extension.py:
              config:                
                path.to.obj1: google
                path.to.obj2: numpy
                path.to.obj3.*: sphinx
                path.to.obj4*: google

```

The benefit of this last solution is that it works for code you don't have control over. An alternative solution is to use the [griffe-autodocstringstyle extension](https://mkdocstrings.github.io/griffe/extensions/official/autodocstringstyle/) (sponsors only), which automatically assigns the `auto` style to all objects coming from sources found in a virtual environment.

# Supporting custom decorators

Griffe aims to support the Python language itself, as well as its standard library. It means that built-in objects and objects from the standard library that can be used or are often used as decorators, should be supported natively or through official extensions, for example `@property`, `@functools.cache`, `@warnings.deprecated`, etc.

Custom decorators however (the ones you define in your code-base) won't be supported by default, at least statically (dynamic analysis might be able to support them), because Griffe doesn't try to infer anything more than the obvious. Griffe is not a type-checker and so doesn't have the same inference abilities.

Therefore, to support your own decorators (at least statically), you have to write Griffe extensions. Don't worry, extensions that support custom decorators are generally super easy to write.

______________________________________________________________________

Lets assume we have a decorator whose path is `my_package.utils.enhance`. It is used throughout our code base like so:

```
from my_package.utils import enhance

@enhance
def my_function() -> ...:
    ...

```

Start by creating an extensions module (a simple Python file) somewhere in your repository, if you don't already have one. Within it, create an extension class:

```
import griffe


class MyDecorator(griffe.Extension):
    """An extension to suport my decorator."""

```

Now we can declare the on_instance hook, which receives any kind of Griffe object (Module, Class, Function, Attribute, TypeAlias), or we could use a kind-specific hook such as on_module_instance, on_class_instance, on_function_instance, on_attribute_instance and on_type_alias_instance. For example, if you know your decorator is only ever used on class declarations, it would make sense to use `on_class_instance`.

For the example, lets use the `on_function_instance` hook, which receives `Function` instances.

```
import griffe


class MyDecorator(griffe.Extension):
    """An extension to suport my decorator."""

    def on_function_instance(self, *, func: griffe.Function, **kwargs) -> None:
        ...

```

In this hook, we check if our function is decorated with our custom decorator:

```
import griffe


class MyDecorator(griffe.Extension):
    """An extension to suport my decorator."""

    def on_function_instance(self, *, func: griffe.Function, **kwargs) -> None:
        for decorator in func.decorators:
            if decorator.callable_path == "my_package.utils.enhance":
                ...  # Update the function attributes.

```

Now all that is left to do is to actually write the code that updates the function according to what the decorator is doing. We could update the function's docstring, or its return type, or its parameters: it all depends on your decorator and what it does to the objects it decorates. Check out the API reference for function objects to see what data this object stores.
# Reference

# CLI reference

## griffe

> Signatures for entire Python programs.

Global Options:

- `-h`, `--help`: Show this help message and exit. Commands also accept the -h/--help option.
- `-V`, `--version`: show program's version number and exit
- `--debug-info`: Print debug information.

Commands:

### dump

> Load package-signatures and dump them as JSON.

Search Options:

- `-s`, `--search`: Paths to search packages into.
- `-y`, `--sys-path`: Whether to append `sys.path` to search paths specified with `-s`.

Loading Options:

- `-B`, `--find-stubs-packages`: Whether to look for stubs-only packages and merge them with concrete ones.
- `-e`, `--extensions`: A list of extensions to use.
- `-X`, `--no-inspection`: Disallow inspection of builtin/compiled/not found modules. Default: `True`.
- `-x`, `--force-inspection`: Force inspection of everything, even when sources are found.

Dump Options:

- `packages` `PACKAGE`: Packages to find, load and dump.
- `-f`, `--full`: Whether to dump full data in JSON.
- `-o`, `--output`: Output file. Supports templating to output each package in its own file, with `{package}`. Default: `sys.stdout`.
- `-d`, `--docstyle`: The docstring style to parse.
- `-D`, `--docopts`: The options for the docstring parser.
- `-r`, `--resolve-aliases`: Whether to resolve aliases.
- `-I`, `--resolve-implicit`: Whether to resolve implicitly exported aliases as well. Aliases are explicitly exported when defined in `__all__`.
- `-U`, `--resolve-external`: Always resolve aliases pointing to external/unknown modules (not loaded directly).Default is to resolve only from one module to its private sibling (`ast` -> `_ast`).
- `--no-resolve-external`: Never resolve aliases pointing to external/unknown modules (not loaded directly).Default is to resolve only from one module to its private sibling (`ast` -> `_ast`). Default: `True`.
- `-S`, `--stats`: Show statistics at the end.

Debugging Options:

- `-L`, `--log-level` `LEVEL`: Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`. Default: `INFO`.

Common Options:

- `-h`, `--help`: Show this help message and exit.

### check

> Check for API breakages or possible improvements.

Search Options:

- `-s`, `--search`: Paths to search packages into.
- `-y`, `--sys-path`: Whether to append `sys.path` to search paths specified with `-s`.

Loading Options:

- `-B`, `--find-stubs-packages`: Whether to look for stubs-only packages and merge them with concrete ones.
- `-e`, `--extensions`: A list of extensions to use.
- `-X`, `--no-inspection`: Disallow inspection of builtin/compiled/not found modules. Default: `True`.
- `-x`, `--force-inspection`: Force inspection of everything, even when sources are found.

Debugging Options:

- `-L`, `--log-level` `LEVEL`: Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`. Default: `INFO`.

Common Options:

- `-h`, `--help`: Show this help message and exit.

Check Options:

- `package` `PACKAGE`: Package to find, load and check, as path.
- `-a`, `--against` `REF`: Older Git reference (commit, branch, tag) to check against. Default: load latest tag.
- `-b`, `--base-ref` `BASE_REF`: Git reference (commit, branch, tag) to check. Default: load current code.
- `--color`: Force enable colors in the output.
- `--no-color`: Force disable colors in the output.
- `-v`, `--verbose`: Verbose output.
- `-f`, `--format`: Output format.

# Docstrings

Griffe provides different docstring parsers allowing to extract even more structured data from source code.

The available parsers are:

- `google`, to parse Google-style docstrings, see [Napoleon's documentation](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html)
- `numpy`, to parse Numpydoc docstrings, see [Numpydoc's documentation](https://numpydoc.readthedocs.io/en/latest/format.html)
- `sphinx`, to parse Sphinx-style docstrings, see [Sphinx's documentation](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html)
- `auto` (sponsors only), to automatically detect the docstring style, see [Auto-style](#auto-style)

Most of the time, the syntax specified in the aforementioned docs is supported. In some cases, the original syntax is not supported, or is supported but with subtle differences. We will try to document these differences in the following sections.

No assumption is made on the markup used in docstrings: it's retrieved as regular text. Tooling making use of Griffe can then choose to render the text as if it is Markdown, or AsciiDoc, or reStructuredText, etc..

## Google-style

Google-style docstrings, see [Napoleon's documentation](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html).

### Syntax

Sections are written like this:

```
section identifier: optional section title
    section contents

```

All sections identifiers are case-insensitive. All sections support multiple lines in descriptions, as well as blank lines. The first line must not be blank. Each section must be separated from contents above by a blank line.

❌ This is **invalid** and will be parsed as regular markup:

```
Some text.
Note: # (1)!
    Some information.

    Blank lines allowed.

```

1. Missing blank line above.

❌ This is **invalid** and will be parsed as regular markup:

```
Some text.

Note: # (1)!

    Some information.

    Blank lines allowed.

```

1. Extraneous blank line below.

✅ This is **valid** and will parsed as a text section followed by a note admonition:

```
Some text.

Note:
    Some information.

    Blank lines allowed.

```

Find out possibly invalid section syntax by grepping for "reasons" in Griffe debug logs:

```
griffe dump -Ldebug -o/dev/null -fdgoogle your_package 2>&1 | grep reasons

```

Some sections support documenting multiple items (attributes, parameters, etc.). When multiple items are supported, each item description can use multiple lines, and continuation lines must be indented once more so that the parser is able to differentiate items.

```
def foo(a, b):
    """Foo.

    Parameters:
        a: Here's a.
            Continuation line 1.

            Continuation line 2.
        b: Here's b.
    """

```

It's possible to start a description with a newline if you find it less confusing:

```
def foo(a, b):
    """Foo.

    Parameters:
        a:
            Here's a.
            Continuation line 1.

            Continuation line 2.
        b: Here's b.
    """

```

### Admonitions

When a section identifier does not match one of the [supported sections](#google-sections), the section is parsed as an "admonition" (or "callout").

Identifiers are case-insensitive, however singular and plural forms are distinct. For example, `Note:` is not the same as `Notes:`.

In particular, `Examples` is parsed as the [Examples section](#google-section-examples), while `Example` is parsed as an admonition whose kind is `example`.

The kind is obtained by lower-casing the identifier and replacing spaces with dashes. For example, an admonition whose identifier is `See also:` will have a kind equal to `see-also`.

Custom section titles are preserved in admonitions: `Tip: Check this out:` is parsed as a `tip` admonition with `Check this out:` as title.

It is up to any downstream documentation renderer to make use of these kinds and titles.

### Parser options

The parser accepts a few options:

- `ignore_init_summary`: Ignore the first line in `__init__` methods' docstrings. Useful when merging `__init__` docstring into class' docstrings with mkdocstrings-python's [`merge_init_into_class`](https://mkdocstrings.github.io/python/usage/configuration/docstrings/#merge_init_into_class) option. Default: false.
- `returns_multiple_items`: Parse [Returns sections](#google-section-returns) and [Yields sections](#google-section-yields) as if they contain multiple items. It means that continuation lines must be indented. Default: true.
- `returns_named_value`: Whether to parse `thing: Description` in [Returns sections](#google-section-returns) and [Yields sections](#google-section-yields) as a name and description, rather than a type and description. When true, type must be wrapped in parentheses: `(int): Description.`. When false, parentheses are optional but the items cannot be named: `int: Description`. Default: true.
- `receives_multiple_items`: Parse [Receives sections](#google-section-receives) as if they contain multiple items. It means that continuation lines must be indented. Default: true.
- `receives_named_value`: Whether to parse `thing: Description` in [Receives sections](#google-section-receives) as a name and description, rather than a type and description. When true, type must be wrapped in parentheses: `(int): Description.`. When false, parentheses are optional but the items cannot be named: `int: Description`. Default: true.
- `returns_type_in_property_summary`: Whether to parse the return type of properties at the beginning of their summary: `str: Summary of the property`. Default: false.
- `trim_doctest_flags`: Remove the [doctest flags](https://docs.python.org/3/library/doctest.html#option-flags) written as comments in `pycon` snippets within a docstring. These flags are used to alter the behavior of [doctest](https://docs.python.org/3/library/doctest.html#module-doctest) when testing docstrings, and should not be visible in your docs. Default: true.
- `warn_unknown_params`: Warn about parameters documented in docstrings that do not appear in the signature. Default: true.
- `warn_missing_types`: Warn about missing type or annotation for parameters, return values, etc. Default: true.
- `warnings`: Generally enable/disable warnings when parsing docstrings. Default: true.

### Sections

The following sections are supported.

#### Attributes

- Multiple items allowed

Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.

```
"""My module.

Attributes:
    foo: Description for `foo`.
    bar: Description for `bar`.
"""

foo: int = 0
bar: bool = True


class MyClass:
    """My class.

    Attributes:
        foofoo: Description for `foofoo`.
        barbar: Description for `barbar`.
    """

    foofoo: int = 0

    def __init__(self):
        self.barbar: bool = True

```

Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:

```
"""My module.

Attributes:
    foo (Integer): Description for `foo`.
    bar (Boolean): Description for `bar`.
"""

```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting an attribute with `attr_name (attr_type): Attribute description`, `attr_type` will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Functions/Methods

- Multiple items allowed

Functions or Methods sections allow to document functions of a module, or methods of a class. They should be used in modules and classes docstrings only.

```
"""My module.

Functions:
    foo: Description for `foo`.
    bar: Description for `bar`.
"""


def foo():
    return "foo"


def bar(baz: int) -> int:
    return baz * 2


class MyClass:
    """My class.

    Methods:
        foofoo: Description for `foofoo`.
        barbar: Description for `barbar`.
    """

    def foofoo(self):
        return "foofoo"

    @staticmethod
    def barbar():
        return "barbar"

```

It's possible to write the function/method signature as well as its name:

```
"""
Functions:
    foo(): Description for `foo`.
    bar(baz=1): Description for `bar`.
"""

```

The signatures do not have to match the real ones: you can shorten them to only show the important parameters.

#### Classes

- Multiple items allowed

Classes sections allow to document classes of a module or class. They should be used in modules and classes docstrings only.

```
"""My module.

Classes:
    Foo: Description for `foo`.
    Bar: Description for `bar`.
"""


class Foo:
    ...


class Bar:
    def __init__(self, baz: int) -> int:
        return baz * 2


class MyClass:
    """My class.

    Classes:
        FooFoo: Description for `foofoo`.
        BarBar: Description for `barbar`.
    """

    class FooFoo:
        ...

    class BarBar:
        ...

```

It's possible to write the class signature as well as its name:

```
"""
Functions:
    Foo(): Description for `Foo`.
    Bar(baz=1): Description for `Bar`.
"""

```

The signatures do not have to match the real ones: you can shorten them to only show the important initialization parameters.

#### Modules

- Multiple items allowed

Modules sections allow to document submodules of a module. They should be used in modules docstrings only.

```
📁 my_pkg/
├──  __init__.py
├──  foo.py
└──  bar.py

```

my_pkg/__init__.py

```
"""My package.

Modules:
    foo: Description for `foo`.
    bar: Description for `bar`.
"""

```

#### Examples

Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.

```
"""My module.

Examples:
    Some explanation of what is possible.

    >>> print("hello!")
    hello!

    Blank lines delimit prose vs. console blocks.

    >>> a = 0
    >>> a += 1
    >>> a
    1
"""

```

Not the same as *Example* sections.

*Example* (singular) sections are parsed as admonitions. Console code blocks will only be understood in *Examples* (plural) sections.

#### Parameters

- Aliases: Args, Arguments, Params
- Multiple items allowed

Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.

```
def foo(a: int, b: str):
    """Foo.

    Parameters:
        a: Here's a.
        b: Here's b.
    """

```

```
from dataclasses import dataclass


@dataclass
class Foo:
    """Foo.

    Parameters:
        a: Here's a.
        b: Here's b.
    """

    foo: int
    bar: str

```

Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:

```
"""My function.

Parameters:
    foo (Integer): Description for `foo`.
    bar (String): Description for `bar`.
"""

```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting a parameter with `param_name (param_type): Parameter description`, `param_type` will be resolved using the scope of the function (or class). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Other Parameters

- Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params
- Multiple items allowed

Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are, but can also be useful in decorators / to document returned callables.

```
def foo(a, b, **kwargs):
    """Foo.

    Parameters:
        a: Here's a.
        b: Here's b.

    Other parameters:
        c (int): Here's c.
        d (bool): Here's d.
    """

```

```
def foo(a, b):
    """Returns a callable.

    Parameters:
        a: Here's a.
        b: Here's b.

    Other parameters: Parameters of the returned callable:
        c (int): Here's c.
        d (bool): Here's d.
    """

    def inner(c, d):
        ...

    return inner

```

Types in docstrings are resolved using the docstrings' parent scope.

See the same tip for parameters.

#### Raises

- Aliases: Exceptions
- Multiple items allowed

Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.

```
def foo(a: int):
    """Foo.

    Parameters:
        a: A value.

    Raises:
        ValueError: When `a` is less than 0.
    """
    if a < 0:
        raise ValueError("message")

```

Exceptions names are resolved using the function's scope.

`ValueError` and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example `my_exceptions.MyCustomException` or `MyCustomException` directly, depending on what you imported/defined in the current module.

#### Warns

- Aliases: Warnings
- Multiple items allowed

Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.

```
import warnings


def foo():
    """Foo.

    Warns:
        UserWarning: To annoy users.
    """
    warnings.warn("Just messing with you.", UserWarning)

```

Warnings names are resolved using the function's scope.

`UserWarning` and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example `my_warnings.MyCustomWarning` or `MyCustomWarning` directly, depending on what you imported/defined in the current module.

#### Yields

- Multiple items allowed

Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Iterator


def foo() -> Iterator[int]:
    """Foo.

    Yields:
        Integers from 0 to 9.
    """
    for i in range(10):
        yield i

```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator` or `typing.Iterator`. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
from datetime import datetime


def foo() -> Iterator[tuple[float, float, datetime]]:
    """Foo.

    Yields:
        x: Absissa.
        y: Ordinate.
        t: Time.

    ...
    """
    ...

```

You have to indent each continuation line when documenting yielded values, even if there's only one value yielded:

```
"""Foo.

Yields:
    partial_result: Some partial result.
        A longer description of details and other information
        for this partial result.
"""

```

If you don't want to indent continuation lines for the only yielded value, use the [`returns_multiple_items=False`](#google-options) parser option.

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Yields:
    x (int): Absissa.
    y (int): Ordinate.
    t (int): Timestamp.
"""

```

If you want to specify the type without a name, you still have to wrap the type in parentheses:

```
"""Foo.

Yields:
    (int): Absissa.
    (int): Ordinate.
    (int): Timestamp.
"""

```

If you don't want to wrap the type in parentheses, use the [`returns_named_value=False`](#google-options) parser option. Setting it to false will disallow specifying a name.

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Receives

- Multiple items allowed

Receives sections allow to document values that can be sent to generators using their `send` method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Generator


def foo() -> Generator[int, str, None]:
    """Foo.

    Receives:
        reverse: Reverse the generator if `"reverse"` is received.

    Yields:
        Integers from 0 to 9.

    Examples:
        >>> gen = foo()
        >>> next(gen)
        0
        >>> next(gen)
        1
        >>> next(gen)
        2
        >>> gen.send("reverse")
        2
        >>> next(gen)
        1
        >>> next(gen)
        0
        >>> next(gen)
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        StopIteration
    """
    for i in range(10):
        received = yield i
        if received == "reverse":
            for j in range(i, -1, -1):
                yield j
            break

```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator`. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> Generator[int, tuple[str, bool], None]:
    """Foo.

    Receives:
        mode: Some mode.
        flag: Some flag.

    ...
    """
    ...

```

You have to indent each continuation line when documenting received values, even if there's only one value received:

```
"""Foo.

Receives:
    data: Input data.
        A longer description of what this data actually is,
        and what it isn't.
"""

```

If you don't want to indent continuation lines for the only received value, use the [`receives_multiple_items=False`](#google-options) parser option.

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Receives:
    mode (ModeEnum): Some mode.
    flag (int): Some flag.
"""

```

If you want to specify the type without a name, you still have to wrap the type in parentheses:

```
"""Foo.

Receives:
    (ModeEnum): Some mode.
    (int): Some flag.
"""

```

If you don't want to wrap the type in parentheses, use the [`receives_named_value=False`](#google-options) parser option. Setting it to false will disallow specifying a name.

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Returns

- Multiple items allowed

Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.

```
import random


def foo() -> int:
    """Foo.

    Returns:
        A random integer.
    """
    return random.randint(0, 100)

```

Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> tuple[bool, float]:
    """Foo.

    Returns:
        success: Whether it succeeded.
        precision: Final precision.

    ...
    """
    ...

```

You have to indent each continuation line when documenting returned values, even if there's only one value returned:

```
"""Foo.

Returns:
    success: Whether it succeeded.
        A longer description of what is considered success,
        and what is considered failure.
"""

```

If you don't want to indent continuation lines for the only returned value, use the [`returns_multiple_items=False`](#google-options) parser option.

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Returns:
    success (int): Whether it succeeded.
    precision (Decimal): Final precision.
"""

```

If you want to specify the type without a name, you still have to wrap the type in parentheses:

```
"""Foo.

Returns:
    (int): Whether it succeeded.
    (Decimal): Final precision.
"""

```

If you don't want to wrap the type in parentheses, use the [`returns_named_value=False`](#google-options) parser option. Setting it to false will disallow specifying a name.

Types in docstrings are resolved using the docstrings' function scope.

See previous tips for types in docstrings.

## Numpydoc-style

Numpydoc docstrings, see [Numpydoc's documentation](https://numpydoc.readthedocs.io/en/latest/format.html)

### Syntax

Sections are written like this:

```
section identifier
------------------
section contents

```

All sections identifiers are case-insensitive. All sections support multiple lines in descriptions.

Some sections support documenting items items. Item descriptions start on a new, indented line. When multiple items are supported, each item description can use multiple lines.

```
def foo(a, b):
    """Foo.

    Parameters
    ----------
    a
        Here's a.
        Continuation line 1.

        Continuation line 2.
    b
        Here's b.
    """

```

For items that have an optional name and type, several syntaxes are supported:

- specifying both the name and type:

  ```
  """
  name : type
      description
  """

  ```

- specifying just the name:

  ```
  """
  name
      description
  """

  ```

  or

  ```
  """
  name :
      description
  """

  ```

- specifying just the type:

  ```
  """
  : type
      description
  """

  ```

- specifying neither the name nor type:

  ```
  """
  :
      description
  """

  ```

### Admonitions

When a section identifier does not match one of the [supported sections](#numpydoc-sections), the section is parsed as an "admonition" (or "callout").

Identifiers are case-insensitive, however singular and plural forms are distinct, except for notes and warnings. In particular, `Examples` is parsed as the [Examples section](#numpydoc-section-examples), while `Example` is parsed as an admonition whose kind is `example`.

The kind is obtained by lower-casing the identifier and replacing spaces with dashes. For example, an admonition whose identifier is `See also` will have a kind equal to `see-also`.

It is up to any downstream documentation renderer to make use of these kinds.

### Parser options

The parser accepts a few options:

- `ignore_init_summary`: Ignore the first line in `__init__` methods' docstrings. Useful when merging `__init__` docstring into class' docstrings with mkdocstrings-python's [`merge_init_into_class`](https://mkdocstrings.github.io/python/usage/configuration/docstrings/#merge_init_into_class) option. Default: false.
- `trim_doctest_flags`: Remove the [doctest flags](https://docs.python.org/3/library/doctest.html#option-flags) written as comments in `pycon` snippets within a docstring. These flags are used to alter the behavior of [doctest](https://docs.python.org/3/library/doctest.html#module-doctest) when testing docstrings, and should not be visible in your docs. Default: true.
- `warn_unknown_params`: Warn about parameters documented in docstrings that do not appear in the signature. Default: true.
- `warn_missing_types`: Warn about missing type or annotation for parameters, return values, etc. Default: true.
- `warnings`: Generally enable/disable warnings when parsing docstrings. Default: true.

### Sections

The following sections are supported.

#### Attributes

- Multiple items allowed

Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.

```
"""My module.

Attributes
----------
foo
    Description for `foo`.
bar
    Description for `bar`.
"""

foo: int = 0
bar: bool = True


class MyClass:
    """My class.

    Attributes
    ----------
    foofoo
        Description for `foofoo`.
    barbar
        Description for `barbar`.
    """

    foofoo: int = 0

    def __init__(self):
        self.barbar: bool = True

```

Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:

```
"""My module.

Attributes
----------
foo : Integer
    Description for `foo`.
bar : Boolean
    Description for `bar`.
"""

```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting an attribute with `attr_name : attr_type`, `attr_type` will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Functions/Methods

- Multiple items allowed

Functions or Methods sections allow to document functions of a module, or methods of a class. They should be used in modules and classes docstrings only.

```
"""My module.

Functions
---------
foo
    Description for `foo`.
bar
    Description for `bar`.
"""


def foo():
    return "foo"


def bar(baz: int) -> int:
    return baz * 2


class MyClass:
    """My class.

    Methods
    -------
    foofoo
        Description for `foofoo`.
    barbar
        Description for `barbar`.
    """

    def foofoo(self):
        return "foofoo"

    @staticmethod
    def barbar():
        return "barbar"

```

It's possible to write the function/method signature as well as its name:

```
"""
Functions
---------
foo()
    Description for `foo`.
bar(baz=1)
    Description for `bar`.
"""

```

The signatures do not have to match the real ones: you can shorten them to only show the important parameters.

#### Classes

- Multiple items allowed

Classes sections allow to document classes of a module or class. They should be used in modules and classes docstrings only.

```
"""My module.

Classes
-------
Foo
    Description for `foo`.
Bar
    Description for `bar`.
"""


class Foo:
    ...


class Bar:
    def __init__(self, baz: int) -> int:
        return baz * 2


class MyClass:
    """My class.

    Classes
    -------
    FooFoo
        Description for `foofoo`.
    BarBar
        Description for `barbar`.
    """

    class FooFoo:
        ...

    class BarBar:
        ...

```

It's possible to write the class signature as well as its name:

```
"""
Functions
---------
Foo()
    Description for `Foo`.
Bar(baz=1)
    Description for `Bar`.
"""

```

The signatures do not have to match the real ones: you can shorten them to only show the important initialization parameters.

#### Modules

- Multiple items allowed

Modules sections allow to document submodules of a module. They should be used in modules docstrings only.

```
📁 my_pkg/
├──  __init__.py
├──  foo.py
└──  bar.py

```

my_pkg/__init__.py

```
"""My package.

Modules
-------
foo
    Description for `foo`.
bar
    Description for `bar`.
"""

```

#### Examples

Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.

```
"""My module.

Examples
--------
Some explanation of what is possible.

>>> print("hello!")
hello!

Blank lines delimit prose vs. console blocks.

>>> a = 0
>>> a += 1
>>> a
1
"""

```

#### Parameters

- Aliases: Args, Arguments, Params
- Multiple items allowed

Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.

```
def foo(a: int, b: str):
    """Foo.

    Parameters
    ----------
    a
        Here's a.
    b
        Here's b.
    """

```

```
from dataclasses import dataclass


@dataclass
class Foo:
    """Foo.

    Parameters
    ----------
    a
        Here's a.
    b
        Here's b.
    """

    foo: int
    bar: str

```

Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:

```
"""My function.

Parameters
----------
foo : Integer
    Description for `foo`.
bar : String
    Description for `bar`.
"""

```

Types in docstrings are resolved using the docstrings' parent scope.

When documenting a parameter with `param_name : param_type`, `param_type` will be resolved using the scope of the function (or class). For example, a type of `list[str]` will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example `Optional[Union[int, Tuple[float, float]]]`.

#### Other Parameters

- Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params
- Multiple items allowed

Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are.

```
def foo(a, b, **kwargs):
    """Foo.

    Parameters
    ----------
    a
        Here's a.
    b
        Here's b.

    Other parameters
    ----------------
    c : int
        Here's c.
    d : bool
        Here's d.
    """

```

Types in docstrings are resolved using the docstrings' parent scope.

See the same tip for parameters.

#### Raises

- Aliases: Exceptions
- Multiple items allowed

Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.

```
def foo(a: int):
    """Foo.

    Parameters
    ----------
    a
        A value.

    Raises
    ------
    ValueError
        When `a` is less than 0.
    """
    if a < 0:
        raise ValueError("message")

```

Exceptions names are resolved using the function's scope.

`ValueError` and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example `my_exceptions.MyCustomException` or `MyCustomException` directly, depending on what you imported/defined in the current module.

#### Warns

- Multiple items allowed

Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.

```
import warnings


def foo():
    """Foo.

    Warns
    -----
    UserWarning
        To annoy users.
    """
    warnings.warn("Just messing with you.", UserWarning)

```

Warnings names are resolved using the function's scope.

`UserWarning` and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example `my_warnings.MyCustomWarning` or `MyCustomWarning` directly, depending on what you imported/defined in the current module.

#### Yields

- Multiple items allowed

Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Iterator


def foo() -> Iterator[int]:
    """Foo.

    Yields
    ------
    :
        Integers from 0 to 9.
    """
    for i in range(10):
        yield i

```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator` or `typing.Iterator`. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
from datetime import datetime


def foo() -> Iterator[tuple[float, float, datetime]]:
    """Foo.

    Yields
    ------
    x
        Absissa.
    y
        Ordinate.
    t
        Time.
    """
    ...

```

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Yields
------
x : int
    Absissa.
y : int
    Ordinate.
t : int
    Timestamp.
"""

```

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Receives

- Multiple items allowed

Receives sections allow to document values that can be sent to generators using their `send` method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.

```
from typing import Generator


def foo() -> Generator[int, str, None]:
    """Foo.

    Receives
    --------
    reverse
        Reverse the generator if `"reverse"` is received.

    Yields
    ------
    :
        Integers from 0 to 9.

    Examples
    --------
    >>> gen = foo()
    >>> next(gen)
    0
    >>> next(gen)
    1
    >>> next(gen)
    2
    >>> gen.send("reverse")
    2
    >>> next(gen)
    1
    >>> next(gen)
    0
    >>> next(gen)
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    StopIteration
    """
    for i in range(10):
        received = yield i
        if received == "reverse":
            for j in range(i, -1, -1):
                yield j
            break

```

Type annotations are fetched from the function return annotation when the annotation is `typing.Generator`. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> Generator[int, tuple[str, bool], None]:
    """Foo.

    Receives
    --------
    mode
        Some mode.
    flag
        Some flag.
    """
    ...

```

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Receives
--------
mode : ModeEnum
    Some mode.
flag : int
    Some flag.
"""

```

Types in docstrings are resolved using the docstrings' parent scope.

See previous tips for types in docstrings.

#### Returns

- Multiple items allowed

Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.

```
import random


def foo() -> int:
    """Foo.

    Returns
    -------
    :
        A random integer.
    """
    return random.randint(0, 100)

```

Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:

```
def foo() -> tuple[bool, float]:
    """Foo.

    Returns
    -------
    success
        Whether it succeeded.
    precision
        Final precision.
    """
    ...

```

Type annotations can as usual be overridden using types in parentheses in the docstring itself:

```
"""Foo.

Returns
-------
success : int
    Whether it succeeded.
precision : Decimal
    Final precision.
"""

```

Types in docstrings are resolved using the docstrings' function scope.

See previous tips for types in docstrings.

## Auto-style

[Sponsors only](../../insiders/) — [Insiders 1.3.0](../../insiders/changelog/#1.3.0).

Automatic style detection. This parser will first try to detect the style used in the docstring, and call the corresponding parser on it.

### Parser options

The parser accepts a few options:

- `method`: The method to use to detect the style and infer the parser. Method 'heuristics' will use regular expressions, while method 'max_sections' will parse the docstring with all parsers specified in `style_order` and return the one who parsed the most sections. Default: `"heuristics"`.
- `style_order`: If multiple parsers parsed the same number of sections, `style_order` is used to decide which one to return. Default: `["sphinx", "google", "numpy"]`.
- `default`: If heuristics fail, the `default` parser is returned. The `default` parser is never used with the 'max_sections' method. Default: `None`.
- Any other option is passed down to the detected parser, if any.

For non-Insiders versions, `default` is returned if specified, else the first parser in `style_order` is returned. If `style_order` is not specified, `None` is returned.

## Parsers features

Want to contribute?

Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item.

The sections are easier to deal in that order:

- Raises, Warns (multiple items, no names, single type each)
- Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each)
- Returns (multiple items, optional name and/or type each, annotation to split when multiple names)
- Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names)

"Examples" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function.

You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables).

### Sections

| Section          | Google | Numpy | Sphinx                                                 |
| ---------------- | ------ | ----- | ------------------------------------------------------ |
| Attributes       | ✅     | ✅    | ✅                                                     |
| Functions        | ✅     | ✅    | ❌                                                     |
| Methods          | ✅     | ✅    | ❌                                                     |
| Classes          | ✅     | ✅    | ❌                                                     |
| Modules          | ✅     | ✅    | ❌                                                     |
| Examples         | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/7)  |
| Parameters       | ✅     | ✅    | ✅                                                     |
| Other Parameters | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/27) |
| Raises           | ✅     | ✅    | ✅                                                     |
| Warns            | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/9)  |
| Yields           | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/10) |
| Receives         | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/8)  |
| Returns          | ✅     | ✅    | ✅                                                     |

### Getting annotations/defaults from parent

| Section          | Google | Numpy | Sphinx                                                 |
| ---------------- | ------ | ----- | ------------------------------------------------------ |
| Attributes       | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/33) |
| Functions        | /      | /     | /                                                      |
| Methods          | /      | /     | /                                                      |
| Classes          | /      | /     | /                                                      |
| Modules          | /      | /     | /                                                      |
| Examples         | /      | /     | /                                                      |
| Parameters       | ✅     | ✅    | ✅                                                     |
| Other Parameters | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/34) |
| Raises           | /      | /     | /                                                      |
| Warns            | /      | /     | /                                                      |
| Yields           | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/36) |
| Receives         | ✅     | ✅    | [❌](https://github.com/mkdocstrings/griffe/issues/35) |
| Returns          | ✅     | ✅    | ✅                                                     |

### Cross-references for annotations in docstrings

| Section          | Google                                                  | Numpy                                                   | Sphinx                                                 |
| ---------------- | ------------------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------ |
| Attributes       | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/19) |
| Functions        | [❌](https://github.com/mkdocstrings/griffe/issues/199) | [❌](https://github.com/mkdocstrings/griffe/issues/200) | /                                                      |
| Methods          | [❌](https://github.com/mkdocstrings/griffe/issues/199) | [❌](https://github.com/mkdocstrings/griffe/issues/200) | /                                                      |
| Classes          | [❌](https://github.com/mkdocstrings/griffe/issues/199) | [❌](https://github.com/mkdocstrings/griffe/issues/200) | /                                                      |
| Modules          | /                                                       | /                                                       | /                                                      |
| Examples         | /                                                       | /                                                       | /                                                      |
| Parameters       | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/21) |
| Other Parameters | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/20) |
| Raises           | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/22) |
| Warns            | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/25) |
| Yields           | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/26) |
| Receives         | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/23) |
| Returns          | ✅                                                      | ✅                                                      | [❌](https://github.com/mkdocstrings/griffe/issues/24) |

# griffe

Griffe package.

Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.

The entirety of the public API is exposed here, in the top-level `griffe` module.

All messages written to standard output or error are logged using the `logging` module. Our logger's name is set to `"griffe"` and is public (you can rely on it). You can obtain the logger from the standard `logging` module: `logging.getLogger("griffe")`. Actual logging messages are not part of the public API (they might change without notice).

Raised exceptions throughout the package are part of the public API (you can rely on them). Their actual messages are not part of the public API (they might change without notice).

The following paragraphs will help you discover the package's content.

### CLI entrypoints

Griffe provides a command-line interface (CLI) to interact with the package. The CLI entrypoints can be called from Python code.

- griffe.main: Run the main program.
- griffe.check: Check for API breaking changes in two versions of the same package.
- griffe.dump: Load packages data and dump it as JSON.

### Loaders

To load API data, Griffe provides several high-level functions.

- griffe.load: Load and return a Griffe object.
- griffe.load_git: Load and return a module from a specific Git reference.
- griffe.load_pypi: Load and return a module from a specific package version downloaded using pip.

### Models

The data loaded by Griffe is represented by several classes.

- griffe.Module: The class representing a Python module.
- griffe.Class: The class representing a Python class.
- griffe.Function: The class representing a Python function or method.
- griffe.Attribute: The class representing a Python attribute.
- griffe.Alias: This class represents an alias, or indirection, to an object declared in another module.

Additional classes are available to represent other concepts.

- griffe.Decorator: This class represents a decorator.
- griffe.Parameters: This class is a container for parameters.
- griffe.Parameter: This class represent a function parameter.

### Agents

Griffe is able to analyze code both statically and dynamically, using the following "agents". However most of the time you will only need to use the loaders above.

- griffe.visit: Parse and visit a module file.
- griffe.inspect: Inspect a module.

### Serializers

Griffe can serizalize data to dictionary and JSON.

- griffe.Object.as_json
- griffe.Object.from_json
- griffe.JSONEncoder: JSON encoder for Griffe objects.
- griffe.json_decoder: JSON decoder for Griffe objects.

### API checks

Griffe can compare two versions of the same package to find breaking changes.

- griffe.find_breaking_changes: Find breaking changes between two versions of the same API.
- griffe.Breakage: Breakage classes can explain what broke from a version to another.

### Extensions

Griffe supports extensions. You can create your own extension by subclassing the `griffe.Extension` class.

- griffe.load_extensions: Load configured extensions.
- griffe.Extension: Base class for Griffe extensions.

### Docstrings

Griffe can parse docstrings into structured data.

Main class:

- griffe.Docstring: This class represents docstrings.

Docstring section and element classes all start with `Docstring`.

Docstring parsers:

- griffe.parse: Parse the docstring.
- griffe.parse_auto: Parse a docstring by automatically detecting the style it uses.
- griffe.parse_google: Parse a Google-style docstring.
- griffe.parse_numpy: Parse a Numpydoc-style docstring.
- griffe.parse_sphinx: Parse a Sphinx-style docstring.

### Exceptions

Griffe uses several exceptions to signal errors.

- griffe.GriffeError: The base exception for all Griffe errors.
- griffe.LoadingError: Exception for loading errors.
- griffe.NameResolutionError: Exception for names that cannot be resolved in a object scope.
- griffe.UnhandledEditableModuleError: Exception for unhandled editables modules, when searching modules.
- griffe.UnimportableModuleError: Exception for modules that cannot be imported.
- griffe.AliasResolutionError: Exception for aliases that cannot be resolved.
- griffe.CyclicAliasError: Exception raised when a cycle is detected in aliases.
- griffe.LastNodeError: Exception raised when trying to access a next or previous node.
- griffe.RootNodeError: Exception raised when trying to use siblings properties on a root node.
- griffe.BuiltinModuleError: Exception raised when trying to access the filepath of a builtin module.
- griffe.ExtensionError: Base class for errors raised by extensions.
- griffe.ExtensionNotLoadedError: Exception raised when an extension could not be loaded.
- griffe.GitError: Exception raised for errors related to Git.

## Expressions

Griffe stores snippets of code (attribute values, decorators, base class, type annotations) as expressions. Expressions are basically abstract syntax trees (AST) with a few differences compared to the nodes returned by ast. Griffe provides a few helpers to extract expressions from regular AST nodes.

- griffe.get_annotation: Get a type annotation as expression.
- griffe.get_base_class: Get a base class as expression.
- griffe.get_condition: Get a condition as expression.
- griffe.get_expression: Get an expression from an AST node.
- griffe.safe_get_annotation: Get a type annotation as expression, safely (returns `None` on error).
- griffe.safe_get_base_class: Get a base class as expression, safely (returns `None` on error).
- griffe.safe_get_condition: Get a condition as expression, safely (returns `None` on error).
- griffe.safe_get_expression: Get an expression from an AST node, safely (returns `None` on error).

The base class for expressions.

- griffe.Expr

Expression classes all start with `Expr`.

## Loggers

If you want to log messages from extensions, get a logger with `get_logger`. The `logger` attribute is used by Griffe itself. You can use it to temporarily disable Griffe logging.

- griffe.logger: Our global logger, used throughout the library.
- griffe.get_logger: Create and return a new logger instance.

## Helpers

To test your Griffe extensions, or to load API data from code in memory, Griffe provides the following helpers.

- griffe.temporary_pyfile: Create a Python file containing the given code in a temporary directory.
- griffe.temporary_pypackage: Create a package containing the given modules in a temporary directory.
- griffe.temporary_visited_module: Create and visit a temporary module with the given code.
- griffe.temporary_visited_package: Create and visit a temporary package.
- griffe.temporary_inspected_module: Create and inspect a temporary module with the given code.
- griffe.temporary_inspected_package: Create and inspect a temporary package.

# Agents

Griffe is able to analyze code both statically and dynamically.

## **Main API**

## visit

```
visit(
    module_name: str,
    filepath: Path,
    code: str,
    *,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module

```

Parse and visit a module file.

We provide this function for static analysis. It uses a NodeVisitor-like class, the Visitor, to compile and parse code (using compile) then visit the resulting AST (Abstract Syntax Tree).

Important

This function is generally not used directly. In most cases, users can rely on the GriffeLoader and its accompanying load shortcut and their respective options to load modules using static analysis.

Parameters:

- ### **`module_name`**

  (`str`) – The module name (as when importing [from] it).

- ### **`filepath`**

  (`Path`) – The module file path.

- ### **`code`**

  (`str`) – The module contents.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use when visiting the AST.

- ### **`parent`**

  (`Module | None`, default: `None` ) – The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Returns:

- `Module` – The module, with its members populated.

## inspect

```
inspect(
    module_name: str,
    *,
    filepath: Path | None = None,
    import_paths: Sequence[str | Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module

```

Inspect a module.

Sometimes we cannot get the source code of a module or an object, typically built-in modules like `itertools`. The only way to know what they are made of is to actually import them and inspect their contents.

Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our static agent is not powerful enough to infer all these dynamic modifications. In this case, we load the module using introspection.

Griffe therefore provides this function for dynamic analysis. It uses a NodeVisitor-like class, the Inspector, to inspect the module with inspect.getmembers().

The inspection agent works similarly to the regular Visitor agent, in that it maintains a state with the current object being handled, and recursively handle its members.

Important

This function is generally not used directly. In most cases, users can rely on the GriffeLoader and its accompanying load shortcut and their respective options to load modules using dynamic analysis.

Parameters:

- ### **`module_name`**

  (`str`) – The module name (as when importing [from] it).

- ### **`filepath`**

  (`Path | None`, default: `None` ) – The module file path.

- ### **`import_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – Paths to import the module from.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use when inspecting the module.

- ### **`parent`**

  (`Module | None`, default: `None` ) – The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Returns:

- `Module` – The module, with its members populated.

## **Advanced API**

## Visitor

```
Visitor(
    module_name: str,
    filepath: Path,
    code: str,
    extensions: Extensions,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
)

```

This class is used to instantiate a visitor.

Visitors iterate on AST nodes to extract data from them.

Parameters:

- ### **`module_name`**

  (`str`) – The module name.

- ### **`filepath`**

  (`Path`) – The module filepath.

- ### **`code`**

  (`str`) – The module source code.

- ### **`extensions`**

  (`Extensions`) – The extensions to use when visiting.

- ### **`parent`**

  (`Module | None`, default: `None` ) – An optional parent for the final module object.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – The docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Methods:

- **`decorators_to_labels`** – Build and return a set of labels based on decorators.
- **`generic_visit`** – Extend the base generic visit with extensions.
- **`get_base_property`** – Check decorators to return the base property in case of setters and deleters.
- **`get_module`** – Build and return the object representing the module attached to this visitor.
- **`handle_attribute`** – Handle an attribute (assignment) node.
- **`handle_function`** – Handle a function definition node.
- **`visit`** – Extend the base visit with extensions.
- **`visit_annassign`** – Visit an annotated assignment node.
- **`visit_assign`** – Visit an assignment node.
- **`visit_asyncfunctiondef`** – Visit an async function definition node.
- **`visit_augassign`** – Visit an augmented assignment node.
- **`visit_classdef`** – Visit a class definition node.
- **`visit_functiondef`** – Visit a function definition node.
- **`visit_if`** – Visit an "if" node.
- **`visit_import`** – Visit an import node.
- **`visit_importfrom`** – Visit an "import from" node.
- **`visit_module`** – Visit a module node.
- **`visit_typealias`** – Visit a type alias node.

Attributes:

- **`code`** (`str`) – The module source code.
- **`current`** (`Module | Class`) – The current object being visited.
- **`docstring_options`** (`dict[str, Any]`) – The docstring parsing options.
- **`docstring_parser`** (`DocstringStyle | Parser | None`) – The docstring parser to use.
- **`extensions`** (`Extensions`) – The extensions to use when visiting the AST.
- **`filepath`** (`Path`) – The module filepath.
- **`lines_collection`** (`LinesCollection`) – A collection of source code lines.
- **`module_name`** (`str`) – The module name.
- **`modules_collection`** (`ModulesCollection`) – A collection of modules.
- **`parent`** (`Module | None`) – An optional parent for the final module object.
- **`type_guarded`** (`bool`) – Whether the current code branch is type-guarded.

### code

```
code: str = code

```

The module source code.

### current

```
current: Module | Class = None

```

The current object being visited.

### docstring_options

```
docstring_options: dict[str, Any] = docstring_options or {}

```

The docstring parsing options.

### docstring_parser

```
docstring_parser: DocstringStyle | Parser | None = (
    docstring_parser
)

```

The docstring parser to use.

### extensions

```
extensions: Extensions = extensions

```

The extensions to use when visiting the AST.

### filepath

```
filepath: Path = filepath

```

The module filepath.

### lines_collection

```
lines_collection: LinesCollection = (
    lines_collection or LinesCollection()
)

```

A collection of source code lines.

### module_name

```
module_name: str = module_name

```

The module name.

### modules_collection

```
modules_collection: ModulesCollection = (
    modules_collection or ModulesCollection()
)

```

A collection of modules.

### parent

```
parent: Module | None = parent

```

An optional parent for the final module object.

### type_guarded

```
type_guarded: bool = False

```

Whether the current code branch is type-guarded.

### decorators_to_labels

```
decorators_to_labels(
    decorators: list[Decorator],
) -> set[str]

```

Build and return a set of labels based on decorators.

Parameters:

- #### **`decorators`**

  (`list[Decorator]`) – The decorators to check.

Returns:

- `set[str]` – A set of labels.

### generic_visit

```
generic_visit(node: AST) -> None

```

Extend the base generic visit with extensions.

Parameters:

- #### **`node`**

  (`AST`) – The node to visit.

### get_base_property

```
get_base_property(
    decorators: list[Decorator], function: Function
) -> str | None

```

Check decorators to return the base property in case of setters and deleters.

Parameters:

- #### **`decorators`**

  (`list[Decorator]`) – The decorators to check.

Returns:

- **`base_property`** ( `str | None` ) – The property for which the setter/deleted is set.
- **`property_function`** ( `str | None` ) – Either "setter" or "deleter".

### get_module

```
get_module() -> Module

```

Build and return the object representing the module attached to this visitor.

This method triggers a complete visit of the module nodes.

Returns:

- `Module` – A module instance.

### handle_attribute

```
handle_attribute(
    node: Assign | AnnAssign,
    annotation: str | Expr | None = None,
) -> None

```

Handle an attribute (assignment) node.

Parameters:

- #### **`node`**

  (`Assign | AnnAssign`) – The node to visit.

- #### **`annotation`**

  (`str | Expr | None`, default: `None` ) – A potential annotation.

### handle_function

```
handle_function(
    node: AsyncFunctionDef | FunctionDef,
    labels: set | None = None,
) -> None

```

Handle a function definition node.

Parameters:

- #### **`node`**

  (`AsyncFunctionDef | FunctionDef`) – The node to visit.

- #### **`labels`**

  (`set | None`, default: `None` ) – Labels to add to the data object.

### visit

```
visit(node: AST) -> None

```

Extend the base visit with extensions.

Parameters:

- #### **`node`**

  (`AST`) – The node to visit.

### visit_annassign

```
visit_annassign(node: AnnAssign) -> None

```

Visit an annotated assignment node.

Parameters:

- #### **`node`**

  (`AnnAssign`) – The node to visit.

### visit_assign

```
visit_assign(node: Assign) -> None

```

Visit an assignment node.

Parameters:

- #### **`node`**

  (`Assign`) – The node to visit.

### visit_asyncfunctiondef

```
visit_asyncfunctiondef(node: AsyncFunctionDef) -> None

```

Visit an async function definition node.

Parameters:

- #### **`node`**

  (`AsyncFunctionDef`) – The node to visit.

### visit_augassign

```
visit_augassign(node: AugAssign) -> None

```

Visit an augmented assignment node.

Parameters:

- #### **`node`**

  (`AugAssign`) – The node to visit.

### visit_classdef

```
visit_classdef(node: ClassDef) -> None

```

Visit a class definition node.

Parameters:

- #### **`node`**

  (`ClassDef`) – The node to visit.

### visit_functiondef

```
visit_functiondef(node: FunctionDef) -> None

```

Visit a function definition node.

Parameters:

- #### **`node`**

  (`FunctionDef`) – The node to visit.

### visit_if

```
visit_if(node: If) -> None

```

Visit an "if" node.

Parameters:

- #### **`node`**

  (`If`) – The node to visit.

### visit_import

```
visit_import(node: Import) -> None

```

Visit an import node.

Parameters:

- #### **`node`**

  (`Import`) – The node to visit.

### visit_importfrom

```
visit_importfrom(node: ImportFrom) -> None

```

Visit an "import from" node.

Parameters:

- #### **`node`**

  (`ImportFrom`) – The node to visit.

### visit_module

```
visit_module(node: Module) -> None

```

Visit a module node.

Parameters:

- #### **`node`**

  (`Module`) – The node to visit.

### visit_typealias

```
visit_typealias(node: TypeAlias) -> None

```

Visit a type alias node.

Parameters:

- #### **`node`**

  (`TypeAlias`) – The node to visit.

## Inspector

```
Inspector(
    module_name: str,
    filepath: Path | None,
    extensions: Extensions,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
)

```

This class is used to instantiate an inspector.

Inspectors iterate on objects members to extract data from them.

Parameters:

- ### **`module_name`**

  (`str`) – The module name.

- ### **`filepath`**

  (`Path | None`) – The optional filepath.

- ### **`extensions`**

  (`Extensions`) – Extensions to use when inspecting.

- ### **`parent`**

  (`Module | None`, default: `None` ) – The module parent.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – The docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Methods:

- **`generic_inspect`** – Extend the base generic inspection with extensions.
- **`get_module`** – Build and return the object representing the module attached to this inspector.
- **`handle_attribute`** – Handle an attribute.
- **`handle_function`** – Handle a function.
- **`inspect`** – Extend the base inspection with extensions.
- **`inspect_attribute`** – Inspect an attribute.
- **`inspect_builtin_function`** – Inspect a builtin function.
- **`inspect_builtin_method`** – Inspect a builtin method.
- **`inspect_cached_property`** – Inspect a cached property.
- **`inspect_class`** – Inspect a class.
- **`inspect_classmethod`** – Inspect a class method.
- **`inspect_coroutine`** – Inspect a coroutine.
- **`inspect_function`** – Inspect a function.
- **`inspect_getset_descriptor`** – Inspect a get/set descriptor.
- **`inspect_method`** – Inspect a method.
- **`inspect_method_descriptor`** – Inspect a method descriptor.
- **`inspect_module`** – Inspect a module.
- **`inspect_property`** – Inspect a property.
- **`inspect_staticmethod`** – Inspect a static method.
- **`inspect_type_alias`** – Inspect a type alias.

Attributes:

- **`current`** (`Module | Class`) – The current object being inspected.
- **`docstring_options`** (`dict[str, Any]`) – The docstring parsing options.
- **`docstring_parser`** (`DocstringStyle | Parser | None`) – The docstring parser to use.
- **`extensions`** (`Extensions`) – The extensions to use when inspecting.
- **`filepath`** (`Path | None`) – The module file path.
- **`lines_collection`** (`LinesCollection`) – A collection of source code lines.
- **`module_name`** (`str`) – The module name.
- **`modules_collection`** (`ModulesCollection`) – A collection of modules.
- **`parent`** (`Module | None`) – An optional parent for the final module object.

### current

```
current: Module | Class = None

```

The current object being inspected.

### docstring_options

```
docstring_options: dict[str, Any] = docstring_options or {}

```

The docstring parsing options.

### docstring_parser

```
docstring_parser: DocstringStyle | Parser | None = (
    docstring_parser
)

```

The docstring parser to use.

### extensions

```
extensions: Extensions = extensions

```

The extensions to use when inspecting.

### filepath

```
filepath: Path | None = filepath

```

The module file path.

### lines_collection

```
lines_collection: LinesCollection = (
    lines_collection or LinesCollection()
)

```

A collection of source code lines.

### module_name

```
module_name: str = module_name

```

The module name.

### modules_collection

```
modules_collection: ModulesCollection = (
    modules_collection or ModulesCollection()
)

```

A collection of modules.

### parent

```
parent: Module | None = parent

```

An optional parent for the final module object.

### generic_inspect

```
generic_inspect(node: ObjectNode) -> None

```

Extend the base generic inspection with extensions.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### get_module

```
get_module(
    import_paths: Sequence[str | Path] | None = None,
) -> Module

```

Build and return the object representing the module attached to this inspector.

This method triggers a complete inspection of the module members.

Parameters:

- #### **`import_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – Paths replacing sys.path to import the module.

Returns:

- `Module` – A module instance.

### handle_attribute

```
handle_attribute(
    node: ObjectNode, annotation: str | Expr | None = None
) -> None

```

Handle an attribute.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

- #### **`annotation`**

  (`str | Expr | None`, default: `None` ) – A potential annotation.

### handle_function

```
handle_function(
    node: ObjectNode, labels: set | None = None
) -> None

```

Handle a function.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

- #### **`labels`**

  (`set | None`, default: `None` ) – Labels to add to the data object.

### inspect

```
inspect(node: ObjectNode) -> None

```

Extend the base inspection with extensions.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_attribute

```
inspect_attribute(node: ObjectNode) -> None

```

Inspect an attribute.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_builtin_function

```
inspect_builtin_function(node: ObjectNode) -> None

```

Inspect a builtin function.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_builtin_method

```
inspect_builtin_method(node: ObjectNode) -> None

```

Inspect a builtin method.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_cached_property

```
inspect_cached_property(node: ObjectNode) -> None

```

Inspect a cached property.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_class

```
inspect_class(node: ObjectNode) -> None

```

Inspect a class.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_classmethod

```
inspect_classmethod(node: ObjectNode) -> None

```

Inspect a class method.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_coroutine

```
inspect_coroutine(node: ObjectNode) -> None

```

Inspect a coroutine.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_function

```
inspect_function(node: ObjectNode) -> None

```

Inspect a function.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_getset_descriptor

```
inspect_getset_descriptor(node: ObjectNode) -> None

```

Inspect a get/set descriptor.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_method

```
inspect_method(node: ObjectNode) -> None

```

Inspect a method.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_method_descriptor

```
inspect_method_descriptor(node: ObjectNode) -> None

```

Inspect a method descriptor.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_module

```
inspect_module(node: ObjectNode) -> None

```

Inspect a module.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_property

```
inspect_property(node: ObjectNode) -> None

```

Inspect a property.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_staticmethod

```
inspect_staticmethod(node: ObjectNode) -> None

```

Inspect a static method.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### inspect_type_alias

```
inspect_type_alias(node: ObjectNode) -> None

```

Inspect a type alias.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

## **Dynamic analysis helpers**

## sys_path

```
sys_path(*paths: str | Path) -> Iterator[None]

```

Redefine `sys.path` temporarily.

Parameters:

- ### **`*paths`**

  (`str | Path`, default: `()` ) – The paths to use when importing modules. If no paths are given, keep sys.path untouched.

Yields:

- `None` – Nothing.

## dynamic_import

```
dynamic_import(
    import_path: str,
    import_paths: Sequence[str | Path] | None = None,
) -> Any

```

Dynamically import the specified object.

It can be a module, class, method, function, attribute, type alias, nested arbitrarily.

It works like this:

- for a given object path `a.b.x.y`
- it tries to import `a.b.x.y` as a module (with `importlib.import_module`)
- if it fails, it tries again with `a.b.x`, storing `y`
- then `a.b`, storing `x.y`
- then `a`, storing `b.x.y`
- if nothing worked, it raises an error
- if one of the iteration worked, it moves on, and...
- it tries to get the remaining (stored) parts with `getattr`
- for example it gets `b` from `a`, then `x` from `b`, etc.
- if a single attribute access fails, it raises an error
- if everything worked, it returns the last obtained attribute

Since the function potentially tries multiple things before succeeding, all errors happening along the way are recorded, and re-emitted with an `ImportError` when it fails, to let users know what was tried.

Important

The paths given through the `import_paths` parameter are used to temporarily patch `sys.path`: this function is therefore not thread-safe.

Important

The paths given as `import_paths` must be *correct*. The contents of `sys.path` must be consistent to what a user of the imported code would expect. Given a set of paths, if the import fails for a user, it will fail here too, with potentially unintuitive errors. If we wanted to make this function more robust, we could add a loop to "roll the window" of given paths, shifting them to the left (for example: `("/a/a", "/a/b", "/a/c/")`, then `("/a/b", "/a/c", "/a/a/")`, then `("/a/c", "/a/a", "/a/b/")`), to make sure each entry is given highest priority at least once, maintaining relative order, but we deem this unnecessary for now.

Parameters:

- ### **`import_path`**

  (`str`) – The path of the object to import.

- ### **`import_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The (sys) paths to import the object from.

Raises:

- `ModuleNotFoundError` – When the object's module could not be found.
- `ImportError` – When there was an import error or when couldn't get the attribute.

Returns:

- `Any` – The imported object.

## ObjectNode

```
ObjectNode(
    obj: Any, name: str, parent: ObjectNode | None = None
)

```

Helper class to represent an object tree.

It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).

Each node stores an object, its name, and a reference to its parent node.

Parameters:

- ### **`obj`**

  (`Any`) – A Python object.

- ### **`name`**

  (`str`) – The object's name.

- ### **`parent`**

  (`ObjectNode | None`, default: `None` ) – The object's parent node.

Attributes:

- **`alias_target_path`** (`str | None`) – Alias target path of this node, if the node should be an alias.
- **`children`** (`Sequence[ObjectNode]`) – The children of this node.
- **`exclude_specials`** (`set[str]`) – Low level attributes known to cause issues when resolving aliases.
- **`is_attribute`** (`bool`) – Whether this node's object is an attribute.
- **`is_builtin_function`** (`bool`) – Whether this node's object is a builtin function.
- **`is_builtin_method`** (`bool`) – Whether this node's object is a builtin method.
- **`is_cached_property`** (`bool`) – Whether this node's object is a cached property.
- **`is_class`** (`bool`) – Whether this node's object is a class.
- **`is_classmethod`** (`bool`) – Whether this node's object is a classmethod.
- **`is_coroutine`** (`bool`) – Whether this node's object is a coroutine.
- **`is_function`** (`bool`) – Whether this node's object is a function.
- **`is_getset_descriptor`** (`bool`) – Whether this node's object is a get/set descriptor.
- **`is_method`** (`bool`) – Whether this node's object is a method.
- **`is_method_descriptor`** (`bool`) – Whether this node's object is a method descriptor.
- **`is_module`** (`bool`) – Whether this node's object is a module.
- **`is_property`** (`bool`) – Whether this node's object is a property.
- **`is_staticmethod`** (`bool`) – Whether this node's object is a staticmethod.
- **`is_type_alias`** (`bool`) – Whether this node's object is a type alias.
- **`kind`** (`ObjectKind`) – The kind of this node.
- **`module`** (`ObjectNode`) – The object's module, fetched from the node tree.
- **`module_path`** (`str | None`) – The object's module path.
- **`name`** (`str`) – The Python object's name.
- **`obj`** (`Any`) – The actual Python object.
- **`parent`** (`ObjectNode | None`) – The parent node.
- **`parent_is_class`** (`bool`) – Whether the object of this node's parent is a class.
- **`path`** (`str`) – The object's (Python) path.

### alias_target_path

```
alias_target_path: str | None

```

Alias target path of this node, if the node should be an alias.

### children

```
children: Sequence[ObjectNode]

```

The children of this node.

### exclude_specials

```
exclude_specials: set[str] = {
    "__builtins__",
    "__loader__",
    "__spec__",
}

```

Low level attributes known to cause issues when resolving aliases.

### is_attribute

```
is_attribute: bool

```

Whether this node's object is an attribute.

### is_builtin_function

```
is_builtin_function: bool

```

Whether this node's object is a builtin function.

### is_builtin_method

```
is_builtin_method: bool

```

Whether this node's object is a builtin method.

### is_cached_property

```
is_cached_property: bool = is_cached_property

```

Whether this node's object is a cached property.

### is_class

```
is_class: bool

```

Whether this node's object is a class.

### is_classmethod

```
is_classmethod: bool

```

Whether this node's object is a classmethod.

### is_coroutine

```
is_coroutine: bool

```

Whether this node's object is a coroutine.

### is_function

```
is_function: bool

```

Whether this node's object is a function.

### is_getset_descriptor

```
is_getset_descriptor: bool

```

Whether this node's object is a get/set descriptor.

### is_method

```
is_method: bool

```

Whether this node's object is a method.

### is_method_descriptor

```
is_method_descriptor: bool

```

Whether this node's object is a method descriptor.

Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods.

### is_module

```
is_module: bool

```

Whether this node's object is a module.

### is_property

```
is_property: bool

```

Whether this node's object is a property.

### is_staticmethod

```
is_staticmethod: bool

```

Whether this node's object is a staticmethod.

### is_type_alias

```
is_type_alias: bool

```

Whether this node's object is a type alias.

### kind

```
kind: ObjectKind

```

The kind of this node.

### module

```
module: ObjectNode

```

The object's module, fetched from the node tree.

### module_path

```
module_path: str | None

```

The object's module path.

### name

```
name: str = name

```

The Python object's name.

### obj

```
obj: Any = obj

```

The actual Python object.

### parent

```
parent: ObjectNode | None = parent

```

The parent node.

### parent_is_class

```
parent_is_class: bool

```

Whether the object of this node's parent is a class.

### path

```
path: str

```

The object's (Python) path.

## ObjectKind

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.ObjectKind[ObjectKind]

              

              click griffe.ObjectKind href "" "griffe.ObjectKind"
            
```

Enumeration of the different runtime object kinds.

Attributes:

- **`ATTRIBUTE`** – Attributes.
- **`BUILTIN_FUNCTION`** – Built-in functions.
- **`BUILTIN_METHOD`** – Built-in methods.
- **`CACHED_PROPERTY`** – Cached properties.
- **`CLASS`** – Classes.
- **`CLASSMETHOD`** – Class methods.
- **`COROUTINE`** – Coroutines
- **`FUNCTION`** – Functions.
- **`GETSET_DESCRIPTOR`** – Get/set descriptors.
- **`METHOD`** – Methods.
- **`METHOD_DESCRIPTOR`** – Method descriptors.
- **`MODULE`** – Modules.
- **`PROPERTY`** – Properties.
- **`STATICMETHOD`** – Static methods.
- **`TYPE_ALIAS`** – Type aliases.

### ATTRIBUTE

```
ATTRIBUTE = 'attribute'

```

Attributes.

### BUILTIN_FUNCTION

```
BUILTIN_FUNCTION = 'builtin_function'

```

Built-in functions.

### BUILTIN_METHOD

```
BUILTIN_METHOD = 'builtin_method'

```

Built-in methods.

### CACHED_PROPERTY

```
CACHED_PROPERTY = 'cached_property'

```

Cached properties.

### CLASS

```
CLASS = 'class'

```

Classes.

### CLASSMETHOD

```
CLASSMETHOD = 'classmethod'

```

Class methods.

### COROUTINE

```
COROUTINE = 'coroutine'

```

Coroutines

### FUNCTION

```
FUNCTION = 'function'

```

Functions.

### GETSET_DESCRIPTOR

```
GETSET_DESCRIPTOR = 'getset_descriptor'

```

Get/set descriptors.

### METHOD

```
METHOD = 'method'

```

Methods.

### METHOD_DESCRIPTOR

```
METHOD_DESCRIPTOR = 'method_descriptor'

```

Method descriptors.

### MODULE

```
MODULE = 'module'

```

Modules.

### PROPERTY

```
PROPERTY = 'property'

```

Properties.

### STATICMETHOD

```
STATICMETHOD = 'staticmethod'

```

Static methods.

### TYPE_ALIAS

```
TYPE_ALIAS = 'type_alias'

```

Type aliases.

## **Static analysis helpers**

## builtin_decorators

```
builtin_decorators = {
    "property": "property",
    "staticmethod": "staticmethod",
    "classmethod": "classmethod",
}

```

Mapping of builtin decorators to labels.

## stdlib_decorators

```
stdlib_decorators = {
    "abc.abstractmethod": {"abstractmethod"},
    "functools.cache": {"cached"},
    "functools.cached_property": {"cached", "property"},
    "cached_property.cached_property": {
        "cached",
        "property",
    },
    "functools.lru_cache": {"cached"},
    "dataclasses.dataclass": {"dataclass"},
}

```

Mapping of standard library decorators to labels.

## typing_overload

```
typing_overload = {
    "typing.overload",
    "typing_extensions.overload",
}

```

Set of recognized typing overload decorators.

When such a decorator is found, the decorated function becomes an overload.

## ast_kind

```
ast_kind(node: AST) -> str

```

Return the kind of an AST node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Returns:

- `str` – The node kind.

## ast_children

```
ast_children(node: AST) -> Iterator[AST]

```

Return the children of an AST node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Yields:

- `AST` – The node children.

## ast_previous_siblings

```
ast_previous_siblings(node: AST) -> Iterator[AST]

```

Return the previous siblings of this node, starting from the closest.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Yields:

- `AST` – The previous siblings.

## ast_next_siblings

```
ast_next_siblings(node: AST) -> Iterator[AST]

```

Return the next siblings of this node, starting from the closest.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Yields:

- `AST` – The next siblings.

## ast_siblings

```
ast_siblings(node: AST) -> Iterator[AST]

```

Return the siblings of this node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Yields:

- `AST` – The siblings.

## ast_previous

```
ast_previous(node: AST) -> AST

```

Return the previous sibling of this node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Raises:

- `LastNodeError` – When the node does not have previous siblings.

Returns:

- `AST` – The sibling.

## ast_next

```
ast_next(node: AST) -> AST

```

Return the next sibling of this node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Raises:

- `LastNodeError` – When the node does not have next siblings.

Returns:

- `AST` – The sibling.

## ast_first_child

```
ast_first_child(node: AST) -> AST

```

Return the first child of this node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Raises:

- `LastNodeError` – When the node does not have children.

Returns:

- `AST` – The child.

## ast_last_child

```
ast_last_child(node: AST) -> AST

```

Return the lasts child of this node.

Parameters:

- ### **`node`**

  (`AST`) – The AST node.

Raises:

- `LastNodeError` – When the node does not have children.

Returns:

- `AST` – The child.

## get_docstring

```
get_docstring(
    node: AST, *, strict: bool = False
) -> tuple[str | None, int | None, int | None]

```

Extract a docstring.

Parameters:

- ### **`node`**

  (`AST`) – The node to extract the docstring from.

- ### **`strict`**

  (`bool`, default: `False` ) – Whether to skip searching the body (functions).

Returns:

- `tuple[str | None, int | None, int | None]` – A tuple with the value and line numbers of the docstring.

## get_name

```
get_name(node: AST) -> str

```

Extract name from an assignment node.

Parameters:

- ### **`node`**

  (`AST`) – The node to extract names from.

Returns:

- `str` – A list of names.

## get_names

```
get_names(node: AST) -> list[str]

```

Extract names from an assignment node.

Parameters:

- ### **`node`**

  (`AST`) – The node to extract names from.

Returns:

- `list[str]` – A list of names.

## get_instance_names

```
get_instance_names(node: AST) -> list[str]

```

Extract names from an assignment node, only for instance attributes.

Parameters:

- ### **`node`**

  (`AST`) – The node to extract names from.

Returns:

- `list[str]` – A list of names.

## get\_\_all\_\_

```
get__all__(
    node: Assign | AnnAssign | AugAssign, parent: Module
) -> list[str | ExprName]

```

Get the values declared in `__all__`.

Parameters:

- ### **`node`**

  (`Assign | AnnAssign | AugAssign`) – The assignment node.

- ### **`parent`**

  (`Module`) – The parent module.

Returns:

- `list[str | ExprName]` – A set of names.

## safe_get\_\_all\_\_

```
safe_get__all__(
    node: Assign | AnnAssign | AugAssign,
    parent: Module,
    log_level: LogLevel = debug,
) -> list[str | ExprName]

```

Safely (no exception) extract values in `__all__`.

Parameters:

- ### **`node`**

  (`Assign | AnnAssign | AugAssign`) – The __all__ assignment node.

- ### **`parent`**

  (`Module`) – The parent used to resolve the names.

- ### **`log_level`**

  (`LogLevel`, default: `debug` ) – Log level to use to log a message.

Returns:

- `list[str | ExprName]` – A list of strings or resolvable names.

## relative_to_absolute

```
relative_to_absolute(
    node: ImportFrom, name: alias, current_module: Module
) -> str

```

Convert a relative import path to an absolute one.

Parameters:

- ### **`node`**

  (`ImportFrom`) – The "from ... import ..." AST node.

- ### **`name`**

  (`alias`) – The imported name.

- ### **`current_module`**

  (`Module`) – The module in which the import happens.

Returns:

- `str` – The absolute import path.

## get_parameters

```
get_parameters(node: arguments) -> ParametersType

```

## get_value

```
get_value(node: AST | None) -> str | None

```

Get the string representation of a node.

Parameters:

- ### **`node`**

  (`AST | None`) – The node to represent.

Returns:

- `str | None` – The representing code for the node.

## safe_get_value

```
safe_get_value(
    node: AST | None, filepath: str | Path | None = None
) -> str | None

```

Safely (no exception) get the string representation of a node.

Parameters:

- ### **`node`**

  (`AST | None`) – The node to represent.

- ### **`filepath`**

  (`str | Path | None`, default: `None` ) – An optional filepath from where the node comes.

Returns:

- `str | None` – The representing code for the node.

## **Deprecated API**

## ExportedName

```
ExportedName(name: str, parent: Module)

```

Deprecated. An intermediate class to store names.

The get\_\_all\_\_ function now returns instances of ExprName instead.

Attributes:

- **`name`** (`str`) – The exported name.
- **`parent`** (`Module`) – The parent module.

### name

```
name: str

```

The exported name.

### parent

```
parent: Module

```

The parent module.

# API checks

## find_breaking_changes

```
find_breaking_changes(
    old_obj: Object | Alias, new_obj: Object | Alias
) -> Iterator[Breakage]

```

Find breaking changes between two versions of the same API.

The function will iterate recursively on all objects and yield breaking changes with detailed information.

Parameters:

- ### **`old_obj`**

  (`Object | Alias`) – The old version of an object.

- ### **`new_obj`**

  (`Object | Alias`) – The new version of an object.

Yields:

- `Breakage` – Breaking changes.

Examples:

```
>>> import sys, griffe
>>> new = griffe.load("pkg")
>>> old = griffe.load_git("pkg", "1.2.3")
>>> for breakage in griffe.find_breaking_changes(old, new)
...     print(breakage.explain(style=style), file=sys.stderr)

```

## ExplanationStyle

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.ExplanationStyle[ExplanationStyle]

              

              click griffe.ExplanationStyle href "" "griffe.ExplanationStyle"
            
```

Enumeration of the possible styles for explanations.

Attributes:

- **`GITHUB`** – Explanation as GitHub workflow commands warnings, adapted to CI.
- **`MARKDOWN`** – Explanations in Markdown, adapted to changelogs.
- **`ONE_LINE`** – Explanations on one-line.
- **`VERBOSE`** – Explanations on multiple lines.

### GITHUB

```
GITHUB = 'github'

```

Explanation as GitHub workflow commands warnings, adapted to CI.

### MARKDOWN

```
MARKDOWN = 'markdown'

```

Explanations in Markdown, adapted to changelogs.

### ONE_LINE

```
ONE_LINE = 'oneline'

```

Explanations on one-line.

### VERBOSE

```
VERBOSE = 'verbose'

```

Explanations on multiple lines.

## Breakage

```
Breakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Breakages can explain what broke from a version to another.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## BreakageKind

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.BreakageKind[BreakageKind]

              

              click griffe.BreakageKind href "" "griffe.BreakageKind"
            
```

Enumeration of the possible API breakages.

Attributes:

- **`ATTRIBUTE_CHANGED_TYPE`** – Attribute types are incompatible
- **`ATTRIBUTE_CHANGED_VALUE`** – Attribute value was changed
- **`CLASS_REMOVED_BASE`** – Base class was removed
- **`OBJECT_CHANGED_KIND`** – Public object points to a different kind of object
- **`OBJECT_REMOVED`** – Public object was removed
- **`PARAMETER_ADDED_REQUIRED`** – Parameter was added as required
- **`PARAMETER_CHANGED_DEFAULT`** – Parameter default was changed
- **`PARAMETER_CHANGED_KIND`** – Parameter kind was changed
- **`PARAMETER_CHANGED_REQUIRED`** – Parameter is now required
- **`PARAMETER_MOVED`** – Positional parameter was moved
- **`PARAMETER_REMOVED`** – Parameter was removed
- **`RETURN_CHANGED_TYPE`** – Return types are incompatible

### ATTRIBUTE_CHANGED_TYPE

```
ATTRIBUTE_CHANGED_TYPE = 'Attribute types are incompatible'

```

Attribute types are incompatible

### ATTRIBUTE_CHANGED_VALUE

```
ATTRIBUTE_CHANGED_VALUE = 'Attribute value was changed'

```

Attribute value was changed

### CLASS_REMOVED_BASE

```
CLASS_REMOVED_BASE = 'Base class was removed'

```

Base class was removed

### OBJECT_CHANGED_KIND

```
OBJECT_CHANGED_KIND = (
    "Public object points to a different kind of object"
)

```

Public object points to a different kind of object

### OBJECT_REMOVED

```
OBJECT_REMOVED = 'Public object was removed'

```

Public object was removed

### PARAMETER_ADDED_REQUIRED

```
PARAMETER_ADDED_REQUIRED = "Parameter was added as required"

```

Parameter was added as required

### PARAMETER_CHANGED_DEFAULT

```
PARAMETER_CHANGED_DEFAULT = 'Parameter default was changed'

```

Parameter default was changed

### PARAMETER_CHANGED_KIND

```
PARAMETER_CHANGED_KIND = 'Parameter kind was changed'

```

Parameter kind was changed

### PARAMETER_CHANGED_REQUIRED

```
PARAMETER_CHANGED_REQUIRED = 'Parameter is now required'

```

Parameter is now required

### PARAMETER_MOVED

```
PARAMETER_MOVED = 'Positional parameter was moved'

```

Positional parameter was moved

### PARAMETER_REMOVED

```
PARAMETER_REMOVED = 'Parameter was removed'

```

Parameter was removed

### RETURN_CHANGED_TYPE

```
RETURN_CHANGED_TYPE = 'Return types are incompatible'

```

Return types are incompatible

## AttributeChangedTypeBreakage

```
AttributeChangedTypeBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.AttributeChangedTypeBreakage[AttributeChangedTypeBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.AttributeChangedTypeBreakage
                


              click griffe.AttributeChangedTypeBreakage href "" "griffe.AttributeChangedTypeBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for attributes whose type changed.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = ATTRIBUTE_CHANGED_TYPE

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## AttributeChangedValueBreakage

```
AttributeChangedValueBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.AttributeChangedValueBreakage[AttributeChangedValueBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.AttributeChangedValueBreakage
                


              click griffe.AttributeChangedValueBreakage href "" "griffe.AttributeChangedValueBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for attributes whose value changed.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = ATTRIBUTE_CHANGED_VALUE

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ClassRemovedBaseBreakage

```
ClassRemovedBaseBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ClassRemovedBaseBreakage[ClassRemovedBaseBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ClassRemovedBaseBreakage
                


              click griffe.ClassRemovedBaseBreakage href "" "griffe.ClassRemovedBaseBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for removed base classes.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = CLASS_REMOVED_BASE

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ObjectChangedKindBreakage

```
ObjectChangedKindBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ObjectChangedKindBreakage[ObjectChangedKindBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ObjectChangedKindBreakage
                


              click griffe.ObjectChangedKindBreakage href "" "griffe.ObjectChangedKindBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for objects whose kind changed.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = OBJECT_CHANGED_KIND

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ObjectRemovedBreakage

```
ObjectRemovedBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ObjectRemovedBreakage[ObjectRemovedBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ObjectRemovedBreakage
                


              click griffe.ObjectRemovedBreakage href "" "griffe.ObjectRemovedBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for removed objects.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = OBJECT_REMOVED

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ParameterAddedRequiredBreakage

```
ParameterAddedRequiredBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ParameterAddedRequiredBreakage[ParameterAddedRequiredBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterAddedRequiredBreakage
                


              click griffe.ParameterAddedRequiredBreakage href "" "griffe.ParameterAddedRequiredBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for new parameters added as required.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_ADDED_REQUIRED

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ParameterChangedDefaultBreakage

```
ParameterChangedDefaultBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ParameterChangedDefaultBreakage[ParameterChangedDefaultBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterChangedDefaultBreakage
                


              click griffe.ParameterChangedDefaultBreakage href "" "griffe.ParameterChangedDefaultBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for parameters whose default value changed.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_CHANGED_DEFAULT

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ParameterChangedKindBreakage

```
ParameterChangedKindBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ParameterChangedKindBreakage[ParameterChangedKindBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterChangedKindBreakage
                


              click griffe.ParameterChangedKindBreakage href "" "griffe.ParameterChangedKindBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for parameters whose kind changed.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_CHANGED_KIND

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ParameterChangedRequiredBreakage

```
ParameterChangedRequiredBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ParameterChangedRequiredBreakage[ParameterChangedRequiredBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterChangedRequiredBreakage
                


              click griffe.ParameterChangedRequiredBreakage href "" "griffe.ParameterChangedRequiredBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for parameters which became required.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_CHANGED_REQUIRED

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ParameterMovedBreakage

```
ParameterMovedBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ParameterMovedBreakage[ParameterMovedBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterMovedBreakage
                


              click griffe.ParameterMovedBreakage href "" "griffe.ParameterMovedBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for moved parameters.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_MOVED

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ParameterRemovedBreakage

```
ParameterRemovedBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ParameterRemovedBreakage[ParameterRemovedBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ParameterRemovedBreakage
                


              click griffe.ParameterRemovedBreakage href "" "griffe.ParameterRemovedBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for removed parameters.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = PARAMETER_REMOVED

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

## ReturnChangedTypeBreakage

```
ReturnChangedTypeBreakage(
    obj: Object,
    old_value: Any,
    new_value: Any,
    details: str = "",
)

```

Bases: `Breakage`

```

              flowchart TD
              griffe.ReturnChangedTypeBreakage[ReturnChangedTypeBreakage]
              griffe._internal.diff.Breakage[Breakage]

                              griffe._internal.diff.Breakage --> griffe.ReturnChangedTypeBreakage
                


              click griffe.ReturnChangedTypeBreakage href "" "griffe.ReturnChangedTypeBreakage"
              click griffe._internal.diff.Breakage href "" "griffe._internal.diff.Breakage"
            
```

Specific breakage class for return values which changed type.

Parameters:

- ### **`obj`**

  (`Object`) – The object related to the breakage.

- ### **`old_value`**

  (`Any`) – The old value.

- ### **`new_value`**

  (`Any`) – The new, incompatible value.

- ### **`details`**

  (`str`, default: `''` ) – Some details about the breakage.

Methods:

- **`as_dict`** – Return this object's data as a dictionary.
- **`explain`** – Explain the breakage by showing old and new value.

Attributes:

- **`details`** – Some details about the breakage.
- **`kind`** (`BreakageKind`) – The kind of breakage.
- **`new_value`** – The new, incompatible value.
- **`obj`** – The object related to the breakage.
- **`old_value`** – The old value.

### details

```
details = details

```

Some details about the breakage.

### kind

```
kind: BreakageKind = RETURN_CHANGED_TYPE

```

The kind of breakage.

### new_value

```
new_value = new_value

```

The new, incompatible value.

### obj

```
obj = obj

```

The object related to the breakage.

### old_value

```
old_value = old_value

```

The old value.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### explain

```
explain(style: ExplanationStyle = ONE_LINE) -> str

```

Explain the breakage by showing old and new value.

Parameters:

- #### **`style`**

  (`ExplanationStyle`, default: `ONE_LINE` ) – The explanation style to use.

Returns:

- `str` – An explanation.

# CLI entrypoints

## **Main API**

## main

```
main(args: list[str] | None = None) -> int

```

Run the main program.

This function is executed when you type `griffe` or `python -m griffe`.

Parameters:

- ### **`args`**

  (`list[str] | None`, default: `None` ) – Arguments passed from the command line.

Returns:

- `int` – An exit code.

## check

```
check(
    package: str | Path,
    against: str | None = None,
    against_path: str | Path | None = None,
    *,
    base_ref: str | None = None,
    extensions: Sequence[
        str | dict[str, Any] | Extension | type[Extension]
    ]
    | None = None,
    search_paths: Sequence[str | Path] | None = None,
    append_sys_path: bool = False,
    find_stubs_package: bool = False,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    verbose: bool = False,
    color: bool | None = None,
    style: str | ExplanationStyle | None = None,
) -> int

```

Check for API breaking changes in two versions of the same package.

Parameters:

- ### **`package`**

  (`str | Path`) – The package to load and check.

- ### **`against`**

  (`str | None`, default: `None` ) – Older Git reference (commit, branch, tag) to check against.

- ### **`against_path`**

  (`str | Path | None`, default: `None` ) – Path when the "against" reference is checked out.

- ### **`base_ref`**

  (`str | None`, default: `None` ) – Git reference (commit, branch, tag) to check.

- ### **`extensions`**

  (`Sequence[str | dict[str, Any] | Extension | type[Extension]] | None`, default: `None` ) – The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The paths to search into.

- ### **`append_sys_path`**

  (`bool`, default: `False` ) – Whether to append the contents of sys.path to the search paths.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) – Whether to force using dynamic analysis when loading data.

- ### **`verbose`**

  (`bool`, default: `False` ) – Use a verbose output.

Returns:

- `int` – 0 for success, 1 for failure.

## dump

```
dump(
    packages: Sequence[str],
    *,
    output: str | IO | None = None,
    full: bool = False,
    docstring_parser: Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    extensions: Sequence[
        str | dict[str, Any] | Extension | type[Extension]
    ]
    | None = None,
    resolve_aliases: bool = False,
    resolve_implicit: bool = False,
    resolve_external: bool | None = None,
    search_paths: Sequence[str | Path] | None = None,
    find_stubs_package: bool = False,
    append_sys_path: bool = False,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    stats: bool = False,
) -> int

```

Load packages data and dump it as JSON.

Parameters:

- ### **`packages`**

  (`Sequence[str]`) – The packages to load and dump.

- ### **`output`**

  (`str | IO | None`, default: `None` ) – Where to output the JSON-serialized data.

- ### **`full`**

  (`bool`, default: `False` ) – Whether to output full or minimal data.

- ### **`docstring_parser`**

  (`Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) – Whether to resolve aliases (indirect objects references).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) – Whether to resolve every alias or only the explicitly exported ones.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) – Whether to load additional, unspecified modules to resolve aliases. Default is to resolve only from one module to its private sibling (ast -> \_ast).

- ### **`extensions`**

  (`Sequence[str | dict[str, Any] | Extension | type[Extension]] | None`, default: `None` ) – The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The paths to search into.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) – Whether to search for stubs-only packages. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`append_sys_path`**

  (`bool`, default: `False` ) – Whether to append the contents of sys.path to the search paths.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) – Whether to force using dynamic analysis when loading data.

- ### **`stats`**

  (`bool`, default: `False` ) – Whether to compute and log stats about loading.

Returns:

- `int` – 0 for success, 1 for failure.

## **Advanced API**

## get_parser

```
get_parser() -> ArgumentParser

```

Return the CLI argument parser.

Returns:

- `ArgumentParser` – An argparse parser.

# Docstrings

Docstrings are [parsed](parsers/) and the extracted information is structured in [models](models/).

# Exceptions

## GriffeError

Bases: `Exception`

```

              flowchart TD
              griffe.GriffeError[GriffeError]

              

              click griffe.GriffeError href "" "griffe.GriffeError"
            
```

The base exception for all Griffe errors.

## LoadingError

Bases: `GriffeError`

```

              flowchart TD
              griffe.LoadingError[LoadingError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.LoadingError
                


              click griffe.LoadingError href "" "griffe.LoadingError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

The base exception for all Griffe errors.

## NameResolutionError

Bases: `GriffeError`

```

              flowchart TD
              griffe.NameResolutionError[NameResolutionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.NameResolutionError
                


              click griffe.NameResolutionError href "" "griffe.NameResolutionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception for names that cannot be resolved in a object scope.

## UnhandledEditableModuleError

Bases: `GriffeError`

```

              flowchart TD
              griffe.UnhandledEditableModuleError[UnhandledEditableModuleError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.UnhandledEditableModuleError
                


              click griffe.UnhandledEditableModuleError href "" "griffe.UnhandledEditableModuleError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception for unhandled editables modules, when searching modules.

## UnimportableModuleError

Bases: `GriffeError`

```

              flowchart TD
              griffe.UnimportableModuleError[UnimportableModuleError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.UnimportableModuleError
                


              click griffe.UnimportableModuleError href "" "griffe.UnimportableModuleError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception for modules that cannot be imported.

## AliasResolutionError

```
AliasResolutionError(alias: Alias)

```

Bases: `GriffeError`

```

              flowchart TD
              griffe.AliasResolutionError[AliasResolutionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.AliasResolutionError
                


              click griffe.AliasResolutionError href "" "griffe.AliasResolutionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception for alias that cannot be resolved.

Parameters:

- ### **`alias`**

  (`Alias`) – The alias that could not be resolved.

Attributes:

- **`alias`** (`Alias`) – The alias that triggered the error.

### alias

```
alias: Alias = alias

```

The alias that triggered the error.

## CyclicAliasError

```
CyclicAliasError(chain: list[str])

```

Bases: `GriffeError`

```

              flowchart TD
              griffe.CyclicAliasError[CyclicAliasError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.CyclicAliasError
                


              click griffe.CyclicAliasError href "" "griffe.CyclicAliasError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception raised when a cycle is detected in aliases.

Parameters:

- ### **`chain`**

  (`list[str]`) – The cyclic chain of items (such as target path).

Attributes:

- **`chain`** (`list[str]`) – The chain of aliases that created the cycle.

### chain

```
chain: list[str] = chain

```

The chain of aliases that created the cycle.

## LastNodeError

Bases: `GriffeError`

```

              flowchart TD
              griffe.LastNodeError[LastNodeError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.LastNodeError
                


              click griffe.LastNodeError href "" "griffe.LastNodeError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception raised when trying to access a next or previous node.

## RootNodeError

Bases: `GriffeError`

```

              flowchart TD
              griffe.RootNodeError[RootNodeError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.RootNodeError
                


              click griffe.RootNodeError href "" "griffe.RootNodeError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception raised when trying to use siblings properties on a root node.

## BuiltinModuleError

Bases: `GriffeError`

```

              flowchart TD
              griffe.BuiltinModuleError[BuiltinModuleError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.BuiltinModuleError
                


              click griffe.BuiltinModuleError href "" "griffe.BuiltinModuleError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception raised when trying to access the filepath of a builtin module.

## ExtensionError

Bases: `GriffeError`

```

              flowchart TD
              griffe.ExtensionError[ExtensionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.ExtensionError
                


              click griffe.ExtensionError href "" "griffe.ExtensionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Base class for errors raised by extensions.

## ExtensionNotLoadedError

Bases: `ExtensionError`

```

              flowchart TD
              griffe.ExtensionNotLoadedError[ExtensionNotLoadedError]
              griffe._internal.exceptions.ExtensionError[ExtensionError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.ExtensionError --> griffe.ExtensionNotLoadedError
                                griffe._internal.exceptions.GriffeError --> griffe._internal.exceptions.ExtensionError
                



              click griffe.ExtensionNotLoadedError href "" "griffe.ExtensionNotLoadedError"
              click griffe._internal.exceptions.ExtensionError href "" "griffe._internal.exceptions.ExtensionError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception raised when an extension could not be loaded.

## GitError

Bases: `GriffeError`

```

              flowchart TD
              griffe.GitError[GitError]
              griffe._internal.exceptions.GriffeError[GriffeError]

                              griffe._internal.exceptions.GriffeError --> griffe.GitError
                


              click griffe.GitError href "" "griffe.GitError"
              click griffe._internal.exceptions.GriffeError href "" "griffe._internal.exceptions.GriffeError"
            
```

Exception raised for errors related to Git.

# Expressions

## **Helpers**

## get_annotation

```
get_annotation = partial(get_expression, parse_strings=None)

```

## get_base_class

```
get_base_class = partial(
    get_expression, parse_strings=False
)

```

## get_condition

```
get_condition = partial(get_expression, parse_strings=False)

```

## get_expression

```
get_expression(
    node: AST | None,
    parent: Module | Class,
    *,
    member: str | None = None,
    parse_strings: bool | None = None,
) -> Expr | None

```

Build an expression from an AST.

Parameters:

- ### **`node`**

  (`AST | None`) – The annotation node.

- ### **`parent`**

  (`Module | Class`) – The parent used to resolve the name.

- ### **`member`**

  (`str | None`, default: `None` ) – The member name (for resolution in its scope).

- ### **`parse_strings`**

  (`bool | None`, default: `None` ) – Whether to try and parse strings as type annotations.

Returns:

- `Expr | None` – A string or resovable name or expression.

## safe_get_annotation

```
safe_get_annotation = partial(
    safe_get_expression,
    parse_strings=None,
    msg_format=_msg_format % "annotation",
)

```

## safe_get_base_class

```
safe_get_base_class = partial(
    safe_get_expression,
    parse_strings=False,
    msg_format=_msg_format % "base class",
)

```

## safe_get_condition

```
safe_get_condition = partial(
    safe_get_expression,
    parse_strings=False,
    msg_format=_msg_format % "condition",
)

```

## safe_get_expression

```
safe_get_expression(
    node: AST | None,
    parent: Module | Class,
    *,
    member: str | None = None,
    parse_strings: bool | None = None,
    log_level: LogLevel | None = error,
    msg_format: str = "{path}:{lineno}: Failed to get expression from {node_class}: {error}",
) -> Expr | None

```

Safely (no exception) build a resolvable annotation.

Parameters:

- ### **`node`**

  (`AST | None`) – The annotation node.

- ### **`parent`**

  (`Module | Class`) – The parent used to resolve the name.

- ### **`member`**

  (`str | None`, default: `None` ) – The member name (for resolution in its scope).

- ### **`parse_strings`**

  (`bool | None`, default: `None` ) – Whether to try and parse strings as type annotations.

- ### **`log_level`**

  (`LogLevel | None`, default: `error` ) – Log level to use to log a message. None to disable logging.

- ### **`msg_format`**

  (`str`, default: `'{path}:{lineno}: Failed to get expression from {node_class}: {error}'` ) – A format string for the log message. Available placeholders: path, lineno, node, error.

Returns:

- `Expr | None` – A string or resovable name or expression.

## **Expression nodes**

## Expr

```
Expr()

```

Base class for expressions.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprAttribute

```
ExprAttribute(values: list[str | Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprAttribute[ExprAttribute]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprAttribute
                


              click griffe.ExprAttribute href "" "griffe.ExprAttribute"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Attributes like `a.b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`append`** – Append a name to this attribute.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – The canonical path of this attribute.
- **`classname`** (`str`) – The expression class name.
- **`first`** (`str | Expr`) – The first part of this attribute (on the left).
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`last`** (`ExprName`) – The last part of this attribute (on the right).
- **`path`** (`str`) – The path of this attribute.
- **`values`** (`list[str | Expr]`) – The different parts of the dotted chain.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

The canonical path of this attribute.

### classname

```
classname: str

```

The expression class name.

### first

```
first: str | Expr

```

The first part of this attribute (on the left).

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### last

```
last: ExprName

```

The last part of this attribute (on the right).

### path

```
path: str

```

The path of this attribute.

### values

```
values: list[str | Expr]

```

The different parts of the dotted chain.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### append

```
append(value: ExprName) -> None

```

Append a name to this attribute.

Parameters:

- #### **`value`**

  (`ExprName`) – The expression name to append.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> ExprName | ExprAttribute

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprBinOp

```
ExprBinOp(
    left: str | Expr, operator: str, right: str | Expr
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprBinOp[ExprBinOp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprBinOp
                


              click griffe.ExprBinOp href "" "griffe.ExprBinOp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Binary operations like `a + b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`left`** (`str | Expr`) – Left part.
- **`operator`** (`str`) – Binary operator.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`right`** (`str | Expr`) – Right part.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### left

```
left: str | Expr

```

Left part.

### operator

```
operator: str

```

Binary operator.

### path

```
path: str

```

Path of the expressed name/attribute.

### right

```
right: str | Expr

```

Right part.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprBoolOp

```
ExprBoolOp(operator: str, values: Sequence[str | Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprBoolOp[ExprBoolOp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprBoolOp
                


              click griffe.ExprBoolOp href "" "griffe.ExprBoolOp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Boolean operations like `a or b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`operator`** (`str`) – Boolean operator.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`values`** (`Sequence[str | Expr]`) – Operands.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### operator

```
operator: str

```

Boolean operator.

### path

```
path: str

```

Path of the expressed name/attribute.

### values

```
values: Sequence[str | Expr]

```

Operands.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprCall

```
ExprCall(function: Expr, arguments: Sequence[str | Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprCall[ExprCall]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprCall
                


              click griffe.ExprCall href "" "griffe.ExprCall"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Calls like `f()`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`arguments`** (`Sequence[str | Expr]`) – Passed arguments.
- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – The canonical path of this subscript's left part.
- **`classname`** (`str`) – The expression class name.
- **`function`** (`Expr`) – Function called.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### arguments

```
arguments: Sequence[str | Expr]

```

Passed arguments.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

The canonical path of this subscript's left part.

### classname

```
classname: str

```

The expression class name.

### function

```
function: Expr

```

Function called.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprCompare

```
ExprCompare(
    left: str | Expr,
    operators: Sequence[str],
    comparators: Sequence[str | Expr],
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprCompare[ExprCompare]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprCompare
                


              click griffe.ExprCompare href "" "griffe.ExprCompare"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Comparisons like `a > b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`comparators`** (`Sequence[str | Expr]`) – Things compared.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`left`** (`str | Expr`) – Left part.
- **`operators`** (`Sequence[str]`) – Comparison operators.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### comparators

```
comparators: Sequence[str | Expr]

```

Things compared.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### left

```
left: str | Expr

```

Left part.

### operators

```
operators: Sequence[str]

```

Comparison operators.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprComprehension

```
ExprComprehension(
    target: str | Expr,
    iterable: str | Expr,
    conditions: Sequence[str | Expr],
    is_async: bool = False,
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprComprehension[ExprComprehension]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprComprehension
                


              click griffe.ExprComprehension href "" "griffe.ExprComprehension"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Comprehensions like `a for b in c if d`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`conditions`** (`Sequence[str | Expr]`) – Conditions to include the target in the result.
- **`is_async`** (`bool`) – Async comprehension or not.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`iterable`** (`str | Expr`) – Value iterated on.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`target`** (`str | Expr`) – Comprehension target (value added to the result).

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### conditions

```
conditions: Sequence[str | Expr]

```

Conditions to include the target in the result.

### is_async

```
is_async: bool = False

```

Async comprehension or not.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### iterable

```
iterable: str | Expr

```

Value iterated on.

### path

```
path: str

```

Path of the expressed name/attribute.

### target

```
target: str | Expr

```

Comprehension target (value added to the result).

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprConstant

```
ExprConstant(value: str)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprConstant[ExprConstant]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprConstant
                


              click griffe.ExprConstant href "" "griffe.ExprConstant"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Constants like `"a"` or `1`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str`) – Constant value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str

```

Constant value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprDict

```
ExprDict(
    keys: Sequence[str | Expr | None],
    values: Sequence[str | Expr],
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprDict[ExprDict]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprDict
                


              click griffe.ExprDict href "" "griffe.ExprDict"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Dictionaries like `{"a": 0}`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`keys`** (`Sequence[str | Expr | None]`) – Dict keys.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`values`** (`Sequence[str | Expr]`) – Dict values.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### keys

```
keys: Sequence[str | Expr | None]

```

Dict keys.

### path

```
path: str

```

Path of the expressed name/attribute.

### values

```
values: Sequence[str | Expr]

```

Dict values.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprDictComp

```
ExprDictComp(
    key: str | Expr,
    value: str | Expr,
    generators: Sequence[Expr],
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprDictComp[ExprDictComp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprDictComp
                


              click griffe.ExprDictComp href "" "griffe.ExprDictComp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Dict comprehensions like `{k: v for k, v in a}`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`generators`** (`Sequence[Expr]`) – Generators iterated on.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`key`** (`str | Expr`) – Target key.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str | Expr`) – Target value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### generators

```
generators: Sequence[Expr]

```

Generators iterated on.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### key

```
key: str | Expr

```

Target key.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str | Expr

```

Target value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprExtSlice

```
ExprExtSlice(dims: Sequence[str | Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprExtSlice[ExprExtSlice]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprExtSlice
                


              click griffe.ExprExtSlice href "" "griffe.ExprExtSlice"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Extended slice like `a[x:y, z]`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`dims`** (`Sequence[str | Expr]`) – Dims.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### dims

```
dims: Sequence[str | Expr]

```

Dims.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprFormatted

```
ExprFormatted(value: str | Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprFormatted[ExprFormatted]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprFormatted
                


              click griffe.ExprFormatted href "" "griffe.ExprFormatted"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Formatted string like `{1 + 1}`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str | Expr`) – Formatted value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str | Expr

```

Formatted value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprGeneratorExp

```
ExprGeneratorExp(
    element: str | Expr, generators: Sequence[Expr]
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprGeneratorExp[ExprGeneratorExp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprGeneratorExp
                


              click griffe.ExprGeneratorExp href "" "griffe.ExprGeneratorExp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Generator expressions like `a for b in c for d in e`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`element`** (`str | Expr`) – Yielded element.
- **`generators`** (`Sequence[Expr]`) – Generators iterated on.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### element

```
element: str | Expr

```

Yielded element.

### generators

```
generators: Sequence[Expr]

```

Generators iterated on.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprIfExp

```
ExprIfExp(
    body: str | Expr, test: str | Expr, orelse: str | Expr
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprIfExp[ExprIfExp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprIfExp
                


              click griffe.ExprIfExp href "" "griffe.ExprIfExp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Conditions like `a if b else c`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`body`** (`str | Expr`) – Value if test.
- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`orelse`** (`str | Expr`) – Other expression.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`test`** (`str | Expr`) – Condition.

### body

```
body: str | Expr

```

Value if test.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### orelse

```
orelse: str | Expr

```

Other expression.

### path

```
path: str

```

Path of the expressed name/attribute.

### test

```
test: str | Expr

```

Condition.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprJoinedStr

```
ExprJoinedStr(values: Sequence[str | Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprJoinedStr[ExprJoinedStr]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprJoinedStr
                


              click griffe.ExprJoinedStr href "" "griffe.ExprJoinedStr"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Joined strings like `f"a {b} c"`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`values`** (`Sequence[str | Expr]`) – Joined values.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### values

```
values: Sequence[str | Expr]

```

Joined values.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprKeyword

```
ExprKeyword(
    name: str,
    value: str | Expr,
    function: Expr | None = None,
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprKeyword[ExprKeyword]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprKeyword
                


              click griffe.ExprKeyword href "" "griffe.ExprKeyword"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Keyword arguments like `a=b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed keyword.
- **`classname`** (`str`) – The expression class name.
- **`function`** (`Expr | None`) – Expression referencing the function called with this parameter.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`name`** (`str`) – Name.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str | Expr`) – Value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed keyword.

### classname

```
classname: str

```

The expression class name.

### function

```
function: Expr | None = None

```

Expression referencing the function called with this parameter.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### name

```
name: str

```

Name.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str | Expr

```

Value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprVarPositional

```
ExprVarPositional(value: Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprVarPositional[ExprVarPositional]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprVarPositional
                


              click griffe.ExprVarPositional href "" "griffe.ExprVarPositional"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Variadic positional parameters like `*args`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`Expr`) – Starred value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: Expr

```

Starred value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprVarKeyword

```
ExprVarKeyword(value: Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprVarKeyword[ExprVarKeyword]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprVarKeyword
                


              click griffe.ExprVarKeyword href "" "griffe.ExprVarKeyword"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Variadic keyword parameters like `**kwargs`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`Expr`) – Double-starred value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: Expr

```

Double-starred value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprLambda

```
ExprLambda(
    parameters: Sequence[ExprParameter], body: str | Expr
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprLambda[ExprLambda]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprLambda
                


              click griffe.ExprLambda href "" "griffe.ExprLambda"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Lambda expressions like `lambda a: a.b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`body`** (`str | Expr`) – Lambda's body.
- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`parameters`** (`Sequence[ExprParameter]`) – Lambda's parameters.
- **`path`** (`str`) – Path of the expressed name/attribute.

### body

```
body: str | Expr

```

Lambda's body.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### parameters

```
parameters: Sequence[ExprParameter]

```

Lambda's parameters.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprList

```
ExprList(elements: Sequence[Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprList[ExprList]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprList
                


              click griffe.ExprList href "" "griffe.ExprList"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Lists like `[0, 1, 2]`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`elements`** (`Sequence[Expr]`) – List elements.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### elements

```
elements: Sequence[Expr]

```

List elements.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprListComp

```
ExprListComp(
    element: str | Expr, generators: Sequence[Expr]
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprListComp[ExprListComp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprListComp
                


              click griffe.ExprListComp href "" "griffe.ExprListComp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

List comprehensions like `[a for b in c]`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`element`** (`str | Expr`) – Target value.
- **`generators`** (`Sequence[Expr]`) – Generators iterated on.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### element

```
element: str | Expr

```

Target value.

### generators

```
generators: Sequence[Expr]

```

Generators iterated on.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprName

```
ExprName(
    name: str,
    parent: str
    | ExprName
    | Module
    | Class
    | Function
    | None = None,
    member: str | None = None,
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprName[ExprName]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprName
                


              click griffe.ExprName href "" "griffe.ExprName"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

This class represents a Python object identified by a name in a given scope.

Methods:

- **`__eq__`** – Two name expressions are equal if they have the same name value (parent is ignored).
- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – The canonical name (resolved one, not alias name).
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_enum_class`** (`bool`) – Whether this name resolves to an enumeration class.
- **`is_enum_instance`** (`bool`) – Whether this name resolves to an enumeration instance.
- **`is_enum_value`** (`bool`) – Whether this name resolves to an enumeration value.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`is_type_parameter`** (`bool`) – Whether this name resolves to a type parameter.
- **`member`** (`str | None`) – Member name (for resolution in its scope).
- **`name`** (`str`) – Actual name.
- **`parent`** (`str | ExprName | Module | Class | Function | None`) – Parent (for resolution in its scope).
- **`path`** (`str`) – The full, resolved name.
- **`resolved`** (`Module | Class | None`) – The resolved object this name refers to.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

The canonical name (resolved one, not alias name).

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_enum_class

```
is_enum_class: bool

```

Whether this name resolves to an enumeration class.

### is_enum_instance

```
is_enum_instance: bool

```

Whether this name resolves to an enumeration instance.

### is_enum_value

```
is_enum_value: bool

```

Whether this name resolves to an enumeration value.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### is_type_parameter

```
is_type_parameter: bool

```

Whether this name resolves to a type parameter.

### member

```
member: str | None = None

```

Member name (for resolution in its scope).

### name

```
name: str

```

Actual name.

### parent

```
parent: (
    str | ExprName | Module | Class | Function | None
) = None

```

Parent (for resolution in its scope).

### path

```
path: str

```

The full, resolved name.

If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source.

### resolved

```
resolved: Module | Class | None

```

The resolved object this name refers to.

### __eq__

```
__eq__(other: object) -> bool

```

Two name expressions are equal if they have the same `name` value (`parent` is ignored).

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[ExprName]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> ExprName

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprNamedExpr

```
ExprNamedExpr(target: Expr, value: str | Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprNamedExpr[ExprNamedExpr]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprNamedExpr
                


              click griffe.ExprNamedExpr href "" "griffe.ExprNamedExpr"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Named/assignment expressions like `a := b`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`target`** (`Expr`) – Target name.
- **`value`** (`str | Expr`) – Value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### target

```
target: Expr

```

Target name.

### value

```
value: str | Expr

```

Value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprParameter

```
ExprParameter(
    name: str,
    kind: ParameterKind = positional_or_keyword,
    annotation: Expr | None = None,
    default: str | Expr | None = None,
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprParameter[ExprParameter]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprParameter
                


              click griffe.ExprParameter href "" "griffe.ExprParameter"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Parameters in function signatures like `a: int = 0`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`annotation`** (`Expr | None`) – Parameter type.
- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`default`** (`str | Expr | None`) – Parameter default.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`kind`** (`ParameterKind`) – Parameter kind.
- **`name`** (`str`) – Parameter name.
- **`path`** (`str`) – Path of the expressed name/attribute.

### annotation

```
annotation: Expr | None = None

```

Parameter type.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### default

```
default: str | Expr | None = None

```

Parameter default.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### kind

```
kind: ParameterKind = positional_or_keyword

```

Parameter kind.

### name

```
name: str

```

Parameter name.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprSet

```
ExprSet(elements: Sequence[str | Expr])

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprSet[ExprSet]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSet
                


              click griffe.ExprSet href "" "griffe.ExprSet"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Sets like `{0, 1, 2}`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`elements`** (`Sequence[str | Expr]`) – Set elements.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### elements

```
elements: Sequence[str | Expr]

```

Set elements.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprSetComp

```
ExprSetComp(
    element: str | Expr, generators: Sequence[Expr]
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprSetComp[ExprSetComp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSetComp
                


              click griffe.ExprSetComp href "" "griffe.ExprSetComp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Set comprehensions like `{a for b in c}`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`element`** (`str | Expr`) – Target value.
- **`generators`** (`Sequence[Expr]`) – Generators iterated on.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### element

```
element: str | Expr

```

Target value.

### generators

```
generators: Sequence[Expr]

```

Generators iterated on.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprSlice

```
ExprSlice(
    lower: str | Expr | None = None,
    upper: str | Expr | None = None,
    step: str | Expr | None = None,
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprSlice[ExprSlice]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSlice
                


              click griffe.ExprSlice href "" "griffe.ExprSlice"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Slices like `[a:b:c]`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`lower`** (`str | Expr | None`) – Lower bound.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`step`** (`str | Expr | None`) – Iteration step.
- **`upper`** (`str | Expr | None`) – Upper bound.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### lower

```
lower: str | Expr | None = None

```

Lower bound.

### path

```
path: str

```

Path of the expressed name/attribute.

### step

```
step: str | Expr | None = None

```

Iteration step.

### upper

```
upper: str | Expr | None = None

```

Upper bound.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprSubscript

```
ExprSubscript(left: str | Expr, slice: str | Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprSubscript[ExprSubscript]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprSubscript
                


              click griffe.ExprSubscript href "" "griffe.ExprSubscript"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Subscripts like `a[b]`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – The canonical path of this subscript's left part.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`left`** (`str | Expr`) – Left part.
- **`path`** (`str`) – The path of this subscript's left part.
- **`slice`** (`str | Expr`) – Slice part.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

The canonical path of this subscript's left part.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### left

```
left: str | Expr

```

Left part.

### path

```
path: str

```

The path of this subscript's left part.

### slice

```
slice: str | Expr

```

Slice part.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> ExprBinOp | ExprSubscript

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprTuple

```
ExprTuple(
    elements: Sequence[str | Expr], implicit: bool = False
)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprTuple[ExprTuple]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprTuple
                


              click griffe.ExprTuple href "" "griffe.ExprTuple"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Tuples like `(0, 1, 2)`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`elements`** (`Sequence[str | Expr]`) – Tuple elements.
- **`implicit`** (`bool`) – Whether the tuple is implicit (e.g. without parentheses in a subscript's slice).
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### elements

```
elements: Sequence[str | Expr]

```

Tuple elements.

### implicit

```
implicit: bool = False

```

Whether the tuple is implicit (e.g. without parentheses in a subscript's slice).

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> ExprTuple

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprUnaryOp

```
ExprUnaryOp(operator: str, value: str | Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprUnaryOp[ExprUnaryOp]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprUnaryOp
                


              click griffe.ExprUnaryOp href "" "griffe.ExprUnaryOp"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Unary operations like `-1`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`operator`** (`str`) – Unary operator.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str | Expr`) – Value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### operator

```
operator: str

```

Unary operator.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str | Expr

```

Value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprYield

```
ExprYield(value: str | Expr | None = None)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprYield[ExprYield]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprYield
                


              click griffe.ExprYield href "" "griffe.ExprYield"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Yield statements like `yield a`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str | Expr | None`) – Yielded value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str | Expr | None = None

```

Yielded value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

## ExprYieldFrom

```
ExprYieldFrom(value: str | Expr)

```

Bases: `Expr`

```

              flowchart TD
              griffe.ExprYieldFrom[ExprYieldFrom]
              griffe._internal.expressions.Expr[Expr]

                              griffe._internal.expressions.Expr --> griffe.ExprYieldFrom
                


              click griffe.ExprYieldFrom href "" "griffe.ExprYieldFrom"
              click griffe._internal.expressions.Expr href "" "griffe._internal.expressions.Expr"
            
```

Yield statements like `yield from a`.

Methods:

- **`__iter__`** – Iterate on the expression syntax and elements.
- **`as_dict`** – Return the expression as a dictionary.
- **`iterate`** – Iterate on the expression elements.
- **`modernize`** – Modernize the expression.

Attributes:

- **`canonical_name`** (`str`) – Name of the expressed name/attribute/parameter.
- **`canonical_path`** (`str`) – Path of the expressed name/attribute.
- **`classname`** (`str`) – The expression class name.
- **`is_classvar`** (`bool`) – Whether this attribute is annotated with ClassVar.
- **`is_generator`** (`bool`) – Whether this expression is a generator.
- **`is_iterator`** (`bool`) – Whether this expression is an iterator.
- **`is_tuple`** (`bool`) – Whether this expression is a tuple.
- **`path`** (`str`) – Path of the expressed name/attribute.
- **`value`** (`str | Expr`) – Yielded-from value.

### canonical_name

```
canonical_name: str

```

Name of the expressed name/attribute/parameter.

### canonical_path

```
canonical_path: str

```

Path of the expressed name/attribute.

### classname

```
classname: str

```

The expression class name.

### is_classvar

```
is_classvar: bool

```

Whether this attribute is annotated with `ClassVar`.

### is_generator

```
is_generator: bool

```

Whether this expression is a generator.

### is_iterator

```
is_iterator: bool

```

Whether this expression is an iterator.

### is_tuple

```
is_tuple: bool

```

Whether this expression is a tuple.

### path

```
path: str

```

Path of the expressed name/attribute.

### value

```
value: str | Expr

```

Yielded-from value.

### __iter__

```
__iter__() -> Iterator[str | Expr]

```

Iterate on the expression syntax and elements.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return the expression as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Configuration options (none available yet).

Returns:

- `dict[str, Any]` – A dictionary.

### iterate

```
iterate(*, flat: bool = True) -> Iterator[str | Expr]

```

Iterate on the expression elements.

Parameters:

- #### **`flat`**

  (`bool`, default: `True` ) – Expressions are trees. When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings. On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.

Yields:

- `str | Expr` – Strings and names when flat, strings and expressions otherwise.

### modernize

```
modernize() -> Expr

```

Modernize the expression.

For example, use PEP 604 type unions `|` instead of `typing.Union`.

Returns:

- `Expr` – A modernized expression.

# Extensions

## **Main API**

## load_extensions

```
load_extensions(*exts: LoadableExtensionType) -> Extensions

```

Load configured extensions.

Parameters:

- ### **`exts`**

  (`LoadableExtensionType`, default: `()` ) – Extensions with potential configuration options.

Returns:

- `Extensions` – An extensions container.

## Extension

Base class for Griffe extensions.

Methods:

- **`generic_inspect`** – Extend the base generic inspection with extensions.
- **`generic_visit`** – Visit children nodes.
- **`inspect`** – Inspect a node.
- **`on_alias`** – Run when an Alias has been created.
- **`on_attribute_instance`** – Run when an Attribute has been created.
- **`on_attribute_node`** – Run when visiting a new attribute node during static/dynamic analysis.
- **`on_class_instance`** – Run when a Class has been created.
- **`on_class_members`** – Run when members of a Class have been loaded.
- **`on_class_node`** – Run when visiting a new class node during static/dynamic analysis.
- **`on_function_instance`** – Run when a Function has been created.
- **`on_function_node`** – Run when visiting a new function node during static/dynamic analysis.
- **`on_instance`** – Run when an Object has been created.
- **`on_members`** – Run when members of an Object have been loaded.
- **`on_module_instance`** – Run when a Module has been created.
- **`on_module_members`** – Run when members of a Module have been loaded.
- **`on_module_node`** – Run when visiting a new module node during static/dynamic analysis.
- **`on_node`** – Run when visiting a new node during static/dynamic analysis.
- **`on_package_loaded`** – Run when a package has been completely loaded.
- **`on_type_alias_instance`** – Run when a TypeAlias has been created.
- **`on_type_alias_node`** – Run when visiting a new type alias node during static/dynamic analysis.
- **`on_wildcard_expansion`** – Run when wildcard imports are expanded into aliases.
- **`visit`** – Visit a node.

### generic_inspect

```
generic_inspect(node: ObjectNode) -> None

```

Extend the base generic inspection with extensions.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### generic_visit

```
generic_visit(node: AST) -> None

```

Visit children nodes.

Parameters:

- #### **`node`**

  (`AST`) – The node to visit the children of.

### inspect

```
inspect(node: ObjectNode) -> None

```

Inspect a node.

Parameters:

- #### **`node`**

  (`ObjectNode`) – The node to inspect.

### on_alias

```
on_alias(
    *,
    node: AST | ObjectNode,
    alias: Alias,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when an Alias has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`alias`**

  (`Alias`) – The alias instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_attribute_instance

```
on_attribute_instance(
    *,
    node: AST | ObjectNode,
    attr: Attribute,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when an Attribute has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`attr`**

  (`Attribute`) – The attribute instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_attribute_node

```
on_attribute_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when visiting a new attribute node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_class_instance

```
on_class_instance(
    *,
    node: AST | ObjectNode,
    cls: Class,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when a Class has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`cls`**

  (`Class`) – The class instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_class_members

```
on_class_members(
    *,
    node: AST | ObjectNode,
    cls: Class,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when members of a Class have been loaded.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`cls`**

  (`Class`) – The class instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_class_node

```
on_class_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when visiting a new class node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_function_instance

```
on_function_instance(
    *,
    node: AST | ObjectNode,
    func: Function,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when a Function has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`func`**

  (`Function`) – The function instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_function_node

```
on_function_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when visiting a new function node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_instance

```
on_instance(
    *,
    node: AST | ObjectNode,
    obj: Object,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when an Object has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`obj`**

  (`Object`) – The object instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_members

```
on_members(
    *,
    node: AST | ObjectNode,
    obj: Object,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when members of an Object have been loaded.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`obj`**

  (`Object`) – The object instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_module_instance

```
on_module_instance(
    *,
    node: AST | ObjectNode,
    mod: Module,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when a Module has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`mod`**

  (`Module`) – The module instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_module_members

```
on_module_members(
    *,
    node: AST | ObjectNode,
    mod: Module,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when members of a Module have been loaded.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`mod`**

  (`Module`) – The module instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_module_node

```
on_module_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when visiting a new module node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_node

```
on_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when visiting a new node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

### on_package_loaded

```
on_package_loaded(
    *, pkg: Module, loader: GriffeLoader, **kwargs: Any
) -> None

```

Run when a package has been completely loaded.

Parameters:

- #### **`pkg`**

  (`Module`) – The package (Module) instance.

- #### **`loader`**

  (`GriffeLoader`) – The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_type_alias_instance

```
on_type_alias_instance(
    *,
    node: AST | ObjectNode,
    type_alias: TypeAlias,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when a TypeAlias has been created.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`type_alias`**

  (`TypeAlias`) – The type alias instance.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_type_alias_node

```
on_type_alias_node(
    *,
    node: AST | ObjectNode,
    agent: Visitor | Inspector,
    **kwargs: Any,
) -> None

```

Run when visiting a new type alias node during static/dynamic analysis.

Parameters:

- #### **`node`**

  (`AST | ObjectNode`) – The currently visited node.

- #### **`agent`**

  (`Visitor | Inspector`) – The analysis agent currently running.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### on_wildcard_expansion

```
on_wildcard_expansion(
    *, alias: Alias, loader: GriffeLoader, **kwargs: Any
) -> None

```

Run when wildcard imports are expanded into aliases.

Parameters:

- #### **`alias`**

  (`Alias`) – The alias instance.

- #### **`loader`**

  (`GriffeLoader`) – The loader currently in use.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – For forward-compatibility.

### visit

```
visit(node: AST) -> None

```

Visit a node.

Parameters:

- #### **`node`**

  (`AST`) – The node to visit.

## **Advanced API**

## Extensions

```
Extensions(*extensions: Extension)

```

This class helps iterating on extensions that should run at different times.

Parameters:

- ### **`*extensions`**

  (`Extension`, default: `()` ) – The extensions to add.

Methods:

- **`add`** – Add extensions to this container.
- **`call`** – Call the extension hook for the given event.

### add

```
add(*extensions: Extension) -> None

```

Add extensions to this container.

Parameters:

- #### **`*extensions`**

  (`Extension`, default: `()` ) – The extensions to add.

### call

```
call(event: str, **kwargs: Any) -> None

```

Call the extension hook for the given event.

Parameters:

- #### **`event`**

  (`str`) – The triggered event.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Arguments passed to the hook.

## **Types**

## LoadableExtensionType

```
LoadableExtensionType = Union[
    str, dict[str, Any], Extension, type[Extension]
]

```

All the types that can be passed to `load_extensions`.

## **Builtin extensions**

## builtin_extensions

```
builtin_extensions: set[str] = {'dataclasses'}

```

The names of built-in Griffe extensions.

## DataclassesExtension

Bases: `Extension`

```

              flowchart TD
              griffe.DataclassesExtension[DataclassesExtension]
              griffe._internal.extensions.base.Extension[Extension]

                              griffe._internal.extensions.base.Extension --> griffe.DataclassesExtension
                


              click griffe.DataclassesExtension href "" "griffe.DataclassesExtension"
              click griffe._internal.extensions.base.Extension href "" "griffe._internal.extensions.base.Extension"
            
```

Built-in extension adding support for dataclasses.

This extension creates `__init__` methods of dataclasses if they don't already exist.

Methods:

- **`on_package_loaded`** – Hook for loaded packages.

### on_package_loaded

```
on_package_loaded(*, pkg: Module, **kwargs: Any) -> None

```

Hook for loaded packages.

Parameters:

- #### **`pkg`**

  (`Module`) – The loaded package.

# Finder

## **Advanced API**

## ModuleFinder

```
ModuleFinder(
    search_paths: Sequence[str | Path] | None = None,
)

```

The Griffe finder, allowing to find modules on the file system.

The module finder is generally not used directly. Each GriffeLoader instance creates its own module finder instance. The finder can be configured when instantiating the loader thanks to the loader's `search_paths` parameter.

Parameters:

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – Optional paths to search into.

Methods:

- **`append_search_path`** – Append a search path.
- **`find_package`** – Find a package or namespace package.
- **`find_spec`** – Find the top-level parent module of a module.
- **`insert_search_path`** – Insert a search path at the given position.
- **`iter_submodules`** – Iterate on a module's submodules, if any.
- **`submodules`** – Return the list of a module's submodules.

Attributes:

- **`accepted_py_module_extensions`** (`list[str]`) – List of extensions supported by the finder.
- **`extensions_set`** (`set[str]`) – Set of extensions supported by the finder.
- **`search_paths`** (`list[Path]`) – The finder search paths.

### accepted_py_module_extensions

```
accepted_py_module_extensions: list[str] = [
    ".py",
    ".pyc",
    ".pyo",
    ".pyd",
    ".pyi",
    ".so",
]

```

List of extensions supported by the finder.

### extensions_set

```
extensions_set: set[str] = set(
    accepted_py_module_extensions
)

```

Set of extensions supported by the finder.

### search_paths

```
search_paths: list[Path] = []

```

The finder search paths.

### append_search_path

```
append_search_path(path: Path) -> None

```

Append a search path.

The path will be resolved (absolute, normalized). The path won't be appended if it is already in the search paths list.

Parameters:

- #### **`path`**

  (`Path`) – The path to append.

### find_package

```
find_package(
    module_name: str,
) -> Package | NamespacePackage

```

Find a package or namespace package.

Parameters:

- #### **`module_name`**

  (`str`) – The module name.

Raises:

- `ModuleNotFoundError` – When the module cannot be found.

Returns:

- `Package | NamespacePackage` – A package or namespace package wrapper.

### find_spec

```
find_spec(
    module: str | Path,
    *,
    try_relative_path: bool = True,
    find_stubs_package: bool = False,
) -> tuple[str, Package | NamespacePackage]

```

Find the top-level parent module of a module.

If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths.

Parameters:

- #### **`module`**

  (`str | Path`) – The module name or path.

- #### **`try_relative_path`**

  (`bool`, default: `True` ) – Whether to try finding the module as a relative path, when the given module is not already a path.

- #### **`find_stubs_package`**

  (`bool`, default: `False` ) – Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

Raises:

- `FileNotFoundError` – When a Path was passed and the module could not be found: the directory has no __init__.py file in it the path does not exist
- `ModuleNotFoundError` – When a string was passed and the module could not be found: no module/__init__.py no module.py no module.pth no module directory (namespace packages) or unsupported .pth file

Returns:

- `tuple[str, Package | NamespacePackage]` – The name of the module, and an instance representing its (namespace) package.

### insert_search_path

```
insert_search_path(position: int, path: Path) -> None

```

Insert a search path at the given position.

The path will be resolved (absolute, normalized). The path won't be inserted if it is already in the search paths list.

Parameters:

- #### **`position`**

  (`int`) – The insert position in the list.

- #### **`path`**

  (`Path`) – The path to insert.

### iter_submodules

```
iter_submodules(
    path: Path | list[Path], seen: set | None = None
) -> Iterator[NamePartsAndPathType]

```

Iterate on a module's submodules, if any.

Parameters:

- #### **`path`**

  (`Path | list[Path]`) – The module path.

- #### **`seen`**

  (`set | None`, default: `None` ) – If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with __init__ modules) of the same name found in different namespace packages. As soon as we find an __init__ module, we add its parent path to the seen set, which will be reused when scanning the next namespace packages.

Yields:

- **`name_parts`** ( `tuple[str, ...]` ) – The parts of a submodule name.
- **`filepath`** ( `Path` ) – A submodule filepath.

### submodules

```
submodules(module: Module) -> list[NamePartsAndPathType]

```

Return the list of a module's submodules.

Parameters:

- #### **`module`**

  (`Module`) – The parent module.

Returns:

- `list[NamePartsAndPathType]` – A list of tuples containing the parts of the submodule name and its path.

## Package

```
Package(name: str, path: Path, stubs: Path | None = None)

```

This class is a simple placeholder used during the process of finding packages.

Parameters:

- ### **`name`**

  (`str`) – The package name.

- ### **`path`**

  (`Path`) – The package path(s).

- ### **`stubs`**

  (`Path | None`, default: `None` ) – An optional path to the related stubs file (.pyi).

Attributes:

- **`name`** (`str`) – Package name.
- **`path`** (`Path`) – Package folder path.
- **`stubs`** (`Path | None`) – Package stubs file.

### name

```
name: str

```

Package name.

### path

```
path: Path

```

Package folder path.

### stubs

```
stubs: Path | None = None

```

Package stubs file.

## NamespacePackage

```
NamespacePackage(name: str, path: list[Path])

```

This class is a simple placeholder used during the process of finding packages.

Parameters:

- ### **`name`**

  (`str`) – The package name.

- ### **`path`**

  (`list[Path]`) – The package paths.

Attributes:

- **`name`** (`str`) – Namespace package name.
- **`path`** (`list[Path]`) – Namespace package folder paths.

### name

```
name: str

```

Namespace package name.

### path

```
path: list[Path]

```

Namespace package folder paths.

## **Types**

## NamePartsType

```
NamePartsType = tuple[str, ...]

```

Type alias for the parts of a module name.

## NamePartsAndPathType

```
NamePartsAndPathType = tuple[NamePartsType, Path]

```

Type alias for the parts of a module name and its path.

# Git utilities

## assert_git_repo

```
assert_git_repo(path: str | Path) -> None

```

Assert that a directory is a Git repository.

Parameters:

- ### **`path`**

  (`str | Path`) – Path to a directory.

Raises:

- `OSError` – When the directory is not a Git repository.

## get_latest_tag

```
get_latest_tag(repo: str | Path) -> str

```

Get latest tag of a Git repository.

Parameters:

- ### **`repo`**

  (`str | Path`) – The path to Git repository.

Returns:

- `str` – The latest tag.

## get_repo_root

```
get_repo_root(repo: str | Path) -> str

```

Get the root of a Git repository.

Parameters:

- ### **`repo`**

  (`str | Path`) – The path to a Git repository.

Returns:

- `str` – The root of the repository.

## tmp_worktree

```
tmp_worktree(
    repo: str | Path = ".", ref: str = "HEAD"
) -> Iterator[Path]

```

Context manager that checks out the given reference in the given repository to a temporary worktree.

Parameters:

- ### **`repo`**

  (`str | Path`, default: `'.'` ) – Path to the repository (i.e. the directory containing the .git directory)

- ### **`ref`**

  (`str`, default: `'HEAD'` ) – A Git reference such as a commit, tag or branch.

Yields:

- `Path` – The path to the temporary worktree.

Raises:

- `OSError` – If repo is not a valid .git repository
- `RuntimeError` – If the git executable is unavailable, or if it cannot create a worktree

# Helpers

## TmpPackage

```
TmpPackage(tmpdir: Path, name: str, path: Path)

```

A temporary package.

The `tmpdir` and `path` parameters can be passed as relative path. They will be resolved to absolute paths after initialization.

Attributes:

- **`name`** (`str`) – The package name, as to dynamically import it.
- **`path`** (`Path`) – The package path.
- **`tmpdir`** (`Path`) – The temporary directory containing the package.

### name

```
name: str

```

The package name, as to dynamically import it.

### path

```
path: Path

```

The package path.

### tmpdir

```
tmpdir: Path

```

The temporary directory containing the package.

## temporary_pyfile

```
temporary_pyfile(
    code: str, *, module_name: str = "module"
) -> Iterator[tuple[str, Path]]

```

Create a Python file containing the given code in a temporary directory.

Parameters:

- ### **`code`**

  (`str`) – The code to write to the temporary file.

- ### **`module_name`**

  (`str`, default: `'module'` ) – The name of the temporary module.

Yields:

- **`module_name`** ( `str` ) – The module name, as to dynamically import it.
- **`module_path`** ( `Path` ) – The module path.

## temporary_pypackage

```
temporary_pypackage(
    package: str,
    modules: Sequence[str]
    | Mapping[str, str]
    | None = None,
    *,
    init: bool = True,
    inits: bool = True,
) -> Iterator[TmpPackage]

```

Create a package containing the given modules in a temporary directory.

Parameters:

- ### **`package`**

  (`str`) – The package name. Example: "a" gives a package named a, while "a/b" gives a namespace package named a with a package inside named b. If init is false, then b is also a namespace package.

- ### **`modules`**

  (`Sequence[str] | Mapping[str, str] | None`, default: `None` ) – Additional modules to create in the package. If a list, simply touch the files: ["b.py", "c/d.py", "e/f"]. If a dict, keys are the file names and values their contents: {"b.py": "b = 1", "c/d.py": "print('hey from c')"}.

- ### **`init`**

  (`bool`, default: `True` ) – Whether to create an __init__ module in the top package.

- ### **`inits`**

  (`bool`, default: `True` ) – Whether to create __init__ modules in subpackages.

Yields:

- `TmpPackage` – A temporary package.

## temporary_visited_module

```
temporary_visited_module(
    code: str,
    *,
    module_name: str = "module",
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Iterator[Module]

```

Create and visit a temporary module with the given code.

Parameters:

- ### **`code`**

  (`str`) – The code of the module.

- ### **`module_name`**

  (`str`, default: `'module'` ) – The name of the temporary module.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use when visiting the AST.

- ### **`parent`**

  (`Module | None`, default: `None` ) – The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Yields:

- `Module` – The visited module.

## temporary_visited_package

```
temporary_visited_package(
    package: str,
    modules: Sequence[str]
    | Mapping[str, str]
    | None = None,
    *,
    init: bool = True,
    inits: bool = True,
    extensions: Extensions | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = False,
    store_source: bool = True,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
    search_sys_path: bool = False,
) -> Iterator[Module]

```

Create and visit a temporary package.

Parameters:

- ### **`package`**

  (`str`) – The package name. Example: "a" gives a package named a, while "a/b" gives a namespace package named a with a package inside named b. If init is false, then b is also a namespace package.

- ### **`modules`**

  (`Sequence[str] | Mapping[str, str] | None`, default: `None` ) – Additional modules to create in the package. If a list, simply touch the files: ["b.py", "c/d.py", "e/f"]. If a dict, keys are the file names and values their contents: {"b.py": "b = 1", "c/d.py": "print('hey from c')"}.

- ### **`init`**

  (`bool`, default: `True` ) – Whether to create an __init__ module in the top package.

- ### **`inits`**

  (`bool`, default: `True` ) – Whether to create __init__ modules in subpackages.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `False` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`store_source`**

  (`bool`, default: `True` ) – Whether to store code source in the lines collection.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) – Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) – Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

- ### **`search_sys_path`**

  (`bool`, default: `False` ) – Whether to search the system paths for the package.

Yields:

- `Module` – A module.

## temporary_inspected_module

```
temporary_inspected_module(
    code: str,
    *,
    module_name: str = "module",
    import_paths: list[Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Iterator[Module]

```

Create and inspect a temporary module with the given code.

Parameters:

- ### **`code`**

  (`str`) – The code of the module.

- ### **`module_name`**

  (`str`, default: `'module'` ) – The name of the temporary module.

- ### **`import_paths`**

  (`list[Path] | None`, default: `None` ) – Paths to import the module from.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use when visiting the AST.

- ### **`parent`**

  (`Module | None`, default: `None` ) – The optional parent of this module.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Yields:

- `Module` – The inspected module.

## temporary_inspected_package

```
temporary_inspected_package(
    package: str,
    modules: Sequence[str]
    | Mapping[str, str]
    | None = None,
    *,
    init: bool = True,
    inits: bool = True,
    extensions: Extensions | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    store_source: bool = True,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
    search_sys_path: bool = False,
) -> Iterator[Module]

```

Create and inspect a temporary package.

Parameters:

- ### **`package`**

  (`str`) – The package name. Example: "a" gives a package named a, while "a/b" gives a namespace package named a with a package inside named b. If init is false, then b is also a namespace package.

- ### **`modules`**

  (`Sequence[str] | Mapping[str, str] | None`, default: `None` ) – Additional modules to create in the package. If a list, simply touch the files: ["b.py", "c/d.py", "e/f"]. If a dict, keys are the file names and values their contents: {"b.py": "b = 1", "c/d.py": "print('hey from c')"}.

- ### **`init`**

  (`bool`, default: `True` ) – Whether to create an __init__ module in the top package.

- ### **`inits`**

  (`bool`, default: `True` ) – Whether to create __init__ modules in subpackages.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules.

- ### **`store_source`**

  (`bool`, default: `True` ) – Whether to store code source in the lines collection.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) – Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) – Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

- ### **`search_sys_path`**

  (`bool`, default: `False` ) – Whether to search the system paths for the package.

Yields:

- `Module` – A module.

## vtree

```
vtree(
    *objects: Object, return_leaf: bool = False
) -> Object

```

Link objects together, vertically.

Parameters:

- ### **`*objects`**

  (`Object`, default: `()` ) – A sequence of objects. The first one is at the top of the tree.

- ### **`return_leaf`**

  (`bool`, default: `False` ) – Whether to return the leaf instead of the root.

Raises:

- `ValueError` – When no objects are provided.

Returns:

- `Object` – The top or leaf object.

## htree

```
htree(*objects: Object) -> Object

```

Link objects together, horizontally.

Parameters:

- ### **`*objects`**

  (`Object`, default: `()` ) – A sequence of objects. All objects starting at the second become members of the first.

Raises:

- `ValueError` – When no objects are provided.

Returns:

- `Object` – The first given object, with all the other objects as members of it.

## module_vtree

```
module_vtree(
    path: str,
    *,
    leaf_package: bool = True,
    return_leaf: bool = False,
) -> Module

```

Link objects together, vertically.

Parameters:

- ### **`path`**

  (`str`) – The complete module path, like "a.b.c.d".

- ### **`leaf_package`**

  (`bool`, default: `True` ) – Whether the deepest module should also be a package.

- ### **`return_leaf`**

  (`bool`, default: `False` ) – Whether to return the leaf instead of the root.

Raises:

- `ValueError` – When no objects are provided.

Returns:

- `Module` – The top or leaf module.

# Loaders

## **Main API**

## load

```
load(
    objspec: str | Path | None = None,
    /,
    *,
    submodules: bool = True,
    try_relative_path: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    store_source: bool = True,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias

```

Load and return a Griffe object.

In Griffe's context, loading means:

- searching for a package, and finding it on the file system or as a builtin module (see the ModuleFinder class for more information)
- extracting information from each of its (sub)modules, by either parsing the source code (see the visit function) or inspecting the module at runtime (see the inspect function)

The extracted information is stored in a collection of modules, which can be queried later. Each collected module is a tree of objects, representing the structure of the module. See the Module, Class, Function, Attribute, and TypeAlias classes for more information.

The main class used to load modules is GriffeLoader. Convenience functions like this one and load_git are also available.

Example

```
import griffe

module = griffe.load(...)

```

This is a shortcut for:

```
from griffe import GriffeLoader

loader = GriffeLoader(...)
module = loader.load(...)

```

See the documentation for the loader: GriffeLoader.

Parameters:

- ### **`objspec`**

  (`str | Path | None`, default: `None` ) – The Python path of an object, or file path to a module.

- ### **`submodules`**

  (`bool`, default: `True` ) – Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- ### **`try_relative_path`**

  (`bool`, default: `True` ) – Whether to try finding the module as a relative path.

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The paths to search into.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) – Whether to force using dynamic analysis when loading data.

- ### **`store_source`**

  (`bool`, default: `True` ) – Whether to store code source in the lines collection.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) – Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) – Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) – Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

Returns:

- `Object | Alias` – A Griffe object.

## load_git

```
load_git(
    objspec: str | Path | None = None,
    /,
    *,
    ref: str = "HEAD",
    repo: str | Path = ".",
    submodules: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias

```

Load and return a module from a specific Git reference.

This function will create a temporary [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference before loading `module` with griffe.load.

This function requires that the `git` executable is installed.

Examples:

```
from griffe import load_git

old_api = load_git("my_module", ref="v0.1.0", repo="path/to/repo")

```

Parameters:

- ### **`objspec`**

  (`str | Path | None`, default: `None` ) – The Python path of an object, or file path to a module.

- ### **`ref`**

  (`str`, default: `'HEAD'` ) – A Git reference such as a commit, tag or branch.

- ### **`repo`**

  (`str | Path`, default: `'.'` ) – Path to the repository (i.e. the directory containing the .git directory)

- ### **`submodules`**

  (`bool`, default: `True` ) – Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The paths to search into (relative to the repository root).

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) – Whether to force using dynamic analysis when loading data.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) – Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) – Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) – Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

Returns:

- `Object | Alias` – A Griffe object.

## load_pypi

```
load_pypi(
    package: str,
    distribution: str,
    version_spec: str,
    *,
    submodules: bool = True,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    find_stubs_package: bool = False,
    resolve_aliases: bool = False,
    resolve_external: bool | None = None,
    resolve_implicit: bool = False,
) -> Object | Alias

```

Load and return a module from a specific package version downloaded using pip.

[Sponsors only](../../../insiders/) — [Insiders 1.1.0](../../../insiders/changelog/#1.1.0).

Parameters:

- ### **`package`**

  (`str`) – The package import name.

- ### **`distribution`**

  (`str`) – The distribution name.

- ### **`version_spec`**

  (`str`) – The version specifier to use when installing with pip.

- ### **`submodules`**

  (`bool`, default: `True` ) – Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The paths to search into (relative to the repository root).

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`force_inspection`**

  (`bool`, default: `False` ) – Whether to force using dynamic analysis when loading data.

- ### **`find_stubs_package`**

  (`bool`, default: `False` ) – Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

- ### **`resolve_aliases`**

  (`bool`, default: `False` ) – Whether to resolve aliases.

- ### **`resolve_external`**

  (`bool | None`, default: `None` ) – Whether to try to load unspecified modules to resolve aliases. Default value (None) means to load external modules only if they are the private sibling or the origin module (for example when ast imports from \_ast).

- ### **`resolve_implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

## **Advanced API**

## GriffeLoader

```
GriffeLoader(
    *,
    extensions: Extensions | None = None,
    search_paths: Sequence[str | Path] | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
    allow_inspection: bool = True,
    force_inspection: bool = False,
    store_source: bool = True,
)

```

The Griffe loader, allowing to load data from modules.

Parameters:

- ### **`extensions`**

  (`Extensions | None`, default: `None` ) – The extensions to use.

- ### **`search_paths`**

  (`Sequence[str | Path] | None`, default: `None` ) – The paths to search into.

- ### **`docstring_parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`docstring_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

- ### **`allow_inspection`**

  (`bool`, default: `True` ) – Whether to allow inspecting modules when visiting them is not possible.

- ### **`store_source`**

  (`bool`, default: `True` ) – Whether to store code source in the lines collection.

Methods:

- **`expand_exports`** – Expand exports: try to recursively expand all module exports (__all__ values).
- **`expand_wildcards`** – Expand wildcards: try to recursively expand all found wildcards.
- **`load`** – Load an object as a Griffe object, given its Python or file path.
- **`resolve_aliases`** – Resolve aliases.
- **`resolve_module_aliases`** – Follow aliases: try to recursively resolve all found aliases.
- **`stats`** – Compute some statistics.

Attributes:

- **`allow_inspection`** (`bool`) – Whether to allow inspecting (importing) modules for which we can't find sources.
- **`docstring_options`** (`dict[str, Any]`) – Configured parsing options.
- **`docstring_parser`** (`DocstringStyle | Parser | None`) – Selected docstring parser.
- **`extensions`** (`Extensions`) – Loaded Griffe extensions.
- **`finder`** (`ModuleFinder`) – The module source finder.
- **`force_inspection`** (`bool`) – Whether to force inspecting (importing) modules, even when sources were found.
- **`ignored_modules`** (`set[str]`) – Special modules to ignore when loading.
- **`lines_collection`** (`LinesCollection`) – Collection of source code lines.
- **`modules_collection`** (`ModulesCollection`) – Collection of modules.
- **`store_source`** (`bool`) – Whether to store source code in the lines collection.

### allow_inspection

```
allow_inspection: bool = allow_inspection

```

Whether to allow inspecting (importing) modules for which we can't find sources.

### docstring_options

```
docstring_options: dict[str, Any] = docstring_options or {}

```

Configured parsing options.

### docstring_parser

```
docstring_parser: DocstringStyle | Parser | None = (
    docstring_parser
)

```

Selected docstring parser.

### extensions

```
extensions: Extensions = extensions or load_extensions()

```

Loaded Griffe extensions.

### finder

```
finder: ModuleFinder = ModuleFinder(search_paths)

```

The module source finder.

### force_inspection

```
force_inspection: bool = force_inspection

```

Whether to force inspecting (importing) modules, even when sources were found.

### ignored_modules

```
ignored_modules: set[str] = {'debugpy', '_pydev'}

```

Special modules to ignore when loading.

For example, `debugpy` and `_pydev` are used when debugging with VSCode and should generally never be loaded.

### lines_collection

```
lines_collection: LinesCollection = (
    lines_collection or LinesCollection()
)

```

Collection of source code lines.

### modules_collection

```
modules_collection: ModulesCollection = (
    modules_collection or ModulesCollection()
)

```

Collection of modules.

### store_source

```
store_source: bool = store_source

```

Whether to store source code in the lines collection.

### expand_exports

```
expand_exports(
    module: Module, seen: set | None = None
) -> None

```

Expand exports: try to recursively expand all module exports (`__all__` values).

See also: Module.exports.

Parameters:

- #### **`module`**

  (`Module`) – The module to recurse on.

- #### **`seen`**

  (`set | None`, default: `None` ) – Used to avoid infinite recursion.

### expand_wildcards

```
expand_wildcards(
    obj: Object,
    *,
    external: bool | None = None,
    seen: set | None = None,
) -> None

```

Expand wildcards: try to recursively expand all found wildcards.

See also: Alias.wildcard.

Parameters:

- #### **`obj`**

  (`Object`) – The object and its members to recurse on.

- #### **`external`**

  (`bool | None`, default: `None` ) – When true, try to load unspecified modules to expand wildcards.

- #### **`seen`**

  (`set | None`, default: `None` ) – Used to avoid infinite recursion.

### load

```
load(
    objspec: str | Path | None = None,
    /,
    *,
    submodules: bool = True,
    try_relative_path: bool = True,
    find_stubs_package: bool = False,
) -> Object | Alias

```

Load an object as a Griffe object, given its Python or file path.

Note that this will load the whole object's package, and return only the specified object. The rest of the package can be accessed from the returned object with regular methods and properties (`parent`, `members`, etc.).

Examples:

```
>>> loader.load("griffe.Module")
Alias("Module", "griffe._internal.models.Module")

```

Parameters:

- #### **`objspec`**

  (`str | Path | None`, default: `None` ) – The Python path of an object, or file path to a module.

- #### **`submodules`**

  (`bool`, default: `True` ) – Whether to recurse on the submodules. This parameter only makes sense when loading a package (top-level module).

- #### **`try_relative_path`**

  (`bool`, default: `True` ) – Whether to try finding the module as a relative path.

- #### **`find_stubs_package`**

  (`bool`, default: `False` ) – Whether to search for stubs-only package. If both the package and its stubs are found, they'll be merged together. If only the stubs are found, they'll be used as the package itself.

Raises:

- `LoadingError` – When loading a module failed for various reasons.
- `ModuleNotFoundError` – When a module was not found and inspection is disallowed.

Returns:

- `Object | Alias` – A Griffe object.

### resolve_aliases

```
resolve_aliases(
    *,
    implicit: bool = False,
    external: bool | None = None,
    max_iterations: int | None = None,
) -> tuple[set[str], int]

```

Resolve aliases.

Parameters:

- #### **`implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

- #### **`external`**

  (`bool | None`, default: `None` ) – When false, don't try to load unspecified modules to resolve aliases.

- #### **`max_iterations`**

  (`int | None`, default: `None` ) – Maximum number of iterations on the loader modules collection.

Returns:

- `tuple[set[str], int]` – The unresolved aliases and the number of iterations done.

### resolve_module_aliases

```
resolve_module_aliases(
    obj: Object | Alias,
    *,
    implicit: bool = False,
    external: bool | None = None,
    seen: set[str] | None = None,
    load_failures: set[str] | None = None,
) -> tuple[set[str], set[str]]

```

Follow aliases: try to recursively resolve all found aliases.

Parameters:

- #### **`obj`**

  (`Object | Alias`) – The object and its members to recurse on.

- #### **`implicit`**

  (`bool`, default: `False` ) – When false, only try to resolve an alias if it is explicitly exported.

- #### **`external`**

  (`bool | None`, default: `None` ) – When false, don't try to load unspecified modules to resolve aliases.

- #### **`seen`**

  (`set[str] | None`, default: `None` ) – Used to avoid infinite recursion.

- #### **`load_failures`**

  (`set[str] | None`, default: `None` ) – Set of external packages we failed to load (to prevent retries).

Returns:

- `tuple[set[str], set[str]]` – Both sets of resolved and unresolved aliases.

### stats

```
stats() -> Stats

```

Compute some statistics.

Returns:

- `Stats` – Some statistics.

## ModulesCollection

```
ModulesCollection()

```

Bases: `GetMembersMixin`, `SetMembersMixin`, `DelMembersMixin`

```

              flowchart TD
              griffe.ModulesCollection[ModulesCollection]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]

                              griffe._internal.mixins.GetMembersMixin --> griffe.ModulesCollection
                
                griffe._internal.mixins.SetMembersMixin --> griffe.ModulesCollection
                
                griffe._internal.mixins.DelMembersMixin --> griffe.ModulesCollection
                


              click griffe.ModulesCollection href "" "griffe.ModulesCollection"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
            
```

A collection of modules, allowing easy access to members.

Initialize the collection.

Methods:

- **`__bool__`** – A modules collection is always true-ish.
- **`__contains__`** – Check if a module is in the collection.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__setitem__`** – Set a member with its name or path.
- **`del_member`** – Delete a member with its name or path.
- **`get_member`** – Get a member with its name or path.
- **`set_member`** – Set a member with its name or path.

Attributes:

- **`all_members`** (`dict[str, Module]`) – Members of the collection.
- **`is_collection`** – Marked as collection to distinguish from objects.
- **`members`** (`dict[str, Module]`) – Members (modules) of the collection.

### all_members

```
all_members: dict[str, Module]

```

Members of the collection.

This property is overwritten to simply return `self.members`, as `all_members` does not make sense for a modules collection.

### is_collection

```
is_collection = True

```

Marked as collection to distinguish from objects.

### members

```
members: dict[str, Module] = {}

```

Members (modules) of the collection.

### __bool__

```
__bool__() -> bool

```

A modules collection is always true-ish.

### __contains__

```
__contains__(item: Any) -> bool

```

Check if a module is in the collection.

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

### del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

### get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## LinesCollection

```
LinesCollection()

```

A simple dictionary containing the modules source code lines.

Initialize the collection.

Methods:

- **`__bool__`** – A lines collection is always true-ish.
- **`__contains__`** – Check if a file path is in the collection.
- **`__getitem__`** – Get the lines of a file path.
- **`__setitem__`** – Set the lines of a file path.
- **`items`** – Return the collection items.
- **`keys`** – Return the collection keys.
- **`values`** – Return the collection values.

### __bool__

```
__bool__() -> bool

```

A lines collection is always true-ish.

### __contains__

```
__contains__(item: Path) -> bool

```

Check if a file path is in the collection.

### __getitem__

```
__getitem__(key: Path) -> list[str]

```

Get the lines of a file path.

### __setitem__

```
__setitem__(key: Path, value: list[str]) -> None

```

Set the lines of a file path.

### items

```
items() -> ItemsView

```

Return the collection items.

Returns:

- `ItemsView` – The collection items.

### keys

```
keys() -> KeysView

```

Return the collection keys.

Returns:

- `KeysView` – The collection keys.

### values

```
values() -> ValuesView

```

Return the collection values.

Returns:

- `ValuesView` – The collection values.

## **Additional API**

## Stats

```
Stats(loader: GriffeLoader)

```

Load statistics for a Griffe loader.

Parameters:

- ### **`loader`**

  (`GriffeLoader`) – The loader to compute stats for.

Methods:

- **`as_text`** – Format the statistics as text.

Attributes:

- **`by_kind`** – Number of objects by kind.
- **`lines`** – Total number of lines.
- **`loader`** – The loader to compute stats for.
- **`modules_by_extension`** – Number of modules by extension.
- **`packages`** – Number of packages.
- **`time_spent_inspecting`** – Time spent inspecting modules.
- **`time_spent_serializing`** – Time spent serializing objects.
- **`time_spent_visiting`** – Time spent visiting modules.

### by_kind

```
by_kind = {
    MODULE: 0,
    CLASS: 0,
    FUNCTION: 0,
    ATTRIBUTE: 0,
    TYPE_ALIAS: 0,
}

```

Number of objects by kind.

### lines

```
lines = sum((len(lines)) for lines in (values()))

```

Total number of lines.

### loader

```
loader = loader

```

The loader to compute stats for.

### modules_by_extension

```
modules_by_extension = modules_by_extension

```

Number of modules by extension.

### packages

```
packages = len(top_modules)

```

Number of packages.

### time_spent_inspecting

```
time_spent_inspecting = 0

```

Time spent inspecting modules.

### time_spent_serializing

```
time_spent_serializing = 0

```

Time spent serializing objects.

### time_spent_visiting

```
time_spent_visiting = 0

```

Time spent visiting modules.

### as_text

```
as_text() -> str

```

Format the statistics as text.

Returns:

- `str` – Text stats.

## merge_stubs

```
merge_stubs(mod1: Module, mod2: Module) -> Module

```

Merge stubs into a module.

Parameters:

- ### **`mod1`**

  (`Module`) – A regular module or stubs module.

- ### **`mod2`**

  (`Module`) – A regular module or stubs module.

Raises:

- `ValueError` – When both modules are regular modules (no stubs is passed).

Returns:

- `Module` – The regular module.

# Loggers

## **Main API**

## logger

```
logger: Logger = _get()

```

Our global logger, used throughout the library.

Griffe's output and error messages are logging messages.

Griffe provides the patch_loggers function so dependent libraries can patch Griffe loggers as they see fit.

For example, to fit in the MkDocs logging configuration and prefix each log message with the module name:

```
import logging
from griffe import patch_loggers


class LoggerAdapter(logging.LoggerAdapter):
    def __init__(self, prefix, logger):
        super().__init__(logger, {})
        self.prefix = prefix

    def process(self, msg, kwargs):
        return f"{self.prefix}: {msg}", kwargs


def get_logger(name):
    logger = logging.getLogger(f"mkdocs.plugins.{name}")
    return LoggerAdapter(name, logger)


patch_loggers(get_logger)

```

## get_logger

```
get_logger(name: str = 'griffe') -> Logger

```

Create and return a new logger instance.

Parameters:

- ### **`name`**

  (`str`, default: `'griffe'` ) – The logger name.

Returns:

- `Logger` – The logger.

## Logger

```
Logger(name: str)

```

Methods:

- **`disable`** – Temporarily disable logging.

### disable

```
disable() -> Iterator[None]

```

Temporarily disable logging.

## LogLevel

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.LogLevel[LogLevel]

              

              click griffe.LogLevel href "" "griffe.LogLevel"
            
```

Enumeration of available log levels.

Attributes:

- **`critical`** – The CRITICAL log level.
- **`debug`** – The DEBUG log level.
- **`error`** – The ERROR log level.
- **`info`** – The INFO log level.
- **`success`** – The SUCCESS log level.
- **`trace`** – The TRACE log level.
- **`warning`** – The WARNING log level.

### critical

```
critical = 'critical'

```

The CRITICAL log level.

### debug

```
debug = 'debug'

```

The DEBUG log level.

### error

```
error = 'error'

```

The ERROR log level.

### info

```
info = 'info'

```

The INFO log level.

### success

```
success = 'success'

```

The SUCCESS log level.

### trace

```
trace = 'trace'

```

The TRACE log level.

### warning

```
warning = 'warning'

```

The WARNING log level.

## DEFAULT_LOG_LEVEL

```
DEFAULT_LOG_LEVEL = os.getenv(
    "GRIFFE_LOG_LEVEL", "INFO"
).upper()

```

The default log level for the CLI.

This can be overridden by the `GRIFFE_LOG_LEVEL` environment variable.

## **Advanced API**

## patch_loggers

```
patch_loggers(
    get_logger_func: Callable[[str], Any],
) -> None

```

Patch Griffe logger and Griffe extensions' loggers.

Parameters:

- ### **`get_logger_func`**

  (`Callable[[str], Any]`) – A function accepting a name as parameter and returning a logger.

# Models

Griffe stores information extracted from Python source code into data models.

These models represent trees of objects, starting with modules, and containing classes, functions, attributes, and type aliases.

Modules can have submodules, classes, functions, attributes, and type aliases. Classes can have nested classes, methods, attributes, and type aliases. Functions and attributes do not have any members.

Indirections to objects declared in other modules are represented as "aliases". An alias therefore represents an imported object, and behaves almost exactly like the object it points to: it is a light wrapper around the object, with special methods and properties that allow to access the target's data transparently.

The 6 models:

- Module
- Class
- Function
- Attribute
- Alias
- TypeAlias

## **Model kind enumeration**

## Kind

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.Kind[Kind]

              

              click griffe.Kind href "" "griffe.Kind"
            
```

Enumeration of the different object kinds.

Attributes:

- **`ALIAS`** – Aliases (imported objects).
- **`ATTRIBUTE`** – Attributes and properties.
- **`CLASS`** – Classes.
- **`FUNCTION`** – Functions and methods.
- **`MODULE`** – Modules.
- **`TYPE_ALIAS`** – Type aliases.

### ALIAS

```
ALIAS = 'alias'

```

Aliases (imported objects).

### ATTRIBUTE

```
ATTRIBUTE = 'attribute'

```

Attributes and properties.

### CLASS

```
CLASS = 'class'

```

Classes.

### FUNCTION

```
FUNCTION = 'function'

```

Functions and methods.

### MODULE

```
MODULE = 'module'

```

Modules.

### TYPE_ALIAS

```
TYPE_ALIAS = 'type alias'

```

Type aliases.

## **Models base classes**

## GetMembersMixin

Mixin class to share methods for accessing members.

Methods:

- **`get_member`** – Get a member with its name or path.
- **`__getitem__`** – Same as get_member, with the item syntax [].

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

### get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

## SetMembersMixin

Mixin class to share methods for setting members.

Methods:

- **`set_member`** – Set a member with its name or path.
- **`__setitem__`** – Same as set_member, with the item syntax [].

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## DelMembersMixin

Mixin class to share methods for deleting members.

Methods:

- **`del_member`** – Delete a member with its name or path.
- **`__delitem__`** – Same as del_member, with the item syntax [].

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

### del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

## SerializationMixin

Mixin class to share methods for de/serializing objects.

Methods:

- **`as_json`** – Return this object's data as a JSON string.
- **`from_json`** – Create an instance of this class from a JSON string.

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) – JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

## ObjectAliasMixin

Bases: `GetMembersMixin`, `SetMembersMixin`, `DelMembersMixin`, `SerializationMixin`

```

              flowchart TD
              griffe.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.mixins.GetMembersMixin --> griffe.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe.ObjectAliasMixin
                


              click griffe.ObjectAliasMixin href "" "griffe.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

Mixin class to share methods that appear both in objects and aliases, unchanged.

Attributes:

- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`modules`** (`dict[str, Module]`) – The module members.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.

Methods:

- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__setitem__`** – Set a member with its name or path.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`set_member`** – Set a member with its name or path.

### all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

### attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

### classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

### functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

### is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

### is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

### is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

### is_generic

```
is_generic: bool

```

Whether this object is generic.

### is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

### is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

### is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

### is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

### is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

### modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

### type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

### del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) – JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

### get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## Object

```
Object(
    name: str,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    runtime: bool = True,
    docstring: Docstring | None = None,
    type_parameters: TypeParameters | None = None,
    parent: Module | Class | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
)

```

Bases: `ObjectAliasMixin`

```

              flowchart TD
              griffe.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.mixins.ObjectAliasMixin --> griffe.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                



              click griffe.Object href "" "griffe.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

An abstract class representing a Python object.

Parameters:

- ### **`name`**

  (`str`) – The object name, as declared in the code.

- ### **`lineno`**

  (`int | None`, default: `None` ) – The object starting line, or None for modules. Lines start at 1.

- ### **`endlineno`**

  (`int | None`, default: `None` ) – The object ending line (inclusive), or None for modules.

- ### **`runtime`**

  (`bool`, default: `True` ) – Whether this object is present at runtime or not.

- ### **`docstring`**

  (`Docstring | None`, default: `None` ) – The object docstring.

- ### **`type_parameters`**

  (`TypeParameters | None`, default: `None` ) – The object type parameters, if any.

- ### **`parent`**

  (`Module | Class | None`, default: `None` ) – The object parent.

- ### **`lines_collection`**

  (`LinesCollection | None`, default: `None` ) – A collection of source code lines.

- ### **`modules_collection`**

  (`ModulesCollection | None`, default: `None` ) – A collection of modules.

Methods:

- **`__bool__`** – An object is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The number of members in this object, recursively.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this object's data as a dictionary.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`set_member`** – Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`deprecated`** (`bool | str | None`) – Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The object docstring.
- **`endlineno`** (`int | None`) – The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) – Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) – The other objects imported by this object.
- **`inherited`** (`bool`) – Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always false for objects.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for objects.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this object is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this object is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** (`Kind`) – The object kind.
- **`labels`** (`set[str]`) – The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to this object or its parents.
- **`name`** (`str`) – The object name.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) – The parent of the object (none if top module).
- **`path`** (`str`) – The dotted path of this object.
- **`public`** (`bool | None`) – Whether this object is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) – Whether this object is available at runtime.
- **`source`** (`str`) – The source code of this object.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The object type parameters.

### aliases

```
aliases: dict[str, Alias] = {}

```

The aliases pointing to this object.

### all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

### attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

### canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

### classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

### deprecated

```
deprecated: bool | str | None = None

```

Whether this object is deprecated (boolean or deprecation message).

### docstring

```
docstring: Docstring | None = docstring

```

The object docstring.

See also: has_docstring, has_docstrings.

### endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the object.

See also: lineno.

### exports

```
exports: list[str | ExprName] | None = None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

### extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

### filepath

```
filepath: Path | list[Path]

```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')

```

### functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

### has_docstring

```
has_docstring: bool

```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

### has_docstrings

```
has_docstrings: bool

```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

### imports

```
imports: dict[str, str] = {}

```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

### inherited

```
inherited: bool = False

```

Always false for objects.

Only aliases can be marked as inherited.

### inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

### is_alias

```
is_alias: bool = False

```

Always false for objects.

### is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

### is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

### is_collection

```
is_collection: bool = False

```

Always false for objects.

### is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

### is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

### is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

### is_generic

```
is_generic: bool

```

Whether this object is generic.

### is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

### is_init_module

```
is_init_module: bool

```

Whether this object is an `__init__.py` module.

See also: is_module.

### is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_namespace_package

```
is_namespace_package: bool

```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

### is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

### is_package

```
is_package: bool

```

Whether this object is a package (top module).

See also: is_subpackage.

### is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

### is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

### is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

### is_subpackage

```
is_subpackage: bool

```

Whether this object is a subpackage.

See also: is_package.

### is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

### is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

### kind

```
kind: Kind

```

The object kind.

### labels

```
labels: set[str] = set()

```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

### lineno

```
lineno: int | None = lineno

```

The starting line number of the object.

See also: endlineno.

### lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: lines_collection, source.

### lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

### members

```
members: dict[str, Object | Alias] = {}

```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

### module

```
module: Module

```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))

```

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

### modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

### modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

### name

```
name: str = name

```

The object name.

### package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))

```

### parent

```
parent: Module | Class | None = parent

```

The parent of the object (none if top module).

### path

```
path: str

```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'

```

### public

```
public: bool | None = None

```

Whether this object is public.

### relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

### relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

### runtime

```
runtime: bool = runtime

```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

### source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

### type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

### type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)

```

The object type parameters.

### __bool__

```
__bool__() -> bool

```

An object is always true-ish.

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

### __len__

```
__len__() -> int

```

The number of members in this object, recursively.

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this object's data as a dictionary.

See also: as_json.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

### del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

### filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members.

Parameters:

- #### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) – JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

### get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

### has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- #### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

### is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- #### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

### resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- #### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## **Models type parameter**

## TypeParameters

```
TypeParameters(*type_parameters: TypeParameter)

```

This class is a container for type parameters.

It allows to get type parameters using their position (index) or their name:

```
>>> type_parameters = TypeParameters(TypeParameter("hello"), kind=TypeParameterKind.type_var)
>>> type_parameters[0] is type_parameters["hello"]
True

```

Parameters:

- ### **`*type_parameters`**

  (`TypeParameter`, default: `()` ) – The initial type parameters to add to the container.

Methods:

- **`__contains__`** – Whether a type parameter with the given name is present.
- **`__delitem__`** – Delete a type parameter by index or name.
- **`__getitem__`** – Get a type parameter by index or name.
- **`__iter__`** – Iterate over the type parameters, in order.
- **`__len__`** – The number of type parameters.
- **`__setitem__`** – Set a type parameter by index or name.
- **`add`** – Add a type parameter to the container.

### __contains__

```
__contains__(type_param_name: str)

```

Whether a type parameter with the given name is present.

### __delitem__

```
__delitem__(name_or_index: int | str) -> None

```

Delete a type parameter by index or name.

### __getitem__

```
__getitem__(name_or_index: int | str) -> TypeParameter

```

Get a type parameter by index or name.

### __iter__

```
__iter__()

```

Iterate over the type parameters, in order.

### __len__

```
__len__()

```

The number of type parameters.

### __setitem__

```
__setitem__(
    name_or_index: int | str, type_parameter: TypeParameter
) -> None

```

Set a type parameter by index or name.

### add

```
add(type_parameter: TypeParameter) -> None

```

Add a type parameter to the container.

Parameters:

- #### **`type_parameter`**

  (`TypeParameter`) – The function parameter to add.

Raises:

- `ValueError` – When a type parameter with the same name is already present.

## TypeParameter

```
TypeParameter(
    name: str,
    *,
    kind: TypeParameterKind,
    bound: str | Expr | None = None,
    constraints: Sequence[str | Expr] | None = None,
    default: str | Expr | None = None,
)

```

This class represents a type parameter.

Parameters:

- ### **`name`**

  (`str`) – The type parameter name, without leading stars (\* or \*\*).

- ### **`kind`**

  (`TypeParameterKind`) – The type parameter kind.

- ### **`bound`**

  (`str | Expr | None`, default: `None` ) – The type parameter bound, if any. Mutually exclusive with constraints.

- ### **`constraints`**

  (`Sequence[str | Expr] | None`, default: `None` ) – The type parameter constraints, if any. Mutually exclusive with bound.

- ### **`default`**

  (`str | Expr | None`, default: `None` ) – The type parameter default, if any.

Raises:

- `ValueError` – When more than one of bound and constraints is set.

Methods:

- **`as_dict`** – Return this type parameter's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The type parameter bound or constraints.
- **`bound`** (`str | Expr | None`) – The type parameter bound.
- **`constraints`** (`tuple[str | Expr, ...] | None`) – The type parameter constraints.
- **`default`** (`str | Expr | None`) – The type parameter default value.
- **`kind`** (`TypeParameterKind`) – The type parameter kind.
- **`name`** (`str`) – The type parameter name.

### annotation

```
annotation: str | Expr | None

```

The type parameter bound or constraints.

### bound

```
bound: str | Expr | None

```

The type parameter bound.

### constraints

```
constraints: tuple[str | Expr, ...] | None

```

The type parameter constraints.

### default

```
default: str | Expr | None = default

```

The type parameter default value.

### kind

```
kind: TypeParameterKind = kind

```

The type parameter kind.

### name

```
name: str = name

```

The type parameter name.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this type parameter's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## TypeParameterKind

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.TypeParameterKind[TypeParameterKind]

              

              click griffe.TypeParameterKind href "" "griffe.TypeParameterKind"
            
```

Enumeration of the different type parameter kinds.

Attributes:

- **`param_spec`** – Parameter specification variable.
- **`type_var`** – Type variable.
- **`type_var_tuple`** – Type variable tuple.

### param_spec

```
param_spec = 'param-spec'

```

Parameter specification variable.

### type_var

```
type_var = 'type-var'

```

Type variable.

### type_var_tuple

```
type_var_tuple = 'type-var-tuple'

```

Type variable tuple.

# Serializers

## **Main API**

See the as_json() and from_json() methods of objects.

## **Advanced API**

## JSONEncoder

```
JSONEncoder(*args: Any, full: bool = False, **kwargs: Any)

```

Bases: `JSONEncoder`

```

              flowchart TD
              griffe.JSONEncoder[JSONEncoder]

              

              click griffe.JSONEncoder href "" "griffe.JSONEncoder"
            
```

JSON encoder.

JSON encoders can be used directly, or through the json.dump or json.dumps methods.

Examples:

```
>>> from griffe import JSONEncoder
>>> JSONEncoder(full=True).encode(..., **kwargs)

```

```
>>> import json
>>> from griffe import JSONEncoder
>>> json.dumps(..., cls=JSONEncoder, full=True, **kwargs)

```

Parameters:

- ### **`*args`**

  (`Any`, default: `()` ) – See json.JSONEncoder.

- ### **`full`**

  (`bool`, default: `False` ) – Whether to dump full data or base data. If you plan to reload the data in Python memory using the json_decoder, you don't need the full data as it can be inferred again using the base data. If you want to feed a non-Python tool instead, dump the full data.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – See json.JSONEncoder.

Methods:

- **`default`** – Return a serializable representation of the given object.

Attributes:

- **`full`** (`bool`) – Whether to dump full data or base data.

### full

```
full: bool = full

```

Whether to dump full data or base data.

### default

```
default(obj: Any) -> Any

```

Return a serializable representation of the given object.

Parameters:

- #### **`obj`**

  (`Any`) – The object to serialize.

Returns:

- `Any` – A serializable representation.

## json_decoder

```
json_decoder(
    obj_dict: dict[str, Any],
) -> (
    dict[str, Any]
    | Object
    | Alias
    | Parameter
    | TypeParameter
    | str
    | Expr
)

```

Decode dictionaries as data classes.

The json.loads method walks the tree from bottom to top.

Examples:

```
>>> import json
>>> from griffe import json_decoder
>>> json.loads(..., object_hook=json_decoder)

```

Parameters:

- ### **`obj_dict`**

  (`dict[str, Any]`) – The dictionary to decode.

Returns:

- `dict[str, Any] | Object | Alias | Parameter | TypeParameter | str | Expr` – An instance of a data class.

# Docstring models

## **Main API**

## Docstring

```
Docstring(
    value: str,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    parent: Object | None = None,
    parser: DocstringStyle | Parser | None = None,
    parser_options: dict[str, Any] | None = None,
)

```

This class represents docstrings.

Parameters:

- ### **`value`**

  (`str`) – The docstring value.

- ### **`lineno`**

  (`int | None`, default: `None` ) – The starting line number.

- ### **`endlineno`**

  (`int | None`, default: `None` ) – The ending line number.

- ### **`parent`**

  (`Object | None`, default: `None` ) – The parent object on which this docstring is attached.

- ### **`parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. By default, no parsing is done.

- ### **`parser_options`**

  (`dict[str, Any] | None`, default: `None` ) – Additional docstring parsing options.

Methods:

- **`as_dict`** – Return this docstring's data as a dictionary.
- **`parse`** – Parse the docstring into structured data.

Attributes:

- **`endlineno`** (`int | None`) – The ending line number of the docstring.
- **`lineno`** (`int | None`) – The starting line number of the docstring.
- **`lines`** (`list[str]`) – The lines of the docstring.
- **`parent`** (`Object | None`) – The object this docstring is attached to.
- **`parsed`** (`list[DocstringSection]`) – The docstring sections, parsed into structured data.
- **`parser`** (`DocstringStyle | Parser | None`) – The selected docstring parser.
- **`parser_options`** (`dict[str, Any]`) – The configured parsing options.
- **`source`** (`str`) – The original, uncleaned value of the docstring as written in the source.
- **`value`** (`str`) – The original value of the docstring, cleaned by inspect.cleandoc.

### endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the docstring.

See also: lineno.

### lineno

```
lineno: int | None = lineno

```

The starting line number of the docstring.

See also: endlineno.

### lines

```
lines: list[str]

```

The lines of the docstring.

See also: source.

### parent

```
parent: Object | None = parent

```

The object this docstring is attached to.

### parsed

```
parsed: list[DocstringSection]

```

The docstring sections, parsed into structured data.

### parser

```
parser: DocstringStyle | Parser | None = parser

```

The selected docstring parser.

See also: parser_options, parse.

### parser_options

```
parser_options: dict[str, Any] = parser_options or {}

```

The configured parsing options.

See also: parser, parse.

### source

```
source: str

```

The original, uncleaned value of the docstring as written in the source.

See also: value.

### value

```
value: str = cleandoc(rstrip())

```

The original value of the docstring, cleaned by `inspect.cleandoc`.

See also: source.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this docstring's data as a dictionary.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### parse

```
parse(
    parser: DocstringStyle | Parser | None = None,
    **options: Any,
) -> list[DocstringSection]

```

Parse the docstring into structured data.

See also: parser, parser_options.

Parameters:

- #### **`parser`**

  (`DocstringStyle | Parser | None`, default: `None` ) – The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section).

- #### **`**options`**

  (`Any`, default: `{}` ) – Additional docstring parsing options.

Returns:

- `list[DocstringSection]` – The parsed docstring as a list of sections.

## **Advanced API: Sections**

## DocstringSectionKind

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.DocstringSectionKind[DocstringSectionKind]

              

              click griffe.DocstringSectionKind href "" "griffe.DocstringSectionKind"
            
```

Enumeration of the possible docstring section kinds.

Attributes:

- **`admonition`** – Admonition block.
- **`attributes`** – Attributes section.
- **`classes`** – Classes section.
- **`deprecated`** – Deprecation section.
- **`examples`** – Examples section.
- **`functions`** – Functions section.
- **`modules`** – Modules section.
- **`other_parameters`** – Other parameters (keyword arguments) section.
- **`parameters`** – Parameters section.
- **`raises`** – Raises (exceptions) section.
- **`receives`** – Received value(s) (generators) section.
- **`returns`** – Returned value(s) section.
- **`text`** – Text section.
- **`type_aliases`** – Type aliases section.
- **`type_parameters`** – Type parameters section.
- **`warns`** – Warnings section.
- **`yields`** – Yielded value(s) (generators) section.

### admonition

```
admonition = 'admonition'

```

Admonition block.

### attributes

```
attributes = 'attributes'

```

Attributes section.

### classes

```
classes = 'classes'

```

Classes section.

### deprecated

```
deprecated = 'deprecated'

```

Deprecation section.

### examples

```
examples = 'examples'

```

Examples section.

### functions

```
functions = 'functions'

```

Functions section.

### modules

```
modules = 'modules'

```

Modules section.

### other_parameters

```
other_parameters = 'other parameters'

```

Other parameters (keyword arguments) section.

### parameters

```
parameters = 'parameters'

```

Parameters section.

### raises

```
raises = 'raises'

```

Raises (exceptions) section.

### receives

```
receives = 'receives'

```

Received value(s) (generators) section.

### returns

```
returns = 'returns'

```

Returned value(s) section.

### text

```
text = 'text'

```

Text section.

### type_aliases

```
type_aliases = 'type aliases'

```

Type aliases section.

### type_parameters

```
type_parameters = 'type parameters'

```

Type parameters section.

### warns

```
warns = 'warns'

```

Warnings section.

### yields

```
yields = 'yields'

```

Yielded value(s) (generators) section.

## DocstringSectionText

```
DocstringSectionText(value: str, title: str | None = None)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionText[DocstringSectionText]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionText
                


              click griffe.DocstringSectionText href "" "griffe.DocstringSectionText"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a text section.

Parameters:

- ### **`value`**

  (`str`) – The section text.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`str`) – The section value.

### kind

```
kind: DocstringSectionKind = text

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: str = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionParameters

```
DocstringSectionParameters(
    value: list[DocstringParameter],
    title: str | None = None,
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionParameters[DocstringSectionParameters]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionParameters
                


              click griffe.DocstringSectionParameters href "" "griffe.DocstringSectionParameters"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a parameters section.

Parameters:

- ### **`value`**

  (`list[DocstringParameter]`) – The section parameters.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringParameter]`) – The section value.

### kind

```
kind: DocstringSectionKind = parameters

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringParameter] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionOtherParameters

```
DocstringSectionOtherParameters(
    value: list[DocstringParameter],
    title: str | None = None,
)

```

Bases: `DocstringSectionParameters`

```

              flowchart TD
              griffe.DocstringSectionOtherParameters[DocstringSectionOtherParameters]
              griffe._internal.docstrings.models.DocstringSectionParameters[DocstringSectionParameters]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSectionParameters --> griffe.DocstringSectionOtherParameters
                                griffe._internal.docstrings.models.DocstringSection --> griffe._internal.docstrings.models.DocstringSectionParameters
                



              click griffe.DocstringSectionOtherParameters href "" "griffe.DocstringSectionOtherParameters"
              click griffe._internal.docstrings.models.DocstringSectionParameters href "" "griffe._internal.docstrings.models.DocstringSectionParameters"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents an other parameters section.

Parameters:

- ### **`value`**

  (`list[DocstringParameter]`) – The section parameters.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringParameter]`) – The section value.

### kind

```
kind: DocstringSectionKind = other_parameters

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringParameter] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionTypeParameters

```
DocstringSectionTypeParameters(
    value: list[DocstringTypeParameter],
    title: str | None = None,
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionTypeParameters[DocstringSectionTypeParameters]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionTypeParameters
                


              click griffe.DocstringSectionTypeParameters href "" "griffe.DocstringSectionTypeParameters"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a type parameters section.

Parameters:

- ### **`value`**

  (`list[DocstringTypeParameter]`) – The section type parameters.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringTypeParameter]`) – The section value.

### kind

```
kind: DocstringSectionKind = type_parameters

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringTypeParameter] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionRaises

```
DocstringSectionRaises(
    value: list[DocstringRaise], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionRaises[DocstringSectionRaises]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionRaises
                


              click griffe.DocstringSectionRaises href "" "griffe.DocstringSectionRaises"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a raises section.

Parameters:

- ### **`value`**

  (`list[DocstringRaise]`) – The section exceptions.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringRaise]`) – The section value.

### kind

```
kind: DocstringSectionKind = raises

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringRaise] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionWarns

```
DocstringSectionWarns(
    value: list[DocstringWarn], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionWarns[DocstringSectionWarns]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionWarns
                


              click griffe.DocstringSectionWarns href "" "griffe.DocstringSectionWarns"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a warns section.

Parameters:

- ### **`value`**

  (`list[DocstringWarn]`) – The section warnings.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringWarn]`) – The section value.

### kind

```
kind: DocstringSectionKind = warns

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringWarn] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionReturns

```
DocstringSectionReturns(
    value: list[DocstringReturn], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionReturns[DocstringSectionReturns]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionReturns
                


              click griffe.DocstringSectionReturns href "" "griffe.DocstringSectionReturns"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a returns section.

Parameters:

- ### **`value`**

  (`list[DocstringReturn]`) – The section returned items.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringReturn]`) – The section value.

### kind

```
kind: DocstringSectionKind = returns

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringReturn] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionYields

```
DocstringSectionYields(
    value: list[DocstringYield], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionYields[DocstringSectionYields]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionYields
                


              click griffe.DocstringSectionYields href "" "griffe.DocstringSectionYields"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a yields section.

Parameters:

- ### **`value`**

  (`list[DocstringYield]`) – The section yielded items.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringYield]`) – The section value.

### kind

```
kind: DocstringSectionKind = yields

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringYield] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionReceives

```
DocstringSectionReceives(
    value: list[DocstringReceive], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionReceives[DocstringSectionReceives]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionReceives
                


              click griffe.DocstringSectionReceives href "" "griffe.DocstringSectionReceives"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a receives section.

Parameters:

- ### **`value`**

  (`list[DocstringReceive]`) – The section received items.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringReceive]`) – The section value.

### kind

```
kind: DocstringSectionKind = receives

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringReceive] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionExamples

```
DocstringSectionExamples(
    value: list[tuple[Literal[text, examples], str]],
    title: str | None = None,
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionExamples[DocstringSectionExamples]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionExamples
                


              click griffe.DocstringSectionExamples href "" "griffe.DocstringSectionExamples"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents an examples section.

Parameters:

- ### **`value`**

  (`list[tuple[Literal[text, examples], str]]`) – The section examples.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[tuple[Literal[text, examples], str]]`) – The section value.

### kind

```
kind: DocstringSectionKind = examples

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[tuple[Literal[text, examples], str]] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionAttributes

```
DocstringSectionAttributes(
    value: list[DocstringAttribute],
    title: str | None = None,
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionAttributes[DocstringSectionAttributes]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionAttributes
                


              click griffe.DocstringSectionAttributes href "" "griffe.DocstringSectionAttributes"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents an attributes section.

Parameters:

- ### **`value`**

  (`list[DocstringAttribute]`) – The section attributes.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringAttribute]`) – The section value.

### kind

```
kind: DocstringSectionKind = attributes

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringAttribute] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionFunctions

```
DocstringSectionFunctions(
    value: list[DocstringFunction], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionFunctions[DocstringSectionFunctions]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionFunctions
                


              click griffe.DocstringSectionFunctions href "" "griffe.DocstringSectionFunctions"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a functions/methods section.

Parameters:

- ### **`value`**

  (`list[DocstringFunction]`) – The section functions.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringFunction]`) – The section value.

### kind

```
kind: DocstringSectionKind = functions

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringFunction] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionClasses

```
DocstringSectionClasses(
    value: list[DocstringClass], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionClasses[DocstringSectionClasses]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionClasses
                


              click griffe.DocstringSectionClasses href "" "griffe.DocstringSectionClasses"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a classes section.

Parameters:

- ### **`value`**

  (`list[DocstringClass]`) – The section classes.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringClass]`) – The section value.

### kind

```
kind: DocstringSectionKind = classes

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringClass] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionTypeAliases

```
DocstringSectionTypeAliases(
    value: list[DocstringTypeAlias],
    title: str | None = None,
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionTypeAliases[DocstringSectionTypeAliases]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionTypeAliases
                


              click griffe.DocstringSectionTypeAliases href "" "griffe.DocstringSectionTypeAliases"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a type aliases section.

Parameters:

- ### **`value`**

  (`list[DocstringTypeAlias]`) – The section classes.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringTypeAlias]`) – The section value.

### kind

```
kind: DocstringSectionKind = type_aliases

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringTypeAlias] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionModules

```
DocstringSectionModules(
    value: list[DocstringModule], title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionModules[DocstringSectionModules]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionModules
                


              click griffe.DocstringSectionModules href "" "griffe.DocstringSectionModules"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a modules section.

Parameters:

- ### **`value`**

  (`list[DocstringModule]`) – The section modules.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`list[DocstringModule]`) – The section value.

### kind

```
kind: DocstringSectionKind = modules

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: list[DocstringModule] = value

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionDeprecated

```
DocstringSectionDeprecated(
    version: str, text: str, title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionDeprecated[DocstringSectionDeprecated]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionDeprecated
                


              click griffe.DocstringSectionDeprecated href "" "griffe.DocstringSectionDeprecated"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents a deprecated section.

Parameters:

- ### **`version`**

  (`str`) – The deprecation version.

- ### **`text`**

  (`str`) – The deprecation text.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`DocstringDeprecated`) – The section value.

### kind

```
kind: DocstringSectionKind = deprecated

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: DocstringDeprecated = DocstringDeprecated(
    annotation=version, description=text
)

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSectionAdmonition

```
DocstringSectionAdmonition(
    kind: str, text: str, title: str | None = None
)

```

Bases: `DocstringSection`

```

              flowchart TD
              griffe.DocstringSectionAdmonition[DocstringSectionAdmonition]
              griffe._internal.docstrings.models.DocstringSection[DocstringSection]

                              griffe._internal.docstrings.models.DocstringSection --> griffe.DocstringSectionAdmonition
                


              click griffe.DocstringSectionAdmonition href "" "griffe.DocstringSectionAdmonition"
              click griffe._internal.docstrings.models.DocstringSection href "" "griffe._internal.docstrings.models.DocstringSection"
            
```

This class represents an admonition section.

Parameters:

- ### **`kind`**

  (`str`) – The admonition kind.

- ### **`text`**

  (`str`) – The admonition text.

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`DocstringAdmonition`) – The section value.

### kind

```
kind: DocstringSectionKind = admonition

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: DocstringAdmonition = DocstringAdmonition(
    annotation=kind, description=text
)

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## **Advanced API: Section items**

## DocstringAdmonition

```
DocstringAdmonition(
    *,
    description: str,
    annotation: str | Expr | None = None,
)

```

Bases: `DocstringElement`

```

              flowchart TD
              griffe.DocstringAdmonition[DocstringAdmonition]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringAdmonition
                


              click griffe.DocstringAdmonition href "" "griffe.DocstringAdmonition"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents an admonition.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`description`**

  (`str`) – The element description.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`contents`** (`str`) – The contents of this admonition.
- **`description`** (`str`) – The element description.
- **`kind`** (`str | Expr | None`) – The kind of this admonition.

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### contents

```
contents: str

```

The contents of this admonition.

### description

```
description: str = description

```

The element description.

### kind

```
kind: str | Expr | None

```

The kind of this admonition.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringDeprecated

```
DocstringDeprecated(
    *,
    description: str,
    annotation: str | Expr | None = None,
)

```

Bases: `DocstringElement`

```

              flowchart TD
              griffe.DocstringDeprecated[DocstringDeprecated]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringDeprecated
                


              click griffe.DocstringDeprecated href "" "griffe.DocstringDeprecated"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented deprecated item.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`description`**

  (`str`) – The element description.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`version`** (`str`) – The version of this deprecation.

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### version

```
version: str

```

The version of this deprecation.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringRaise

```
DocstringRaise(
    *,
    description: str,
    annotation: str | Expr | None = None,
)

```

Bases: `DocstringElement`

```

              flowchart TD
              griffe.DocstringRaise[DocstringRaise]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringRaise
                


              click griffe.DocstringRaise href "" "griffe.DocstringRaise"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented raise value.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`description`**

  (`str`) – The element description.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringWarn

```
DocstringWarn(
    *,
    description: str,
    annotation: str | Expr | None = None,
)

```

Bases: `DocstringElement`

```

              flowchart TD
              griffe.DocstringWarn[DocstringWarn]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringWarn
                


              click griffe.DocstringWarn href "" "griffe.DocstringWarn"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented warn value.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`description`**

  (`str`) – The element description.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringReturn

```
DocstringReturn(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringReturn[DocstringReturn]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringReturn
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringReturn href "" "griffe.DocstringReturn"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented return value.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringYield

```
DocstringYield(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringYield[DocstringYield]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringYield
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringYield href "" "griffe.DocstringYield"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented yield value.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringReceive

```
DocstringReceive(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringReceive[DocstringReceive]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringReceive
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringReceive href "" "griffe.DocstringReceive"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented receive value.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringParameter

```
DocstringParameter(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringParameter[DocstringParameter]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringParameter
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringParameter href "" "griffe.DocstringParameter"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represent a documented function parameter.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`default`** (`str | Expr | None`) – The default value of this parameter.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### default

```
default: str | Expr | None

```

The default value of this parameter.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringTypeParameter

```
DocstringTypeParameter(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringTypeParameter[DocstringTypeParameter]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringTypeParameter
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringTypeParameter href "" "griffe.DocstringTypeParameter"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represent a documented type parameter.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`bound`** (`str | Expr | None`) – The bound of this type parameter.
- **`constraints`** (`tuple[str | Expr, ...] | None`) – The constraints of this type parameter.
- **`default`** (`str | Expr | None`) – The default value of this type parameter.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### bound

```
bound: str | Expr | None

```

The bound of this type parameter.

### constraints

```
constraints: tuple[str | Expr, ...] | None

```

The constraints of this type parameter.

### default

```
default: str | Expr | None

```

The default value of this type parameter.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringAttribute

```
DocstringAttribute(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringAttribute[DocstringAttribute]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringAttribute
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringAttribute href "" "griffe.DocstringAttribute"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented module/class attribute.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringFunction

```
DocstringFunction(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringFunction[DocstringFunction]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringFunction
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringFunction href "" "griffe.DocstringFunction"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented function.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`signature`** (`str | Expr | None`) – The function signature.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### signature

```
signature: str | Expr | None

```

The function signature.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringClass

```
DocstringClass(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringClass[DocstringClass]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringClass
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringClass href "" "griffe.DocstringClass"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented class.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`signature`** (`str | Expr | None`) – The class signature.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### signature

```
signature: str | Expr | None

```

The class signature.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringTypeAlias

```
DocstringTypeAlias(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringTypeAlias[DocstringTypeAlias]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringTypeAlias
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringTypeAlias href "" "griffe.DocstringTypeAlias"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented type alias.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringModule

```
DocstringModule(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringNamedElement`

```

              flowchart TD
              griffe.DocstringModule[DocstringModule]
              griffe._internal.docstrings.models.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringNamedElement --> griffe.DocstringModule
                                griffe._internal.docstrings.models.DocstringElement --> griffe._internal.docstrings.models.DocstringNamedElement
                



              click griffe.DocstringModule href "" "griffe.DocstringModule"
              click griffe._internal.docstrings.models.DocstringNamedElement href "" "griffe._internal.docstrings.models.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This class represents a documented module.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## **Models base classes**

## DocstringElement

```
DocstringElement(
    *,
    description: str,
    annotation: str | Expr | None = None,
)

```

This base class represents annotated, nameless elements.

Parameters:

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`description`**

  (`str`) – The element description.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringNamedElement

```
DocstringNamedElement(
    name: str,
    *,
    description: str,
    annotation: str | Expr | None = None,
    value: str | Expr | None = None,
)

```

Bases: `DocstringElement`

```

              flowchart TD
              griffe.DocstringNamedElement[DocstringNamedElement]
              griffe._internal.docstrings.models.DocstringElement[DocstringElement]

                              griffe._internal.docstrings.models.DocstringElement --> griffe.DocstringNamedElement
                


              click griffe.DocstringNamedElement href "" "griffe.DocstringNamedElement"
              click griffe._internal.docstrings.models.DocstringElement href "" "griffe._internal.docstrings.models.DocstringElement"
            
```

This base class represents annotated, named elements.

Parameters:

- ### **`name`**

  (`str`) – The element name.

- ### **`description`**

  (`str`) – The element description.

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The element annotation, if any.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The element value, as a string.

Methods:

- **`as_dict`** – Return this element's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The element annotation.
- **`description`** (`str`) – The element description.
- **`name`** (`str`) – The element name.
- **`value`** (`str | Expr | None`) – The element value, if any

### annotation

```
annotation: str | Expr | None = annotation

```

The element annotation.

### description

```
description: str = description

```

The element description.

### name

```
name: str = name

```

The element name.

### value

```
value: str | Expr | None = value

```

The element value, if any

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this element's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## DocstringSection

```
DocstringSection(title: str | None = None)

```

This class represents a docstring section.

Parameters:

- ### **`title`**

  (`str | None`, default: `None` ) – An optional title.

Methods:

- **`__bool__`** – Whether this section has a true-ish value.
- **`as_dict`** – Return this section's data as a dictionary.

Attributes:

- **`kind`** (`DocstringSectionKind`) – The section kind.
- **`title`** (`str | None`) – The section title.
- **`value`** (`Any`) – The section value.

### kind

```
kind: DocstringSectionKind

```

The section kind.

### title

```
title: str | None = title

```

The section title.

### value

```
value: Any = None

```

The section value.

### __bool__

```
__bool__() -> bool

```

Whether this section has a true-ish value.

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this section's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

# Docstring parsers

## **Main API**

## parse

```
parse(
    docstring: Docstring,
    parser: DocstringStyle | Parser | None,
    **options: Any,
) -> list[DocstringSection]

```

Parse the docstring.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring to parse.

- ### **`parser`**

  (`DocstringStyle | Parser | None`) – The docstring parser to use. If None, return a single text section.

- ### **`**options`**

  (`Any`, default: `{}` ) – The options accepted by the parser.

Returns:

- `list[DocstringSection]` – A list of docstring sections.

## parse_auto

```
parse_auto(
    docstring: Docstring,
    *,
    method: DocstringDetectionMethod = "heuristics",
    style_order: list[Parser]
    | list[DocstringStyle]
    | None = None,
    default: Parser | DocstringStyle | None = None,
    per_style_options: dict[
        Parser | DocstringStyle, dict[str, Any]
    ]
    | None = None,
    **options: Any,
) -> list[DocstringSection]

```

Parse a docstring by automatically detecting the style it uses.

[Sponsors only](../../../../insiders/) — [Insiders 1.3.0](../../../../insiders/changelog/#1.3.0).

See infer_docstring_style for more information on the available parameters.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring to parse.

- ### **`method`**

  (`DocstringDetectionMethod`, default: `'heuristics'` ) – The method to use to infer the parser.

- ### **`style_order`**

  (`list[Parser] | list[DocstringStyle] | None`, default: `None` ) – The order of the styles to try when inferring the parser.

- ### **`default`**

  (`Parser | DocstringStyle | None`, default: `None` ) – The default parser to use if the inference fails.

- ### **`per_style_options`**

  (`dict[Parser | DocstringStyle, dict[str, Any]] | None`, default: `None` ) – Additional parsing options per style.

- ### **`**options`**

  (`Any`, default: `{}` ) – Deprecated. Use per_style_options instead.

Returns:

- `list[DocstringSection]` – A list of docstring sections.

## parse_google

```
parse_google(
    docstring: Docstring,
    *,
    ignore_init_summary: bool = False,
    trim_doctest_flags: bool = True,
    returns_multiple_items: bool = True,
    returns_named_value: bool = True,
    returns_type_in_property_summary: bool = False,
    receives_multiple_items: bool = True,
    receives_named_value: bool = True,
    warn_unknown_params: bool = True,
    warn_missing_types: bool = True,
    warnings: bool = True,
    **options: Any,
) -> list[DocstringSection]

```

Parse a Google-style docstring.

This function iterates on lines of a docstring to build sections. It then returns this list of sections.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring to parse.

- ### **`ignore_init_summary`**

  (`bool`, default: `False` ) – Whether to ignore the summary in __init__ methods' docstrings.

- ### **`trim_doctest_flags`**

  (`bool`, default: `True` ) – Whether to remove doctest flags from Python example blocks.

- ### **`returns_multiple_items`**

  (`bool`, default: `True` ) – Whether to parse multiple items in Yields and Returns sections. When true, each item's continuation lines must be indented. When false (single item), no further indentation is required.

- ### **`returns_named_value`**

  (`bool`, default: `True` ) – Whether to parse Yields and Returns section items as name and description, rather than type and description. When true, type must be wrapped in parentheses: (int): Description.. Names are optional: name (int): Description.. When false, parentheses are optional but the items cannot be named: int: Description.

- ### **`receives_multiple_items`**

  (`bool`, default: `True` ) – Whether to parse multiple items in Receives sections. When true, each item's continuation lines must be indented. When false (single item), no further indentation is required.

- ### **`receives_named_value`**

  (`bool`, default: `True` ) – Whether to parse Receives section items as name and description, rather than type and description. When true, type must be wrapped in parentheses: (int): Description.. Names are optional: name (int): Description.. When false, parentheses are optional but the items cannot be named: int: Description.

- ### **`returns_type_in_property_summary`**

  (`bool`, default: `False` ) – Whether to parse the return type of properties at the beginning of their summary: str: Summary of the property.

- ### **`warn_unknown_params`**

  (`bool`, default: `True` ) – Warn about documented parameters not appearing in the signature.

- ### **`warn_missing_types`**

  (`bool`, default: `True` ) – Warn about missing types/annotations for parameters, return values, etc.

- ### **`warnings`**

  (`bool`, default: `True` ) – Whether to log warnings at all.

- ### **`**options`**

  (`Any`, default: `{}` ) – Additional parsing options.

Returns:

- `list[DocstringSection]` – A list of docstring sections.

## parse_numpy

```
parse_numpy(
    docstring: Docstring,
    *,
    ignore_init_summary: bool = False,
    trim_doctest_flags: bool = True,
    warn_unknown_params: bool = True,
    warn_missing_types: bool = True,
    warnings: bool = True,
    **options: Any,
) -> list[DocstringSection]

```

Parse a Numpydoc-style docstring.

This function iterates on lines of a docstring to build sections. It then returns this list of sections.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring to parse.

- ### **`ignore_init_summary`**

  (`bool`, default: `False` ) – Whether to ignore the summary in __init__ methods' docstrings.

- ### **`trim_doctest_flags`**

  (`bool`, default: `True` ) – Whether to remove doctest flags from Python example blocks.

- ### **`warn_unknown_params`**

  (`bool`, default: `True` ) – Warn about documented parameters not appearing in the signature.

- ### **`warn_missing_types`**

  (`bool`, default: `True` ) – Warn about missing types/annotations for parameters, return values, etc.

- ### **`warnings`**

  (`bool`, default: `True` ) – Whether to log warnings at all.

- ### **`**options`**

  (`Any`, default: `{}` ) – Additional parsing options.

Returns:

- `list[DocstringSection]` – A list of docstring sections.

## parse_sphinx

```
parse_sphinx(
    docstring: Docstring,
    *,
    warn_unknown_params: bool = True,
    warnings: bool = True,
    **options: Any,
) -> list[DocstringSection]

```

Parse a Sphinx-style docstring.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring to parse.

- ### **`warn_unknown_params`**

  (`bool`, default: `True` ) – Warn about documented parameters not appearing in the signature.

- ### **`warnings`**

  (`bool`, default: `True` ) – Whether to log warnings at all.

- ### **`**options`**

  (`Any`, default: `{}` ) – Additional parsing options.

Returns:

- `list[DocstringSection]` – A list of docstring sections.

## DocstringStyle

```
DocstringStyle = Literal[
    "google", "numpy", "sphinx", "auto"
]

```

The supported docstring styles (literal values of the Parser enumeration).

## **Advanced API**

## Parser

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.Parser[Parser]

              

              click griffe.Parser href "" "griffe.Parser"
            
```

Enumeration of the different docstring parsers.

Attributes:

- **`auto`** – Infer docstring parser.
- **`google`** – Google-style docstrings parser.
- **`numpy`** – Numpydoc-style docstrings parser.
- **`sphinx`** – Sphinx-style docstrings parser.

### auto

```
auto = 'auto'

```

Infer docstring parser.

[Sponsors only](../../../../insiders/) — [Insiders 1.3.0](../../../../insiders/changelog/#1.3.0).

### google

```
google = 'google'

```

Google-style docstrings parser.

### numpy

```
numpy = 'numpy'

```

Numpydoc-style docstrings parser.

### sphinx

```
sphinx = 'sphinx'

```

Sphinx-style docstrings parser.

## parsers

```
parsers: dict[
    Parser, Callable[[Docstring], list[DocstringSection]]
] = {
    auto: parse_auto,
    google: parse_google,
    sphinx: parse_sphinx,
    numpy: parse_numpy,
}

```

## parse_docstring_annotation

```
parse_docstring_annotation(
    annotation: str,
    docstring: Docstring,
    log_level: LogLevel = error,
) -> str | Expr

```

Parse a string into a true name or expression that can be resolved later.

Parameters:

- ### **`annotation`**

  (`str`) – The annotation to parse.

- ### **`docstring`**

  (`Docstring`) – The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression.

- ### **`log_level`**

  (`LogLevel`, default: `error` ) – Log level to use to log a message.

Returns:

- `str | Expr` – The string unchanged, or a new name or expression.

## docstring_warning

```
docstring_warning(
    docstring: Docstring,
    offset: int,
    message: str,
    log_level: LogLevel = warning,
) -> None

```

Log a warning when parsing a docstring.

This function logs a warning message by prefixing it with the filepath and line number.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring object.

- ### **`offset`**

  (`int`) – The offset in the docstring lines.

- ### **`message`**

  (`str`) – The message to log.

Returns:

- `None` – A function used to log parsing warnings if name was passed, else none.

## DocstringDetectionMethod

```
DocstringDetectionMethod = Literal[
    "heuristics", "max_sections"
]

```

The supported methods to infer docstring styles.

## infer_docstring_style

```
infer_docstring_style(
    docstring: Docstring,
    *,
    method: DocstringDetectionMethod = "heuristics",
    style_order: list[Parser]
    | list[DocstringStyle]
    | None = None,
    default: Parser | DocstringStyle | None = None,
    per_style_options: dict[
        Parser | DocstringStyle, dict[str, Any]
    ]
    | None = None,
    **options: Any,
) -> tuple[Parser | None, list[DocstringSection] | None]

```

Infer the parser to use for the docstring.

[Sponsors only](../../../../insiders/) — [Insiders 1.3.0](../../../../insiders/changelog/#1.3.0).

The 'heuristics' method uses regular expressions. The 'max_sections' method parses the docstring with all parsers specified in `style_order` and returns the one who parsed the most sections.

If heuristics fail, the `default` parser is returned. If multiple parsers parsed the same number of sections, `style_order` is used to decide which one to return. The `default` parser is never used with the 'max_sections' method.

For non-Insiders versions, `default` is returned if specified, else the first parser in `style_order` is returned. If `style_order` is not specified, `None` is returned.

Additional options are parsed to the detected parser, if any.

Parameters:

- ### **`docstring`**

  (`Docstring`) – The docstring to parse.

- ### **`method`**

  (`DocstringDetectionMethod`, default: `'heuristics'` ) – The method to use to infer the parser.

- ### **`style_order`**

  (`list[Parser] | list[DocstringStyle] | None`, default: `None` ) – The order of the styles to try when inferring the parser.

- ### **`default`**

  (`Parser | DocstringStyle | None`, default: `None` ) – The default parser to use if the inference fails.

- ### **`per_style_options`**

  (`dict[Parser | DocstringStyle, dict[str, Any]] | None`, default: `None` ) – Additional parsing options per style.

- ### **`**options`**

  (`Any`, default: `{}` ) – Deprecated. Use per_style_options instead.

Returns:

- `tuple[Parser | None, list[DocstringSection] | None]` – The inferred parser, and optionally parsed sections (when method is 'max_sections').

# Alias

```
Alias(
    name: str,
    target: str | Object | Alias,
    *,
    lineno: int | None = None,
    endlineno: int | None = None,
    runtime: bool = True,
    parent: Module | Class | Alias | None = None,
    inherited: bool = False,
)

```

Bases: `ObjectAliasMixin`

```

              flowchart TD
              griffe.Alias[Alias]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.mixins.ObjectAliasMixin --> griffe.Alias
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                



              click griffe.Alias href "" "griffe.Alias"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

This class represents an alias, or indirection, to an object declared in another module.

Aliases represent objects that are in the scope of a module or class, but were imported from another module.

They behave almost exactly like regular objects, to a few exceptions:

- line numbers are those of the alias, not the target
- the path is the alias path, not the canonical one
- the name can be different from the target's
- if the target can be resolved, the kind is the target's kind
- if the target cannot be resolved, the kind becomes Kind.ALIAS

Parameters:

- ## **`name`**

  (`str`) – The alias name.

- ## **`target`**

  (`str | Object | Alias`) – If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set.

- ## **`lineno`**

  (`int | None`, default: `None` ) – The alias starting line number.

- ## **`endlineno`**

  (`int | None`, default: `None` ) – The alias ending line number.

- ## **`runtime`**

  (`bool`, default: `True` ) – Whether this alias is present at runtime or not.

- ## **`parent`**

  (`Module | Class | Alias | None`, default: `None` ) – The alias parent.

- ## **`inherited`**

  (`bool`, default: `False` ) – Whether this alias wraps an inherited member.

Methods:

- **`__bool__`** – An alias is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The length of an alias is always 1.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this alias' data as a dictionary.
- **`as_json`** – Return this target's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`mro`** – Return a list of classes in order corresponding to Python's MRO.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`resolve_target`** – Resolve the target.
- **`set_member`** – Set a member with its name or path.
- **`signature`** – Construct the class/function signature.

Attributes:

- **`alias_endlineno`** (`int | None`) – The ending line number of the alias.
- **`alias_lineno`** (`int | None`) – The starting line number of the alias.
- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`annotation`** (`str | Expr | None`) – The attribute type annotation.
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`bases`** (`list[Expr | str]`) – The class bases.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`decorators`** (`list[Decorator]`) – The class/function decorators.
- **`deleter`** (`Function | None`) – The deleter linked to this function (property).
- **`deprecated`** (`str | bool | None`) – Whether this alias is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The target docstring.
- **`endlineno`** (`int | None`) – The ending line number of the target object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path (or directory list for namespace packages) where this object was defined.
- **`final_target`** (`Object`) – The final, resolved target, if possible.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this alias' target has a non-empty docstring.
- **`has_docstrings`** (`bool`) – Whether this alias' target or any of its members has a non-empty docstring.
- **`imports`** (`dict[str, str]`) – The other objects imported by this alias' target.
- **`imports_future_annotations`** (`bool`) – Whether this module import future annotations.
- **`inherited`** (`bool`) – Whether this alias represents an inherited member.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always true for aliases.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for aliases.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this module is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this module is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this module is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this module is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this module is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** (`Kind`) – The target's kind, or Kind.ALIAS if the target cannot be resolved.
- **`labels`** (`set[str]`) – The target labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the target object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The target's members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to the alias parents.
- **`name`** (`str`) – The alias name.
- **`overloads`** (`dict[str, list[Function]] | list[Function] | None`) – The overloaded signatures declared in this class/module or for this function.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parameters`** (`Parameters`) – The parameters of the current function or __init__ method for classes.
- **`parent`** (`Module | Class | Alias | None`) – The parent of this alias.
- **`path`** (`str`) – The dotted path / import path of this object.
- **`public`** (`bool | None`) – Whether this alias is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`resolved`** (`bool`) – Whether this alias' target is resolved.
- **`resolved_bases`** (`list[Object]`) – Resolved class bases.
- **`returns`** (`str | Expr | None`) – The function return type annotation.
- **`runtime`** (`bool`) – Whether this alias is available at runtime.
- **`setter`** (`Function | None`) – The setter linked to this function (property).
- **`source`** (`str`) – The source code of this object.
- **`target`** (`Object | Alias`) – The resolved target (actual object), if possible.
- **`target_path`** (`str`) – The path of this alias' target.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The target type parameters.
- **`value`** (`str | Expr | None`) – The attribute or type alias value.
- **`wildcard`** (`str | None`) – The module on which the wildcard import is performed (if any).

## alias_endlineno

```
alias_endlineno: int | None = endlineno

```

The ending line number of the alias.

## alias_lineno

```
alias_lineno: int | None = lineno

```

The starting line number of the alias.

## aliases

```
aliases: dict[str, Alias]

```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## annotation

```
annotation: str | Expr | None

```

The attribute type annotation.

## attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## bases

```
bases: list[Expr | str]

```

The class bases.

See also: Class, resolved_bases, mro.

## canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## decorators

```
decorators: list[Decorator]

```

The class/function decorators.

See also: Function, Class.

## deleter

```
deleter: Function | None

```

The deleter linked to this function (property).

## deprecated

```
deprecated: str | bool | None = None

```

Whether this alias is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None

```

The target docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None

```

The ending line number of the target object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]

```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

## final_target

```
final_target: Object

```

The final, resolved target, if possible.

This will iterate through the targets until a non-alias object is found.

See also: target, resolve_target, resolved.

## functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## has_docstring

```
has_docstring: bool

```

Whether this alias' target has a non-empty docstring.

See also: has_docstrings, docstring.

## has_docstrings

```
has_docstrings: bool

```

Whether this alias' target or any of its members has a non-empty docstring.

See also: has_docstring, docstring.

## imports

```
imports: dict[str, str]

```

The other objects imported by this alias' target.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

See also: is_imported.

## imports_future_annotations

```
imports_future_annotations: bool

```

Whether this module import future annotations.

## inherited

```
inherited: bool = inherited

```

Whether this alias represents an inherited member.

## inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

Each inherited member of the target will be wrapped in an alias, to preserve correct object access paths.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = True

```

Always true for aliases.

## is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module, is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False

```

Always false for aliases.

See also: ModulesCollection.

## is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

## is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module, is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool

```

Whether this object is generic.

## is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

## is_init_module

```
is_init_module: bool

```

Whether this module is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool

```

Whether this module is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this module is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool

```

Whether this module is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool

```

Whether this module is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module, is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

## kind

```
kind: Kind

```

The target's kind, or `Kind.ALIAS` if the target cannot be resolved.

See also: is_kind.

## labels

```
labels: set[str]

```

The target labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None

```

The starting line number of the target object.

See also: endlineno.

## lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: source, lines_collection.

## lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias]

```

The target's members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module

```

The parent module of this object.

See also: package.

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to the alias parents.

## name

```
name: str = name

```

The alias name.

## overloads

```
overloads: dict[str, list[Function]] | list[Function] | None

```

The overloaded signatures declared in this class/module or for this function.

## package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

## parameters

```
parameters: Parameters

```

The parameters of the current function or `__init__` method for classes.

This property can fetch inherited members, and therefore is part of the consumer API: do not use when producing Griffe trees!

## parent

```
parent: Module | Class | Alias | None

```

The parent of this alias.

## path

```
path: str

```

The dotted path / import path of this object.

See also: canonical_path.

## public

```
public: bool | None = None

```

Whether this alias is public.

## relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## resolved

```
resolved: bool

```

Whether this alias' target is resolved.

## resolved_bases

```
resolved_bases: list[Object]

```

Resolved class bases.

This method is part of the consumer API: do not use when producing Griffe trees!

## returns

```
returns: str | Expr | None

```

The function return type annotation.

## runtime

```
runtime: bool = runtime

```

Whether this alias is available at runtime.

## setter

```
setter: Function | None

```

The setter linked to this function (property).

## source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

## target

```
target: Object | Alias

```

The resolved target (actual object), if possible.

Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target.

See also: final_target, resolve_target, resolved.

## target_path

```
target_path: str

```

The path of this alias' target.

## type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters

```

The target type parameters.

## value

```
value: str | Expr | None

```

The attribute or type alias value.

## wildcard

```
wildcard: str | None

```

The module on which the wildcard import is performed (if any).

See also: GriffeLoader.expand_wildcards.

## __bool__

```
__bool__() -> bool

```

An alias is always true-ish.

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

## __len__

```
__len__() -> int

```

The length of an alias is always 1.

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

## as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this alias' data as a dictionary.

See also: as_json.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this target's data as a JSON string.

See also: as_dict.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

## del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members, get_member, set_member.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) – JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

## get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

## has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

## mro

```
mro() -> list[Class]

```

Return a list of classes in order corresponding to Python's MRO.

## resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

## resolve_target

```
resolve_target() -> None

```

Resolve the target.

See also: target, final_target, resolved.

Raises:

- `AliasResolutionError` – When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection.
- `CyclicAliasError` – When the resolved target is the alias itself.

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## signature

```
signature(
    *, return_type: bool = False, name: str | None = None
) -> str

```

Construct the class/function signature.

Parameters:

- ### **`return_type`**

  (`bool`, default: `False` ) – Whether to include the return type in the signature.

- ### **`name`**

  (`str | None`, default: `None` ) – The name of the class/function to use in the signature.

Returns:

- `str` – A string representation of the class/function signature.

# Attribute

```
Attribute(
    *args: Any,
    value: str | Expr | None = None,
    annotation: str | Expr | None = None,
    **kwargs: Any,
)

```

Bases: `Object`

```

              flowchart TD
              griffe.Attribute[Attribute]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Attribute
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Attribute href "" "griffe.Attribute"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

The class representing a Python module/class/instance attribute.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) – See griffe.Object.

- ## **`value`**

  (`str | Expr | None`, default: `None` ) – The attribute value, if any.

- ## **`annotation`**

  (`str | Expr | None`, default: `None` ) – The attribute annotation, if any.

- ## **`**kwargs`**

  (`Any`, default: `{}` ) – See griffe.Object.

Methods:

- **`__bool__`** – An object is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The number of members in this object, recursively.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this attribute's data as a dictionary.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`set_member`** – Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`annotation`** (`str | Expr | None`) – The attribute type annotation.
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`deleter`** (`Function | None`) – The deleter linked to this property.
- **`deprecated`** (`bool | str | None`) – Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The object docstring.
- **`endlineno`** (`int | None`) – The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) – Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) – The other objects imported by this object.
- **`inherited`** (`bool`) – Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always false for objects.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for objects.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this object is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this object is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** – The object kind.
- **`labels`** (`set[str]`) – The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to this object or its parents.
- **`name`** (`str`) – The object name.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) – The parent of the object (none if top module).
- **`path`** (`str`) – The dotted path of this object.
- **`public`** (`bool | None`) – Whether this object is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) – Whether this object is available at runtime.
- **`setter`** (`Function | None`) – The setter linked to this property.
- **`source`** (`str`) – The source code of this object.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The object type parameters.
- **`value`** (`str | Expr | None`) – The attribute value.

## aliases

```
aliases: dict[str, Alias] = {}

```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## annotation

```
annotation: str | Expr | None = annotation

```

The attribute type annotation.

## attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## deleter

```
deleter: Function | None = None

```

The deleter linked to this property.

## deprecated

```
deprecated: bool | str | None = None

```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring

```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]

```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')

```

## functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## has_docstring

```
has_docstring: bool

```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool

```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}

```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## inherited

```
inherited: bool = False

```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False

```

Always false for objects.

## is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False

```

Always false for objects.

## is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

## is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool

```

Whether this object is generic.

## is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

## is_init_module

```
is_init_module: bool

```

Whether this object is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool

```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool

```

Whether this object is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool

```

Whether this object is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

## kind

```
kind = ATTRIBUTE

```

The object kind.

## labels

```
labels: set[str] = set()

```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno

```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}

```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module

```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))

```

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## name

```
name: str = name

```

The object name.

## package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))

```

## parent

```
parent: Module | Class | None = parent

```

The parent of the object (none if top module).

## path

```
path: str

```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'

```

## public

```
public: bool | None = None

```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## runtime

```
runtime: bool = runtime

```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## setter

```
setter: Function | None = None

```

The setter linked to this property.

## source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

## type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)

```

The object type parameters.

## value

```
value: str | Expr | None = value

```

The attribute value.

## __bool__

```
__bool__() -> bool

```

An object is always true-ish.

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

## __len__

```
__len__() -> int

```

The number of members in this object, recursively.

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this attribute's data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

## del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) – JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

## get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

## has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

## resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

# Class

```
Class(
    *args: Any,
    bases: Sequence[Expr | str] | None = None,
    decorators: list[Decorator] | None = None,
    **kwargs: Any,
)

```

Bases: `Object`

```

              flowchart TD
              griffe.Class[Class]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Class
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Class href "" "griffe.Class"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

The class representing a Python class.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) – See griffe.Object.

- ## **`bases`**

  (`Sequence[Expr | str] | None`, default: `None` ) – The list of base classes, if any.

- ## **`decorators`**

  (`list[Decorator] | None`, default: `None` ) – The class decorators, if any.

- ## **`**kwargs`**

  (`Any`, default: `{}` ) – See griffe.Object.

Methods:

- **`__bool__`** – An object is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The number of members in this object, recursively.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this class' data as a dictionary.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`mro`** – Return a list of classes in order corresponding to Python's MRO.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`set_member`** – Set a member with its name or path.
- **`signature`** – Construct the class signature.

Attributes:

- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`bases`** (`list[Expr | str]`) – The class bases.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`decorators`** (`list[Decorator]`) – The class decorators.
- **`deprecated`** (`bool | str | None`) – Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The object docstring.
- **`endlineno`** (`int | None`) – The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) – Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) – The other objects imported by this object.
- **`inherited`** (`bool`) – Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always false for objects.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for objects.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this object is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this object is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** – The object kind.
- **`labels`** (`set[str]`) – The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to this object or its parents.
- **`name`** (`str`) – The object name.
- **`overloads`** (`dict[str, list[Function]]`) – The overloaded signatures declared in this class.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parameters`** (`Parameters`) – The parameters of this class' __init__ method, if any.
- **`parent`** (`Module | Class | None`) – The parent of the object (none if top module).
- **`path`** (`str`) – The dotted path of this object.
- **`public`** (`bool | None`) – Whether this object is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`resolved_bases`** (`list[Object]`) – Resolved class bases.
- **`runtime`** (`bool`) – Whether this object is available at runtime.
- **`source`** (`str`) – The source code of this object.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The object type parameters.

## aliases

```
aliases: dict[str, Alias] = {}

```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## bases

```
bases: list[Expr | str] = list(bases) if bases else []

```

The class bases.

See also: resolved_bases, mro.

## canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## decorators

```
decorators: list[Decorator] = decorators or []

```

The class decorators.

## deprecated

```
deprecated: bool | str | None = None

```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring

```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]

```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')

```

## functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## has_docstring

```
has_docstring: bool

```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool

```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}

```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## inherited

```
inherited: bool = False

```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False

```

Always false for objects.

## is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False

```

Always false for objects.

## is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

## is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool

```

Whether this object is generic.

## is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

## is_init_module

```
is_init_module: bool

```

Whether this object is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool

```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool

```

Whether this object is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool

```

Whether this object is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

## kind

```
kind = CLASS

```

The object kind.

## labels

```
labels: set[str] = set()

```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno

```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}

```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module

```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))

```

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## name

```
name: str = name

```

The object name.

## overloads

```
overloads: dict[str, list[Function]] = defaultdict(list)

```

The overloaded signatures declared in this class.

## package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))

```

## parameters

```
parameters: Parameters

```

The parameters of this class' `__init__` method, if any.

This property fetches inherited members, and therefore is part of the consumer API: do not use when producing Griffe trees!

## parent

```
parent: Module | Class | None = parent

```

The parent of the object (none if top module).

## path

```
path: str

```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'

```

## public

```
public: bool | None = None

```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## resolved_bases

```
resolved_bases: list[Object]

```

Resolved class bases.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: bases, mro.

## runtime

```
runtime: bool = runtime

```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

## type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)

```

The object type parameters.

## __bool__

```
__bool__() -> bool

```

An object is always true-ish.

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

## __len__

```
__len__() -> int

```

The number of members in this object, recursively.

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this class' data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

## del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) – JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

## get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

## has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

## mro

```
mro() -> list[Class]

```

Return a list of classes in order corresponding to Python's MRO.

See also: bases, resolved_bases.

## resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## signature

```
signature(
    *, return_type: bool = False, name: str | None = None
) -> str

```

Construct the class signature.

Parameters:

- ### **`return_type`**

  (`bool`, default: `False` ) – Whether to include the return type in the signature.

- ### **`name`**

  (`str | None`, default: `None` ) – The name of the class to use in the signature.

Returns:

- `str` – A string representation of the class signature.

## **Utilities**

## c3linear_merge

```
c3linear_merge(*lists: list[_T]) -> list[_T]

```

Merge lists of lists in the order defined by the C3Linear algorithm.

Parameters:

- ### **`*lists`**

  (`list[_T]`, default: `()` ) – Lists of items.

Returns:

- `list[_T]` – The merged list of items.

# Function

```
Function(
    *args: Any,
    parameters: Parameters | None = None,
    returns: str | Expr | None = None,
    decorators: list[Decorator] | None = None,
    **kwargs: Any,
)

```

Bases: `Object`

```

              flowchart TD
              griffe.Function[Function]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Function
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Function href "" "griffe.Function"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

The class representing a Python function.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) – See griffe.Object.

- ## **`parameters`**

  (`Parameters | None`, default: `None` ) – The function parameters.

- ## **`returns`**

  (`str | Expr | None`, default: `None` ) – The function return annotation.

- ## **`decorators`**

  (`list[Decorator] | None`, default: `None` ) – The function decorators, if any.

- ## **`**kwargs`**

  (`Any`, default: `{}` ) – See griffe.Object.

Methods:

- **`__bool__`** – An object is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The number of members in this object, recursively.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this function's data as a dictionary.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`set_member`** – Set a member with its name or path.
- **`signature`** – Construct the function signature.

Attributes:

- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`annotation`** (`str | Expr | None`) – The type annotation of the returned value.
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`decorators`** (`list[Decorator]`) – The function decorators.
- **`deprecated`** (`bool | str | None`) – Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The object docstring.
- **`endlineno`** (`int | None`) – The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) – Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) – The other objects imported by this object.
- **`inherited`** (`bool`) – Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always false for objects.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for objects.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this object is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this object is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** – The object kind.
- **`labels`** (`set[str]`) – The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to this object or its parents.
- **`name`** (`str`) – The object name.
- **`overloads`** (`list[Function] | None`) – The overloaded signatures of this function.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parameters`** (`Parameters`) – The function parameters.
- **`parent`** (`Module | Class | None`) – The parent of the object (none if top module).
- **`path`** (`str`) – The dotted path of this object.
- **`public`** (`bool | None`) – Whether this object is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`returns`** (`str | Expr | None`) – The function return type annotation.
- **`runtime`** (`bool`) – Whether this object is available at runtime.
- **`source`** (`str`) – The source code of this object.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The object type parameters.

## aliases

```
aliases: dict[str, Alias] = {}

```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## annotation

```
annotation: str | Expr | None

```

The type annotation of the returned value.

## attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## decorators

```
decorators: list[Decorator] = decorators or []

```

The function decorators.

## deprecated

```
deprecated: bool | str | None = None

```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring

```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]

```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')

```

## functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## has_docstring

```
has_docstring: bool

```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool

```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}

```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## inherited

```
inherited: bool = False

```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False

```

Always false for objects.

## is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False

```

Always false for objects.

## is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

## is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool

```

Whether this object is generic.

## is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

## is_init_module

```
is_init_module: bool

```

Whether this object is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool

```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool

```

Whether this object is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool

```

Whether this object is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

## kind

```
kind = FUNCTION

```

The object kind.

## labels

```
labels: set[str] = set()

```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno

```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}

```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module

```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))

```

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## name

```
name: str = name

```

The object name.

## overloads

```
overloads: list[Function] | None = None

```

The overloaded signatures of this function.

## package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))

```

## parameters

```
parameters: Parameters = parameters or Parameters()

```

The function parameters.

## parent

```
parent: Module | Class | None = parent

```

The parent of the object (none if top module).

## path

```
path: str

```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'

```

## public

```
public: bool | None = None

```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## returns

```
returns: str | Expr | None = returns

```

The function return type annotation.

## runtime

```
runtime: bool = runtime

```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

## type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)

```

The object type parameters.

## __bool__

```
__bool__() -> bool

```

An object is always true-ish.

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

## __len__

```
__len__() -> int

```

The number of members in this object, recursively.

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this function's data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

## del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) – JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

## get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

## has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

## resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

## signature

```
signature(
    *, return_type: bool = True, name: str | None = None
) -> str

```

Construct the function signature.

Parameters:

- ### **`return_type`**

  (`bool`, default: `True` ) – Whether to include the return type in the signature.

- ### **`name`**

  (`str | None`, default: `None` ) – The name of the function to use in the signature.

Returns:

- `str` – A string representation of the function signature.

## Parameters

```
Parameters(*parameters: Parameter)

```

This class is a container for parameters.

It allows to get parameters using their position (index) or their name:

```
>>> parameters = Parameters(Parameter("hello"))
>>> parameters[0] is parameters["hello"]
True

```

See also: Parameter.

Parameters:

- ### **`*parameters`**

  (`Parameter`, default: `()` ) – The initial parameters to add to the container.

Methods:

- **`__contains__`** – Whether a parameter with the given name is present.
- **`__delitem__`** – Delete a parameter by index or name.
- **`__getitem__`** – Get a parameter by index or name.
- **`__iter__`** – Iterate over the parameters, in order.
- **`__len__`** – The number of parameters.
- **`__setitem__`** – Set a parameter by index or name.
- **`add`** – Add a parameter to the container.

### __contains__

```
__contains__(param_name: str)

```

Whether a parameter with the given name is present.

### __delitem__

```
__delitem__(name_or_index: int | str) -> None

```

Delete a parameter by index or name.

### __getitem__

```
__getitem__(name_or_index: int | str) -> Parameter

```

Get a parameter by index or name.

### __iter__

```
__iter__()

```

Iterate over the parameters, in order.

### __len__

```
__len__()

```

The number of parameters.

### __setitem__

```
__setitem__(
    name_or_index: int | str, parameter: Parameter
) -> None

```

Set a parameter by index or name.

### add

```
add(parameter: Parameter) -> None

```

Add a parameter to the container.

Parameters:

- #### **`parameter`**

  (`Parameter`) – The function parameter to add.

Raises:

- `ValueError` – When a parameter with the same name is already present.

## Parameter

```
Parameter(
    name: str,
    *,
    annotation: str | Expr | None = None,
    kind: ParameterKind | None = None,
    default: str | Expr | None = None,
    docstring: Docstring | None = None,
)

```

This class represent a function parameter.

See also: Parameters.

Parameters:

- ### **`name`**

  (`str`) – The parameter name, without leading stars (\* or \*\*).

- ### **`annotation`**

  (`str | Expr | None`, default: `None` ) – The parameter annotation, if any.

- ### **`kind`**

  (`ParameterKind | None`, default: `None` ) – The parameter kind.

- ### **`default`**

  (`str | Expr | None`, default: `None` ) – The parameter default, if any.

- ### **`docstring`**

  (`Docstring | None`, default: `None` ) – The parameter docstring.

Methods:

- **`__eq__`** – Parameters are equal if all their attributes except docstring and function are equal.
- **`as_dict`** – Return this parameter's data as a dictionary.

Attributes:

- **`annotation`** (`str | Expr | None`) – The parameter type annotation.
- **`default`** (`str | Expr | None`) – The parameter default value.
- **`docstring`** (`Docstring | None`) – The parameter docstring.
- **`function`** (`Function | None`) – The parent function of the parameter.
- **`kind`** (`ParameterKind | None`) – The parameter kind.
- **`name`** (`str`) – The parameter name.
- **`required`** (`bool`) – Whether this parameter is required.

### annotation

```
annotation: str | Expr | None = annotation

```

The parameter type annotation.

### default

```
default: str | Expr | None = default

```

The parameter default value.

### docstring

```
docstring: Docstring | None = docstring

```

The parameter docstring.

### function

```
function: Function | None = None

```

The parent function of the parameter.

### kind

```
kind: ParameterKind | None = kind

```

The parameter kind.

### name

```
name: str = name

```

The parameter name.

### required

```
required: bool

```

Whether this parameter is required.

### __eq__

```
__eq__(value: object) -> bool

```

Parameters are equal if all their attributes except `docstring` and `function` are equal.

### as_dict

```
as_dict(
    *, full: bool = False, **kwargs: Any
) -> dict[str, Any]

```

Return this parameter's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## ParameterKind

Bases: `str`, `Enum`

```

              flowchart TD
              griffe.ParameterKind[ParameterKind]

              

              click griffe.ParameterKind href "" "griffe.ParameterKind"
            
```

Enumeration of the different parameter kinds.

Attributes:

- **`keyword_only`** – Keyword-only parameter.
- **`positional_only`** – Positional-only parameter.
- **`positional_or_keyword`** – Positional or keyword parameter.
- **`var_keyword`** – Variadic keyword parameter.
- **`var_positional`** – Variadic positional parameter.

### keyword_only

```
keyword_only = 'keyword-only'

```

Keyword-only parameter.

### positional_only

```
positional_only = 'positional-only'

```

Positional-only parameter.

### positional_or_keyword

```
positional_or_keyword = 'positional or keyword'

```

Positional or keyword parameter.

### var_keyword

```
var_keyword = 'variadic keyword'

```

Variadic keyword parameter.

### var_positional

```
var_positional = 'variadic positional'

```

Variadic positional parameter.

## ParametersType

```
ParametersType = list[
    tuple[
        str,
        Optional[AST],
        ParameterKind,
        Optional[Union[str, AST]],
    ]
]

```

Type alias for the list of parameters of a function.

## Decorator

```
Decorator(
    value: str | Expr,
    *,
    lineno: int | None,
    endlineno: int | None,
)

```

This class represents decorators.

Parameters:

- ### **`value`**

  (`str | Expr`) – The decorator code.

- ### **`lineno`**

  (`int | None`) – The starting line number.

- ### **`endlineno`**

  (`int | None`) – The ending line number.

Methods:

- **`as_dict`** – Return this decorator's data as a dictionary.

Attributes:

- **`callable_path`** (`str`) – The path of the callable used as decorator.
- **`endlineno`** (`int | None`) – The ending line number of the decorator.
- **`lineno`** (`int | None`) – The starting line number of the decorator.
- **`value`** (`str | Expr`) – The decorator value (as a Griffe expression or string).

### callable_path

```
callable_path: str

```

The path of the callable used as decorator.

### endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the decorator.

### lineno

```
lineno: int | None = lineno

```

The starting line number of the decorator.

### value

```
value: str | Expr = value

```

The decorator value (as a Griffe expression or string).

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this decorator's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

# Module

```
Module(
    *args: Any,
    filepath: Path | list[Path] | None = None,
    **kwargs: Any,
)

```

Bases: `Object`

```

              flowchart TD
              griffe.Module[Module]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.Module
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.Module href "" "griffe.Module"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

The class representing a Python module.

Parameters:

- ## **`*args`**

  (`Any`, default: `()` ) – See griffe.Object.

- ## **`filepath`**

  (`Path | list[Path] | None`, default: `None` ) – The module file path (directory for namespace [sub]packages, none for builtin modules).

- ## **`**kwargs`**

  (`Any`, default: `{}` ) – See griffe.Object.

Methods:

- **`__bool__`** – An object is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The number of members in this object, recursively.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this module's data as a dictionary.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`set_member`** – Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`deprecated`** (`bool | str | None`) – Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The object docstring.
- **`endlineno`** (`int | None`) – The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path of this module.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) – Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) – The other objects imported by this object.
- **`imports_future_annotations`** (`bool`) – Whether this module import future annotations.
- **`inherited`** (`bool`) – Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always false for objects.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for objects.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this module is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this module is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this module is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this module is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this module is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** – The object kind.
- **`labels`** (`set[str]`) – The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to this object or its parents.
- **`name`** (`str`) – The object name.
- **`overloads`** (`dict[str, list[Function]]`) – The overloaded signatures declared in this module.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) – The parent of the object (none if top module).
- **`path`** (`str`) – The dotted path of this object.
- **`public`** (`bool | None`) – Whether this object is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) – Whether this object is available at runtime.
- **`source`** (`str`) – The source code of this object.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The object type parameters.

## aliases

```
aliases: dict[str, Alias] = {}

```

The aliases pointing to this object.

## all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

## attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

## canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

## classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

## deprecated

```
deprecated: bool | str | None = None

```

Whether this object is deprecated (boolean or deprecation message).

## docstring

```
docstring: Docstring | None = docstring

```

The object docstring.

See also: has_docstring, has_docstrings.

## endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the object.

See also: lineno.

## exports

```
exports: list[str | ExprName] | None = None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

## extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

## filepath

```
filepath: Path | list[Path]

```

The file path of this module.

Raises:

- `BuiltinModuleError` – When the instance filepath is None.

## functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

## has_docstring

```
has_docstring: bool

```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

## has_docstrings

```
has_docstrings: bool

```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

## imports

```
imports: dict[str, str] = {}

```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

## imports_future_annotations

```
imports_future_annotations: bool

```

Whether this module import future annotations.

## inherited

```
inherited: bool = False

```

Always false for objects.

Only aliases can be marked as inherited.

## inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

## is_alias

```
is_alias: bool = False

```

Always false for objects.

## is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

## is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

## is_collection

```
is_collection: bool = False

```

Always false for objects.

## is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

## is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

## is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

## is_generic

```
is_generic: bool

```

Whether this object is generic.

## is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

## is_init_module

```
is_init_module: bool

```

Whether this module is an `__init__.py` module.

See also: is_module.

## is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

## is_namespace_package

```
is_namespace_package: bool

```

Whether this module is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

## is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this module is a namespace subpackage.

See also: is_namespace_package.

## is_package

```
is_package: bool

```

Whether this module is a package (top module).

See also: is_subpackage.

## is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

## is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

## is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

## is_subpackage

```
is_subpackage: bool

```

Whether this module is a subpackage.

See also: is_package.

## is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

## is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

## kind

```
kind = MODULE

```

The object kind.

## labels

```
labels: set[str] = set()

```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

## lineno

```
lineno: int | None = lineno

```

The starting line number of the object.

See also: endlineno.

## lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: lines_collection, source.

## lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## members

```
members: dict[str, Object | Alias] = {}

```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

## module

```
module: Module

```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))

```

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

## modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

## modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

## name

```
name: str = name

```

The object name.

## overloads

```
overloads: dict[str, list[Function]] = defaultdict(list)

```

The overloaded signatures declared in this module.

## package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))

```

## parent

```
parent: Module | Class | None = parent

```

The parent of the object (none if top module).

## path

```
path: str

```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'

```

## public

```
public: bool | None = None

```

Whether this object is public.

## relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

## runtime

```
runtime: bool = runtime

```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

## source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

## type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

## type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)

```

The object type parameters.

## __bool__

```
__bool__() -> bool

```

An object is always true-ish.

## __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

## __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

## __len__

```
__len__() -> int

```

The number of members in this object, recursively.

## __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

## as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this module's data as a dictionary.

See also: as_json.

Parameters:

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

## as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- ### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

## del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

## filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members.

Parameters:

- ### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

## from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- ### **`json_string`**

  (`str`) – JSON to decode into Object.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

## get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

## has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- ### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

## is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- ### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

## resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- ### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

## set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- ### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- ### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```

# Type Alias

## TypeAlias

```
TypeAlias(
    *args: Any,
    value: str | Expr | None = None,
    **kwargs: Any,
)

```

Bases: `Object`

```

              flowchart TD
              griffe.TypeAlias[TypeAlias]
              griffe._internal.models.Object[Object]
              griffe._internal.mixins.ObjectAliasMixin[ObjectAliasMixin]
              griffe._internal.mixins.GetMembersMixin[GetMembersMixin]
              griffe._internal.mixins.SetMembersMixin[SetMembersMixin]
              griffe._internal.mixins.DelMembersMixin[DelMembersMixin]
              griffe._internal.mixins.SerializationMixin[SerializationMixin]

                              griffe._internal.models.Object --> griffe.TypeAlias
                                griffe._internal.mixins.ObjectAliasMixin --> griffe._internal.models.Object
                                griffe._internal.mixins.GetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SetMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.DelMembersMixin --> griffe._internal.mixins.ObjectAliasMixin
                
                griffe._internal.mixins.SerializationMixin --> griffe._internal.mixins.ObjectAliasMixin
                




              click griffe.TypeAlias href "" "griffe.TypeAlias"
              click griffe._internal.models.Object href "" "griffe._internal.models.Object"
              click griffe._internal.mixins.ObjectAliasMixin href "" "griffe._internal.mixins.ObjectAliasMixin"
              click griffe._internal.mixins.GetMembersMixin href "" "griffe._internal.mixins.GetMembersMixin"
              click griffe._internal.mixins.SetMembersMixin href "" "griffe._internal.mixins.SetMembersMixin"
              click griffe._internal.mixins.DelMembersMixin href "" "griffe._internal.mixins.DelMembersMixin"
              click griffe._internal.mixins.SerializationMixin href "" "griffe._internal.mixins.SerializationMixin"
            
```

The class representing a Python type alias.

Parameters:

- ### **`*args`**

  (`Any`, default: `()` ) – See griffe.Object.

- ### **`value`**

  (`str | Expr | None`, default: `None` ) – The type alias value.

- ### **`**kwargs`**

  (`Any`, default: `{}` ) – See griffe.Object.

Methods:

- **`__bool__`** – An object is always true-ish.
- **`__delitem__`** – Delete a member with its name or path.
- **`__getitem__`** – Get a member with its name or path.
- **`__len__`** – The number of members in this object, recursively.
- **`__setitem__`** – Set a member with its name or path.
- **`as_dict`** – Return this type alias's data as a dictionary.
- **`as_json`** – Return this object's data as a JSON string.
- **`del_member`** – Delete a member with its name or path.
- **`filter_members`** – Filter and return members based on predicates.
- **`from_json`** – Create an instance of this class from a JSON string.
- **`get_member`** – Get a member with its name or path.
- **`has_labels`** – Tell if this object has all the given labels.
- **`is_kind`** – Tell if this object is of the given kind.
- **`resolve`** – Resolve a name within this object's and parents' scope.
- **`set_member`** – Set a member with its name or path.

Attributes:

- **`aliases`** (`dict[str, Alias]`) – The aliases pointing to this object.
- **`all_members`** (`dict[str, Object | Alias]`) – All members (declared and inherited).
- **`attributes`** (`dict[str, Attribute]`) – The attribute members.
- **`canonical_path`** (`str`) – The full dotted path of this object.
- **`classes`** (`dict[str, Class]`) – The class members.
- **`deprecated`** (`bool | str | None`) – Whether this object is deprecated (boolean or deprecation message).
- **`docstring`** (`Docstring | None`) – The object docstring.
- **`endlineno`** (`int | None`) – The ending line number of the object.
- **`exports`** (`list[str | ExprName] | None`) – The names of the objects exported by this (module) object through the __all__ variable.
- **`extra`** (`dict[str, dict[str, Any]]`) – Namespaced dictionaries storing extra metadata for this object, used by extensions.
- **`filepath`** (`Path | list[Path]`) – The file path (or directory list for namespace packages) where this object was defined.
- **`functions`** (`dict[str, Function]`) – The function members.
- **`has_docstring`** (`bool`) – Whether this object has a docstring (empty or not).
- **`has_docstrings`** (`bool`) – Whether this object or any of its members has a docstring (empty or not).
- **`imports`** (`dict[str, str]`) – The other objects imported by this object.
- **`inherited`** (`bool`) – Always false for objects.
- **`inherited_members`** (`dict[str, Alias]`) – Members that are inherited from base classes.
- **`is_alias`** (`bool`) – Always false for objects.
- **`is_attribute`** (`bool`) – Whether this object is an attribute.
- **`is_class`** (`bool`) – Whether this object is a class.
- **`is_class_private`** (`bool`) – Whether this object/alias is class-private (starts with \_\_ and is a class member).
- **`is_collection`** (`bool`) – Always false for objects.
- **`is_deprecated`** (`bool`) – Whether this object is deprecated.
- **`is_exported`** (`bool`) – Whether this object/alias is exported (listed in __all__).
- **`is_function`** (`bool`) – Whether this object is a function.
- **`is_generic`** (`bool`) – Whether this object is generic.
- **`is_imported`** (`bool`) – Whether this object/alias was imported from another module.
- **`is_init_module`** (`bool`) – Whether this object is an __init__.py module.
- **`is_module`** (`bool`) – Whether this object is a module.
- **`is_namespace_package`** (`bool`) – Whether this object is a namespace package (top folder, no __init__.py).
- **`is_namespace_subpackage`** (`bool`) – Whether this object is a namespace subpackage.
- **`is_package`** (`bool`) – Whether this object is a package (top module).
- **`is_private`** (`bool`) – Whether this object/alias is private (starts with \_) but not special.
- **`is_public`** (`bool`) – Whether this object is considered public.
- **`is_special`** (`bool`) – Whether this object/alias is special ("dunder" attribute/method, starts and end with \_\_).
- **`is_subpackage`** (`bool`) – Whether this object is a subpackage.
- **`is_type_alias`** (`bool`) – Whether this object is a type alias.
- **`is_wildcard_exposed`** (`bool`) – Whether this object/alias is exposed to wildcard imports.
- **`kind`** – The object kind.
- **`labels`** (`set[str]`) – The object labels (property, dataclass, etc.).
- **`lineno`** (`int | None`) – The starting line number of the object.
- **`lines`** (`list[str]`) – The lines containing the source of this object.
- **`lines_collection`** (`LinesCollection`) – The lines collection attached to this object or its parents.
- **`members`** (`dict[str, Object | Alias]`) – The object members (modules, classes, functions, attributes, type aliases).
- **`module`** (`Module`) – The parent module of this object.
- **`modules`** (`dict[str, Module]`) – The module members.
- **`modules_collection`** (`ModulesCollection`) – The modules collection attached to this object or its parents.
- **`name`** (`str`) – The object name.
- **`package`** (`Module`) – The absolute top module (the package) of this object.
- **`parent`** (`Module | Class | None`) – The parent of the object (none if top module).
- **`path`** (`str`) – The dotted path of this object.
- **`public`** (`bool | None`) – Whether this object is public.
- **`relative_filepath`** (`Path`) – The file path where this object was defined, relative to the current working directory.
- **`relative_package_filepath`** (`Path`) – The file path where this object was defined, relative to the top module path.
- **`runtime`** (`bool`) – Whether this object is available at runtime.
- **`source`** (`str`) – The source code of this object.
- **`type_aliases`** (`dict[str, TypeAlias]`) – The type alias members.
- **`type_parameters`** (`TypeParameters`) – The object type parameters.
- **`value`** (`str | Expr | None`) – The type alias value.

### aliases

```
aliases: dict[str, Alias] = {}

```

The aliases pointing to this object.

### all_members

```
all_members: dict[str, Object | Alias]

```

All members (declared and inherited).

This method is part of the consumer API: do not use when producing Griffe trees!

### attributes

```
attributes: dict[str, Attribute]

```

The attribute members.

This method is part of the consumer API: do not use when producing Griffe trees!

### canonical_path

```
canonical_path: str

```

The full dotted path of this object.

The canonical path is the path where the object was defined (not imported).

See also: path.

### classes

```
classes: dict[str, Class]

```

The class members.

This method is part of the consumer API: do not use when producing Griffe trees!

### deprecated

```
deprecated: bool | str | None = None

```

Whether this object is deprecated (boolean or deprecation message).

### docstring

```
docstring: Docstring | None = docstring

```

The object docstring.

See also: has_docstring, has_docstrings.

### endlineno

```
endlineno: int | None = endlineno

```

The ending line number of the object.

See also: lineno.

### exports

```
exports: list[str | ExprName] | None = None

```

The names of the objects exported by this (module) object through the `__all__` variable.

Exports can contain string (object names) or resolvable names, like other lists of exports coming from submodules:

```
from .submodule import __all__ as submodule_all

__all__ = ["hello", *submodule_all]

```

Exports get expanded by the loader before it expands wildcards and resolves aliases.

See also: GriffeLoader.expand_exports.

### extra

```
extra: dict[str, dict[str, Any]] = defaultdict(dict)

```

Namespaced dictionaries storing extra metadata for this object, used by extensions.

### filepath

```
filepath: Path | list[Path]

```

The file path (or directory list for namespace packages) where this object was defined.

See also: relative_filepath, relative_package_filepath.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown.filepath
PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py')

```

### functions

```
functions: dict[str, Function]

```

The function members.

This method is part of the consumer API: do not use when producing Griffe trees!

### has_docstring

```
has_docstring: bool

```

Whether this object has a docstring (empty or not).

See also: docstring, has_docstrings.

### has_docstrings

```
has_docstrings: bool

```

Whether this object or any of its members has a docstring (empty or not).

Inherited members are not considered. Imported members are not considered, unless they are also public.

See also: docstring, has_docstring.

### imports

```
imports: dict[str, str] = {}

```

The other objects imported by this object.

Keys are the names within the object (`from ... import ... as AS_NAME`), while the values are the actual names of the objects (`from ... import REAL_NAME as ...`).

### inherited

```
inherited: bool = False

```

Always false for objects.

Only aliases can be marked as inherited.

### inherited_members

```
inherited_members: dict[str, Alias]

```

Members that are inherited from base classes.

This method is part of the consumer API: do not use when producing Griffe trees!

See also: members.

### is_alias

```
is_alias: bool = False

```

Always false for objects.

### is_attribute

```
is_attribute: bool

```

Whether this object is an attribute.

See also: is_module. is_class, is_function, is_type_alias, is_alias, is_kind.

### is_class

```
is_class: bool

```

Whether this object is a class.

See also: is_module. is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_class_private

```
is_class_private: bool

```

Whether this object/alias is class-private (starts with `__` and is a class member).

### is_collection

```
is_collection: bool = False

```

Always false for objects.

### is_deprecated

```
is_deprecated: bool

```

Whether this object is deprecated.

### is_exported

```
is_exported: bool

```

Whether this object/alias is exported (listed in `__all__`).

### is_function

```
is_function: bool

```

Whether this object is a function.

See also: is_module. is_class, is_attribute, is_type_alias, is_alias, is_kind.

### is_generic

```
is_generic: bool

```

Whether this object is generic.

### is_imported

```
is_imported: bool

```

Whether this object/alias was imported from another module.

### is_init_module

```
is_init_module: bool

```

Whether this object is an `__init__.py` module.

See also: is_module.

### is_module

```
is_module: bool

```

Whether this object is a module.

See also: is_init_module. is_class, is_function, is_attribute, is_type_alias, is_alias, is_kind.

### is_namespace_package

```
is_namespace_package: bool

```

Whether this object is a namespace package (top folder, no `__init__.py`).

See also: is_namespace_subpackage.

### is_namespace_subpackage

```
is_namespace_subpackage: bool

```

Whether this object is a namespace subpackage.

See also: is_namespace_package.

### is_package

```
is_package: bool

```

Whether this object is a package (top module).

See also: is_subpackage.

### is_private

```
is_private: bool

```

Whether this object/alias is private (starts with `_`) but not special.

### is_public

```
is_public: bool

```

Whether this object is considered public.

In modules, developers can mark objects as public thanks to the `__all__` variable. In classes however, there is no convention or standard to do so.

Therefore, to decide whether an object is public, we follow this algorithm:

- If the object's `public` attribute is set (boolean), return its value.
- If the object is listed in its parent's (a module) `__all__` attribute, it is public.
- If the parent (module) defines `__all__` and the object is not listed in, it is private.
- If the object has a private name, it is private.
- If the object was imported from another module, it is private.
- Otherwise, the object is public.

### is_special

```
is_special: bool

```

Whether this object/alias is special ("dunder" attribute/method, starts and end with `__`).

### is_subpackage

```
is_subpackage: bool

```

Whether this object is a subpackage.

See also: is_package.

### is_type_alias

```
is_type_alias: bool

```

Whether this object is a type alias.

See also: is_module. is_class, is_function, is_attribute, is_alias, is_kind.

### is_wildcard_exposed

```
is_wildcard_exposed: bool

```

Whether this object/alias is exposed to wildcard imports.

To be exposed to wildcard imports, an object/alias must:

- be available at runtime
- have a module as parent
- be listed in `__all__` if `__all__` is defined
- or not be private (having a name starting with an underscore)

Special case for Griffe trees: a submodule is only exposed if its parent imports it.

Returns:

- `bool` – True or False.

### kind

```
kind = TYPE_ALIAS

```

The object kind.

### labels

```
labels: set[str] = set()

```

The object labels (`property`, `dataclass`, etc.).

See also: has_labels.

### lineno

```
lineno: int | None = lineno

```

The starting line number of the object.

See also: endlineno.

### lines

```
lines: list[str]

```

The lines containing the source of this object.

See also: lines_collection, source.

### lines_collection

```
lines_collection: LinesCollection

```

The lines collection attached to this object or its parents.

See also: lines, source.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

### members

```
members: dict[str, Object | Alias] = {}

```

The object members (modules, classes, functions, attributes, type aliases).

See also: inherited_members, get_member, set_member, filter_members.

### module

```
module: Module

```

The parent module of this object.

See also: package.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))
>>> # The `module` of a module is itself.
>>> markdown["core"].module
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/core.py'))

```

Raises:

- `ValueError` – When the object is not a module and does not have a parent.

### modules

```
modules: dict[str, Module]

```

The module members.

This method is part of the consumer API: do not use when producing Griffe trees!

### modules_collection

```
modules_collection: ModulesCollection

```

The modules collection attached to this object or its parents.

Raises:

- `ValueError` – When no modules collection can be found in the object or its parents.

### name

```
name: str = name

```

The object name.

### package

```
package: Module

```

The absolute top module (the package) of this object.

See also: module.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].package
Module(PosixPath('~/project/.venv/lib/python3.11/site-packages/markdown/__init__.py'))

```

### parent

```
parent: Module | Class | None = parent

```

The parent of the object (none if top module).

### path

```
path: str

```

The dotted path of this object.

On regular objects (not aliases), the path is the canonical path.

See also: canonical_path.

Examples:

```
>>> import griffe
>>> markdown = griffe.load("markdown")
>>> markdown["core.Markdown.references"].path
'markdown.core.Markdown.references'

```

### public

```
public: bool | None = None

```

Whether this object is public.

### relative_filepath

```
relative_filepath: Path

```

The file path where this object was defined, relative to the current working directory.

If this object's file path is not relative to the current working directory, return its absolute path.

See also: filepath, relative_package_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

### relative_package_filepath

```
relative_package_filepath: Path

```

The file path where this object was defined, relative to the top module path.

See also: filepath, relative_filepath.

Raises:

- `ValueError` – When the relative path could not be computed.

### runtime

```
runtime: bool = runtime

```

Whether this object is available at runtime.

Typically, type-guarded objects (under an `if TYPE_CHECKING` condition) are not available at runtime.

### source

```
source: str

```

The source code of this object.

See also: lines, lines_collection.

### type_aliases

```
type_aliases: dict[str, TypeAlias]

```

The type alias members.

This method is part of the consumer API: do not use when producing Griffe trees!

### type_parameters

```
type_parameters: TypeParameters = (
    type_parameters or TypeParameters()
)

```

The object type parameters.

### value

```
value: str | Expr | None = value

```

The type alias value.

### __bool__

```
__bool__() -> bool

```

An object is always true-ish.

### __delitem__

```
__delitem__(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> del griffe_object["foo"]
>>> del griffe_object["path.to.bar"]
>>> del griffe_object[("path", "to", "qux")]

```

### __getitem__

```
__getitem__(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Members will be looked up in both declared members and inherited ones, triggering computation of the latter.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> qux = griffe_object[("path", "to", "qux")]

```

### __len__

```
__len__() -> int

```

The number of members in this object, recursively.

### __setitem__

```
__setitem__(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the consumer API: do not use when producing Griffe trees!

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object["foo"] = foo
>>> griffe_object["path.to.bar"] = bar
>>> griffe_object[("path", "to", "qux")] = qux

```

### as_dict

```
as_dict(**kwargs: Any) -> dict[str, Any]

```

Return this type alias's data as a dictionary.

Parameters:

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options.

Returns:

- `dict[str, Any]` – A dictionary.

### as_json

```
as_json(*, full: bool = False, **kwargs: Any) -> str

```

Return this object's data as a JSON string.

Parameters:

- #### **`full`**

  (`bool`, default: `False` ) – Whether to return full info, or just base info.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional serialization options passed to encoder.

Returns:

- `str` – A JSON string.

### del_member

```
del_member(key: str | Sequence[str]) -> None

```

Delete a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> griffe_object.del_member("foo")
>>> griffe_object.del_member("path.to.bar")
>>> griffe_object.del_member(("path", "to", "qux"))

```

### filter_members

```
filter_members(
    *predicates: Callable[[Object | Alias], bool],
) -> dict[str, Object | Alias]

```

Filter and return members based on predicates.

See also: members.

Parameters:

- #### **`*predicates`**

  (`Callable[[Object | Alias], bool]`, default: `()` ) – A list of predicates, i.e. callables accepting a member as argument and returning a boolean.

Returns:

- `dict[str, Object | Alias]` – A dictionary of members.

### from_json

```
from_json(json_string: str, **kwargs: Any) -> _ObjType

```

Create an instance of this class from a JSON string.

Parameters:

- #### **`json_string`**

  (`str`) – JSON to decode into Object.

- #### **`**kwargs`**

  (`Any`, default: `{}` ) – Additional options passed to decoder.

Returns:

- `_ObjType` – An Object instance.

Raises:

- `TypeError` – When the json_string does not represent and object of the class from which this classmethod has been called.

### get_member

```
get_member(key: str | Sequence[str]) -> Any

```

Get a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Members will be looked up in declared members only, not inherited ones.

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

Examples:

```
>>> foo = griffe_object["foo"]
>>> bar = griffe_object["path.to.bar"]
>>> bar = griffe_object[("path", "to", "bar")]

```

### has_labels

```
has_labels(*labels: str) -> bool

```

Tell if this object has all the given labels.

See also: labels.

Parameters:

- #### **`*labels`**

  (`str`, default: `()` ) – Labels that must be present.

Returns:

- `bool` – True or False.

### is_kind

```
is_kind(kind: str | Kind | set[str | Kind]) -> bool

```

Tell if this object is of the given kind.

See also: is_module, is_class, is_function, is_attribute, is_type_alias, is_alias.

Parameters:

- #### **`kind`**

  (`str | Kind | set[str | Kind]`) – An instance or set of kinds (strings or enumerations).

Raises:

- `ValueError` – When an empty set is given as argument.

Returns:

- `bool` – True or False.

### resolve

```
resolve(name: str) -> str

```

Resolve a name within this object's and parents' scope.

Parameters:

- #### **`name`**

  (`str`) – The name to resolve.

Raises:

- `NameResolutionError` – When the name could not be resolved.

Returns:

- `str` – The resolved name.

### set_member

```
set_member(
    key: str | Sequence[str], value: Object | Alias
) -> None

```

Set a member with its name or path.

This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).

Parameters:

- #### **`key`**

  (`str | Sequence[str]`) – The name or path of the member.

- #### **`value`**

  (`Object | Alias`) – The member.

Examples:

```
>>> griffe_object.set_member("foo", foo)
>>> griffe_object.set_member("path.to.bar", bar)
>>> griffe_object.set_member(("path", "to", "qux"), qux)

```
# Extensions

# Built-in extensions

Built-in extensions are maintained in Griffe's code base. They generally bring support for core features of the Python language or its standard library.

| Extension                     | Description              |
| ----------------------------- | ------------------------ |
| [`dataclasses`](dataclasses/) | Support for dataclasses. |

# `dataclasses`

The `dataclasses` extension adds support for dataclasses from the standard library. It works both statically and dynamically. When used statically, it re-creates the `__init__` methods and their signatures (as Griffe objects), that would otherwise be created at runtime. When used dynamically, it does nothing since `__init__` methods are created by the library and can be inspected normally.

**This extension is enabled by default.**

# Official extensions

Official extensions are developed and maintained within the mkdocstrings organization on GitHub, in separate repositories. They generally bring support for various third-party libraries or other documentation-related features that are part of Python's standard library.

| Extension                                               | Description                                                                                                                   | Sponsors only? |
| ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- | -------------- |
| [`autodocstringstyle`](autodocstringstyle/)             | Set docstring style to `auto` for external packages.                                                                          |                |
| [`inherited-docstrings`](inherited-docstrings/)         | Inherit docstrings from parent classes.                                                                                       |                |
| [`public-redundant-aliases`](public-redundant-aliases/) | Mark objects imported with redundant aliases as public.                                                                       |                |
| [`public-wildcard-imports`](public-wildcard-imports/)   | Mark wildcard imported objects as public.                                                                                     |                |
| [`pydantic`](pydantic/)                                 | Support for [Pydantic](https://docs.pydantic.dev/latest/) models.                                                             |                |
| [`runtime-objects`](runtime-objects/)                   | Access runtime objects corresponding to each loaded Griffe object through their `extra` attribute.                            |                |
| [`sphinx`](sphinx/)                                     | Parse [Sphinx](https://www.sphinx-doc.org/)-comments above attributes (`#:`) as docstrings.                                   |                |
| [`typing-doc`](typingdoc/)                              | Support for [PEP 727](https://peps.python.org/pep-0727/)'s typing.Doc, "Documentation in Annotated Metadata".                 |                |
| [`warnings-deprecated`](warnings-deprecated/)           | Support for [PEP 702](https://peps.python.org/pep-0702/)'s warnings.deprecated, "Marking deprecations using the type system". |                |

# `griffe-autodocstringstyle`

[Sponsors only](../../../insiders/)

- **PyPI**: [`griffe-autodocstringstyle`](https://pypi.org/project/griffe-autodocstringstyle/)
- **GitHub**: [mkdocstrings/griffe-autodocstringstyle](https://github.com/mkdocstrings/griffe-autodocstringstyle)
- **Documentation:** [mkdocstrings.github.io/griffe-autodocstringstyle](https://mkdocstrings.github.io/griffe-autodocstringstyle)
- **Extension name:** `griffe_autodocstringstyle`

______________________________________________________________________

This extension sets the docstring parser to `auto` for all the docstrings of external packages. Packages are considered "external" when their sources are found in a virtual environment instead of a folder under the current working directory. Setting their docstring style to `auto` is useful if you plan on rendering the docstring of these objects in your own documentation.

# `griffe-inherited-docstrings`

- **PyPI**: [`griffe-inherited-docstrings`](https://pypi.org/project/griffe-inherited-docstrings/)
- **GitHub**: [mkdocstrings/griffe-inherited-docstrings](https://github.com/mkdocstrings/griffe-inherited-docstrings)
- **Documentation:** [mkdocstrings.github.io/griffe-inherited-docstrings](https://mkdocstrings.github.io/griffe-inherited-docstrings)
- **Extension name:** `griffe_inherited_docstrings`

______________________________________________________________________

This extension, when enabled, iterates over the declared members of all classes found within a package, and if they don't have a docstring, but do have a parent member with a docstring, sets their docstring to that parent's docstring.

```
class Base:
    attr = "hello"
    """Hello."""

    def hello(self):
        """Hello again."""
        ...

class Derived(Base):
    attr = "bye"

    def hello(self):
        ...

```

In the example above, *without* the extension `Derived.attr` and `Derived.hello` have no docstrings, while *with* the extension they will have the `Base.attr` and `Base.hello` docstrings attached, respectively.

# `griffe-public-redundant-aliases`

[Sponsors only](../../../insiders/)

- **PyPI**: [`griffe-public-redundant-aliases`](https://pypi.org/project/griffe-public-redundant-aliases/)
- **GitHub**: [mkdocstrings/griffe-public-redundant-aliases](https://github.com/mkdocstrings/griffe-public-redundant-aliases)
- **Documentation:** [mkdocstrings.github.io/griffe-public-redundant-aliases](https://mkdocstrings.github.io/griffe-public-redundant-aliases)
- **Extension name:** `griffe_public_redundant_aliases`

______________________________________________________________________

This extension marks every object that was imported with a redundant alias as public. See our documentation on the [redundant aliases convention](../../../guide/users/recommendations/public-apis/#redundant-aliases).

# `griffe-public-wildcard-imports`

[Sponsors only](../../../insiders/)

- **PyPI**: [`griffe-public-wildcard-imports`](https://pypi.org/project/griffe-public-wildcard-imports/)
- **GitHub**: [mkdocstrings/griffe-public-wildcard-imports](https://github.com/mkdocstrings/griffe-public-wildcard-imports)
- **Documentation:** [mkdocstrings.github.io/griffe-public-wildcard-imports](https://mkdocstrings.github.io/griffe-public-wildcard-imports)
- **Extension name:** `griffe_public_wildcard_imports`

______________________________________________________________________

This extension marks every object that was imported with a wildcard import as public. See our documentation on the [wildcard imports convention](../../../guide/users/recommendations/public-apis/#wildcard-imports).

# `griffe-pydantic`

- **PyPI**: [`griffe-pydantic`](https://pypi.org/project/griffe-pydantic/)
- **GitHub**: [mkdocstrings/griffe-pydantic](https://github.com/mkdocstrings/griffe-pydantic)
- **Documentation:** [mkdocstrings.github.io/griffe-pydantic](https://mkdocstrings.github.io/griffe-pydantic)
- **Extension name:** `griffe_pydantic`

______________________________________________________________________

This extension adds support for [Pydantic](https://docs.pydantic.dev/latest/) models. It extracts useful information from them, stores this information into the `extra` attribute of objects, and binds custom mkdocstrings templates to the objects for better rendering. The extension works both statically and dynamically, and supports model inheritance.

# `griffe-runtime-objects`

[Sponsors only](../../../insiders/)

- **PyPI**: [`griffe-runtime-objects`](https://pypi.org/project/griffe-runtime-objects/)
- **GitHub**: [mkdocstrings/griffe-runtime-objects](https://github.com/mkdocstrings/griffe-runtime-objects)
- **Documentation:** [mkdocstrings.github.io/griffe-runtime-objects](https://mkdocstrings.github.io/griffe-runtime-objects)
- **Extension name:** `griffe_runtime_objects`

______________________________________________________________________

This extension stores runtime objects corresponding to each loaded Griffe object into its `extra` attribute, under the `runtime-objects` namespace.

```
>>> import griffe
>>> griffe_data = griffe.load("griffe", extensions=griffe.load_extensions("griffe_runtime_objects"), resolve_aliases=True)
>>> griffe_data["parse"].extra
defaultdict(<class 'dict'>, {'runtime-objects': {'object': <function parse at 0x78685c951260>}})
>>> griffe_data["Module"].extra
defaultdict(<class 'dict'>, {'runtime-objects': {'object': <class 'griffe._internal.models.Module'>}})

```

It can be useful in combination with mkdocstrings-python and custom templates, to iterate over object values or their attributes that couldn't be loaded by Griffe itself (for example, objects built dynamically and loaded as attributes won't have "members" to iterate over).

# `griffe-sphinx`

[Sponsors only](../../../insiders/)

- **PyPI**: [`griffe-sphinx`](https://pypi.org/project/griffe-sphinx/)
- **GitHub**: [mkdocstrings/griffe-sphinx](https://github.com/mkdocstrings/griffe-sphinx)
- **Documentation:** [mkdocstrings.github.io/griffe-sphinx](https://mkdocstrings.github.io/griffe-sphinx)
- **Extension name:** `griffe_sphinx`

______________________________________________________________________

This extension reads Sphinx comments placed above attribute assignments and uses them as docstrings.

```
#: Summary of `module_attr`. 
module_attr = "hello"


class Hello:
    #: Summary of `class_attr`.
    #:
    #: Description of the class attribute.
    #: *Markup* and [cross-references][] are __supported__,
    #: just like in regular docstrings.
    class_attr = "hello"

    def __init__(self):
        #: Summary of `instance_attr`.
        self.instance_attr = "hello"

```

Comments are treated exactly like regular docstrings: they are "cleaned" (dedented and stripped of leading and trailing newlines) and can contain any markup you want, be it Markdown, rST, AsciiDoc, etc.

Trailing comments are not supported:

```
module_attr  #: This is not supported.

```

# `griffe-typingdoc`

- **PyPI**: [`griffe-typingdoc`](https://pypi.org/project/griffe-typingdoc/)
- **GitHub**: [mkdocstrings/griffe-typingdoc](https://github.com/mkdocstrings/griffe-typingdoc)
- **Documentation:** [mkdocstrings.github.io/griffe-typingdoc](https://mkdocstrings.github.io/griffe-typingdoc)
- **Extension name:** `griffe_typingdoc`

______________________________________________________________________

This extension reads docstrings for parameters, return values and more from type annotations using Annotated and the Doc class suggested in [PEP 727](https://peps.python.org/pep-0727/). Documenting parameters and return values this way makes it possible to completely avoid relying on a particular "docstring style" (Google, Numpydoc, Sphinx, etc.) and just use plain markup in module/classes/function docstrings. Docstrings therefore do not have to be parsed at all.

```
from typing import Annotated as An
from typing_extensions import Doc


def function(
    param1: An[int, Doc("Some integer value.")],
    param2: An[
        str,
        Doc(
            """
            Summary of the parameter.

            Multi-line docstrings can be used, as usual.
            Any **markup** is supported, as usual.
            """
        )
    ]
) -> An[bool, Doc("Whether you like PEP 727.")]:
    """Summary of the function.

    No more "Args", "Parameters" or "Returns" sections.
    Just plain markup.
    """
    ...

```

PEP 727 is likely to be withdrawn or rejected, but the `Doc` class will remain in `typing_extensions`, [as told by Jelle Zijlstra](https://discuss.python.org/t/pep-727-documentation-metadata-in-typing/32566/183):

> We’ll probably keep it in `typing_extensions` indefinitely even if the PEP gets withdrawn or rejected, for backwards compatibility reasons.
>
> You are free to use it in your own code using the typing-extensions version. If usage of `typing_extensions.Doc` becomes widespread, that will be a good argument for accepting the PEP and putting it in the standard library.

# `griffe-warnings-deprecated`

- **PyPI**: [`griffe-warnings-deprecated`](https://pypi.org/project/griffe-warnings-deprecated/)
- **GitHub**: [mkdocstrings/griffe-warnings-deprecated](https://github.com/mkdocstrings/griffe-warnings-deprecated)
- **Documentation:** [mkdocstrings.github.io/griffe-warnings-deprecated](https://mkdocstrings.github.io/griffe-warnings-deprecated)
- **Extension name:** `griffe_warnings_deprecated`

______________________________________________________________________

This extension adds support for functions and classes decorated with @warnings.deprecated(...), as implemented thanks to [PEP 702](https://peps.python.org/pep-0702/). The message provided in the decorator call will be stored in the corresponding Griffe object's deprecated attribute (usable by downstream rendering templates), and will also add an admonition to the object's docstring with the provided message as text.

```
from warnings import deprecated

@deprecated("This function is **deprecated**. Use [another one][package.another_func] instead.")
def deprecated_func():
    ...


def another_func():
    ...

```

# Third-party extensions

Third-party extensions are developed and maintained outside of the mkdocstrings organization, by various developers. They generally bring support for third-party libraries.

| Extension                                                   | Description                                                                                                                   |
| ----------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| [`docstring-inheritance`](docstring-inheritance/)           | A more advanced docstring inheritance utility that also provides a Griffe extension.                                          |
| [`fieldz`](fieldz/)                                         | Support for data-class like objects (dataclasses, pydantic, attrs, etc.) using [fieldz](https://github.com/pyapp-kit/fieldz). |
| [`generics`](generics/)                                     | Resolve generic type parameters as bound types in subclasses.                                                                 |
| [`inherited-method-crossrefs`](inherited-method-crossrefs/) | Replace docstrings of inherited methods with cross-references to parents.                                                     |
| [`modernized-annotations`](modernized-annotations/)         | Modernize type annotations by adopting PEP 585 and PEP 604.                                                                   |

You can find more third-party extensions by exploring the [`griffe-extension` topic on GitHub](https://github.com/topics/griffe-extension). You can also check out the "in-project" extensions (not published to PyPI) used in various projects on GitHub by [searching for "griffe extension" in code](https://github.com/search?q=griffe+Extension+language%3Apython&type=code).

# `docstring-inheritance`

- **PyPI**: [`docstring-inheritance`](https://pypi.org/project/docstring-inheritance/)
- **GitHub**: [AntoineD/docstring-inheritance](https://github.com/AntoineD/docstring-inheritance)
- **Extension name:** `docstring_inheritance.griffe`

______________________________________________________________________

`docstring-inheritance` is a Python package that allows to avoid writing and maintaining duplicated Python docstrings. The typical usage is to enable the inheritance of the docstrings from a base class such that its derived classes fully or partially inherit the docstrings. It provides a Griffe extension and recommends to use it alongside the official [`inherited-docstrings`](../../official/inherited-docstrings/) extension in MkDocs:

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - griffe_inherited_docstrings
          - docstring_inheritance.griffe

```

# `griffe-fieldz`

- **PyPI**: [`griffe-fieldz`](https://pypi.org/project/griffe-fieldz/)
- **GitHub**: [pyapp-kit/griffe-fieldz](https://github.com/pyapp-kit/griffe-fieldz)
- **Extension name:** `griffe_fieldz`

______________________________________________________________________

This extension adds support for data-class like things (pydantic, attrs, etc...). This extension will inject the fields of the data-class into the documentation, preventing you from duplicating field metadata in your docstrings.

It supports anything that [fieldz](https://github.com/pyapp-kit/fieldz) supports, which is currently:

- [`dataclasses.dataclass`](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass)
- [`pydantic.BaseModel`](https://docs.pydantic.dev/latest/)
- [`attrs.define`](https://www.attrs.org/en/stable/overview.html)
- [`msgspec.Struct`](https://jcristharif.com/msgspec/)

# `griffe-generics`

- **PyPI**: [`griffe-generics`](https://pypi.org/project/griffe-generics/)
- **GitHub**: [jonghwanhyeon/griffe-generics](https://github.com/jonghwanhyeon/griffe-generics)
- **Extension name:** `griffe_generics`

______________________________________________________________________

This extension resolves generic type parameters as bound types in subclasses. For example, if a parent class inherits from `Generics[L]`, and a subclass specifies `L` as `Hashable`, then all type annotations using `L` in the class methods or attributes inherited from the parent class will be transformed to use `Hashable` instead.

# `griffe-inherited-method-crossrefs`

- **PyPI**: [`griffe-inherited-method-crossrefs`](https://pypi.org/project/griffe-inherited-method-crossrefs/)
- **GitHub**: [mlprt/griffe-inherited-method-crossrefs](https://github.com/mlprt/griffe-inherited-method-crossrefs)
- **Extension name:** `griffe_inherited_method_crossrefs`

______________________________________________________________________

This extension replaces docstrings of inherited methods with cross-references to parent methods. For example, if a class `foo.Child` inherits the method `do_something` from `bar.Parent`, then in the generated documentation, the docstring of `Child.do_something` will appear similar to

> Inherited from [bar.Parent](https://example.com/link/to/bar.Parent.do_something)

whereas the docstring of `bar.Parent.do_something` will be unaffected.

This is contrast to the official [`inherited-docstrings`](../../official/inherited-docstrings/) extension which simply attaches the docstring of the parent method to the subclass method, which means that modifying the subclass method docstring also modifies the parent method docstring (it's the same object).

# `griffe-modernized-annotations`

- **PyPI**: [`griffe-modernized-annotations`](https://pypi.org/project/griffe-modernized-annotations/)
- **GitHub**: [jonghwanhyeon/griffe-modernized-annotations](https://github.com/jonghwanhyeon/griffe-modernized-annotations)
- **Extension name:** `griffe_modernized_annotations`

______________________________________________________________________

This extension modernizes type annotations by adopting [PEP 585](https://peps.python.org/pep-0585/) and [PEP 604](https://peps.python.org/pep-0604/). For example, it will transform `Union[A, B]` into `A | B`, and `List[str]` into `list[str]`.
# Contributing

# Contributor guide

Welcome to the Griffe contributor guide! If you are familiar with Python tooling, development, and contributions to open-source projects, see the [TL;DR](#tldr) at the end, otherwise we recommend you walk through the following pages:

- [Environment setup](setup/)
- [Management commands](commands/)
- [Development workflow](workflow/)

Regular contributors might be interested in the following documents that explain Griffe's design and inner workings:

- [Architecture](architecture/)

If you are unsure about what to contribute to, you can check out [our issue tracker](https://github.com/mkdocstrings/griffe/issues) to see if some issues are interesting to you, or you could check out [our coverage report](coverage/) to help us cover more of the codebase with tests.

## TL;DR

- Install [Python](https://www.python.org/), [uv](https://docs.astral.sh/uv/) and [direnv](https://direnv.net/)
- Fork, clone, and enter repository
- Run `direnv allow` and `make setup`
- Checkout a new branch
- Edit code, tests and/or documentation
- Run `make format check test docs` to check everything
- Commit, push, open PR

# Project architecture

This document describes how the project is architectured, both regarding boilerplate and actual code. We start by giving an overview of the project's contents:

```
📁 .git/
📁 .github/ # (1)!
📁 .venv/ # (2)!
📁 .venvs/ # (3)!
📁 .vscode/ # (4)!
📁 config/ # (5)!
📁 docs/ # (6)!
📁 htmlcov/ # (7)!
📁 scripts/ # (8)!
📁 src/ # (9)!
📁 tests/ # (10)!
 .copier-answers.yml # (11)!
 .envrc # (12)!
 .gitignore
 CHANGELOG.md
 CODE_OF_CONDUCT.md
 CONTRIBUTING.md
 LICENSE
 Makefile # (13)!
 README.md
 duties.py # (14)!
 logo.svg
 mkdocs.yml # (15)!
 pyproject.toml # (16)!
 uv.lock

```

1. GitHub workflows, issue templates and other configuration.

   ```
   📁 ISSUE_TEMPLATE/ # (1)!
   📁 workflows/ # (2)!
    FUNDING.yml

   ```

   1. ```
       1-bug.md
       2-feature.md
       3-docs.md
       4-change.md
       config.yml

      ```
   1. ```
       ci.yml
       release.yml

      ```

1. The default virtual environment (git-ignored). See make setup command.

1. The virtual environments for all supported Python versions (git-ignored). See make setup command.

1. The configuration for VSCode (git-ignored). See make vscode command.

   ```
    launch.json
    settings.json
    tasks.json

   ```

1. Contains our tooling configuration. See [Scripts, configuration](#scripts-configuration).

   ```
   📁 vscode/ # (1)!
    coverage.ini
    git-changelog.toml
    mypy.ini
    pytest.ini
    ruff.toml

   ```

   1. ```
       launch.json
       settings.json
       tasks.json

      ```

1. Documentation sources (Markdown pages). See make docs task.

   ```
   📁 .overrides/ # (1)!
   📁 css/ # (2)!
   📁 extensions/ # (3)!
   📁 guide/ # (4)!
   📁 img/ # (5)!
   📁 insiders/ # (6)!
   📁 js/ # (7)!
   📁 reference/ # (8)!
    alternatives.md
    changelog.md
    code-of-conduct.md
    community.md
    contributing.md
    credits.md
    downstream-projects.md
    extensions.md
    getting-help.md
    getting-started.md
    guide.md
    index.md
    installation.md
    introduction.md
    license.md
    logo.svg
    playground.md
    reference.md
    schema-docstrings-options.json
    schema.json

   ```

   1. Customization of [Material for MkDocs](https://squidfunk.github.io/mkdocs-material/)' templates.

      ```
      📁 partials/ # (1)!
       main.html

      ```

      1. ```
          comments.html
          path-item.html

         ```

   1. ```
       custom.css
       insiders.css
       material.css
       mkdocstrings.css

      ```

   1. ```
      📁 built-in/ # (1)!
      📁 official/ # (2)!
      📁 third-party/ # (3)!
       built-in.md
       official.md
       third-party.md

      ```

      1. ```
          dataclasses.md

         ```
      1. ```
          autodocstringstyle.md
          inherited-docstrings.md
          public-redundant-aliases.md
          public-wildcard-imports.md
          pydantic.md
          runtime-objects.md
          sphinx.md
          typingdoc.md
          warnings-deprecated.md

         ```
      1. ```
          docstring-inheritance.md
          fieldz.md
          generics.md
          inherited-method-crossrefs.md
          modernized-annotations.md

         ```

   1. ```
      📁 contributors/ # (1)!
      📁 users/ # (2)!
       contributors.md
       users.md

      ```

      1. ```
          architecture.md
          commands.md
          setup.md
          workflow.md

         ```
      1. ```
         📁 how-to/ # (1)!
         📁 recommendations/ # (2)!
          checking.md
          extending.md
          loading.md
          navigating.md
          serializing.md

         ```
         1. ```
             parse-docstrings.md
             selectively-inspect.md
             set-docstring-styles.md
             support-decorators.md

            ```
         1. ```
             docstrings.md
             public-apis.md
             python-code.md

            ```

   1. ```
       favicon.ico
       gha_annotations_1.png
       gha_annotations_2.png

      ```

   1. ```
       changelog.md
       goals.yml
       index.md
       installation.md

      ```

   1. ```
       feedback.js
       insiders.js

      ```

   1. ```
      📁 api/ # (1)!
       api.md
       cli.md
       docstrings.md

      ```

      1. Python API reference, injected with [mkdocstrings](https://mkdocstrings.github.io/).

         ```
         📁 docstrings/ # (1)!
         📁 models/ # (2)!
          agents.md
          checks.md
          cli.md
          docstrings.md
          exceptions.md
          expressions.md
          extensions.md
          finder.md
          git.md
          helpers.md
          loaders.md
          loggers.md
          models.md
          serializers.md

         ```

         1. ```
             models.md
             parsers.md

            ```
         1. ```
             alias.md
             attribute.md
             class.md
             function.md
             module.md
             type_alias.md

            ```

1. HTML report for Python code coverage (git-ignored), integrated in the [Coverage report](../coverage/) page. See make coverage task.

1. Our different scripts. See [Scripts, configuration](#scripts-configuration).

   ```
    gen_credits.py
    gen_griffe_json.py
    gen_structure_docs.py
    get_version.py
    insiders.py
    make
    make.py

   ```

1. The source of our Python package(s). See [Sources](#sources) and [Program structure](#program-structure).

   ```
   📁 griffe/ # (1)!

   ```

   1. Our public API, exposed to users. See [Program structure](#program-structure).

      ```
      📁 _internal/ # (1)!
       __init__.py
       __main__.py
       py.typed

      ```

      1. Our internal API, hidden from users. See [Program structure](#program-structure).

         ```
         📁 agents/ # (1)!
         📁 docstrings/ # (2)!
         📁 extensions/ # (3)!
          __init__.py
          c3linear.py
          cli.py
          collections.py
          debug.py
          diff.py
          encoders.py
          enumerations.py
          exceptions.py
          expressions.py
          finder.py
          git.py
          importer.py
          loader.py
          logger.py
          merger.py
          mixins.py
          models.py
          py.typed
          stats.py
          tests.py

         ```

         1. ```
            📁 nodes/ # (1)!
             __init__.py
             inspector.py
             visitor.py

            ```
            1. ```
                __init__.py
                assignments.py
                ast.py
                docstrings.py
                exports.py
                imports.py
                parameters.py
                runtime.py
                values.py

               ```
         1. ```
             __init__.py
             google.py
             models.py
             numpy.py
             parsers.py
             sphinx.py
             utils.py

            ```
         1. ```
             __init__.py
             base.py
             dataclasses.py

            ```

1. Our test suite. See [Tests](#tests).

   ```
   📁 fixtures/
   📁 test_docstrings/ # (1)!
    __init__.py
    conftest.py
    helpers.py
    test_api.py
    test_cli.py
    test_diff.py
    test_encoders.py
    test_expressions.py
    test_extensions.py
    test_finder.py
    test_functions.py
    test_git.py
    test_inheritance.py
    test_inspector.py
    test_loader.py
    test_merger.py
    test_mixins.py
    test_models.py
    test_nodes.py
    test_public_api.py
    test_stdlib.py
    test_visitor.py

   ```

   1. ```
       __init__.py
       conftest.py
       helpers.py
       test_google.py
       test_numpy.py
       test_sphinx.py
       test_warnings.py

      ```

1. The answers file generated by [Copier](https://copier.readthedocs.io/en/stable/). See [Boilerplate](#boilerplate).

1. The environment configuration, automatically sourced by [direnv](https://direnv.net/). See [commands](../commands/).

1. A dummy makefile, only there for auto-completion. See [commands](../commands/).

1. Our project tasks, written with [duty](https://pawamoy.github.io/duty). See Tasks.

1. The build configuration for our docs. See make docs task.

1. The project metadata and production dependencies.

## Boilerplate

This project's skeleton (the file-tree shown above) is actually generated from a [Copier](https://copier.readthedocs.io/en/stable/) template called [copier-uv](https://pawamoy.github.io/copier-uv/). When generating the project, Copier asks a series of questions (configured by the template itself), and the answers are used to render the file and directory names, as well as the file contents. Copier also records answers in the `.copier-answers.yml` file, allowing to update the project with latest changes from the template while reusing previous answers.

To update the project (in order to apply latest changes from the template), we use the following command:

```
copier update --trust --skip-answered

```

## Scripts, configuration

We have a few scripts that let us manage the various maintenance aspects for this project. The entry-point is the `make` script located in the `scripts` folder. It doesn't need any dependency to be installed to run. See [Management commands](../commands/) for more information.

The `make` script can also invoke what we call "tasks". Tasks need our development dependencies to be installed to run. These tasks are written in the `duties.py` file, and the development dependencies are listed in `devdeps.txt`.

The tools used in tasks have their configuration files stored in the `config` folder, to unclutter the root of the repository. The tasks take care of calling the tools with the right options to locate their respective configuration files.

## Sources

Sources are located in the `src` folder, following the [src-layout](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/). We use [PDM-Backend](https://backend.pdm-project.org/) to build source and wheel distributions, and configure it in `pyproject.toml` to search for packages in the `src` folder.

## Tests

Our test suite is located in the `tests` folder. It is located outside of the sources as to not pollute distributions (it would be very wrong to publish a `tests` package as part of our distributions, since this name is extremely common), or worse, the public API. The `tests` folder is however included in our source distributions (`.tar.gz`), alongside most of our metadata and configuration files. Check out `pyproject.toml` to get the full list of files included in our source distributions.

The test suite is based on [pytest](https://docs.pytest.org/en/8.2.x/). Test modules reflect our internal API structure, and except for a few test modules that test specific aspects of our API, each test module tests the logic from the corresponding module in the internal API. For example, `test_finder.py` tests code of the `griffe._internal.finder` internal module, while `test_functions` tests our ability to extract correct information from function signatures, statically. The general rule of thumb when writing new tests is to mirror the internal API. If a test touches to many aspects of the loading process, it can be added to the `test_loader` test module.

## Program structure

The internal API is contained within the `src/griffe/_internal` folder. The top-level `griffe/__init__.py` module exposes all the public API, by importing the internal objects from various submodules of `griffe._internal`.

Users then import `griffe` directly, or import objects from it.

We'll be honest: our code organization is not the most elegant, but it works Have a look at the following module dependency graph, which will basically tell you nothing except that we have a lot of inter-module dependencies. Arrows read as "imports from". The code base is generally pleasant to work with though.

*You can zoom and pan all diagrams on this page with mouse inputs.*

The following sections are generated automatically by iterating on the modules of our public and internal APIs respectively, and extracting the comment blocks at the top of each module. The comment blocks are addressed to readers of the code (maintainers, contributors), while module docstrings are addressed to users of the API. Module docstrings in our internal API are never written, because our module layout is hidden, and therefore modules aren't part of the public API, so it doesn't make much sense to write "user documentation" in them.

### CLI entrypoint

#### `griffe.__main__`

Entry-point module, in case you use `python -m griffe`.

Why does this file exist, and why `__main__`? For more info, read:

- <https://www.python.org/dev/peps/pep-0338/>
- <https://docs.python.org/3/using/cmdline.html#cmdoption-m>

### Public API

#### `griffe`

This top-level module imports all public names from the package, and exposes them as public objects. We have tests to make sure no object is forgotten in this list.

### Internal API

The internal API layout doesn't follow any particular paradigm: we simply organize code in different modules, depending on what the code is used for.

#### `agents`

These modules contain the different agents that are able to extract data.

##### `inspector.py`

This module contains our dynamic analysis agent, capable of inspecting modules and objects in memory, at runtime.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `nodes`

These submodules contain utilities for working with AST and object nodes.

###### `assignments.py`

This module contains utilities for extracting information from assignment nodes.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `ast.py`

This module contains utilities for navigating AST nodes.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `docstrings.py`

This module contains utilities for extracting docstrings from nodes.

###### `exports.py`

This module contains utilities for extracting exports from `__all__` assignments.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `imports.py`

This module contains utilities for working with imports and relative imports.

###### `parameters.py`

This module contains utilities for extracting information from parameter nodes.

###### `runtime.py`

This module contains utilities for extracting information from runtime objects.

xml version="1.0" encoding="UTF-8" standalone="no"?

###### `values.py`

This module contains utilities for extracting attribute values.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `visitor.py`

This module contains our static analysis agent, capable of parsing and visiting sources, statically.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `c3linear.py`

This module contains a single function, `c3linear_merge`. The function is generic enough to be in its own module.

- Copyright (c) 2019 Vitaly R. Samigullin
- Adapted from <https://github.com/pilosus/c3linear>
- Adapted from <https://github.com/tristanlatr/pydocspec>

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `cli.py`

This module contains all CLI-related things. Why does this file exist, and why not put this in `__main__`?

We might be tempted to import things from `__main__` later, but that will cause problems; the code will get executed twice:

- When we run `python -m griffe`, Python will execute `__main__.py` as a script. That means there won't be any `griffe.__main__` in `sys.modules`.
- When you import `__main__` it will get executed again (as a module) because there's no `griffe.__main__` in `sys.modules`.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `collections.py`

This module contains collection-related classes, which are used throughout the API.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `debug.py`

This module is here to help users report bugs. It provides a function to print environment information, which is called from the public `griffe.debug` module (when called with `python -m griffe.debug`) or thanks to the `--debug-info` CLI flag.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `diff.py`

This module exports "breaking changes" related utilities. The logic here is to iterate on objects and their members recursively, to yield found breaking changes.

The breakage class definitions might sound a bit verbose, but declaring them this way helps with (de)serialization, which we don't use yet, but could use in the future.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `docstrings`

These submodules define models and parsers for docstrings.

##### `google.py`

This module defines functions to parse Google-style docstrings into structured data.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `models.py`

This module contains the models for storing docstrings structured data.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `numpy.py`

This module defines functions to parse Numpy-style docstrings into structured data.

Based on <https://numpydoc.readthedocs.io/en/latest/format.html>, it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification.

Rejected as non particularly Pythonic or useful as sections:

- See also: this section feels too subjective (specially crafted as a standard for Numpy itself), and there are may ways to reference related items in a docstring, depending on the chosen markup.

Rejected as naturally handled by the user-chosen markup:

- Warnings: this is just markup.
- Notes: again, just markup.
- References: again, just markup.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `parsers.py`

This module imports all the defined parsers and provides a generic function to parse docstrings.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `sphinx.py`

This module defines functions to parse Sphinx docstrings into structured data.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `utils.py`

This module contains utilities for docstrings parsers.

#### `encoders.py`

This module contains data encoders/serializers and decoders/deserializers. We only support JSON for now, but might want to add more formats in the future.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `enumerations.py`

This module contains all the enumerations of the package.

#### `exceptions.py`

This module contains all the exceptions specific to Griffe.

#### `expressions.py`

This module contains the data classes that represent resolvable names and expressions. First we declare data classes for each kind of expression, mostly corresponding to Python's AST nodes. Then we declare builder methods, that iterate AST nodes and build the corresponding data classes, and two utilities `_yield` and `_join` to help iterate on expressions. Finally we declare a few public helpers to safely get expressions from AST nodes in different scenarios.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `extensions`

These submodules contain our extension system, as well as built-in extensions.

##### `base.py`

This module contains the base class for extensions and the functions to load them.

xml version="1.0" encoding="UTF-8" standalone="no"?

##### `dataclasses.py`

Built-in extension adding support for dataclasses.

This extension re-creates `__init__` methods of dataclasses during static analysis.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `finder.py`

This module contains the code allowing to find modules.

Note: It might be possible to replace a good part of this module's logic with utilities from `importlib` (however the util in question is private):

```
>>> from importlib.util import _find_spec
>>> _find_spec("griffe.agents", _find_spec("griffe", None).submodule_search_locations)
ModuleSpec(
    name='griffe.agents',
    loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fa5f34e8110>,
    origin='/media/data/dev/griffe/src/griffe/agents/__init__.py',
    submodule_search_locations=['/media/data/dev/griffe/src/griffe/agents'],
)

```

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `git.py`

This module contains Git utilities, used by our load_git function, which in turn is used to load the API for different snapshots of a Git repository and find breaking changes between them.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `importer.py`

This module contains utilities to dynamically import objects. These utilities are used by our Inspector to dynamically import objects specified as Python paths, like `package.module.Class.method`.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `loader.py`

This module contains all the logic for loading API data from sources or compiled modules.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `logger.py`

This module contains the logger used throughout Griffe. The logger is actually a wrapper around the standard Python logger. We wrap it so that it is easier for other downstream libraries to patch it. For example, mkdocstrings-python patches the logger to relocate it as a child of `mkdocs.plugins` so that it fits in the MkDocs logging configuration.

We use a single, global logger because our public API is exposed in a single module, `griffe`. Extensions however should use their own logger, which is why we provide the `get_logger` function.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `merger.py`

This module contains utilities to merge stubs data and concrete data.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `mixins.py`

This module contains some mixins classes that hold shared methods of the different kinds of objects, and aliases.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `models.py`

This module contains our models definitions, to represent Python objects (and other aspects of Python APIs)... in Python.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `stats.py`

This module contains utilities to compute loading statistics, like time spent visiting modules statically or dynamically.

xml version="1.0" encoding="UTF-8" standalone="no"?

#### `tests.py`

This module contains helpers. They simplify programmatic use of Griffe, for example to load data from strings or to create temporary packages. They are particularly useful for our own tests suite.

xml version="1.0" encoding="UTF-8" standalone="no"?

# Management commands

The entry-point to run commands to manage the project is our Python `make` script, located in the `scripts` folder. You can either call it directly with `./scripts/make`, or you can use [direnv](https://direnv.net/) to add the script to your command line path. Once direnv is installed and hooked into your shell, allow it once for this directory with `direnv allow`. Now you can directly call the Python script with `make`. The `Makefile` is just here to provide auto-completion.

Try typing `make` or `make help` to show the available commands.

```
$ make
Available commands
  help                  Print this help. Add task name to print help.
  setup                 Setup all virtual environments (install dependencies).
  run                   Run a command in the default virtual environment.
  multirun              Run a command for all configured Python versions.
  allrun                Run a command in all virtual environments.
  3.x                   Run a command in the virtual environment for Python 3.x.
  clean                 Delete build artifacts and cache files.
  vscode                Configure VSCode to work on this project.

```

## Commands

Commands are always available: they don't require any Python dependency to be installed.

### `setup`

Setup all virtual environments (install dependencies).

```
make setup

```

The `setup` command installs all the Python dependencies required to work on the project. Virtual environments and dependencies are managed by [uv](https://github.com/astral-sh/uv). Development dependencies are listed in the `devdeps.txt` file.

The command will create a virtual environment in the `.venv` folder, as well as one virtual environment per supported Python version in the `.venvs/3.x` folders. Supported Python versions are listed in the `scripts/make` file, and can be overridden by setting the `PYTHON_VERSIONS` environment variable.

If you cloned the repository on the same file-system as uv's cache, everything will be hard linked from the cache, so don't worry about wasting disk space.

Once dependencies are installed, try running `make` or `make help` again, to show additional tasks.

```
$ make
Available commands
  help                  Print this help. Add task name to print help.
  setup                 Setup all virtual environments (install dependencies).
  run                   Run a command in the default virtual environment.
  multirun              Run a command for all configured Python versions.
  allrun                Run a command in all virtual environments.
  3.x                   Run a command in the virtual environment for Python 3.x.
  clean                 Delete build artifacts and cache files.
  vscode                Configure VSCode to work on this project.

Available tasks
  build                 Build source and wheel distributions.
  changelog             Update the changelog in-place with latest commits.
  check                 Check it all!
  check-api             Check for API breaking changes.
  check-docs            Check if the documentation builds correctly.
  check-quality         Check the code quality.
  check-types           Check that the code is correctly typed.
  coverage              Report coverage as text and HTML.
  docs                  Serve the documentation (localhost:8000).
  docs-deploy           Deploy the documentation to GitHub pages.
  format                Run formatting tools on the code.
  fuzz                  Fuzz Griffe against generated Python code.
  publish               Publish source and wheel distributions to PyPI.
  release               Release a new version of the project.
  test                  Run the test suite.

```

These tasks are written using [duty](https://github.com/pawamoy/duty) (a task runner), and located in the `duties.py` module in the repository root.

Some of these tasks will run in the default virtual environment (`.venv`), while others will run in all the supported Python version environments (`.venvs/3.x`).

### `help`

Print this help. Add task name to print help.

```
make help [TASK]

```

When the Python dependencies are not installed, this command just print the available commands. When the Python dependencies are installed, [duty](https://github.com/pawamoy/duty) is available so the command can also print the available tasks.

If you add a task name after the command, it will print help for this specific task.

### `run`

Run a command in the default virtual environment.

```
make run <CMD> [ARG...]

```

This command runs an arbitrary command inside the default virtual environment (`.venv`). It is especially useful to start a Python interpreter without having to first activate the virtual environment: `make run python`.

### `multirun`

Run a command for all configured Python versions.

```
make multirun <CMD> [ARG...]

```

This command runs an arbitrary command inside the environments for all supported Python versions. It is especially useful for running tests.

### `allrun`

Run a command in all virtual environments.

```
make multirun <CMD> [ARG...]

```

This command runs an arbitrary command inside the default environment, as well as the environments for all supported Python versions.

This command is especially useful to install, remove or update dependencies in all environments at once. For example, if you want to install a dependency in editable mode, from a local source:

```
make allrun uv pip install -e ../other-project

```

### `3.x`

Run a command in the virtual environment for Python 3.x.

```
make 3.x <CMD> [ARG...]

```

This command runs an arbitrary command inside the environment of the selected Python version. It can be useful if you want to run a task that usually runs in the default environment with a different Python version.

### `clean`

Delete build artifacts and cache files.

```
make clean

```

This command simply deletes build artifacts and cache files and folders such as `build/`, `.cache/`, etc.. The virtual environments (`.venv` and `.venvs/*`) are not removed by this command.

### `vscode`

Configure VSCode to work on this project.

```
make vscode

```

This command configures the [VSCode editor](https://code.visualstudio.com/) by copying the following files into the `.vscode` directory:

- `launch.json`, for run configurations (to run debug sessions)
- `settings.json`, for various editor settings like linting tools and their configuration
- `tasks.json`, for running tasks directly from VSCode's interface

Warning: These files will be overwritten every time the command is run.

## Tasks

Tasks require the Python dependencies to be installed. They use various tools and libraries to assert code quality, run tests, serve the documentation locally, or build and publish distributions of your project. There are multiple ways to run tasks:

- `make TASK`, the main, configured way to run a task
- `make run duty TASK`, to run a task in the default environment
- `make multirun duty TASK`, to run a task on all supported Python versions
- `make allrun duty TASK`, to run a task in *all* environments
- `make 3.x duty TASK`, to run a task on a specific Python version

### `build`

Build source and wheel distributions.

```
make build

```

Build distributions of your project for the current version. The build task uses the [`build` tool](https://build.pypa.io/en/stable/) to build `.tar.gz` (Gzipped sources archive) and `.whl` (wheel) distributions of your project in the `dist` directory.

### `changelog`

Update the changelog in-place with latest commits.

```
make changelog [bump=VERSION]

```

Update the changelog in-place. The changelog task uses [git-changelog](https://pawamoy.github.io/git-changelog/) to read Git commits and parse their messages to infer the new version based on our commit message convention.

The new version will be based on the types of the latest commits, unless a specific version is provided with the `bump` parameter.

If the group of commits contains only bug fixes (`fix:`) and/or commits that are not interesting for users (`chore:`, `style:`, etc.), the changelog will gain a new **patch** entry. It means that the new suggested version will be a patch bump of the previous one: `0.1.1` becomes `0.1.2`.

If the group of commits contains at least one feature (`feat:`), the changelog will gain a new **minor** entry. It means that the new suggested version will be a minor bump of the previous one: `0.1.1` becomes `0.2.0`.

If there is, in the group of commits, a commit whose body contains something like `Breaking change`, the changelog will gain a new **major** entry, unless the version is still an "alpha" version (starting with 0), in which case it gains a **minor** entry. It means that the new suggested version will be a major bump of the previous one: `1.2.1` becomes `2.0.0`, but `0.2.1` is only bumped up to `0.3.0`. Moving from "alpha" status to "beta" or "stable" status is a choice left to the developers, when they consider the package is ready for it.

The configuration for git-changelog is located at `config/git-changelog.toml`.

Parameters:

- **`bump`** (`str`, default: `''` ) – Bump option passed to git-changelog.

### `check`

Check it all!

```
make check

```

Composite command to run all the check commands:

- check-quality, to check the code quality on all Python versions
- check-types, to type-check the code on all Python versions
- check-docs, to check the docs on all Python versions
- check-api, to check for API breaking changes

### `check-api`

Check for API breaking changes.

```
make check-api

```

Compare the current code to the latest version (Git tag) using [Griffe](https://mkdocstrings.github.io/griffe/), to search for API breaking changes since latest version. It is set to allow failures, and is more about providing information than preventing CI to pass.

Parameters:

- **`*cli_args`** (`str`, default: `()` ) – Additional Griffe CLI arguments.

### `check-docs`

Check if the documentation builds correctly.

```
make check-docs

```

Build the docs with [MkDocs](https://www.mkdocs.org/) in strict mode.

The configuration for MkDocs is located at `mkdocs.yml`.

This task builds the documentation with strict behavior: any warning will be considered an error and the command will fail. The warnings/errors can be about incorrect docstring format, or invalid cross-references.

### `check-quality`

Check the code quality.

```
make check-quality

```

Check the code quality using [Ruff](https://astral.sh/ruff).

The configuration for Ruff is located at `config/ruff.toml`. In this file, you can deactivate rules or activate others to customize your analysis. Rule identifiers always start with one or more capital letters, like `D`, `S` or `BLK`, then followed by a number.

You can ignore a rule on a specific code line by appending a `noqa` comment ("no quality analysis/assurance"):

src/your_package/module.py

```
print("a code line that triggers a Ruff warning")  # noqa: ID

```

...where ID is the identifier of the rule you want to ignore for this line.

Example:

src/your_package/module.py

```
import subprocess

```

````
```console
$ make check-quality
✗ Checking code quality (1)
> ruff check --config=config/ruff.toml src/ tests/ scripts/
src/your_package/module.py:2:1: S404 Consider possible security implications associated with subprocess module.
````

Now add a comment to ignore this warning.

```python title="src/your_package/module.py"
import subprocess  # noqa: S404
```

```console
$ make check-quality
✓ Checking code quality
```

You can disable multiple different warnings on a single line by separating them with commas, for example `# noqa: D300,D301`.

```

You can disable a warning globally by adding its ID
into the list in `config/ruff.toml`.

You can also disable warnings per file, like so:

config/ruff.toml

```

[per-file-ignores] "src/your_package/your_module.py" = [ "T201", # Print statement ]

```

### `check-types`

Check that the code is correctly typed.

```

make check-types

```

Run type-checking on the code with [Mypy](https://mypy.readthedocs.io/).

The configuration for Mypy is located at `config/mypy.ini`.

If you cannot or don't know how to fix a typing error in your code,
as a last resort you can ignore this specific error with a comment:

src/your_package/module.py

```

print("a code line that triggers a Mypy warning") # type: ignore[ID]

```

...where ID is the name of the warning.

Example:

src/your_package/module.py

```

result = data_dict.get(key, None).value

```

```

```console
$ make check-types
✗ Checking types (1)
> mypy --config-file=config/mypy.ini src/ tests/ scripts/
src/your_package/module.py:2:1: Item "None" of "Data | None" has no attribute "value" [union-attr]
```

Now add a comment to ignore this warning.

```python title="src/your_package/module.py"
result = data_dict.get(key, None).value  # type: ignore[union-attr]
```

```console
$ make check-types
✓ Checking types
```

```

### `coverage`

Report coverage as text and HTML.

```

make coverage

```

Combine coverage data from multiple test runs with [Coverage.py](https://coverage.readthedocs.io/),
then generate an HTML report into the `htmlcov` directory,
and print a text report in the console.

### `docs`

Serve the documentation (localhost:8000).

```

make docs

```

This task uses [MkDocs](https://www.mkdocs.org/) to serve the documentation locally.

Parameters:

- **`*cli_args`**
  (`str`, default:
  `()`
  )
  –
  Additional MkDocs CLI arguments.
- **`host`**
  (`str`, default:
  `'127.0.0.1'`
  )
  –
  The host to serve the docs from.
- **`port`**
  (`int`, default:
  `8000`
  )
  –
  The port to serve the docs on.

### `docs-deploy`

Deploy the documentation to GitHub pages.

```

make docs-deploy

```

Use [MkDocs](https://www.mkdocs.org/) to build and deploy the documentation to GitHub pages.

Parameters:

- **`force`**
  (`bool`, default:
  `False`
  )
  –
  Whether to force deployment, even from non-Insiders version.

### `format`

Run formatting tools on the code.

```

make format

```

Format the code with [Ruff](https://astral.sh/ruff).
This command will also automatically fix some coding issues when possible.

### `fuzz`

Fuzz Griffe against generated Python code.

Parameters:

- **`ctx`**
  (`Context`)
  –
  The context instance (passed automatically).
- **`size`**
  (`int`, default:
  `20`
  )
  –
  The size of the case set (number of cases to test).
- **`seeds`**
  (`_Seeds`, default:
  `_Seeds()`
  )
  –
  Seeds to test or exclude (comma-separated integers).
- **`min_seed`**
  (`int`, default:
  `0`
  )
  –
  Minimum value for the seeds range.
- **`max_seed`**
  (`int`, default:
  `1000000`
  )
  –
  Maximum value for the seeds range.

### `publish`

Publish source and wheel distributions to PyPI.

```

make publish

```

Publish the source and wheel distributions of your project to PyPI
using [Twine](https://twine.readthedocs.io/).

### `release`

Release a new version of the project.

```

make release [version=VERSION]

```

This task will:

- Stage changes to `pyproject.toml` and `CHANGELOG.md`
- Commit the changes with a message like `chore: Prepare release 1.0.0`
- Tag the commit with the new version number
- Push the commit and the tag to the remote repository
- Build source and wheel distributions
- Publish the distributions to PyPI
- Deploy the documentation to GitHub pages

Parameters:

- **`version`**
  (`str`, default:
  `''`
  )
  –
  The new version number to use. If not provided, you will be prompted for it.

### `test`

Run the test suite.

```

make test [match=EXPR]

````

Run the test suite with [Pytest](https://docs.pytest.org/) and plugins.
Code source coverage is computed thanks to
[coveragepy](https://coverage.readthedocs.io/en/coverage-5.1/).

Parameters:

- **`*cli_args`**
  (`str`, default:
  `()`
  )
  –
  Additional Pytest CLI arguments.
- **`match`**
  (`str`, default:
  `''`
  )
  –
  A pytest expression to filter selected tests.```
````

# Environment setup

To work on the project, whether to update the code or the documentation, you will have to setup a development environment.

## Requirements

The only requirement is that you have [Python](https://www.python.org/) and [uv](https://docs.astral.sh/uv/) installed and available on your command line path.

```
curl -LsSf https://astral.sh/uv/install.sh | sh

```

See [Installation methods](https://docs.astral.sh/uv/getting-started/installation/).

```
pip install --user uv

```

[pip](https://pip.pypa.io/en/stable/) is the main package installer for Python.

```
pipx install uv

```

[pipx](https://pipx.pypa.io/stable/) allows to install and run Python applications in isolated environments.

```
rye install uv

```

[Rye](https://rye.astral.sh/) is an all-in-one solution for Python project management, written in Rust.

Optionally, we recommend using [direnv](https://direnv.net/), which will add our `scripts` folder to your path when working on the project, allowing to call our `make` Python script with the usual `make` command.

## Fork and clone

[Fork the repository on GitHub](https://github.com/mkdocstrings/griffe/fork), then clone it locally:

```
gh repo clone griffe

```

The [`gh` GitHub CLI](https://cli.github.com/) allows you to interact with GitHub on the command line.

```
git clone git@github.com:your-username/griffe

```

See the documentation on GitHub for [Connecting with SSH](https://docs.github.com/en/authentication/connecting-to-github-with-ssh) and for [Cloning a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository).

```
git clone https://github.com/your-username/griffe

```

See the documentation on GitHub for [Cloning a repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository).

## Install dependencies

First, enter the repository.

If you installed [direnv](https://direnv.net/):

- run `direnv allow`
- run `make setup`

If you didn't install [direnv](https://direnv.net/), just run `./scripts/make setup`.

The setup command will install all the Python dependencies required to work on the project. This command will create a virtual environment in the `.venv` folder, as well as one virtual environment per supported Python version in the `.venvs/3.x` folders. If you cloned the repository on the same file-system as [uv](https://docs.astral.sh/uv/)'s cache, everything will be hard linked from the cache, so don't worry about wasting disk space.

## IDE setup

If you work in VSCode, we provide [a command to configure VSCode](../commands/#vscode) for the project.

# Development workflow

This document describes our workflow when developing features, fixing bugs and updating the documentation. It also includes guidelines for pull requests on GitHub.

## Features and bug fixes

The development worklow is rather usual.

**For a new feature:**

1. create a new branch: `git switch -c feat-summary`
1. edit the code and the documentation
1. write new tests

**For a bug fix:**

1. create a new branch: `git switch -c fix-summary`
1. write tests that fail but are expected to pass once the bug is fixed
1. run make test to make sure the new tests fail
1. fix the code

**For a docs update:**

1. create a new branch: `git switch -c docs-summary`

1. start the live reloading server: `make docs` (1)

1. update the documentation

1. preview changes at <http://localhost:8000>

1. To speed-up the live reloading, disable mkdocstrings with `MKDOCSTRINGS_ENABLED=false make docs`.

**Before committing:**

1. run make format to auto-format the code
1. run make check to check everything (fix any warning)
1. run make test to run the tests (fix any issue)
1. if you updated the documentation or the project dependencies:
   1. run make docs
   1. go to <http://localhost:8000> and check that everything looks good

Once you are ready to commit, follow our [commit message convention](#commit-message-convention).

Occasional contributors

If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.

## Breaking changes and deprecations

Breaking changes should generally be avoided. If we decide to add a breaking change anyway, we should first allow a deprecation period. To deprecate parts of the API, check [Griffe's hints on how to deprecate things](../../users/checking/).

Use make check-api to check if there are any breaking changes. All of them should allow deprecation periods. Run this command again until no breaking changes are detected.

Deprecated code should also be marked as legacy code. We use [Yore](https://pawamoy.github.io/yore/) to mark legacy code. Similarly, code branches made to support older version of Python should be marked as legacy code using Yore too.

Examples:

Remove function when we bump to 2.0

```
# YORE: Bump 2: Remove block.
def deprecated_function():
    ...

```

Simplify imports when Python 3.9 is EOL

```
# YORE: EOL 3.9: Replace block with line 4.
try:
    import ...
except ImportError:
    import ...

```

Check [Yore's docs](https://pawamoy.github.io/yore/), and Yore-comments in our own code base (`git grep -A1 YORE`) to learn how to use it.

Occasional contributors

If you are unsure about how to deprecate something or mark legacy code, let us do it during review.

## Commit message convention

Commit messages must follow our convention based on the [Angular style](https://gist.github.com/stephenparish/9941e89d80e2bc58a153#format-of-the-commit-message) or the [Karma convention](https://karma-runner.github.io/4.0/dev/git-commit-msg.html):

```
type(scope): Subject

Body.

```

**Subject and body must be valid Markdown.** Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general. Example:

```
feat: Add CLI option to run in verbose mode

```

Scope and body are optional. Type can be:

- `build`: About packaging, building wheels, etc.
- `chore`: About packaging or repo/files management.
- `ci`: About Continuous Integration.
- `deps`: Dependencies update.
- `docs`: About documentation.
- `feat`: New feature.
- `fix`: Bug fix.
- `perf`: About performance.
- `refactor`: Changes that are not features or bug fixes.
- `style`: A change in code style/format.
- `tests`: About tests.

If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:

```
This is the body of the commit message.

Issue-10: https://github.com/namespace/project/issues/10
Related-to-PR-namespace/other-project#15: https://github.com/namespace/other-project/pull/15

```

These "trailers" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons `:`. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).

We do not enforce a line length on commit messages summary and body.

Occasional contributors

If this convention seems unclear to you, just write the message of your choice, and we will rewrite it ourselves before merging.

## Pull requests guidelines

Link to any related issue in the Pull Request message.

During the review, we recommend using fixups:

```
# SHA is the SHA of the commit you want to fix
git commit --fixup=SHA

```

Once all the changes are approved, you can squash your commits:

```
git rebase -i --autosquash main

```

And force-push:

```
git push -f

```

Occasional contributors

If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.

## Release process

Occasional or even regular contributors don't *have* to read this, but can anyway if they are interested in our release process.

Once we are ready for a new release (a few bugfixes and/or features merged in the main branch), maintainers should update the changelog. If our [commit message convention](./#commit-message-convention) was properly followed, the changelog can be automatically updated from the messages in the Git history with make changelog. This task updates the changelog in place to add a new version entry.

Once the changelog is updated, maintainers should review the new version entry, to:

- (optionally) add general notes for this new version, like highlights
- insert **Breaking changes** and **Deprecations** sections if needed, before other sections
- add links to the relevant parts of the documentation
- fix typos or markup if needed

Once the changelog is ready, a new release can be made with make release. If the version wasn't passed on the command-line with `make release version=x.x.x`, the task will prompt you for it. **Use the same version as the one that was just added to the changelog.** For example if the new version added to the changelog is `7.8.9`, use `make release version=7.8.9`.

The release task will stage the changelog, commit, tag, push, then build distributions and upload them to PyPI.org, and finally deploy the documentation. If any of these steps fail, you can manually run each step with Git commands, then make build, make publish and make docs-deploy.

# Other

# License

```
ISC License

Copyright (c) 2021, Timothée Mazzucotelli

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

```

# Community

Griffe is part of is the [mkdocstrings](https://mkdocstrings.github.io/) ecosystem, and therefore part of the [MkDocs](https://www.mkdocs.org/) ecosystem too. These two ecosystems have wonderful communities and we invite you to join them Make sure to read and follow our [code of conduct](../code-of-conduct/) when engaging with the community.

You can start new discussions on GitHub, in the following repositories, depending on the specificity of the discussion: [griffe](https://github.com/mkdocstrings/griffe), [mkdocstrings-python](https://github.com/mkdocstrings/python), [mkdocstrings](https://github.com/mkdocstrings/mkdocstrings), and [MkDocs](https://github.com/mkdocs/mkdocs).

You can also join our dedicated Gitter channels: [Griffe channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im), [mkdocstrings-python channel](https://app.gitter.im/#/room/#mkdocstrings_python:gitter.im), [mkdocstrings channel](https://app.gitter.im/#/room/#mkdocstrings_community:gitter.im), and [MkDocs channel](https://app.gitter.im/#/room/#mkdocs_community:gitter.im).

The best place to share about Griffe is of course our Gitter channel.

[Join Griffe's Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im)

More generally, Griffe is also related to **API documentation** and **API analysis** (static or dynamic): if your project is related to these two domains, but in different ecosystems (other programming languages, static site generators, or environments), feel free to drop us a message! We are always happy to share with other actors in these domains

- [Getting help](../getting-help/)
- [Contributing](../contributing/)
- [Code of conduct](../code-of-conduct/)
- [Credits](../credits/)

# Getting help

If you have a quick question regarding Griffe, ask on our [Gitter channel](https://app.gitter.im/#/room/#mkdocstrings_griffe:gitter.im).

For more complex questions, or actual issues that require showing code and configuration, please create [new Q/A discussions](https://github.com/mkdocstrings/griffe/discussions/categories/q-a) or [new bug reports](https://github.com/mkdocstrings/griffe/issues) respectively. Make sure to search previous discussions and issues to avoid creating duplicates. Also make sure to read our documentation before asking questions or opening bug reports. Don't hesitate to report unclear or missing documentation, we will do our best to improve it.

In any case (quick or complex questions) please remember to be **kind**, and to follow our [code of conduct](../code-of-conduct/). The people helping you do so voluntarily, in their free time. Be respectful of their time, and of your own. Help them help you by providing all the necessary information in minimal, reproducible examples. When creating a bug report, make sure to fill out the issue template.

# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience
- Focusing on what is best not just for us as individuals, but for the overall community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email address, without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.

Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [dev@pawamoy.fr](mailto:dev@pawamoy.fr). All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of actions.

**Consequence**: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 2.1, available at <https://www.contributor-covenant.org/version/2/1/code_of_conduct.html>.

Community Impact Guidelines were inspired by [Mozilla's code of conduct enforcement ladder](https://github.com/mozilla/diversity).

For answers to common questions about this code of conduct, see the FAQ at <https://www.contributor-covenant.org/faq>. Translations are available at <https://www.contributor-covenant.org/translations>.

# Alternatives

Similar projects exist in the ecosystem. They generally allow to extract API data from Python source, or to build a representation of the Python source or Python API. Some of them also allow to compare representations to find breaking changes.

## Docspec

[Docspec](https://github.com/NiklasRosenstein/python-docspec) is a JSON object specification for representing API documentation of programming languages. While in it's current form it is targeting Python APIs, it is intended to be able to represent other programming languages in the future as well.

The repository contains two projects, docspec and docspec-python. **docspec** is the reference implementation for reading/writing the JSON format and API for representing API objects in memory. **docspec-python** is a parser for Python packages and modules based on lib2to3 producing docspec API object representations.

## Frappucino

[Frappucino](https://github.com/Carreau/frappuccino) allows you to make sure you haven't broken your API, by first taking an imprint of your API at one point in time and then compare it to the current project state. The goal is to warn you when incompatible changes have been introduced, and to list these changes.

## Other related projects

The work of [@tristanlatr](https://github.com/tristanlatr) is worth checking out, notably his [ast-nodes](https://github.com/tristanlatr/ast-nodes) and [astuce](https://github.com/tristanlatr/astuce) projects, which aim at providing lower-level Python AST utilities to help implementing API data extraction with powerful inference. Tristan is [advocating for more interoperability](https://github.com/mkdocstrings/griffe/discussions/287) between Docspec, Griffe and his own projects.

We should also mention our own simplified "Griffe" variants for other programming languages, such as [Griffe TypeDoc](https://mkdocstrings.github.io/griffe-typedoc/), which extracts API data from TypeScript sources thanks to [TypeDoc](https://typedoc.org/), and builds Python objects from it.

______________________________________________________________________

The following projects are more than API data extraction tools, but deserve being mentioned.

### Papyri

[Papyri](https://github.com/jupyter/papyri) is a set of tools to build, publish (future functionality - to be done), install and render documentation within IPython and Jupyter.

Papyri [has considered using Griffe in the past](https://github.com/jupyter/papyri/issues/249) , but eventually went with their own solution, trying to be compatible with Griffe serialization format.

### pdoc

[pdoc](https://github.com/mitmproxy/pdoc) is a documentation renderer for Python projects. pdoc's main feature is a focus on simplicity: pdoc aims to do one thing and do it well.

### Sphinx AutoAPI

[Sphinx AutoAPI](https://github.com/readthedocs/sphinx-autoapi) is a new approach to API documentation in Sphinx. It is a Sphinx extension for generating complete API documentation without needing to load, run, or import the project being documented. In contrast to the traditional [Sphinx autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), which requires manual authoring and uses code imports, AutoAPI finds and generates documentation by parsing source code.

Sphinx AutoAPI is [considering Griffe as a data extraction backend](https://github.com/readthedocs/sphinx-autoapi/issues/444)

# Downstream projects

Griffe is used by various projects in the Python ecosystem.

## griffe2md

[griffe2md](https://mkdocstrings.github.io/griffe2md/) outputs API docs in Markdown. It uses Griffe to load the data, and then use Jinja templates to render documentation in Markdown, just like [mkdocstrings-python](https://mkdocstrings.github.io/python/), but in Markdown instead of HTML.

## Griffe TUI

[Griffe TUI](https://mkdocstrings.github.io/griffe-tui/) is a textual user interface for Griffe. It offers 100% offline, beautiful Python API docs, in your terminal, thanks to Griffe and [Textual](https://textual.textualize.io/).

## mkdocstrings-python

Of course, Griffe is what powers [the Python handler of mkdocstrings](https://mkdocstrings.github.io/python/). mkdocstrings is a plugin for [MkDocs](https://www.mkdocs.org/) that allows rendering API docs easily.

## OpenAI Agents SDK

The [OpenAI Agents SDK](https://github.com/openai/openai-agents-python) is a lightweight yet powerful framework for building multi-agent workflows. It was inspired by Pydantic AI and uses Griffe the same way, to parse docstrings in order to generate function schemas.

## pydanclick

[Pydanclick](https://pypi.org/project/pydanclick/) allows to use [Pydantic](https://docs.pydantic.dev/latest/) models as [Click](https://click.palletsprojects.com/en/8.1.x/) options. It uses Griffe to parse docstrings and find Attributes sections, to help itself build Click options.

## PydanticAI

[PydanticAI](https://ai.pydantic.dev/) is a Python Agent Framework designed to make it less painful to build production grade applications with Generative AI. It uses Griffe to extract tool and parameter descriptions from docstrings.

## quartodoc

[quartodoc](https://machow.github.io/quartodoc/) lets you quickly generate Python package API reference documentation using Markdown and [Quarto](https://quarto.org/). quartodoc is designed as an alternative to [Sphinx](https://www.sphinx-doc.org/en/master/). It uses Griffe to load API data and parse docstrings in order to render HTML documentation, just like [mkdocstrings-python](https://mkdocstrings.github.io/python/), but for Quarto instead of Mkdocs.

## rafe

[rafe](https://pypi.org/project/rafe/) is a tool for inspecting Python environments and building packages (irrespective of language) in a reproducible manner. It wraps Griffe to provide a CLI command to check for API breaking changes.

## Yapper

[Yapper](https://pypi.org/project/yapper/) converts Python docstrings to `astro` files for use by the [Astro](https://astro.build/) static site generator. It uses Griffe to parse Python modules and extracts Numpydoc-style docstrings.

# Credits

These projects were used to build *griffe*. **Thank you!**

[Python](https://www.python.org/) | [uv](https://github.com/astral-sh/uv) | [copier-uv](https://github.com/pawamoy/copier-uv)

### Runtime dependencies

| Project                                                | Summary                                                                                            | Version (accepted) | Version (last resolved) | License     |
| ------------------------------------------------------ | -------------------------------------------------------------------------------------------------- | ------------------ | ----------------------- | ----------- |
| [colorama](https://pypi.org/project/colorama/)         | Cross-platform colored terminal text.                                                              | `>=0.4`            | `0.4.6`                 | BSD License |
| [platformdirs](https://pypi.org/project/platformdirs/) | A small Python package for determining appropriate platform-specific dirs, e.g. a `user data dir`. | `>=4.2, >=2.2.0`   | `4.3.8`                 | MIT         |

### Development dependencies

| Project                                                                                                          | Summary                                                                                                   | Version (accepted) | Version (last resolved)   | License                                                        |
| ---------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------ | ------------------------- | -------------------------------------------------------------- |
| [ansimarkup](https://pypi.org/project/ansimarkup/)                                                               | Produce colored terminal text with an xml-like markup                                                     | `~=1.4`            | `1.5.0`                   | Revised BSD License                                            |
| [appdirs](https://pypi.org/project/appdirs/)                                                                     | A small Python module for determining appropriate platform-specific dirs, e.g. a "user data dir".         | `>=1.4`            | `1.4.4`                   | MIT                                                            |
| [attrs](https://pypi.org/project/attrs/)                                                                         | Classes Without Boilerplate                                                                               | `>=22.2.0`         | `25.3.0`                  | MIT                                                            |
| [babel](https://pypi.org/project/babel/)                                                                         | Internationalization utilities                                                                            | `>=2.7.0`          | `2.17.0`                  | BSD-3-Clause                                                   |
| [backrefs](https://pypi.org/project/backrefs/)                                                                   | A wrapper around re and regex that adds additional back references.                                       | `~=5.7.post1`      | `5.9`                     | MIT                                                            |
| [beautifulsoup4](https://pypi.org/project/beautifulsoup4/)                                                       | Screen-scraping library                                                                                   | `>=4.12`           | `4.13.4`                  | MIT License                                                    |
| [build](https://pypi.org/project/build/)                                                                         | A simple, correct Python build frontend                                                                   | `>=1.2`            | `1.3.0`                   | MIT                                                            |
| [cappa](https://pypi.org/project/cappa/)                                                                         | Declarative CLI argument parser.                                                                          | `>=0.29`           | `0.29.1`                  | ?                                                              |
| [certifi](https://pypi.org/project/certifi/)                                                                     | Python package for providing Mozilla's CA Bundle.                                                         | `>=2017.4.17`      | `2025.8.3`                | MPL-2.0                                                        |
| [cffi](https://pypi.org/project/cffi/)                                                                           | Foreign Function Interface for Python calling C code.                                                     | `>=1.14`           | `1.17.1`                  | MIT                                                            |
| [charset-normalizer](https://pypi.org/project/charset-normalizer/)                                               | The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet.   | `>=2, <4`          | `3.4.2`                   | MIT                                                            |
| [click](https://pypi.org/project/click/)                                                                         | Composable command line interface toolkit                                                                 | `>=7.0`            | `8.2.1`                   | BSD-3-Clause                                                   |
| [code2flow](https://pypi.org/project/code2flow/)                                                                 | Visualize your source code as DOT flowcharts                                                              | `>=2.5`            | `2.5.1`                   | MIT                                                            |
| [colorama](https://pypi.org/project/colorama/)                                                                   | Cross-platform colored terminal text.                                                                     | `>=0.4`            | `0.4.6`                   | BSD License                                                    |
| [coverage](https://pypi.org/project/coverage/)                                                                   | Code coverage measurement for Python                                                                      | `>=7.5`            | `7.10.2`                  | Apache-2.0                                                     |
| [cryptography](https://pypi.org/project/cryptography/)                                                           | cryptography is a package which provides cryptographic recipes and primitives to Python developers.       | `>=2.0`            | `45.0.6`                  | Apache-2.0 OR BSD-3-Clause                                     |
| [csscompressor](https://pypi.org/project/csscompressor/)                                                         | A python port of YUI CSS Compressor                                                                       | `>=0.9.5`          | `0.9.5`                   | BSD                                                            |
| [docutils](https://pypi.org/project/docutils/)                                                                   | Docutils -- Python Documentation Utilities                                                                | `>=0.21.2`         | `0.22`                    | Public Domain + BSD License + GNU General Public License (GPL) |
| [duty](https://pypi.org/project/duty/)                                                                           | A simple task runner.                                                                                     | `>=1.6`            | `1.6.2`                   | ISC                                                            |
| [execnet](https://pypi.org/project/execnet/)                                                                     | execnet: rapid multi-Python deployment                                                                    | `>=2.1`            | `2.1.1`                   | MIT                                                            |
| [failprint](https://pypi.org/project/failprint/)                                                                 | Run a command, print its output only if it fails.                                                         | `>=1.0.5`          | `1.0.5`                   | ISC                                                            |
| [ghp-import](https://pypi.org/project/ghp-import/)                                                               | Copy your docs directly to the gh-pages branch.                                                           | `>=1.0`            | `2.1.0`                   | Apache Software License                                        |
| [git-changelog](https://pypi.org/project/git-changelog/)                                                         | Automatic Changelog generator using Jinja2 templates.                                                     | `>=2.5`            | `2.5.3`                   | ISC                                                            |
| [gitdb](https://pypi.org/project/gitdb/)                                                                         | Git Object Database                                                                                       | `>=4.0.1, <5`      | `4.0.12`                  | BSD License                                                    |
| [GitPython](https://pypi.org/project/GitPython/)                                                                 | GitPython is a Python library used to interact with Git repositories                                      | `>=3.1.44`         | `3.1.45`                  | BSD-3-Clause                                                   |
| [griffe-inherited-docstrings](https://pypi.org/project/griffe-inherited-docstrings/)                             | Griffe extension for inheriting docstrings.                                                               | `>=1.0`            | `1.1.1`                   | ISC                                                            |
| [htmlmin2](https://pypi.org/project/htmlmin2/)                                                                   | An HTML Minifier                                                                                          | `>=0.1.13`         | `0.1.13`                  | BSD                                                            |
| [humanize](https://pypi.org/project/humanize/)                                                                   | Python humanize utilities                                                                                 | `>=4.9`            | `4.12.3`                  | MIT                                                            |
| [id](https://pypi.org/project/id/)                                                                               | A tool for generating OIDC identities                                                                     |                    | `1.5.0`                   | Apache Software License                                        |
| [idna](https://pypi.org/project/idna/)                                                                           | Internationalized Domain Names in Applications (IDNA)                                                     | `>=2.5, <4`        | `3.10`                    | BSD License                                                    |
| [iniconfig](https://pypi.org/project/iniconfig/)                                                                 | brain-dead simple config-ini parsing                                                                      | `>=1`              | `2.1.0`                   | MIT                                                            |
| [jaraco.classes](https://pypi.org/project/jaraco.classes/)                                                       | Utility functions for Python class constructs                                                             |                    | `3.4.0`                   | MIT License                                                    |
| [jaraco.context](https://pypi.org/project/jaraco.context/)                                                       | Useful decorators and context managers                                                                    |                    | `6.0.1`                   | MIT License                                                    |
| [jaraco.functools](https://pypi.org/project/jaraco.functools/)                                                   | Functools like those found in stdlib                                                                      |                    | `4.2.1`                   | MIT                                                            |
| [jeepney](https://pypi.org/project/jeepney/)                                                                     | Low-level, pure Python DBus protocol wrapper.                                                             | `>=0.4.2`          | `0.9.0`                   | MIT                                                            |
| [Jinja2](https://pypi.org/project/Jinja2/)                                                                       | A very fast and expressive template engine.                                                               | `>=2.10`           | `3.1.6`                   | BSD License                                                    |
| [jsmin](https://pypi.org/project/jsmin/)                                                                         | JavaScript minifier.                                                                                      | `>=3.0.1`          | `3.0.1`                   | MIT License                                                    |
| [jsonschema](https://pypi.org/project/jsonschema/)                                                               | An implementation of JSON Schema validation for Python                                                    | `>=4.17`           | `4.25.0`                  | MIT                                                            |
| [jsonschema-specifications](https://pypi.org/project/jsonschema-specifications/)                                 | The JSON Schema meta-schemas and vocabularies, exposed as a Registry                                      | `>=2023.03.6`      | `2025.4.1`                | MIT                                                            |
| [keyring](https://pypi.org/project/keyring/)                                                                     | Store and access your passwords safely.                                                                   | `>=15.1`           | `25.6.0`                  | MIT License                                                    |
| [Markdown](https://pypi.org/project/Markdown/)                                                                   | Python implementation of John Gruber's Markdown.                                                          | `>=3.3.3`          | `3.8.2`                   | BSD-3-Clause                                                   |
| [markdown-callouts](https://pypi.org/project/markdown-callouts/)                                                 | Markdown extension: a classier syntax for admonitions                                                     | `>=0.4`            | `0.4.0`                   | MIT                                                            |
| [markdown-exec](https://pypi.org/project/markdown-exec/)                                                         | Utilities to execute code blocks in Markdown files.                                                       | `>=1.8`            | `1.11.0.1.1.1`            | ISC                                                            |
| [markdown-it-py](https://pypi.org/project/markdown-it-py/)                                                       | Python port of markdown-it. Markdown parsing, done right!                                                 | `>=2.2.0`          | `3.0.0`                   | MIT License                                                    |
| [markdownify](https://pypi.org/project/markdownify/)                                                             | Convert HTML to markdown.                                                                                 | `>=0.14`           | `1.1.0`                   | MIT License                                                    |
| [MarkupSafe](https://pypi.org/project/MarkupSafe/)                                                               | Safely add untrusted strings to HTML/XML markup.                                                          | `>=2.0`            | `3.0.2`                   | BSD License                                                    |
| [mdformat](https://pypi.org/project/mdformat/)                                                                   | CommonMark compliant Markdown formatter                                                                   | `>=0.7.21`         | `0.7.22`                  | MIT License                                                    |
| [mdformat_tables](https://pypi.org/project/mdformat_tables/)                                                     | An mdformat plugin for rendering tables.                                                                  | `>=1.0`            | `1.0.0`                   | MIT License                                                    |
| [mdurl](https://pypi.org/project/mdurl/)                                                                         | Markdown URL utilities                                                                                    | `~=0.1`            | `0.1.2`                   | MIT License                                                    |
| [mergedeep](https://pypi.org/project/mergedeep/)                                                                 | A deep merge function for 🐍.                                                                             | `~=1.3`            | `1.3.4`                   | MIT License                                                    |
| [mkdocs](https://pypi.org/project/mkdocs/)                                                                       | Project documentation with Markdown.                                                                      | `>=1.6`            | `1.6.1`                   | BSD-2-Clause                                                   |
| [mkdocs-autorefs](https://pypi.org/project/mkdocs-autorefs/)                                                     | Automatically link across pages in MkDocs.                                                                | `>=1.4`            | `1.4.2`                   | ISC                                                            |
| [mkdocs-coverage](https://pypi.org/project/mkdocs-coverage/)                                                     | MkDocs plugin to integrate your coverage HTML report into your site.                                      | `>=1.0`            | `1.1.0`                   | ISC                                                            |
| [mkdocs-gen-files](https://pypi.org/project/mkdocs-gen-files/)                                                   | MkDocs plugin to programmatically generate documentation pages during the build                           | `>=0.5`            | `0.5.0`                   | MIT                                                            |
| [mkdocs-get-deps](https://pypi.org/project/mkdocs-get-deps/)                                                     | MkDocs extension that lists all dependencies according to a mkdocs.yml file                               | `>=0.2.0`          | `0.2.0`                   | MIT                                                            |
| [mkdocs-git-revision-date-localized-plugin](https://pypi.org/project/mkdocs-git-revision-date-localized-plugin/) | Mkdocs plugin that enables displaying the localized date of the last git modification of a markdown file. | `>=1.2`            | `1.4.7`                   | MIT                                                            |
| [mkdocs-llmstxt](https://pypi.org/project/mkdocs-llmstxt/)                                                       | MkDocs plugin to generate an /llms.txt file.                                                              | `>=0.2`            | `0.3.1`                   | ISC                                                            |
| [mkdocs-material](https://pypi.org/project/mkdocs-material/)                                                     | Documentation that simply works                                                                           | `>=9.5`            | `9.6.15+insiders.4.53.16` | MIT                                                            |
| [mkdocs-material-extensions](https://pypi.org/project/mkdocs-material-extensions/)                               | Extension pack for Python Markdown and MkDocs Material.                                                   | `~=1.3`            | `1.3.1`                   | MIT                                                            |
| [mkdocs-minify-plugin](https://pypi.org/project/mkdocs-minify-plugin/)                                           | An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk                           | `>=0.8`            | `0.8.0`                   | MIT                                                            |
| [mkdocs-redirects](https://pypi.org/project/mkdocs-redirects/)                                                   | A MkDocs plugin for dynamic page redirects to prevent broken links                                        | `>=1.2`            | `1.2.2`                   | MIT                                                            |
| [mkdocs-section-index](https://pypi.org/project/mkdocs-section-index/)                                           | MkDocs plugin to allow clickable sections that lead to an index page                                      | `>=0.3`            | `0.3.10`                  | MIT                                                            |
| [mkdocstrings](https://pypi.org/project/mkdocstrings/)                                                           | Automatic documentation from sources, for MkDocs.                                                         | `>=0.29`           | `0.30.0`                  | ISC                                                            |
| [mkdocstrings-python](https://pypi.org/project/mkdocstrings-python/)                                             | A Python handler for mkdocstrings.                                                                        | `>=1.16.2`         | `1.16.12.1.12.1`          | ISC                                                            |
| [more-itertools](https://pypi.org/project/more-itertools/)                                                       | More routines for operating on iterables, beyond itertools                                                |                    | `10.7.0`                  | MIT License                                                    |
| [mypy](https://pypi.org/project/mypy/)                                                                           | Optional static typing for Python                                                                         | `>=1.10`           | `1.17.1`                  | MIT                                                            |
| [mypy_extensions](https://pypi.org/project/mypy_extensions/)                                                     | Type system extensions for programs checked with the mypy type checker.                                   | `>=1.0.0`          | `1.1.0`                   | MIT                                                            |
| [nh3](https://pypi.org/project/nh3/)                                                                             | Python binding to Ammonia HTML sanitizer Rust crate                                                       | `>=0.2.14`         | `0.3.0`                   | MIT                                                            |
| [packaging](https://pypi.org/project/packaging/)                                                                 | Core utilities for Python packages                                                                        | `>=20`             | `25.0`                    | Apache Software License + BSD License                          |
| [paginate](https://pypi.org/project/paginate/)                                                                   | Divides large result sets into pages for easier browsing                                                  | `~=0.5`            | `0.5.7`                   | MIT                                                            |
| [pathspec](https://pypi.org/project/pathspec/)                                                                   | Utility library for gitignore style pattern matching of file paths.                                       | `>=0.9.0`          | `0.12.1`                  | Mozilla Public License 2.0 (MPL 2.0)                           |
| [platformdirs](https://pypi.org/project/platformdirs/)                                                           | A small Python package for determining appropriate platform-specific dirs, e.g. a `user data dir`.        | `>=4.2, >=2.2.0`   | `4.3.8`                   | MIT                                                            |
| [pluggy](https://pypi.org/project/pluggy/)                                                                       | plugin and hook calling mechanisms for python                                                             | `>=1.2`            | `1.6.0`                   | MIT                                                            |
| [ptyprocess](https://pypi.org/project/ptyprocess/)                                                               | Run a subprocess in a pseudo terminal                                                                     | `~=0.6`            | `0.7.0`                   | ISC License (ISCL)                                             |
| [pycparser](https://pypi.org/project/pycparser/)                                                                 | C parser in Python                                                                                        |                    | `2.22`                    | BSD-3-Clause                                                   |
| [pydeps](https://pypi.org/project/pydeps/)                                                                       | Display module dependencies                                                                               | `>=1.12`           | `3.0.1`                   | BSD                                                            |
| [Pygments](https://pypi.org/project/Pygments/)                                                                   | Pygments is a syntax highlighting package written in Python.                                              | `>=2.7.2`          | `2.19.2`                  | BSD-2-Clause                                                   |
| [pygments-ansi-color](https://pypi.org/project/pygments-ansi-color/)                                             |                                                                                                           | `>=0.3`            | `0.3.0`                   | Apache Software License                                        |
| [pymdown-extensions](https://pypi.org/project/pymdown-extensions/)                                               | Extension pack for Python Markdown.                                                                       | `>=9`              | `10.16.1`                 | MIT                                                            |
| [pyproject_hooks](https://pypi.org/project/pyproject_hooks/)                                                     | Wrappers to call pyproject.toml-based build backend hooks.                                                |                    | `1.2.0`                   | MIT License                                                    |
| [pysource-codegen](https://pypi.org/project/pysource-codegen/)                                                   | generate random python code to test linter/formatter/and other tools                                      | `>=0.4`            | `0.6.0`                   | MIT                                                            |
| [pysource-minimize](https://pypi.org/project/pysource-minimize/)                                                 | minimize python source code                                                                               | `>=0.5`            | `0.9.0`                   | MIT                                                            |
| [pytest](https://pypi.org/project/pytest/)                                                                       | pytest: simple powerful testing with Python                                                               | `>=8.2`            | `8.4.1`                   | MIT                                                            |
| [pytest-cov](https://pypi.org/project/pytest-cov/)                                                               | Pytest plugin for measuring coverage.                                                                     | `>=5.0`            | `6.2.1`                   | MIT                                                            |
| [pytest-randomly](https://pypi.org/project/pytest-randomly/)                                                     | Pytest plugin to randomly order tests and control random.seed.                                            | `>=3.15`           | `3.16.0`                  | MIT License                                                    |
| [pytest-xdist](https://pypi.org/project/pytest-xdist/)                                                           | pytest xdist plugin for distributed testing, most importantly across multiple CPUs                        | `>=3.6`            | `3.8.0`                   | MIT                                                            |
| [python-dateutil](https://pypi.org/project/python-dateutil/)                                                     | Extensions to the standard Python datetime module                                                         | `>=2.8.1`          | `2.9.0.post0`             | BSD License + Apache Software License                          |
| [pytz](https://pypi.org/project/pytz/)                                                                           | World timezone definitions, modern and historical                                                         | `>=2025.1`         | `2025.2`                  | MIT                                                            |
| [PyYAML](https://pypi.org/project/PyYAML/)                                                                       | YAML parser and emitter for Python                                                                        | `>=5.1`            | `6.0.2`                   | MIT                                                            |
| [pyyaml_env_tag](https://pypi.org/project/pyyaml_env_tag/)                                                       | A custom YAML tag for referencing environment variables in YAML files.                                    | `>=0.1`            | `1.1`                     | MIT                                                            |
| [readme_renderer](https://pypi.org/project/readme_renderer/)                                                     | readme_renderer is a library for rendering readme descriptions for Warehouse                              | `>=35.0`           | `44.0`                    | Apache License, Version 2.0                                    |
| [referencing](https://pypi.org/project/referencing/)                                                             | JSON Referencing + Python                                                                                 | `>=0.28.4`         | `0.36.2`                  | MIT                                                            |
| [requests](https://pypi.org/project/requests/)                                                                   | Python HTTP for Humans.                                                                                   | `>=2.20`           | `2.32.4`                  | Apache-2.0                                                     |
| [requests-toolbelt](https://pypi.org/project/requests-toolbelt/)                                                 | A utility belt for advanced users of python-requests                                                      | `>=0.8.0, !=0.9.0` | `1.0.0`                   | Apache 2.0                                                     |
| [rfc3986](https://pypi.org/project/rfc3986/)                                                                     | Validating URI References per RFC 3986                                                                    | `>=1.4.0`          | `2.0.0`                   | Apache 2.0                                                     |
| [rich](https://pypi.org/project/rich/)                                                                           | Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal           | `>=12.0.0`         | `14.1.0`                  | MIT                                                            |
| [rpds-py](https://pypi.org/project/rpds-py/)                                                                     | Python bindings to Rust's persistent data structures (rpds)                                               | `>=0.7.1`          | `0.26.0`                  | MIT                                                            |
| [ruff](https://pypi.org/project/ruff/)                                                                           | An extremely fast Python linter and code formatter, written in Rust.                                      | `>=0.4`            | `0.12.7`                  | MIT License                                                    |
| [SecretStorage](https://pypi.org/project/SecretStorage/)                                                         | Python bindings to FreeDesktop.org Secret Service API                                                     | `>=3.2`            | `3.3.3`                   | BSD 3-Clause License                                           |
| [semver](https://pypi.org/project/semver/)                                                                       | Python helper for Semantic Versioning (<https://semver.org>)                                              | `>=2.13`           | `3.0.4`                   | BSD License                                                    |
| [six](https://pypi.org/project/six/)                                                                             | Python 2 and 3 compatibility utilities                                                                    | `>=1.15, <2`       | `1.17.0`                  | MIT                                                            |
| [smmap](https://pypi.org/project/smmap/)                                                                         | A pure Python implementation of a sliding window memory map manager                                       | `>=3.0.1, <6`      | `5.0.2`                   | BSD-3-Clause                                                   |
| [soupsieve](https://pypi.org/project/soupsieve/)                                                                 | A modern CSS selector implementation for Beautiful Soup.                                                  | `>1.2`             | `2.7`                     | MIT                                                            |
| [stdlib-list](https://pypi.org/project/stdlib-list/)                                                             | A list of Python Standard Libraries (2.7 through 3.13).                                                   |                    | `0.11.1`                  | MIT License                                                    |
| [twine](https://pypi.org/project/twine/)                                                                         | Collection of utilities for publishing packages on PyPI                                                   | `>=5.1`            | `6.1.0`                   | Apache Software License                                        |
| [type-lens](https://pypi.org/project/type-lens/)                                                                 | type-lens is a Python template project designed to simplify the setup of a new project.                   | `>=0.2.4`          | `0.2.4`                   | MIT                                                            |
| [types-Markdown](https://pypi.org/project/types-Markdown/)                                                       | Typing stubs for Markdown                                                                                 | `>=3.6`            | `3.8.0.20250708`          | Apache-2.0                                                     |
| [types-PyYAML](https://pypi.org/project/types-PyYAML/)                                                           | Typing stubs for PyYAML                                                                                   | `>=6.0`            | `6.0.12.20250516`         | Apache-2.0                                                     |
| [typing_extensions](https://pypi.org/project/typing_extensions/)                                                 | Backported and Experimental Type Hints for Python 3.9+                                                    | `>=4.9`            | `4.14.1`                  | PSF-2.0                                                        |
| [urllib3](https://pypi.org/project/urllib3/)                                                                     | HTTP library with thread-safe connection pooling, file post, and more.                                    | `>=1.26.0`         | `2.5.0`                   | MIT                                                            |
| [watchdog](https://pypi.org/project/watchdog/)                                                                   | Filesystem events monitoring                                                                              | `>=2.0`            | `6.0.0`                   | Apache-2.0                                                     |
| [wcwidth](https://pypi.org/project/wcwidth/)                                                                     | Measures the displayed width of unicode strings in a terminal                                             | `>=0.2.13`         | `0.2.13`                  | MIT                                                            |
| [yore](https://pypi.org/project/yore/)                                                                           | Manage legacy code with comments.                                                                         | `>=0.3.3`          | `0.4.5`                   | ISC                                                            |

**[More credits from the author](http://pawamoy.github.io/credits/)**

# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/) and this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).

## [1.12.0](https://github.com/mkdocstrings/griffe/releases/tag/1.12.0) - 2025-08-14

[Compare with 1.11.1](https://github.com/mkdocstrings/griffe/compare/1.11.1...1.12.0)

### Features

- Allow disabling "missing type/annotation" warnings ([07564b4](https://github.com/mkdocstrings/griffe/commit/07564b43524220342c3078ece406459c08b80a86) by Timothée Mazzucotelli). [Issue-mkdocstrings-437](https://github.com/mkdocstrings/mkdocstrings/issues/437)

## [1.11.1](https://github.com/mkdocstrings/griffe/releases/tag/1.11.1) - 2025-08-11

[Compare with 1.11.0](https://github.com/mkdocstrings/griffe/compare/1.11.0...1.11.1)

### Bug Fixes

- Fix type parameters loading ([ce41279](https://github.com/mkdocstrings/griffe/commit/ce41279cc8b7abc45c7b94316b24e87d4a1edc40) by Timothée Mazzucotelli).

### Code Refactoring

- Move private `_griffe` package under `griffe._internal` ([8f37158](https://github.com/mkdocstrings/griffe/commit/8f37158eb5617d2cf686f9a0a044f29c638598b2) by Timothée Mazzucotelli).

## [1.11.0](https://github.com/mkdocstrings/griffe/releases/tag/1.11.0) - 2025-08-07

[Compare with 1.10.0](https://github.com/mkdocstrings/griffe/compare/1.10.0...1.11.0)

### Features

- Add data to dict/json output ([9731afc](https://github.com/mkdocstrings/griffe/commit/9731afcbeab377e7f3f69a0d18d19677e790072e) by Timothée Mazzucotelli).

## [1.10.0](https://github.com/mkdocstrings/griffe/releases/tag/1.10.0) - 2025-08-06

[Compare with 1.9.0](https://github.com/mkdocstrings/griffe/compare/1.9.0...1.10.0)

### Features

- Allow adding `sys.path` to search paths when temporary visiting/inspecting package ([42983bc](https://github.com/mkdocstrings/griffe/commit/42983bc843fd9a63883e9c50ad5043b0f737b450) by Timothée Mazzucotelli).

## [1.9.0](https://github.com/mkdocstrings/griffe/releases/tag/1.9.0) - 2025-07-28

[Compare with 1.8.0](https://github.com/mkdocstrings/griffe/compare/1.8.0...1.9.0)

### Features

- Support PEP 695 generics ([be28e9c](https://github.com/mkdocstrings/griffe/commit/be28e9c9835a709fca0a78990c56e8d652a71a8c) by Victor Westerhuis). [Issue-342](https://github.com/mkdocstrings/griffe/issues/342), [PR-348](https://github.com/mkdocstrings/griffe/pull/348), Co-authored-by: Timothée Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)

## [1.8.0](https://github.com/mkdocstrings/griffe/releases/tag/1.8.0) - 2025-07-23

[Compare with 1.7.3](https://github.com/mkdocstrings/griffe/compare/1.7.3...1.8.0)

### Features

- Add method to functions and classes to build and return a stringified signature ([8ef1486](https://github.com/mkdocstrings/griffe/commit/8ef1486e9b1f0872cca3b1cd2419144b702a0c1e) by ISOREX). [Discussion-376](https://github.com/mkdocstrings/griffe/discussions/376), [PR-381](https://github.com/mkdocstrings/griffe/pull/381), Co-authored-by: Timothée Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Enhance Sphinx-style parameter parsing to handle invalid type info ([cbce5a2](https://github.com/mkdocstrings/griffe/commit/cbce5a2c2429dc92e15ac3a8fe53db55825ebd6c) by Edouard Choinière). [PR-396](https://github.com/mkdocstrings/griffe/pull/396)
- Parse Sphinx parameter types as expressions ([70dda21](https://github.com/mkdocstrings/griffe/commit/70dda21d15dfdf5807dde370fb636d69eea6272b) by Edouard Choinière). [PR-392](https://github.com/mkdocstrings/griffe/pull/392)

### Bug Fixes

- Avoid SyntaxError when loading modules encoded in UTF8 with BOM ([b346190](https://github.com/mkdocstrings/griffe/commit/b3461901ae08204ea6184025a006f5d34152d30d) by John Hennig). [Issue-386](https://github.com/mkdocstrings/griffe/issues/386), [PR-387](https://github.com/mkdocstrings/griffe/pull/387), Co-authored-by: Timothée Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Correctly parenthesize expressions ([a8c5585](https://github.com/mkdocstrings/griffe/commit/a8c5585c8a45a4d6b67bd5dc36d7054478d3873d) by Abraham Cheung). [PR-389](https://github.com/mkdocstrings/griffe/pull/389), Co-authored-by: Timothée Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)

### Code Refactoring

- Be more consistent regarding not overriding submodules with aliases ([be1963c](https://github.com/mkdocstrings/griffe/commit/be1963cca6d7d49bcc41fdf05570b1bfba934330) by Timothée Mazzucotelli).
- Allow `ExprName.parent` to be of type `griffe.Function` ([acafbd8](https://github.com/mkdocstrings/griffe/commit/acafbd8b6d97fe8370f3eb730e2154e19b2c1a54) by Edouard Choinière). [Issue-391](https://github.com/mkdocstrings/griffe/discussions/391), [PR-395](https://github.com/mkdocstrings/griffe/pull/395)
- Normalize labels for attributes ([1b376cd](https://github.com/mkdocstrings/griffe/commit/1b376cd39ce99730910d8344abbfd5c53ce28300) by Timothée Mazzucotelli).

## [1.7.3](https://github.com/mkdocstrings/griffe/releases/tag/1.7.3) - 2025-04-23

[Compare with 1.7.2](https://github.com/mkdocstrings/griffe/compare/1.7.2...1.7.3)

### Bug Fixes

- Don't output color codes with GitHub format ([2666399](https://github.com/mkdocstrings/griffe/commit/2666399a2ca34644cabc265f803754ca8aef6aa7) by Timothée Mazzucotelli). [Issue-378](https://github.com/mkdocstrings/griffe/issues/378)

### Code Refactoring

- Log a debug message when inspecting a module raises an error ([4e73b3e](https://github.com/mkdocstrings/griffe/commit/4e73b3e4d85018f5523aa907246dad760723eb3c) by Timothée Mazzucotelli). [Issue-mkdocstrings-753](https://github.com/mkdocstrings/mkdocstrings/issues/753)

## [1.7.2](https://github.com/mkdocstrings/griffe/releases/tag/1.7.2) - 2025-04-01

[Compare with 1.7.1](https://github.com/mkdocstrings/griffe/compare/1.7.1...1.7.2)

### Bug Fixes

- Override exports when merging module stubs ([94f23e7](https://github.com/mkdocstrings/griffe/commit/94f23e72e456310d37765ea2eecf29cf655d34d3) by Timothée Mazzucotelli). [Issue-mkdocstrings-751](https://github.com/mkdocstrings/mkdocstrings/issues/751)
- Override attribute values when merging stubs ([b940c51](https://github.com/mkdocstrings/griffe/commit/b940c51ba729ce39465bd92a40b0f5464d7d346c) by Timothée Mazzucotelli). [Issue-mkdocstrings-751](https://github.com/mkdocstrings/mkdocstrings/issues/751)

## [1.7.1](https://github.com/mkdocstrings/griffe/releases/tag/1.7.1) - 2025-03-29

[Compare with 1.7.0](https://github.com/mkdocstrings/griffe/compare/1.7.0...1.7.1)

### Bug Fixes

- Never raise alias resolution error when resolving a name from an `__init__` method scope ([949ff7d](https://github.com/mkdocstrings/griffe/commit/949ff7dd3916a96f52068ceefebeed9c2ac16cee) by Timothée Mazzucotelli). [Issue-374](https://github.com/mkdocstrings/griffe/issues/374)

## [1.7.0](https://github.com/mkdocstrings/griffe/releases/tag/1.7.0) - 2025-03-27

[Compare with 1.6.3](https://github.com/mkdocstrings/griffe/compare/1.6.3...1.7.0)

### Dependencies

- Remove dependency to `astunparse` (Python 3.8-) ([fd052b1](https://github.com/mkdocstrings/griffe/commit/fd052b1e6079ae1883ac3db43708b5cc17ae5cf6) by Timothée Mazzucotelli).

### Features

- Add `warnings` parameter to docstring parsers, allowing to disable all warning logs when parsing docstrings ([7ac01ba](https://github.com/mkdocstrings/griffe/commit/7ac01ba4da62176119fcf249c338eb3110d15513) by Timothée Mazzucotelli). [Issue-293](https://github.com/mkdocstrings/griffe/issues/293)

## [1.6.3](https://github.com/mkdocstrings/griffe/releases/tag/1.6.3) - 2025-03-26

[Compare with 1.6.2](https://github.com/mkdocstrings/griffe/compare/1.6.2...1.6.3)

### Bug Fixes

- Allow setting `lineno`, `endlineno` and `value` through aliases ([d038eaa](https://github.com/mkdocstrings/griffe/commit/d038eaa1eb96cab7e70a4ceebacd4246f6a1cfb4) by Timothée Mazzucotelli). [Issue-griffe-pydantic-29](https://github.com/mkdocstrings/griffe-pydantic/issues/29)
- Don't resolve attribute values to attribute with same name ([25cc58f](https://github.com/mkdocstrings/griffe/commit/25cc58fae55b6b34b2938fdce6acc80ea0e78aff) by Timothée Mazzucotelli). [Issue-367](https://github.com/mkdocstrings/griffe/issues/367)

### Code Refactoring

- Improve objects conversion to annotation during dynamic analysis ([716d27b](https://github.com/mkdocstrings/griffe/commit/716d27b0c9bdd798d35a23d999431b62b0b647da) by Timothée Mazzucotelli). [Issue-369](https://github.com/mkdocstrings/griffe/issues/369)

## [1.6.2](https://github.com/mkdocstrings/griffe/releases/tag/1.6.2) - 2025-03-20

[Compare with 1.6.1](https://github.com/mkdocstrings/griffe/compare/1.6.1...1.6.2)

### Code Refactoring

- Maintain exports order (`__all__`) ([ded36bf](https://github.com/mkdocstrings/griffe/commit/ded36bf94ed4b8b83797e9da4a3d034d0533a5bd) by Timothée Mazzucotelli).

## [1.6.1](https://github.com/mkdocstrings/griffe/releases/tag/1.6.1) - 2025-03-18

[Compare with 1.6.0](https://github.com/mkdocstrings/griffe/compare/1.6.0...1.6.1)

### Bug Fixes

- Extend exports from already expanded modules ([7e708cf](https://github.com/mkdocstrings/griffe/commit/7e708cf9ffe1845d310633e8486b99d32d5fca5c) by Timothée Mazzucotelli). [Issue-746](https://github.com/mkdocstrings/mkdocstrings/discussions/746)
- Update imports when merging stubs ([5a92379](https://github.com/mkdocstrings/griffe/commit/5a92379e42c5a8bebc9323aabbbc9df881463718) by Timothée Mazzucotelli). [Issue-746](https://github.com/mkdocstrings/mkdocstrings/discussions/746)
- Don't alias attributes when inspecting ([8063ba9](https://github.com/mkdocstrings/griffe/commit/8063ba9fd4b3d1f782515b81ba362c63d4ccd2bd) by Timothée Mazzucotelli). [Issue-366](https://github.com/mkdocstrings/griffe/issues/366)
- Register top-module in collection earlier ([2c389b5](https://github.com/mkdocstrings/griffe/commit/2c389b57781c3c24a21141ad3d0103458418ec51) by Timothée Mazzucotelli).
- Prevent recursion errors by not looking into inherited members when resolving base classes ([87cbaf8](https://github.com/mkdocstrings/griffe/commit/87cbaf87f09103b5972a47fdf5437e00df6e830a) by Timothée Mazzucotelli).

## [1.6.0](https://github.com/mkdocstrings/griffe/releases/tag/1.6.0) - 2025-03-01

[Compare with 1.5.7](https://github.com/mkdocstrings/griffe/compare/1.5.7...1.6.0)

### Features

- Allow passing literal docstring styles everywhere in the API, not just `Parser` enumeration values ([053bf20](https://github.com/mkdocstrings/griffe/commit/053bf20e8da49f6bc0171c1755ee4fde1fb401fa) by Timothée Mazzucotelli).

### Bug Fixes

- Follow symlinks when finding modules ([087832f](https://github.com/mkdocstrings/griffe/commit/087832f07dfb8dc529cf68438e7051bd8ce2ae1d) by Timothée Mazzucotelli). [Issue-mkdocstrings-python-258](https://github.com/mkdocstrings/python/issues/258)

## [1.5.7](https://github.com/mkdocstrings/griffe/releases/tag/1.5.7) - 2025-02-11

[Compare with 1.5.6](https://github.com/mkdocstrings/griffe/compare/1.5.6...1.5.7)

### Bug Fixes

- Don't conflate passed argument with class member (instance attribute) ([4791b0b](https://github.com/mkdocstrings/griffe/commit/4791b0b5739e64ab2d225b299aea723f3cfbdf00) by Timothée Mazzucotelli). [Issue-357](https://github.com/mkdocstrings/griffe/issues/357)

## [1.5.6](https://github.com/mkdocstrings/griffe/releases/tag/1.5.6) - 2025-01-30

[Compare with 1.5.5](https://github.com/mkdocstrings/griffe/compare/1.5.5...1.5.6)

### Bug Fixes

- Handle get/set descriptor objects as properties during dynamic analysis ([bc3c75a](https://github.com/mkdocstrings/griffe/commit/bc3c75acd440356fd7b91d221a8fca87231a6eab) by Timothée Mazzucotelli). [Issue-354](https://github.com/mkdocstrings/griffe/issues/354)

### Code Refactoring

- Remove Google parser support for Deprecated sections (previously never used) ([425aece](https://github.com/mkdocstrings/griffe/commit/425aeceb9935be446979b669c9d557db84a36873) by Timothée Mazzucotelli).

## [1.5.5](https://github.com/mkdocstrings/griffe/releases/tag/1.5.5) - 2025-01-16

[Compare with 1.5.4](https://github.com/mkdocstrings/griffe/compare/1.5.4...1.5.5)

### Bug Fixes

- Fix check command's Markdown output format not displaying parameter names ([5e7af22](https://github.com/mkdocstrings/griffe/commit/5e7af227792f602c8e1c40707bc7c058e272ce12) by Timothée Mazzucotelli).
- Don't output empty change for removed objects when using GitHub output format (check command) ([6842372](https://github.com/mkdocstrings/griffe/commit/68423726c625649dd35b5c8018c752dbb72e5be2) by Timothée Mazzucotelli). [Issue-349](https://github.com/mkdocstrings/griffe/issues/349)

## [1.5.4](https://github.com/mkdocstrings/griffe/releases/tag/1.5.4) - 2024-12-26

[Compare with 1.5.3](https://github.com/mkdocstrings/griffe/compare/1.5.3...1.5.4)

### Bug Fixes

- Append trailing comma to length-1 tuples ([4fccca7](https://github.com/mkdocstrings/griffe/commit/4fccca7dd8d8a3dd31ccc88930ca89f4f26d26b0) by Timothée Mazzucotelli). [Issue-343](https://github.com/mkdocstrings/griffe/issues/343)

### Performance Improvements

- Avoid dictionary creation when accessing members of non-classes with subscript syntax ([0279998](https://github.com/mkdocstrings/griffe/commit/027999881415bea9e890493d3ef20b96b8749c4a) by Timothée Mazzucotelli).

## [1.5.3](https://github.com/mkdocstrings/griffe/releases/tag/1.5.3) - 2024-12-26

[Compare with 1.5.2](https://github.com/mkdocstrings/griffe/compare/1.5.2...1.5.3)

### Code Refactoring

- Stop caching objects' inherited members, aliases' members and inherited members, classes' resolved bases ([e8db3a2](https://github.com/mkdocstrings/griffe/commit/e8db3a2d6c5c2a19a1fa3fc924f11c57d8e86a8e) by Timothée Mazzucotelli). [Issue-346](https://github.com/mkdocstrings/griffe/issues/346)

## [1.5.2](https://github.com/mkdocstrings/griffe/releases/tag/1.5.2) - 2024-12-26

[Compare with 1.5.1](https://github.com/mkdocstrings/griffe/compare/1.5.1...1.5.2)

### Bug Fixes

- Always resolve aliases when checking APIs ([0b4f0da](https://github.com/mkdocstrings/griffe/commit/0b4f0da1658a3c4877a2519447288c1247694a0d) by Timothée Mazzucotelli).
- Don't use same branch name when creating a worktree ([6d6c996](https://github.com/mkdocstrings/griffe/commit/6d6c99679976a18233ccda5e5cbfb4eb176312fd) by Timothée Mazzucotelli). [Issue-337](https://github.com/mkdocstrings/griffe/issues/337)
- Fetch attribute annotations from inherited members too when parsing docstrings ([88fb6b6](https://github.com/mkdocstrings/griffe/commit/88fb6b6abd286b5552887023faa1a22f30cb11e7) by Timothée Mazzucotelli). [Issue-mkdocstrings/python#175](https://github.com/mkdocstrings/python/issues/175)

## [1.5.1](https://github.com/mkdocstrings/griffe/releases/tag/1.5.1) - 2024-10-18

[Compare with 1.5.0](https://github.com/mkdocstrings/griffe/compare/1.5.0...1.5.1)

### Bug Fixes

- Sort Git tags using `creatordate` field, which works with both lightweight and annotated tags ([3bfa401](https://github.com/mkdocstrings/griffe/commit/3bfa4015c333dd7e56e535aa31bd2296701b6fa5) by Timothée Mazzucotelli). [Issue-327](https://github.com/mkdocstrings/griffe/issues/327)

## [1.5.0](https://github.com/mkdocstrings/griffe/releases/tag/1.5.0) - 2024-10-18

[Compare with 1.4.1](https://github.com/mkdocstrings/griffe/compare/1.4.1...1.5.0)

### Features

- Allow setting and deleting parameters within container ([19f354d](https://github.com/mkdocstrings/griffe/commit/19f354da6a331a12d80a61bd3005cdcc30a3c42c) by Timothée Mazzucotelli).

## [1.4.1](https://github.com/mkdocstrings/griffe/releases/tag/1.4.1) - 2024-10-12

[Compare with 1.4.0](https://github.com/mkdocstrings/griffe/compare/1.4.0...1.4.1)

### Code Refactoring

- Drop support for Python 3.8 ([f2d39b8](https://github.com/mkdocstrings/griffe/commit/f2d39b8ed40f2b90ac15fd7ad818b3c59b657a43) by Timothée Mazzucotelli).

## [1.4.0](https://github.com/mkdocstrings/griffe/releases/tag/1.4.0) - 2024-10-11

[Compare with 1.3.2](https://github.com/mkdocstrings/griffe/compare/1.3.2...1.4.0)

### Features

- Add Markdown and GitHub output formats to the `griffe check` command ([806805c](https://github.com/mkdocstrings/griffe/commit/806805c3970a7cf3f32eec436255ea1323a60e1a) by Timothée Mazzucotelli).

## [1.3.2](https://github.com/mkdocstrings/griffe/releases/tag/1.3.2) - 2024-10-01

[Compare with 1.3.1](https://github.com/mkdocstrings/griffe/compare/1.3.1...1.3.2)

### Bug Fixes

- Normalize paths of temporary Git worktrees ([0821e67](https://github.com/mkdocstrings/griffe/commit/0821e6784e5a3aeb56020867c8b46f9477621ed3) by Timothée Mazzucotelli). [Issue-324](https://github.com/mkdocstrings/griffe/issues/324)

## [1.3.1](https://github.com/mkdocstrings/griffe/releases/tag/1.3.1) - 2024-09-12

[Compare with 1.3.0](https://github.com/mkdocstrings/griffe/compare/1.3.0...1.3.1)

### Bug Fixes

- Refactor and fix logic again for fetching returns/yields/receives annotation from parents ([a80bd3c](https://github.com/mkdocstrings/griffe/commit/a80bd3c0cc14e5f6efc30fb804b8c7fccb319276) by Timothée Mazzucotelli). [Follow-up-of-PR-322](https://github.com/mkdocstrings/griffe/pull/322)
- Don't crash on invalid signature given "Receives" section ([1cb8f51](https://github.com/mkdocstrings/griffe/commit/1cb8f514eae9d588cfce8cbbfc3ef84d7deadb47) by Timothée Mazzucotelli).

## [1.3.0](https://github.com/mkdocstrings/griffe/releases/tag/1.3.0) - 2024-09-10

[Compare with 1.2.0](https://github.com/mkdocstrings/griffe/compare/1.2.0...1.3.0)

### Features

- Allow deselecting multiple or named items in Yields and Receives ([344df50](https://github.com/mkdocstrings/griffe/commit/344df50bfcd66ddb3b8d8250babb40012cbc82b5) by Marco Ricci). [Issue-263](https://github.com/mkdocstrings/griffe/issues/263)

### Bug Fixes

- Don't crash when trying to merge stubs into a compiled module that has no file path ([e1f3ed9](https://github.com/mkdocstrings/griffe/commit/e1f3ed9ad3b046bf137de22f855bb392a76ca116) by Timothée Mazzucotelli). [Issue-323](https://github.com/mkdocstrings/griffe/issues/323)
- Fix identity checks in inspector when handling attributes ([676cfb4](https://github.com/mkdocstrings/griffe/commit/676cfb44a79e059f74514ff492035e930ed57d03) by Timothée Mazzucotelli).

### Code Refactoring

- Extract common functionality in Returns, Yields and Receives parsing ([c768356](https://github.com/mkdocstrings/griffe/commit/c768356023e1fedaaa3f896b073457a0af34ce0e) by Marco Ricci). [Issue-263](https://github.com/mkdocstrings/griffe/issues/263)
- Remove useless branch in `resolve` method, add tests for it ([aa6c7e4](https://github.com/mkdocstrings/griffe/commit/aa6c7e4d3dbabef384193b778cfdafd05a7102c2) by Timothée Mazzucotelli).

## [1.2.0](https://github.com/mkdocstrings/griffe/releases/tag/1.2.0) - 2024-08-23

[Compare with 1.1.1](https://github.com/mkdocstrings/griffe/compare/1.1.1...1.2.0)

### Features

- Support attribute syntax in `__all__` values ([ad99794](https://github.com/mkdocstrings/griffe/commit/ad997940b136d315787fcb11c03fc70a40c7e8c2) by Timothée Mazzucotelli). [Issue-316](https://github.com/mkdocstrings/griffe/issues/316)

## [1.1.1](https://github.com/mkdocstrings/griffe/releases/tag/1.1.1) - 2024-08-20

[Compare with 1.1.0](https://github.com/mkdocstrings/griffe/compare/1.1.0...1.1.1)

### Bug Fixes

- Preemptively expand `__all__` values and wildcard imports before firing the `on_package_loaded` event ([21b3780](https://github.com/mkdocstrings/griffe/commit/21b3780b1a3f7ac62a3380089857a720b646dc4a) by Timothée Mazzucotelli).

## [1.1.0](https://github.com/mkdocstrings/griffe/releases/tag/1.1.0) - 2024-08-17

[Compare with 1.0.0](https://github.com/mkdocstrings/griffe/compare/1.0.0...1.1.0)

### Features

- Add `on_wildcard_expansion` event ([c6bc6fa](https://github.com/mkdocstrings/griffe/commit/c6bc6fa858a43ea2180f97fd270075d7ee7169e3) by Timothée Mazzucotelli). [Issue-282](https://github.com/mkdocstrings/griffe/issues/282)
- Add `on_alias` event ([a760a8c](https://github.com/mkdocstrings/griffe/commit/a760a8c684cae0da6b6cc83e37d1d374bfeed662) by Timothée Mazzucotelli). [Issue-282](https://github.com/mkdocstrings/griffe/issues/282)
- Pass `loader` to `on_package_loaded` hooks ([7f82dc3](https://github.com/mkdocstrings/griffe/commit/7f82dc382f1f20ee9e5f58a9ef7a775563894056) by Timothée Mazzucotelli).

## [1.0.0](https://github.com/mkdocstrings/griffe/releases/tag/1.0.0) - 2024-08-15

[Compare with 0.49.0](https://github.com/mkdocstrings/griffe/compare/0.49.0...1.0.0)

**V1!**

### Breaking changes

Highlights:

- Extensions inherit from `Extension`, (`VisitorExtension` and `InspectorExtension` are removed)
- Members are serialized (`as_dict`/JSON) as a dictionary instead of a list
- All objects are available in the top-level `griffe` module, nowhere else

Removed objects:

- all modules under the `griffe` package
- the `griffe.DocstringWarningCallable` class
- the `griffe.When` class
- the `griffe.ExtensionType` type
- the `griffe.InspectorExtension` class
- the `griffe.VisitorExtension` class
- the `griffe.HybridExtension` extension
- the `griffe.patch_logger` function
- the `griffe.JSONEncoder.docstring_parser` attribute
- the `griffe.JSONEncoder.docstring_options` attribute
- the `griffe.Extensions.attach_visitor` method
- the `griffe.Extensions.attach_inspector` method
- the `griffe.Extensions.before_visit` method
- the `griffe.Extensions.before_children_visit` method
- the `griffe.Extensions.after_children_visit` method
- the `griffe.Extensions.after_visit` method
- the `griffe.Extensions.before_inspection` method
- the `griffe.Extensions.before_children_inspection` method
- the `griffe.Extensions.after_children_inspection` method
- the `griffe.Extensions.after_inspection` method
- the `griffe.GriffeLoader.load_module` method
- the `has_special_name` and `has_private_name` properties on objects
- the `is_explicitely_exported` and `is_implicitely_exported` properties on objects
- the `member_is_exported` method on objects

Renamed/moved objects:

- `griffe.Function.setter` -> `griffe.Attribute.setter`
- `griffe.Function.deleter` -> `griffe.Attribute.deleter`

Signatures:

- `griffe.docstring_warning(name)` parameter was removed
- `griffe.GriffeLoader.load(module)` parameter was removed
- `griffe.load(module)` parameter was removed
- `griffe.load_git(module)` parameter was removed
- `griffe.find_breaking_changes(ignore_private)` parameter was removed
- see previous deprecations

### Code Refactoring

- Remove all legacy code for v1 ([86d321e](https://github.com/mkdocstrings/griffe/commit/86d321ed1303f7bde28950f14ea75412be1d6888) and [fd72083](https://github.com/mkdocstrings/griffe/commit/fd72083fa06c3eb4ef76fe74c5126eef308766c0)by Timothée Mazzucotelli). [PR-314](https://github.com/mkdocstrings/griffe/pull/314)

## [0.49.0](https://github.com/mkdocstrings/griffe/releases/tag/0.49.0) - 2024-08-14

[Compare with 0.48.0](https://github.com/mkdocstrings/griffe/compare/0.48.0...0.49.0)

⚡ Imminent v1! ⚡🚀 See [v0.46](#0460-2024-06-16).

### Deprecations

- Cancel deprecation of `get_logger` and `patch_loggers` (and deprecate `patch_logger` instead). Extensions need loggers too, distinct ones, and they were forgotten... Sorry for the back and forth 🙇
- Attributes `setter` and `deleter` on `Function` are deprecated. They were moved into the `Attribute` class since properties are instantiated as attributes, not functions.
- Extension hooks must accept `**kwargs` in their signature, to allow forward-compatibility. Accepting `**kwargs` also makes it possible to remove unused arguments from the signature.
- In version 1, Griffe will serialize object members as dictionaries instead of lists. Lists were initially used to preserve source order, but source order can be re-obtained thanks to the line number attributes (`lineno`, `endlineno`). Version 0.49 is able to load both lists and dictionaries from JSON dumps, and version 1 will maintain this ability. However external tools loading JSON dumps will need to be updated.

### Features

- Add `temporary_inspected_package` helper ([3c4ba16](https://github.com/mkdocstrings/griffe/commit/3c4ba160ca4c3407bc60d9125e0d93ae5e08d8f3) by Timothée Mazzucotelli).
- Accept alias resolution related parameters in `temporary_visited_package` ([7d5408a](https://github.com/mkdocstrings/griffe/commit/7d5408a3bf81d64841bbe620b883bc16cb633f82) by Timothée Mazzucotelli).
- Accept `inits` parameter in `temporary_visited_package` ([a4859b7](https://github.com/mkdocstrings/griffe/commit/a4859b74bf52ca29cbb46c147a2b6df4532297e1) by Timothée Mazzucotelli).
- Warn (DEBUG) when an object coming from a sibling, parent or external module instead of the current module or a submodule is exported (listed in `__all__`) ([f82317a](https://github.com/mkdocstrings/griffe/commit/f82317a00333e1b8971625f14e4452e93e9840ff) by Timothée Mazzucotelli). [Issue-249](https://github.com/mkdocstrings/griffe/issues/249), [Related-to-PR-251](https://github.com/mkdocstrings/griffe/pull/251)
- Pass down agent to extension hooks ([71acb01](https://github.com/mkdocstrings/griffe/commit/71acb018716031331bc26d79bc27fd45f67735c1) by Timothée Mazzucotelli). [Issue-312](https://github.com/mkdocstrings/griffe/issues/312)
- Add `source` property to docstrings, which return the docstring lines as written in the source ([3f6a71a](https://github.com/mkdocstrings/griffe/commit/3f6a71a34f503e95fad55038292e3c8ab2ce30b6) by Timothée Mazzucotelli). [Issue-90](https://github.com/mkdocstrings/griffe/issues/90)

### Bug Fixes

- Move `setter` and `deleter` to `Attribute` class instead of `Function`, since that's how properties are instantiated ([309c6e3](https://github.com/mkdocstrings/griffe/commit/309c6e34aded516dcfeab0dd81c2fbcecd2691ac) by Timothée Mazzucotelli). [Issue-311](https://github.com/mkdocstrings/griffe/issues/311)
- Reduce risk of recursion errors by excluding imported objects from `has_docstrings`, unless they're public ([9296ca7](https://github.com/mkdocstrings/griffe/commit/9296ca7273eb1e6b7255b92793a09b82fd3bc4a9) by Timothée Mazzucotelli). [Issue-302](https://github.com/mkdocstrings/griffe/issues/302)
- Fix retrieval of annotations from parent for Yields section in properties ([8a21f4d](https://github.com/mkdocstrings/griffe/commit/8a21f4db1743902c56875980a4aa2366609642c1) by Timothée Mazzucotelli). [Issue-298](https://github.com/mkdocstrings/griffe/issues/298)
- Fix parsing Yields section (Google-style) when yielded values are tuples, and the description has more lines than tuple values ([9091776](https://github.com/mkdocstrings/griffe/commit/90917761ef7ea71ccda8147b3e1ebbc4675d9685) by Timothée Mazzucotelli).
- Fix condition on objects kinds when merging stubs ([727f99b](https://github.com/mkdocstrings/griffe/commit/727f99b084c703937393d52e930aba4ee5739c3b) by Timothée Mazzucotelli).

### Code Refactoring

- Sort keys when dumping JSON from the command line ([8cdffe9](https://github.com/mkdocstrings/griffe/commit/8cdffe9a68383369f6598820ec867740bee58207) by Timothée Mazzucotelli). [Issue-310](https://github.com/mkdocstrings/griffe/issues/310)
- Handle both lists and dicts for members when loading JSON data in preparation of v1 ([f89050c](https://github.com/mkdocstrings/griffe/commit/f89050c3dced88d5295971ab019e5c9a5706f6cc) by Timothée Mazzucotelli). [Issue-310](https://github.com/mkdocstrings/griffe/issues/310)
- Accept `**kwargs` in extension hooks to allow forward-compatibility ([2621d52](https://github.com/mkdocstrings/griffe/commit/2621d52e4d1e89e043e022efb8eba087df5d321e) by Timothée Mazzucotelli). [Issue-312](https://github.com/mkdocstrings/griffe/issues/312)
- Revert deprecation of `patch_loggers` in favor of `patch_logger` ([a20796a](https://github.com/mkdocstrings/griffe/commit/a20796ac821ac72b22082fde2a68ad9dac735076) by Timothée Mazzucotelli).
- Expose dummy `load_pypi` in non-Insiders version ([a69cffd](https://github.com/mkdocstrings/griffe/commit/a69cffd89215dbe629cec892ccda3c259d5572ef) by Timothée Mazzucotelli).
- Don't emit deprecation warnings through own usage of deprecated API ([9922d74](https://github.com/mkdocstrings/griffe/commit/9922d741dc1f9538e5e5f00dd115b297665ac6f8) by Timothée Mazzucotelli). [Issue-mkdocstrings#676](https://github.com/mkdocstrings/mkdocstrings/issues/676)
- Finish preparing docstring style auto-detection feature ([03bdec6](https://github.com/mkdocstrings/griffe/commit/03bdec61bbba86b1fa1b98cb890c034bbfcd44c3) by Timothée Mazzucotelli). [Issue-5](https://github.com/mkdocstrings/griffe/issues/5)
- Add DocstringStyle literal type to prepare docstring style auto detection feature ([b7aaf64](https://github.com/mkdocstrings/griffe/commit/b7aaf6487f04876b498237726b36d08f8e35b905) by Timothée Mazzucotelli). [Issue-5](https://github.com/mkdocstrings/griffe/issues/5)
- Inherit from `str, Enum` instead of `StrEnum` which needs a backport ([77f1544](https://github.com/mkdocstrings/griffe/commit/77f15443540acd2d279e08675b41bd69470f76d9) by Timothée Mazzucotelli). [Issue-307](https://github.com/mkdocstrings/griffe/issues/307)

## [0.48.0](https://github.com/mkdocstrings/griffe/releases/tag/0.48.0) - 2024-07-15

[Compare with 0.47.0](https://github.com/mkdocstrings/griffe/compare/0.47.0...0.48.0)

⚡ Imminent v1! ⚡🚀 See [v0.46](#0460-2024-06-16).

### Deprecations

- All submodules are deprecated. All objects are now exposed in the top-level `griffe` module.
- All logger names are deprecated, and will be replaced with `"griffe"` in v1. In v1 our single `"griffe"` logger will provide a method to temporarily disable logging, logger.disable(), since that's the most common third-party use.
- The `get_logger` function is deprecated. Instead, we'll use a global `logger` internally, and users are welcome to use it too.
- The `patch_loggers` function is renamed `patch_logger`.
- Following the logging changes, the docstring_warning function can now directly log a warning message instead of returning a callable that does. Passing it a logger name (to get a callable) is deprecated in favor of passing it a docstring, message and offset directly.

### Features

- Support `FORCE_COLOR` environment variable ([e1b7bd9](https://github.com/mkdocstrings/griffe/commit/e1b7bd9c3a5be585815dc972a86a51cb1b63bfe7) by Timothée Mazzucotelli).

### Bug Fixes

- Don't take a shortcut to the end of an alias chain when getting/setting/deleting alias members ([1930609](https://github.com/mkdocstrings/griffe/commit/193060908aa1cecb9931553abbb0f9fa182c66a1) by Timothée Mazzucotelli).
- Short-circuit `__all__` convention when checking if a module is public ([5abf4e3](https://github.com/mkdocstrings/griffe/commit/5abf4e3343410dbd41760415cff7c5f9e8c2b6b8) by Timothée Mazzucotelli).
- Reuse existing loggers, preventing overwriting issues ([3c2825f](https://github.com/mkdocstrings/griffe/commit/3c2825f9cf34eb8b0dbedd9fb542e14af3d24c33) by Timothée Mazzucotelli).
- Ignore .pth files that are not utf-8 encoded ([ea299dc](https://github.com/mkdocstrings/griffe/commit/ea299dcb38ad78c9b3de961e88da214ccadd31be) by Andrew Sansom). [Issue-300](https://github.com/mkdocstrings/griffe/issues/300), [PR-301](https://github.com/mkdocstrings/griffe/pull/301)
- Attributes without annotations cannot be dataclass parameters ([c9b2e09](https://github.com/mkdocstrings/griffe/commit/c9b2e09344538778426c446dad306c4881a873b2) by Hassan Kibirige). [PR-297](https://github.com/mkdocstrings/griffe/pull/297)
- When deciding to alias an object or not during inspection, consider module paths to be equivalent even with arbitrary private components ([8c9f6e6](https://github.com/mkdocstrings/griffe/commit/8c9f6e609a1bb93d0c8c41962bb5a9f410862769) by Timothée Mazzucotelli). [Issue-296](https://github.com/mkdocstrings/griffe/issues/296)
- Fix target path computation: use qualified names to maintain classes in the path ([6e17def](https://github.com/mkdocstrings/griffe/commit/6e17def0759409c7d5148c1a2f7747d029f17594) by Timothée Mazzucotelli). [Issue-296](https://github.com/mkdocstrings/griffe/issues/296)

### Code Refactoring

- Prepare loggers for simplification ([381f10f](https://github.com/mkdocstrings/griffe/commit/381f10f9cc3c2e8b7e9f54db23c13334dacc1203) by Timothée Mazzucotelli).
- Add all previous modules for backward compatibility ([a86e44e](https://github.com/mkdocstrings/griffe/commit/a86e44e14b8f7be5b6fa9fb2e6a1614da65a3918) by Timothée Mazzucotelli).
- Add main public modules ([fb860b3](https://github.com/mkdocstrings/griffe/commit/fb860b3200699ae85fed52289f3a6136ea522618) by Timothée Mazzucotelli).
- Simplify "is imported" check in `is_public` property ([c2bbc10](https://github.com/mkdocstrings/griffe/commit/c2bbc10082da8e3b11d2fe4576db9719b25054e0) by Timothée Mazzucotelli).
- Use string and integer enumerations ([06b383b](https://github.com/mkdocstrings/griffe/commit/06b383b5d61bc5083c53745e2c19d0da75e55481) by Timothée Mazzucotelli).
- Renamed agents nodes modules ([ddc5b0c](https://github.com/mkdocstrings/griffe/commit/ddc5b0cc5bba3e0901fe6c7e9f9fe5b70bd2883c) by Timothée Mazzucotelli).
- Clean up and document internal API, mark legacy code ([92594a9](https://github.com/mkdocstrings/griffe/commit/92594a99fed42eb2daa3bbeb797edbf3507f3068) by Timothée Mazzucotelli).
- Renamed `dataclasses` internal modules to `models` ([5555de6](https://github.com/mkdocstrings/griffe/commit/5555de62426063483196888f1bc73757e7492ce8) by Timothée Mazzucotelli).
- Move sources under `_griffe` internal package ([cbce6a5](https://github.com/mkdocstrings/griffe/commit/cbce6a5c4740a5964f9b0eb605adbd6f554e99bc) by Timothée Mazzucotelli).

## [0.47.0](https://github.com/mkdocstrings/griffe/releases/tag/0.47.0) - 2024-06-18

[Compare with 0.46.1](https://github.com/mkdocstrings/griffe/compare/0.46.1...0.47.0)

⚡ Imminent v1! ⚡🚀 See [v0.46](#0460-2024-06-16).

### Deprecations

- The `has_private_name` and `has_special_name` properties on objects and aliases have been renamed `is_private` and `is_special`. The `is_private` property now only returns true if the name is *not* special.

### Features

- Add `deprecated` attribute and `is_deprecated` property to objects/aliases ([2a75d84](https://github.com/mkdocstrings/griffe/commit/2a75d84265b40983ce4a1eb148677efb803f78c6) by Timothée Mazzucotelli).
- Add `is_imported` property to objects/aliases ([de926cc](https://github.com/mkdocstrings/griffe/commit/de926cc4782d53b9b28a2f887890d7711dfbc667) by Timothée Mazzucotelli).
- Add `is_class_private` property to objects/aliases ([491b6c4](https://github.com/mkdocstrings/griffe/commit/491b6c4da086a68e8e1eee13f2d4b7840390b6b9) by Timothée Mazzucotelli).

### Code Refactoring

- Rename `has_private_name` and `has_special_name` to `is_private` and `is_special` ([ae7c7e7](https://github.com/mkdocstrings/griffe/commit/ae7c7e73e7bf7f02b86fc58503888113d98e8e39) by Timothée Mazzucotelli).

## [0.46.1](https://github.com/mkdocstrings/griffe/releases/tag/0.46.1) - 2024-06-17

[Compare with 0.46.0](https://github.com/mkdocstrings/griffe/compare/0.46.0...0.46.1)

⚡ Imminent v1! ⚡🚀 See [v0.46](#0460-2024-06-16).

### Bug Fixes

- Always consider special objects ("dunder" attributes/methods/etc.) to be public ([3319410](https://github.com/mkdocstrings/griffe/commit/331941029decd9d400b30ea1471b6bcc384fd54f) by Timothée Mazzucotelli). [Issue-294](https://github.com/mkdocstrings/griffe/issues/294), [Issue-295](https://github.com/mkdocstrings/griffe/issues/295)
- Don't consider imported objects as public ([ea90952](https://github.com/mkdocstrings/griffe/commit/ea909526f3a637849364544daff74cd49ccaf428) by Timothée Mazzucotelli). [Discussion-169](https://github.com/mkdocstrings/python/discussions/169)

## [0.46.0](https://github.com/mkdocstrings/griffe/releases/tag/0.46.0) - 2024-06-16

[Compare with 0.45.3](https://github.com/mkdocstrings/griffe/compare/0.45.3...0.46.0)

⚡ Imminent v1! ⚡🚀

We are working on v1, and it will come soon, so we recommend that you consider adding an upper bound on Griffe. Version 1 will remove all legacy code! There will be a couple more v0 before so that you get all the deprecation warnings needed to upgrade your code using Griffe before upgrading to v1. See breaking changes and deprecations for v0.46 below.

### Breaking Changes

We are still in v0, so no major bump yet.

- Calling objects' has_labels() method with a `labels` keyword argument is not supported anymore. The parameter became a variadic positional parameter, so it cannot be used as a keyword argument anymore. Passing a sequence instead of multiple positional arguments still works but will emit a deprecation warning.
- Calling the load_extensions() function with an `exts` keyword argument is not supported anymore. The parameter became a variadic positional parameter, so it cannot be used as a keyword argument anymore. Passing a sequence instead of multiple positional arguments still works but will emit a deprecation warning.

### Deprecations

- As seen above in the breaking changes section, the only parameters of Object.has_labels() and load_extensions() both became variadic positional parameters. Passing a sequence as single argument is deprecated in favor of passing multiple arguments. This is an ergonomic change: I myself often forgot to wrap extensions in a list. Passing sequences of labels (lists, sets, tuples) is also difficult from Jinja templates.
- The following methods and properties on objects and aliases are deprecated: `member_is_exported()`, `is_explicitely_exported`, `is_implicitely_exported`. Use the is_exported property instead. See [issue 281](https://github.com/mkdocstrings/griffe/issues/281).
- The is_exported() and is_public() methods became properties. They can still be called like methods, but will emit deprecation warnings when doing so. See [issue 281](https://github.com/mkdocstrings/griffe/issues/281).
- The `ignore_private` parameter of the find_breaking_changes() function is now deprecated and unused. With the reworked "exported" and "public" API, this parameter became useless. See [issue 281](https://github.com/mkdocstrings/griffe/issues/281).
- Using `stats()` instead of Stats will now emit a deprecation warning.

### Features

- Add `docstring` attribute to parameters ([e21eabe](https://github.com/mkdocstrings/griffe/commit/e21eabe8c48e3650d04fec805804683cb743ce12) by Hassan Kibirige). [Issue-286](https://github.com/mkdocstrings/griffe/issues/286), [Related-to-mkdocstrings/griffe#252](https://github.com/mkdocstrings/griffe/pull/252), [PR-288](https://github.com/mkdocstrings/griffe/pull/288), Co-authored-by: Timothée Mazzucotelli [dev@pawamoy.fr](mailto:dev@pawamoy.fr)
- Provide line numbers for classes and functions when inspecting ([b6ddcc4](https://github.com/mkdocstrings/griffe/commit/b6ddcc4e6da42318961bb7cb7be59041a43c6451) by Timothée Mazzucotelli). [Issue-272](https://github.com/mkdocstrings/griffe/issues/272)
- Populate lines collection within helpers ([ab2e947](https://github.com/mkdocstrings/griffe/commit/ab2e9479c2b94dc7b6736e40024db87fb87b4e62) by Timothée Mazzucotelli). [GitHub-issue-270](https://github.com/mkdocstrings/griffe/issues/270), [Radicle-issue-0d6a513](https://app.radicle.xyz/nodes/seed.radicle.garden/rad:z23ZVuA1DWS99PDJ1rcarCtJi99x1/issues/0d6a51328f554f235c38a2a652b844c4ba21bba5)

### Bug Fixes

- Handle partials as functions while inspecting ([be29c32](https://github.com/mkdocstrings/griffe/commit/be29c3214680dc20c9c776d12a2a15ca690fa8d0) by Timothée Mazzucotelli).
- Populate lines collection before visiting/inspecting modules within helpers ([08c3f40](https://github.com/mkdocstrings/griffe/commit/08c3f409f3fc130f07b2d717cddff38d47d4dbca) by Timothée Mazzucotelli). [Issue-272](https://github.com/mkdocstrings/griffe/issues/272)
- Don't return all lines when line numbers are missing ([9e6dcaa](https://github.com/mkdocstrings/griffe/commit/9e6dcaa8f30132ebef59eb27b1f2f3ff7bc03bae) by Timothée Mazzucotelli). [Issue-271](https://github.com/mkdocstrings/griffe/issues/271)

### Code Refactoring

- Emit deprecation warning when accessing `stats` instead of `Stats` ([e5572d2](https://github.com/mkdocstrings/griffe/commit/e5572d2eb1dd8dbe8f9b43b33119bd9becc4a4d9) by Timothée Mazzucotelli).
- Rework "exported" and "public" logic ([b327b90](https://github.com/mkdocstrings/griffe/commit/b327b908d9546c8eb8f4ce5d3a216309937a6552) by Timothée Mazzucotelli). [Issue-281](https://github.com/mkdocstrings/griffe/issues/281)
- Allow passing multiple extensions to `load_extensions` instead of a sequence ([fadb72b](https://github.com/mkdocstrings/griffe/commit/fadb72b4b693f418ebc11aefba3be188a2522c7e) by Timothée Mazzucotelli). [Issue-268](https://github.com/mkdocstrings/griffe/issues/268)
- Allow passing multiple labels to `Object.has_labels` instead of set ([c4e3bf2](https://github.com/mkdocstrings/griffe/commit/c4e3bf2c1a6ff7a1a66f203ae7abec859cbdea44) by Timothée Mazzucotelli). [Issue-267](https://github.com/mkdocstrings/griffe/issues/267)

## [0.45.3](https://github.com/mkdocstrings/griffe/releases/tag/0.45.3) - 2024-06-09

[Compare with 0.45.2](https://github.com/mkdocstrings/griffe/compare/0.45.2...0.45.3)

### Bug Fixes

- Always call `on_package_loaded` hook on a package, and not any other object ([40db38d](https://github.com/mkdocstrings/griffe/commit/40db38d6d55c5a7926d39408e7fd51ec198b62b9) by Timothée Mazzucotelli). [Issue-283](https://github.com/mkdocstrings/griffe/issues/283)

## [0.45.2](https://github.com/mkdocstrings/griffe/releases/tag/0.45.2) - 2024-05-23

[Compare with 0.45.1](https://github.com/mkdocstrings/griffe/compare/0.45.1...0.45.2)

### Bug Fixes

- Support setuptools' new editable modules using type annotations ([14d45e8](https://github.com/mkdocstrings/griffe/commit/14d45e83d4a48c67b2347965351145cc78d7abe9) by Timothée Mazzucotelli). [Issue-273](https://github.com/mkdocstrings/griffe/issues/273)

## [0.45.1](https://github.com/mkdocstrings/griffe/releases/tag/0.45.1) - 2024-05-18

[Compare with 0.45.0](https://github.com/mkdocstrings/griffe/compare/0.45.0...0.45.1)

### Bug Fixes

- Fix loading of importable modules thanks to their `__path__` attribute ([56f5363](https://github.com/mkdocstrings/griffe/commit/56f5363063b54bc43a7e61da7ac6b177db2f158f) by Timothée Mazzucotelli). [Issue-269](https://github.com/mkdocstrings/griffe/issues/269)

## [0.45.0](https://github.com/mkdocstrings/griffe/releases/tag/0.45.0) - 2024-05-12

[Compare with 0.44.0](https://github.com/mkdocstrings/griffe/compare/0.44.0...0.45.0)

### Features

- Implement `-x`, `--force-inspection` CLI option ([776063d](https://github.com/mkdocstrings/griffe/commit/776063d971b059576c62f62fdd2e1199de033711) by Timothée Mazzucotelli).
- Implement `force_inspection` option in the loader API ([3266f22](https://github.com/mkdocstrings/griffe/commit/3266f2290637d3f46d782fe7ce222ff29f549043) by Timothée Mazzucotelli).
- Support inspecting packages (`__init__` modules) ([3f74f67](https://github.com/mkdocstrings/griffe/commit/3f74f679de15df098482fead505d0402bff84401) by Timothée Mazzucotelli).
- Add parameters for resolving aliases to `load` functions ([e418dee](https://github.com/mkdocstrings/griffe/commit/e418dee1563e2a02ec61c920842e8b8a13419448) by Timothée Mazzucotelli).
- Load private sibling modules by default when resolving aliases ([4806189](https://github.com/mkdocstrings/griffe/commit/4806189111572495466638bb7899cf906eeebfe9) by Timothée Mazzucotelli).

### Bug Fixes

- Pass down modules collection when inspecting ([bc0f74b](https://github.com/mkdocstrings/griffe/commit/bc0f74bef40a812e00765a7ab17507b0bfbd62c3) by Timothée Mazzucotelli).
- Catch loading errors when loading additional modules during wildcard expansion and alias resolution ([964e0d2](https://github.com/mkdocstrings/griffe/commit/964e0d2b78d3bc3530601009148fb4a5905b8721) by Timothée Mazzucotelli).

### Code Refactoring

- Improve stats code and performance ([eeb497f](https://github.com/mkdocstrings/griffe/commit/eeb497fa41acf50801cc6a7a240d079cc1592e79) by Timothée Mazzucotelli).
- Recurse immediately into non-discoverable submodules (no path on disk) during dynamic analysis ([d0b7a1d](https://github.com/mkdocstrings/griffe/commit/d0b7a1d96a4dd7513f34673b0ef6cd02aa7d0fca) by Timothée Mazzucotelli).
- Simplify the code that checks if an object should be aliased or not during dynamic analysis ([fc794c2](https://github.com/mkdocstrings/griffe/commit/fc794c24c578fe868900483b20601937db3f3d05) by Timothée Mazzucotelli).
- Avoid side-effect in inspector by checking early if an object is a cached property ([a6bfcfd](https://github.com/mkdocstrings/griffe/commit/a6bfcfdb9e2a0740d72abbd1480e0aa7e23c9af1) by Timothée Mazzucotelli).

## [0.44.0](https://github.com/mkdocstrings/griffe/releases/tag/0.44.0) - 2024-04-19

[Compare with 0.43.0](https://github.com/mkdocstrings/griffe/compare/0.43.0...0.44.0)

### Features

- Add `resolved` property on expression names, returning the corresponding Griffe object ([9b5ca45](https://github.com/mkdocstrings/griffe/commit/9b5ca4574250f847fd33a8cb92af56806db50c1b) by Timothée Mazzucotelli).

### Bug Fixes

- Fix enumeration properties on expression names ([6f22256](https://github.com/mkdocstrings/griffe/commit/6f22256ad02439d961bce2bb1afa32d4e9e10b10) by Timothée Mazzucotelli).

## [0.43.0](https://github.com/mkdocstrings/griffe/releases/tag/0.43.0) - 2024-04-18

[Compare with 0.42.2](https://github.com/mkdocstrings/griffe/compare/0.42.2...0.43.0)

### Features

- Add properties telling whether an expression name resolves to an enumeration class, instance or value ([fdb21d9](https://github.com/mkdocstrings/griffe/commit/fdb21d943f72fb10a4406930bf3e3bf7aceff6b0) by Timothée Mazzucotelli). [Issue-mkdocstrings/python#124](https://github.com/mkdocstrings/python/issues/124)

## [0.42.2](https://github.com/mkdocstrings/griffe/releases/tag/0.42.2) - 2024-04-15

[Compare with 0.42.1](https://github.com/mkdocstrings/griffe/compare/0.42.1...0.42.2)

### Bug Fixes

- Fix target path of aliases for multipart imports (`import a.b.c as x`) ([ee27ad9](https://github.com/mkdocstrings/griffe/commit/ee27ad97669a7321d18e6724e6c155cef601a289) by Timothée Mazzucotelli). [Issue-259](https://github.com/mkdocstrings/griffe/issues/259)

## [0.42.1](https://github.com/mkdocstrings/griffe/releases/tag/0.42.1) - 2024-03-19

[Compare with 0.42.0](https://github.com/mkdocstrings/griffe/compare/0.42.0...0.42.1)

### Bug Fixes

- Don't return class variables as parameters of dataclasses ([2729c22](https://github.com/mkdocstrings/griffe/commit/2729c22505d87b771ab7a70c91c9f8301275aa8c) by Hassan Kibirige). [PR-253](https://github.com/mkdocstrings/griffe/pull/253)
- Don't turn items annotated as InitVar into dataclass members ([6835ea3](https://github.com/mkdocstrings/griffe/commit/6835ea361325a205c0af69acabc66ca5193156c5) by Hassan Kibirige). [PR-252](https://github.com/mkdocstrings/griffe/pull/252)

## [0.42.0](https://github.com/mkdocstrings/griffe/releases/tag/0.42.0) - 2024-03-11

[Compare with 0.41.3](https://github.com/mkdocstrings/griffe/compare/0.41.3...0.42.0)

### Features

- Better support for dataclasses ([82a9d57](https://github.com/mkdocstrings/griffe/commit/82a9d5798b2eebddfd640b918415a0e3de2ca739) by Timothée Mazzucotelli). [Issue-33](https://github.com/mkdocstrings/griffe/issues/233), [Issue-34](https://github.com/mkdocstrings/griffe/issues/234), [Issue-38](https://github.com/mkdocstrings/griffe/issues/238), [Issue-39](https://github.com/mkdocstrings/griffe/issues/239), [PR-240](https://github.com/mkdocstrings/griffe/pull/240)

### Bug Fixes

- Don't return properties as parameters of dataclasses (again) ([8c48397](https://github.com/mkdocstrings/griffe/commit/8c48397e7301bbb296e2f2630405f2d22f7222e3) by Hassan Kibirige). [Issue-232](https://github.com/mkdocstrings/griffe/issues/232), [PR-248](https://github.com/mkdocstrings/griffe/pull/248)
- Fix getting return type from parent property when parsing Sphinx docstrings ([f314957](https://github.com/mkdocstrings/griffe/commit/f314957c9da7805a9eb1a23d1a7f3d47b0b1e4c0) by Timothée Mazzucotelli). [Issue-125](https://github.com/mkdocstrings/griffe/issues/125)

### Code Refactoring

- Warn (debug) when a submodule shadows a member with the same name ([cdc9e1c](https://github.com/mkdocstrings/griffe/commit/cdc9e1c5ee92a4c621314a9d9c6c465bfdd2ad92) by Timothée Mazzucotelli). [Issue-124](https://github.com/mkdocstrings/griffe/issues/124)

## [0.41.3](https://github.com/mkdocstrings/griffe/releases/tag/0.41.3) - 2024-03-04

[Compare with 0.41.2](https://github.com/mkdocstrings/griffe/compare/0.41.2...0.41.3)

### Code Refactoring

- Catch index errors when finding top module in case of search path misconfiguration ([46c56c7](https://github.com/mkdocstrings/griffe/commit/46c56c7ff505531f5422f526ad38095ed463cc1b) by Timothée Mazzucotelli). [Issue-#246](https://github.com/mkdocstrings/griffe/issues/246)

## [0.41.2](https://github.com/mkdocstrings/griffe/releases/tag/0.41.2) - 2024-03-03

[Compare with 0.41.1](https://github.com/mkdocstrings/griffe/compare/0.41.1...0.41.2)

### Bug Fixes

- Fix discovery of packages in the current working directory ([44f9617](https://github.com/mkdocstrings/griffe/commit/44f96173df188568bb1db54a20270ff0a08298c6) by Timothée Mazzucotelli). [Discussion-mkdocstrings#654](https://github.com/mkdocstrings/mkdocstrings/discussions/654)

## [0.41.1](https://github.com/mkdocstrings/griffe/releases/tag/0.41.1) - 2024-03-01

[Compare with 0.41.0](https://github.com/mkdocstrings/griffe/compare/0.41.0...0.41.1)

### Deprecations

- The `load_git` function moved from `griffe.git` to `griffe.loader`. It is still importable from `griffe.git`, but will emit a deprecation warning.

### Code Refactoring

- Expose Git utilities, move `load_git` into the `loader` module ([327cc5b](https://github.com/mkdocstrings/griffe/commit/327cc5b0f28f7236eaaf1c028674b6e0006611da) by Timothée Mazzucotelli).

## [0.41.0](https://github.com/mkdocstrings/griffe/releases/tag/0.41.0) - 2024-02-26

[Compare with 0.40.1](https://github.com/mkdocstrings/griffe/compare/0.40.1...0.41.0)

### Features

- Add option to append `sys.path` to search paths to the check command too ([d153fa0](https://github.com/mkdocstrings/griffe/commit/d153fa0aeaa248ae13101f189f887f9bfee27f04) by Timothée Mazzucotelli).

### Bug Fixes

- Special case NumpyDoc "warnings" and "notes" sections (plural) ([3b47cdb](https://github.com/mkdocstrings/griffe/commit/3b47cdb889e08106404bfcdbd3ce651f7eee6cdf) by Ethan Henderson). [PR #236](https://github.com/mkdocstrings/griffe/pull/236)
- Serialize line numbers even if zero ([55e6e0e](https://github.com/mkdocstrings/griffe/commit/55e6e0e6c01351aa832aaf934d001442f66c8598) by Timothée Mazzucotelli).
- Fix handling of lambda expressions ([598d08a](https://github.com/mkdocstrings/griffe/commit/598d08ae0dcd7d266194237211e6431ee65aee67) by Timothée Mazzucotelli).
- Fix building expressions (and string values) for `yield` and `yield from` statements ([439f65e](https://github.com/mkdocstrings/griffe/commit/439f65e3703c5cad7d68aa3b2da371599236f58b) by Timothée Mazzucotelli).
- Do not create aliases pointing to themselves ([356305f](https://github.com/mkdocstrings/griffe/commit/356305f69664c1d955f4dbf7c865cb4f553488fc) by Timothée Mazzucotelli).

### Code Refactoring

- Remove `get_call_keyword_arguments` utility function, as it is implemented with a single line and creates a cyclic dependency with expressions ([35cf170](https://github.com/mkdocstrings/griffe/commit/35cf170cc91ba740e6f997d76f99d6a07e8d4437) by Timothée Mazzucotelli).
- Further prevent cyclic dependency between node utils and expressions ([9614c83](https://github.com/mkdocstrings/griffe/commit/9614c83c037637d7823a4c06f115c3e2e4b6e10f) by Timothée Mazzucotelli).
- Avoid cyclic dependency between node utils and expressions ([aedf39c](https://github.com/mkdocstrings/griffe/commit/aedf39c3795197deb6067e039da8bdec182bd363) by Timothée Mazzucotelli).
- Move arguments node-parsing logic into its own module (used by visitor and lambda expressions) ([ad68e65](https://github.com/mkdocstrings/griffe/commit/ad68e65363c4338d7f38ccade2f9cc05d41f8100) by Timothée Mazzucotelli).
- Use canonical imports ([3091660](https://github.com/mkdocstrings/griffe/commit/3091660ae1b6253e481cedbdcc31b73c0ab334df) by Timothée Mazzucotelli).
- Use `ast.unparse` instead of our own unparser ([6fe1316](https://github.com/mkdocstrings/griffe/commit/6fe1316807870cbf93bba79f3d400cae6630ea73) by Timothée Mazzucotelli).
- Only return 0 for the line number of removed objects when the location is reworked as relative ([3a4d054](https://github.com/mkdocstrings/griffe/commit/3a4d054e993e8a53cce9e53057e81479ab5f6034) by Timothée Mazzucotelli).

## [0.40.1](https://github.com/mkdocstrings/griffe/releases/tag/0.40.1) - 2024-02-08

[Compare with 0.40.0](https://github.com/mkdocstrings/griffe/compare/0.40.0...0.40.1)

### Bug Fixes

- Don't return properties as parameters of dataclasses ([5a5c03b](https://github.com/mkdocstrings/griffe/commit/5a5c03b38366049f19fc2b65f09153e7df5748ce) by Timothée Mazzucotelli). [Issue #232](https://github.com/mkdocstrings/griffe/issues/232)

## [0.40.0](https://github.com/mkdocstrings/griffe/releases/tag/0.40.0) - 2024-01-30

[Compare with 0.39.1](https://github.com/mkdocstrings/griffe/compare/0.39.1...0.40.0)

### Features

- Store reference to function call in keyword expressions ([d72f9d3](https://github.com/mkdocstrings/griffe/commit/d72f9d3a425fee11f23f9f7b44814b6fda458e6e) by Timothée Mazzucotelli). [PR #231](https://github.com/mkdocstrings/griffe/pull/231)

## [0.39.1](https://github.com/mkdocstrings/griffe/releases/tag/0.39.1) - 2024-01-18

[Compare with 0.39.0](https://github.com/mkdocstrings/griffe/compare/0.39.0...0.39.1)

### Bug Fixes

- De-duplicate search paths in finder as they could lead to the same modules being yielded twice or more when scanning namespace packages ([80a158a](https://github.com/mkdocstrings/griffe/commit/80a158a2de8d53a054405c3e14113b09d73335a3) by Timothée Mazzucotelli).
- Fix logic for skipping already encountered modules when scanning namespace packages ([21a48d0](https://github.com/mkdocstrings/griffe/commit/21a48d0b9248467fe3c36440bee649ce8879f295) by Timothée Mazzucotelli). [Issue mkdocstrings#646](https://github.com/mkdocstrings/mkdocstrings/issues/646)

## [0.39.0](https://github.com/mkdocstrings/griffe/releases/tag/0.39.0) - 2024-01-16

[Compare with 0.38.1](https://github.com/mkdocstrings/griffe/compare/0.38.1...0.39.0)

### Features

- Support editable installs dynamically exposing modules from other directories ([2c4ba75](https://github.com/mkdocstrings/griffe/commit/2c4ba751d7d47eb48b47179d316722315e5d4647) by Timothée Mazzucotelli). [Issue #229](https://github.com/mkdocstrings/griffe/issues/229)
- Support meson-python editable modules ([9123897](https://github.com/mkdocstrings/griffe/commit/9123897ad8d85e48bd3c435ffabcf9a36a0ed355) by Timothée Mazzucotelli).
- Support admonitions in Numpydoc docstrings ([1e311a4](https://github.com/mkdocstrings/griffe/commit/1e311a4eb935c58d488c928a86493ab3f3368f06) by Michael Chow). [Issue #214](https://github.com/mkdocstrings/griffe/issues/214), [PR #219](https://github.com/mkdocstrings/griffe/pull/219), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Expose module properties on all objects ([123f8c5](https://github.com/mkdocstrings/griffe/commit/123f8c5ba1826435e90dafffbfe304bd6ab8e187) by Timothée Mazzucotelli). [Issue #226](https://github.com/mkdocstrings/griffe/issues/226)

### Bug Fixes

- Consider space-only lines to be empty, never break Numpydoc sections on blank lines ([8c57354](https://github.com/mkdocstrings/griffe/commit/8c5735497578417e1dd723625590539016e7b7a5) by Timothée Mazzucotelli). [PR #220](https://github.com/mkdocstrings/griffe/pull/220), [Related to PR #219](https://github.com/mkdocstrings/griffe/pull/219), [Numpydoc discussion](https://github.com/numpy/numpydoc/issues/463)
- Allow merging stubs into alias targets ([3cf7958](https://github.com/mkdocstrings/griffe/commit/3cf795871a0549b901d9374705d6a1eb84700128) by Timothée Mazzucotelli).
- Insert the right directory in front of import paths before inspecting a module (dynamically imported) ([7d75c71](https://github.com/mkdocstrings/griffe/commit/7d75c71477ccb208e071bfe3c3204a0490274b44) by Timothée Mazzucotelli).

### Code Refactoring

- Set lineno to 0 for removed objects when checking API ([b660c34](https://github.com/mkdocstrings/griffe/commit/b660c346feb3a95fbe54a6dad460e988a9a41774) by Timothée Mazzucotelli).
- Prepare support for new output formats (styles) of the check command ([f2ece1e](https://github.com/mkdocstrings/griffe/commit/f2ece1e602b0fb3d888a60d892089a55fdcf60f0) by Timothée Mazzucotelli).
- Transform finder's package and namespace package classes into dataclasses ([16be6a4](https://github.com/mkdocstrings/griffe/commit/16be6a4a7660d8ed13ccdcf9c571eda647e078f0) by Timothée Mazzucotelli).

## [0.38.1](https://github.com/mkdocstrings/griffe/releases/tag/0.38.1) - 2023-12-06

[Compare with 0.38.0](https://github.com/mkdocstrings/griffe/compare/0.38.0...0.38.1)

### Bug Fixes

- Support absolute Windows paths for extensions ([4e67d8f](https://github.com/mkdocstrings/griffe/commit/4e67d8fa5f0e9f23c1df2e1d772fc0f1e4e6c2e0) by Timothée Mazzucotelli). [Issue mkdocstrings-python#116](https://github.com/mkdocstrings/python/issues/116)

## [0.38.0](https://github.com/mkdocstrings/griffe/releases/tag/0.38.0) - 2023-11-13

[Compare with 0.37.0](https://github.com/mkdocstrings/griffe/compare/0.37.0...0.38.0)

### Features

- Allow passing load parameters to the temporary package visit helper ([3a7854f](https://github.com/mkdocstrings/griffe/commit/3a7854fb180e34392fd520d9d25a6298d4b80830) by Timothée Mazzucotelli).

## [0.37.0](https://github.com/mkdocstrings/griffe/releases/tag/0.37.0) - 2023-11-12

[Compare with 0.36.9](https://github.com/mkdocstrings/griffe/compare/0.36.9...0.37.0)

### Deprecations

- The loader `load_module` method was renamed `load`, Its `module` parameter was renamed `objspec` and is now positional-only. This method always returned the specified object, not just modules, so it made more sense to rename it `load` and to rename the parameter specifying the object. Old usages (`load_module` and `module=...`) will continue to work for some time (a few months, a year, more), and will emit deprecation warnings.

### Features

- Add option to warn about unknown parameters in Sphinx docstrings ([8b11d77](https://github.com/mkdocstrings/griffe/commit/8b11d77315ca7a5e15da519db1663d05805dd075) by Ashwin Vinod). [Issue #64](https://github.com/mkdocstrings/griffe/issues/64), [PR #210](https://github.com/mkdocstrings/griffe/pull/210), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Add `on_package_loaded` event ([a5cf654](https://github.com/mkdocstrings/griffe/commit/a5cf6543b43db06c4d0f24d2631ddc86b1fee41e) by Timothée Mazzucotelli).
- Add option to find, load and merge stubs-only packages ([6e55f3b](https://github.com/mkdocstrings/griffe/commit/6e55f3bd0838e3f229fcd37d3aeced0146d33ff1) by Romain). [PR #221](https://github.com/mkdocstrings/griffe/pull/221), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

### Bug Fixes

- Report attributes who lost their value as "unset" ([dfffa4b](https://github.com/mkdocstrings/griffe/commit/dfffa4b96a8a70f93b899bd41aefeaa9939819e9) by Geethakrishna-Puligundla). [Issue #218](https://github.com/mkdocstrings/griffe/issues/218), [PR #225](https://github.com/mkdocstrings/griffe/pull/225)
- Don't crash when computing MRO for a class that is named after its parent ([a2dd8a6](https://github.com/mkdocstrings/griffe/commit/a2dd8a6bc3f95679e1c2e79ce05d175fb8f89ccc) by Timothée Mazzucotelli).

### Code Refactoring

- Rename loader `load_module` method to `load` ([2bfe206](https://github.com/mkdocstrings/griffe/commit/2bfe206b57f607b56f7bcb5a85a7e2a25fe3bf47) by Timothée Mazzucotelli).

## [0.36.9](https://github.com/mkdocstrings/griffe/releases/tag/0.36.9) - 2023-10-27

[Compare with 0.36.8](https://github.com/mkdocstrings/griffe/compare/0.36.8...0.36.9)

### Bug Fixes

- Fix accessing alias members with `__getitem__` ([8929409](https://github.com/mkdocstrings/griffe/commit/8929409d4703c6b684084e88aae0d99423e05dbf) by Timothée Mazzucotelli). [Issue mkdocstrings-python#111](https://github.com/mkdocstrings/python/issues/111)

### Code Refactoring

- Expose parser enumeration and parser functions in top-level module ([785baa0](https://github.com/mkdocstrings/griffe/commit/785baa04e3081fcf80756f56dddb95a00cb9b025) by Timothée Mazzucotelli).

## [0.36.8](https://github.com/mkdocstrings/griffe/releases/tag/0.36.8) - 2023-10-25

[Compare with 0.36.7](https://github.com/mkdocstrings/griffe/compare/0.36.7...0.36.8)

### Bug Fixes

- Use already parsed docstring sections when dumping full data ([311807b](https://github.com/mkdocstrings/griffe/commit/311807b8fa1716dabe5ba18d3e12c947286afd8e) by Timothée Mazzucotelli). [Discussion griffe-typingdoc#6](https://github.com/mkdocstrings/griffe-typingdoc/discussions/6)

## [0.36.7](https://github.com/mkdocstrings/griffe/releases/tag/0.36.7) - 2023-10-17

[Compare with 0.36.6](https://github.com/mkdocstrings/griffe/compare/0.36.6...0.36.7)

### Bug Fixes

- Add missing proxies (methods/properties) to aliases ([7320640](https://github.com/mkdocstrings/griffe/commit/7320640d42ebb4546f787fe458d5032a67ea20b7) by Timothée Mazzucotelli).

### Code Refactoring

- Use final target in alias proxies ([731d662](https://github.com/mkdocstrings/griffe/commit/731d66237252e754b7a935ca4d0344f554edb5ff) by Timothée Mazzucotelli).

## [0.36.6](https://github.com/mkdocstrings/griffe/releases/tag/0.36.6) - 2023-10-16

[Compare with 0.36.5](https://github.com/mkdocstrings/griffe/compare/0.36.5...0.36.6)

### Code Refactoring

- Only consider presence/absence for docstrings truthiness, not emptiness of their value ([4c49611](https://github.com/mkdocstrings/griffe/commit/4c496117880d2166bfc2bc8c40a235c23cef8527) by Timothée Mazzucotelli).

## [0.36.5](https://github.com/mkdocstrings/griffe/releases/tag/0.36.5) - 2023-10-09

[Compare with 0.36.4](https://github.com/mkdocstrings/griffe/compare/0.36.4...0.36.5)

### Bug Fixes

- Force extension import path to be a string (coming from MkDocs' `!relative` tag) ([34e21a9](https://github.com/mkdocstrings/griffe/commit/34e21a9545a38b61a1b80192af312d70f6c607f2) by Timothée Mazzucotelli).
- Fix crash when trying to get a decorator callable path (found thanks to pysource-codegen) ([e57f08e](https://github.com/mkdocstrings/griffe/commit/e57f08eb5770eb3a9ed12e97da3076b87f109224) by Timothée Mazzucotelli).
- Fix crash when trying to get docstring after assignment (found thanks to pysource-codegen) ([fb0a0c1](https://github.com/mkdocstrings/griffe/commit/fb0a0c1a8558c9d04855b75e4a9f579b46e2edd8) by Timothée Mazzucotelli).
- Fix type errors in expressions and value extractor, don't pass duplicate arguments (found thanks to pysource-codegen) ([7e53288](https://github.com/mkdocstrings/griffe/commit/7e53288586bd90198cfd6a898002850c67213209) by Timothée Mazzucotelli).

## [0.36.4](https://github.com/mkdocstrings/griffe/releases/tag/0.36.4) - 2023-09-28

[Compare with 0.36.3](https://github.com/mkdocstrings/griffe/compare/0.36.3...0.36.4)

### Bug Fixes

- Fix visiting relative imports in non-init modules ([c1138c3](https://github.com/mkdocstrings/griffe/commit/c1138c34b89965fd780d669c7dd6b12f245d8cd9) by Timothée Mazzucotelli).

## [0.36.3](https://github.com/mkdocstrings/griffe/releases/tag/0.36.3) - 2023-09-28

[Compare with 0.36.2](https://github.com/mkdocstrings/griffe/compare/0.36.2...0.36.3)

### Bug Fixes

- Fix parsing of choices in Numpy parameters ([5f2d997](https://github.com/mkdocstrings/griffe/commit/5f2d99776e326679d2c0d1d9cb6b06d6436971c6) by Timothée Mazzucotelli). [Issue #212](https://github.com/mkdocstrings/griffe/issues/212)

### Code Refactoring

- Add `repr` methods to function parameters ([9442234](https://github.com/mkdocstrings/griffe/commit/94422349483a25db627921dfe13c7a89b81e700e) by Timothée Mazzucotelli).

## [0.36.2](https://github.com/mkdocstrings/griffe/releases/tag/0.36.2) - 2023-09-10

[Compare with 0.36.1](https://github.com/mkdocstrings/griffe/compare/0.36.1...0.36.2)

### Bug Fixes

- Fix warnings for docstrings in builtin modules ([6ba3e04](https://github.com/mkdocstrings/griffe/commit/6ba3e0461647c2c76d0fd68889d37bbada686259) by Timothée Mazzucotelli).
- Fix dumping `filepath` to a dict when it is a list ([066a4a7](https://github.com/mkdocstrings/griffe/commit/066a4a7f22827783c930feacd6a339ed3d00ec27) by davfsa). [PR #207](https://github.com/mkdocstrings/griffe/pull/207)

## [0.36.1](https://github.com/mkdocstrings/griffe/releases/tag/0.36.1) - 2023-09-04

[Compare with 0.36.0](https://github.com/mkdocstrings/griffe/compare/0.36.0...0.36.1)

### Bug Fixes

- Fix iterating non-flat expressions (some nodes were skipped) ([3249155](https://github.com/mkdocstrings/griffe/commit/324915507c1100e04ffed6d926143f66f0016870) by Timothée Mazzucotelli).

## [0.36.0](https://github.com/mkdocstrings/griffe/releases/tag/0.36.0) - 2023-09-01

[Compare with 0.35.2](https://github.com/mkdocstrings/griffe/compare/0.35.2...0.36.0)

### Features

- Add option to read return type of properties in their summary (Google-style) ([096970f](https://github.com/mkdocstrings/griffe/commit/096970ffa66f491ef34ae1121e8b907f2da4c742) by Timothée Mazzucotelli). [Issue #137](https://github.com/mkdocstrings/griffe/issues/137), [PR #206](https://github.com/mkdocstrings/griffe/pull/206)
- Add option to make parentheses around the type of returned values optional (Google-style) ([b0620f8](https://github.com/mkdocstrings/griffe/commit/b0620f86e1767183d776771992ce12f961efe395) by Timothée Mazzucotelli). [Issue #137](https://github.com/mkdocstrings/griffe/issues/137)
- Get class parameters from parent's `__init__` method ([e8a9fdc](https://github.com/mkdocstrings/griffe/commit/e8a9fdcce1cffdc7db5a216f833d10da6116db5a) by Timothée Mazzucotelli). [Issue #205](https://github.com/mkdocstrings/griffe/issues/205)

### Bug Fixes

- Use all members (declared and inherited) when checking for breakages, avoid false-positives when a member of a class is moved into a parent class ([1c4340b](https://github.com/mkdocstrings/griffe/commit/1c4340b09b111313a5a242caa986a2fa3fdef852) by Timothée Mazzucotelli). [Issue #203](https://github.com/mkdocstrings/griffe/issues/203)
- Skip early submodules with dots in their path ([5e81b8a](https://github.com/mkdocstrings/griffe/commit/5e81b8afef4e6ce8294cdbaf348f4f1a05add1d8) by Timothée Mazzucotelli). [Issue #185](https://github.com/mkdocstrings/griffe/issues/185)

### Code Refactoring

- Allow iterating on expressions in both flat and nested ways ([3957fa7](https://github.com/mkdocstrings/griffe/commit/3957fa70abf3f2d8af1a4ab4b1041b873bc724e0) by Timothée Mazzucotelli).

## [0.35.2](https://github.com/mkdocstrings/griffe/releases/tag/0.35.2) - 2023-08-27

[Compare with 0.35.1](https://github.com/mkdocstrings/griffe/compare/0.35.1...0.35.2)

### Code Refactoring

- Be more strict when parsing sections in Google docstrings ([6a8a228](https://github.com/mkdocstrings/griffe/commit/6a8a2280f8910d4268380400d7888cb8d72b4296) by Timothée Mazzucotelli). [Issue #204](https://github.com/mkdocstrings/griffe/issues/204)

## [0.35.1](https://github.com/mkdocstrings/griffe/releases/tag/0.35.1) - 2023-08-26

[Compare with 0.35.0](https://github.com/mkdocstrings/griffe/compare/0.35.0...0.35.1)

### Bug Fixes

- Preserve inherited attribute on alias inherited members ([1e19e7b](https://github.com/mkdocstrings/griffe/commit/1e19e7b2c3f2bb10c822c7d8b63b04a76024b4f7) by Timothée Mazzucotelli). [Issue mkdocstrings/python#102](https://github.com/mkdocstrings/python/issues/102)

## [0.35.0](https://github.com/mkdocstrings/griffe/releases/tag/0.35.0) - 2023-08-24

[Compare with 0.34.0](https://github.com/mkdocstrings/griffe/compare/0.34.0...0.35.0)

### Features

- Add an `is_public` helper method to guess if an object is public ([b823639](https://github.com/mkdocstrings/griffe/commit/b8236391f4ac8b16e9ee861c322e75ea10d6a39b) by Timothée Mazzucotelli).
- Add option to Google parser allowing to parse Returns sections with or without multiple items ([65fee70](https://github.com/mkdocstrings/griffe/commit/65fee70cf87399b7da92f054180791de0eb4f22d) by Antoine Dechaume). [PR #196](https://github.com/mkdocstrings/griffe/pull/196)

### Bug Fixes

- Allow passing `warn_unknown_params` option to Google and Numpy parsers ([5bf0746](https://github.com/mkdocstrings/griffe/commit/5bf07468d38a158f8e58e3e1c562e8d886d83321) by Timothée Mazzucotelli).

### Code Refactoring

- Preserve alias members path by re-aliasing members instead of returning target's members ([d400cb1](https://github.com/mkdocstrings/griffe/commit/d400cb13c8b7c250ff1e6b6c8ec9be1c7b6ff989) by Timothée Mazzucotelli).

## [0.34.0](https://github.com/mkdocstrings/griffe/releases/tag/0.34.0) - 2023-08-20

[Compare with 0.33.0](https://github.com/mkdocstrings/griffe/compare/0.33.0...0.34.0)

### Features

- Allow checking if docstring section is empty or not with `if section` ([f6cf559](https://github.com/mkdocstrings/griffe/commit/f6cf559db50718e86cde40eae9d14489cabd9ed8) by Timothée Mazzucotelli).
- Implement Functions (or Methods), Classes and Modules docstring sections ([929e615](https://github.com/mkdocstrings/griffe/commit/929e6158c093b021ba80773e17613406b38fbf0c) by Timothée Mazzucotelli).
- Allow passing a docstring parser name instead of its enumeration value ([ce59b7d](https://github.com/mkdocstrings/griffe/commit/ce59b7dca69e3a9946a0735405535e296e0ec9c9) by Timothée Mazzucotelli).

### Code Refactoring

- Explicit checks for subprocess runs ([cc3ca2e](https://github.com/mkdocstrings/griffe/commit/cc3ca2e18877c17fe23e2ceeb1c13e10c9fe46d2) by Timothée Mazzucotelli).

## [0.33.0](https://github.com/mkdocstrings/griffe/releases/tag/0.33.0) - 2023-08-16

[Compare with 0.32.3](https://github.com/mkdocstrings/griffe/compare/0.32.3...0.33.0)

### Breaking Changes

- Removed `griffe.expressions.Expression` in favor of griffe.Expr and subclasses
- Removed `griffe.expressions.Name` in favor of griffe.ExprName

### Features

- Add `-V`, `--version` CLI flag to show version ([a41515f](https://github.com/mkdocstrings/griffe/commit/a41515f39e6e5e2e28d68980c44cc07a7e0ebbe0) by jgart). [Issue #186](https://github.com/mkdocstrings/griffe/issues/186), [PR #187](https://github.com/mkdocstrings/griffe/pull/187), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

### Code Refactoring

- Improve expressions ([66c8ad5](https://github.com/mkdocstrings/griffe/commit/66c8ad5074e1475aa88a51d8652b5e197760d774) and [0fe8f91](https://github.com/mkdocstrings/griffe/commit/0fe8f9155b571714b0fe2a1bd7aef0b9b0738b08) by Timothée Mazzucotelli).

## [0.32.3](https://github.com/mkdocstrings/griffe/releases/tag/0.32.3) - 2023-07-17

[Compare with 0.32.2](https://github.com/mkdocstrings/griffe/compare/0.32.2...0.32.3)

### Bug Fixes

- Fix detecting whether an object should be an alias during inspection ([6a63b37](https://github.com/mkdocstrings/griffe/commit/6a63b375db7d639dd05589c56a2f89d1be9d66a8) by Timothée Mazzucotelli). [Issue #180](https://github.com/mkdocstrings/griffe/issues/180)

### Code Refactoring

- Improve log message when trying to stubs-merge objects of different kinds ([d34a3ba](https://github.com/mkdocstrings/griffe/commit/d34a3ba4bbd15c3fafe9cc5e2e82a2281cf3e094) by Timothée Mazzucotelli).
- De-duplicate stubs merging log message ([cedc062](https://github.com/mkdocstrings/griffe/commit/cedc062cd4035a4ad0f3a14b4ef31bea4e39374d) by Timothée Mazzucotelli).

## [0.32.2](https://github.com/mkdocstrings/griffe/releases/tag/0.32.2) - 2023-07-17

[Compare with 0.32.1](https://github.com/mkdocstrings/griffe/compare/0.32.1...0.32.2)

### Bug Fixes

- Keep parentheses around tuples, except within subscripts ([df6e636](https://github.com/mkdocstrings/griffe/commit/df6e636c3ecfaa6befdfdaf26e898e1a71218675) by Timothée Mazzucotelli). [Issue mkdocstrings/python#88](https://github.com/mkdocstrings/python/issues/88)

## [0.32.1](https://github.com/mkdocstrings/griffe/releases/tag/0.32.1) - 2023-07-15

[Compare with 0.32.0](https://github.com/mkdocstrings/griffe/compare/0.32.0...0.32.1)

### Bug Fixes

- Fix aliases for direct nested imports ([e9867f7](https://github.com/mkdocstrings/griffe/commit/e9867f78044a2a33b575e274224d3a4c16b62439) by Timothée Mazzucotelli). [Issue mkdocstrings/python#32](https://github.com/mkdocstrings/python/issues/32)

### Code Refactoring

- Simplify AST imports, stop using deprecated code from `ast` ([21d5832](https://github.com/mkdocstrings/griffe/commit/21d5832ba6db051b9754f515f1d7125126dd801f) by Timothée Mazzucotelli). [Issue #179](https://github.com/mkdocstrings/griffe/issues/179)

## [0.32.0](https://github.com/mkdocstrings/griffe/releases/tag/0.32.0) - 2023-07-13

[Compare with 0.31.0](https://github.com/mkdocstrings/griffe/compare/0.31.0...0.32.0)

### Deprecations

- Classes `InspectorExtension` and `VisitorExtension` are deprecated in favor of Extension. As a side-effect, the `hybrid` extension is also deprecated. See [how to use and write extensions](../guide/users/extending/).

### Breaking Changes

- Module `griffe.agents.base` was removed
- Module `griffe.docstrings.markdown` was removed
- Class `ASTNode` was removed
- Class `BaseInspector` was removed
- Class `BaseVisitor` was removed
- Function `get_parameter_default` was removed
- Function `load_extension` was removed (made private)
- Function `patch_ast` was removed
- Function `tmp_worktree` was removed (made private)
- Type Extension is now a class

### Features

- Numpy parser: handle return section items with just type, or no name and no type ([bdec37d](https://github.com/mkdocstrings/griffe/commit/bdec37dd32a5d4e089ee5e14e5a66be645bb8360) by Michael Chow). [Issue #173](https://github.com/mkdocstrings/griffe/issues/173), [PR #174](https://github.com/mkdocstrings/griffe/pull/174), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Rework extension system ([dea4c83](https://github.com/mkdocstrings/griffe/commit/dea4c830e3bfa0bf7c9f307975cb53e1314c50eb) by Timothée Mazzucotelli).
- Parse attribute values, parameter defaults and decorators as expressions ([7b653b3](https://github.com/mkdocstrings/griffe/commit/7b653b31bd9c38bf8d960baa5ab75dd56c62fbcb) by Timothée Mazzucotelli).
- Add loader option to avoid storing source code, reducing memory footprint ([d592edf](https://github.com/mkdocstrings/griffe/commit/d592edf477d9e7a5f9723c96cc259db65b1cae71) by Timothée Mazzucotelli).
- Add `extra` attribute to objects ([707a348](https://github.com/mkdocstrings/griffe/commit/707a34833f56cf4a1aa302cb1201ad96ff361252) by Timothée Mazzucotelli).

### Bug Fixes

- Numpy-style: don't strip spaces from the left of indented lines ([f13fc0a](https://github.com/mkdocstrings/griffe/commit/f13fc0a7edc7c8ac14c8c482b58735a5f7301bd6) by Timothée Mazzucotelli). [Discussion #587](https://github.com/mkdocstrings/mkdocstrings/discussions/587)
- Fix relative paths for old versions when checking API ([96fd45b](https://github.com/mkdocstrings/griffe/commit/96fd45b41186eb503d6a2ff4e587cae427aea013) by Timothée Mazzucotelli).

### Performance Improvements

- Don't store source when dumping as JSON ([d7f314a](https://github.com/mkdocstrings/griffe/commit/d7f314a62dd40c38c8c76ec7102233a588c1e64a) by Timothée Mazzucotelli).
- Stop caching properties on Object methods ([15bdd74](https://github.com/mkdocstrings/griffe/commit/15bdd744db1f089f4448b952f9acf184c43289ea) by Timothée Mazzucotelli).
- Stop patching AST, use functions instead ([7302f17](https://github.com/mkdocstrings/griffe/commit/7302f178392c70890d083a1617f1cf4e72395be3) by Timothée Mazzucotelli). [Issue #171](https://github.com/mkdocstrings/griffe/issues/171)

### Code Refactoring

- Privatize/remove objects ([fdeb16f](https://github.com/mkdocstrings/griffe/commit/fdeb16f61cb5ae7db2394ef2a8ec31843b7ae85b) by Timothée Mazzucotelli).
- Document public objects with `__all__` ([db0e0e3](https://github.com/mkdocstrings/griffe/commit/db0e0e340efcd48904f448a6e4397a9df36ac50f) by Timothée Mazzucotelli).
- Remove base visitor and inspector ([bc446e4](https://github.com/mkdocstrings/griffe/commit/bc446e4ac9445636be7fdadbfc0b056cbc1d73e3) by Timothée Mazzucotelli).
- Auto-register module in collection within loading helpers ([591bacc](https://github.com/mkdocstrings/griffe/commit/591bacc6c46d91beb30f6e01e0ae96f8e3102cf8) by Timothée Mazzucotelli). [Issue #177](https://github.com/mkdocstrings/griffe/issues/177)

## [0.31.0](https://github.com/mkdocstrings/griffe/releases/tag/0.31.0) - 2023-07-04

[Compare with 0.30.1](https://github.com/mkdocstrings/griffe/compare/0.30.1...0.31.0)

### Breaking Changes

- Drop support for Python 3.7
- API changes:
  - GriffeLoader.resolve_aliases(only_exported): Deprecated parameter was removed and replaced by `implicit` (inverse semantics)
  - GriffeLoader.resolve_aliases(only_known_modules): Deprecated parameter was removed and replaced by `external` (inverse semantics)
  - LinesCollection.tokens: Public object was removed (Python 3.7)
  - `ASTNode.end_lineno`: Public object was removed (Python 3.7)
  - `griffe.agents.extensions`: Deprecated module was removed and replaced by `griffe.extensions`

### Features

- Add `--color`, `--no-color` options to check subcommand ([eac783c](https://github.com/mkdocstrings/griffe/commit/eac783c2df5a0ba57612b71b0797a74cf7fc8e39) by Timothée Mazzucotelli).

### Bug Fixes

- Report removed public modules ([68906cb](https://github.com/mkdocstrings/griffe/commit/68906cb6083e5f7cad3a1cb5a74878d6e74f9c69) by Timothée Mazzucotelli).

### Code Refactoring

- Improve check output ([6b0a1f0](https://github.com/mkdocstrings/griffe/commit/6b0a1f0397d153a95d1b6c69d109ce141e39e1f1) by Timothée Mazzucotelli).
- Remove deprecated `griffe.agents.extensions` module ([b555c78](https://github.com/mkdocstrings/griffe/commit/b555c788b624fa5aa0c871e2c199079868252f22) by Timothée Mazzucotelli).
- Remove deprecated parameters from loader's `resolve_aliases` method ([dd98acd](https://github.com/mkdocstrings/griffe/commit/dd98acd5f0c85661c7a00002805c92caa4c11a21) by Timothée Mazzucotelli).
- Drop Python 3.7 support ([e4be30a](https://github.com/mkdocstrings/griffe/commit/e4be30a4c1025fd2f99f088c76f8e263714d8e33) by Timothée Mazzucotelli).

## [0.30.1](https://github.com/mkdocstrings/griffe/releases/tag/0.30.1) - 2023-07-02

[Compare with 0.30.0](https://github.com/mkdocstrings/griffe/compare/0.30.0...0.30.1)

### Bug Fixes

- Prevent duplicate yields of breaking changes ([9edef90](https://github.com/mkdocstrings/griffe/commit/9edef90d6c54b330046582e2a52ad88b5798d32c) by Timothée Mazzucotelli). [Issue #162](https://github.com/mkdocstrings/griffe/issues/162)
- Prevent alias resolution errors when checking for API breaking changes ([93c964a](https://github.com/mkdocstrings/griffe/commit/93c964a4cc3f759d101db45af5816a4d3b07c85e) by Timothée Mazzucotelli). [Issue #145](https://github.com/mkdocstrings/griffe/issues/145)
- Handle Git errors when checking for API breaking changes ([f9e8ba3](https://github.com/mkdocstrings/griffe/commit/f9e8ba381b75f650cfeb7bc96c976fec2251ac7a) by Timothée Mazzucotelli). [Issue #144](https://github.com/mkdocstrings/griffe/issues/144)

### Code Refactoring

- Force remove worktree branch when done checking ([45332ba](https://github.com/mkdocstrings/griffe/commit/45332ba89e213b4f9490ea7d2507d972267bed73) by Timothée Mazzucotelli).
- Change command to obtain latest tag ([f70f630](https://github.com/mkdocstrings/griffe/commit/f70f630ef7c67589d60c17ef4fb19c90127b2e06) by Timothée Mazzucotelli).

## [0.30.0](https://github.com/mkdocstrings/griffe/releases/tag/0.30.0) - 2023-06-30

[Compare with 0.29.1](https://github.com/mkdocstrings/griffe/compare/0.29.1...0.30.0)

### Features

- Add `allow_section_blank_line` option to the Numpy parser ([245845e](https://github.com/mkdocstrings/griffe/commit/245845ecaabedf4abb0af80d783702e55ea83883) by Michael Chow). [Issue #167](https://github.com/mkdocstrings/griffe/issues/167), [PR #168](https://github.com/mkdocstrings/griffe/pull/168)
- Support inheritance ([08bbe09](https://github.com/mkdocstrings/griffe/commit/08bbe09879dfa5440a359c8b2ad0b896c20c1dfc) by Timothée Mazzucotelli). [PR #170](https://github.com/mkdocstrings/griffe/pull/170)

### Bug Fixes

- Handle semi-colons in pth files ([e2ec661](https://github.com/mkdocstrings/griffe/commit/e2ec661e614df6c5f4fda1444468363777985b7c) by Michael Chow). [Issue #172](https://github.com/mkdocstrings/griffe/issues/172), [PR #175](https://github.com/mkdocstrings/griffe/pull/175)

### Code Refactoring

- Split members API in two parts: producer and consumer ([2269449](https://github.com/mkdocstrings/griffe/commit/226944983a9073d643ed09b47e7d3f99c76d3d5e) by Timothée Mazzucotelli). [PR #170](https://github.com/mkdocstrings/griffe/pull/170)

## [0.29.1](https://github.com/mkdocstrings/griffe/releases/tag/0.29.1) - 2023-06-19

[Compare with 0.29.0](https://github.com/mkdocstrings/griffe/compare/0.29.0...0.29.1)

### Bug Fixes

- Fix detection of optional and default in Numpydoc-style parameters ([3509106](https://github.com/mkdocstrings/griffe/commit/3509106399c5475ef71bb074dfa8f885e6759058) by Timothée Mazzucotelli). [Issue #165](https://github.com/mkdocstrings/griffe/issues/165)
- Fallback to string literal when parsing fails with syntax error ([53827c8](https://github.com/mkdocstrings/griffe/commit/53827c8c073e55a7f6d8ef61b36e9baf51f1c2bc) by Timothée Mazzucotelli). [Issue mkdocstrings/python#80](https://github.com/mkdocstrings/python/issues/80)
- Don't mutate finder's import paths ([a9e025a](https://github.com/mkdocstrings/griffe/commit/a9e025a16571b83713ce44f2be2356e498a847a2) by Timothée Mazzucotelli).
- Respect `external` when expanding wildcards ([8ef92c8](https://github.com/mkdocstrings/griffe/commit/8ef92c873db175dbd35e6d09277f6023a8fde32d) by Timothée Mazzucotelli).
- Extract actual type for yielded/received values ([3ea37ba](https://github.com/mkdocstrings/griffe/commit/3ea37ba2bcafea47f4b28bab6ae916ecb921b5ce) by Timothée Mazzucotelli). [Issue mkdocstrings/python#75](https://github.com/mkdocstrings/python/issues/75)

### Code Refactoring

- Improve error handling when importing a module ([a732e21](https://github.com/mkdocstrings/griffe/commit/a732e217622cc5ab2161479b9dde0ce59e2361af) by Timothée Mazzucotelli).
- Improve tests helpers (accept all visit/inspection parameters) ([6da5869](https://github.com/mkdocstrings/griffe/commit/6da586963cddff4dceadcd4b485dbb805830b6ea) by Timothée Mazzucotelli).
- Allow passing a modules collection to the inspector, for consistency with the visitor ([5f73a28](https://github.com/mkdocstrings/griffe/commit/5f73a28a09a4b445fa253356034c5ef40b9ecfec) by Timothée Mazzucotelli).
- Always add import path of module to inspect when it has a file path ([4021e6f](https://github.com/mkdocstrings/griffe/commit/4021e6fe9f5e06543f9709e7ae42f6ad8cd0b093) by Timothée Mazzucotelli).

## [0.29.0](https://github.com/mkdocstrings/griffe/releases/tag/0.29.0) - 2023-05-26

[Compare with 0.28.2](https://github.com/mkdocstrings/griffe/compare/0.28.2...0.29.0)

### Features

- Provide test helpers and pytest fixtures ([611ed58](https://github.com/mkdocstrings/griffe/commit/611ed5868e22ac3ada6467ba25c6dab606f5dee7) by Timothée Mazzucotelli).

## [0.28.2](https://github.com/mkdocstrings/griffe/releases/tag/0.28.2) - 2023-05-24

[Compare with 0.28.1](https://github.com/mkdocstrings/griffe/compare/0.28.1...0.28.2)

### Bug Fixes

- Correctly resolve full expressions ([fa57f4f](https://github.com/mkdocstrings/griffe/commit/fa57f4ff6495679b4e7e70d72d5adb80bd8ebc56) by Timothée Mazzucotelli). [Issue mkdocstrings/autorefs#23](https://github.com/mkdocstrings/autorefs/issues/23)
- Use `full` attribute instead of `canonical` for expressions ([4338ccc](https://github.com/mkdocstrings/griffe/commit/4338ccc9234f0c4df0ea302a81092a4f3d29f0bf) by Michael Chow). [Issue #163](https://github.com/mkdocstrings/griffe/issues/163), [PR #164](https://github.com/mkdocstrings/griffe/pull/164)

## [0.28.1](https://github.com/mkdocstrings/griffe/releases/tag/0.28.1) - 2023-05-22

[Compare with 0.28.0](https://github.com/mkdocstrings/griffe/compare/0.28.0...0.28.1)

### Bug Fixes

- Return docstring warnings as warnings, not attributes ([7bd51ba](https://github.com/mkdocstrings/griffe/commit/7bd51ba7c9c268a1cc378d38fdff3a891adc520c) by Matthew Anderson). [PR #161](https://github.com/mkdocstrings/griffe/pull/161)

### Code Refactoring

- Refactor AST nodes parsers ([7e53127](https://github.com/mkdocstrings/griffe/commit/7e5312744cd7f6ad3baba54fe8194d15896f5e6d) by Timothée Mazzucotelli). [Issue #160](https://github.com/mkdocstrings/griffe/issues/160)
- Full expressions use canonical names ([65c7184](https://github.com/mkdocstrings/griffe/commit/65c7184b5462b70debce1195c69449935cb0a0b1) by Timothée Mazzucotelli).

## [0.28.0](https://github.com/mkdocstrings/griffe/releases/tag/0.28.0) - 2023-05-17

[Compare with 0.27.5](https://github.com/mkdocstrings/griffe/compare/0.27.5...0.28.0)

### Features

- Support scikit-build-core editable modules (partially) ([eb64779](https://github.com/mkdocstrings/griffe/commit/eb64779cb5408553bd4923ab9cdfc72d0b5e6103) by Timothée Mazzucotelli). [Issue #154](https://github.com/mkdocstrings/griffe/issues/154)

### Bug Fixes

- Parse complex, stringified annotations ([f743616](https://github.com/mkdocstrings/griffe/commit/f74361684a2cd5db153875b8880788c254828e95) by Timothée Mazzucotelli). [Issue #159](https://github.com/mkdocstrings/griffe/issues/159)

## [0.27.5](https://github.com/mkdocstrings/griffe/releases/tag/0.27.5) - 2023-05-12

[Compare with 0.27.4](https://github.com/mkdocstrings/griffe/compare/0.27.4...0.27.5)

### Code Refactoring

- Represent function using their names when inspecting default values ([9116c1f](https://github.com/mkdocstrings/griffe/commit/9116c1fbb562c894547d72207921c02259147958) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#180](https://github.com/mkdocstrings/mkdocstrings/issues/180)

## [0.27.4](https://github.com/mkdocstrings/griffe/releases/tag/0.27.4) - 2023-05-10

[Compare with 0.27.3](https://github.com/mkdocstrings/griffe/compare/0.27.3...0.27.4)

### Bug Fixes

- Don't recurse through targets, get directly to final target and handle alias-related errors ([c5bc197](https://github.com/mkdocstrings/griffe/commit/c5bc1973975951389501addf567622c0e3eb71c6) by Timothée Mazzucotelli). [Issue #155](https://github.com/mkdocstrings/griffe/issues/155)

### Code Refactoring

- Follow `.pth` files to extend search paths with editable modules ([79bf724](https://github.com/mkdocstrings/griffe/commit/79bf72498150588d05ccdfc80a898c0330e08247) by Timothée Mazzucotelli). [Issue #154](https://github.com/mkdocstrings/griffe/issues/154)
- Add default values to `_load_packages` helper ([f104c20](https://github.com/mkdocstrings/griffe/commit/f104c20304dcf24c5d2e39220302a941db4161eb) by Timothée Mazzucotelli).

## [0.27.3](https://github.com/mkdocstrings/griffe/releases/tag/0.27.3) - 2023-05-05

[Compare with 0.27.2](https://github.com/mkdocstrings/griffe/compare/0.27.2...0.27.3)

### Bug Fixes

- Allow setting docstring through alias ([2e0f553](https://github.com/mkdocstrings/griffe/commit/2e0f553c833e9b27f5e97c05065c2127212b603c) by Timothée Mazzucotelli).
- Prevent infinite recursion ([0e98546](https://github.com/mkdocstrings/griffe/commit/0e985460eb886ea832e7cbefca261620eedb0e56) by Timothée Mazzucotelli). [Issue #155](https://github.com/mkdocstrings/griffe/issues/155)

## [0.27.2](https://github.com/mkdocstrings/griffe/releases/tag/0.27.2) - 2023-05-03

[Compare with 0.27.1](https://github.com/mkdocstrings/griffe/compare/0.27.1...0.27.2)

### Dependencies

- Remove async extra (aiofiles) ([70d9b93](https://github.com/mkdocstrings/griffe/commit/70d9b9305370f03c221876838aaad9b72dc388d3) by Timothée Mazzucotelli).

### Bug Fixes

- Support walrus operator ([bf721f4](https://github.com/mkdocstrings/griffe/commit/bf721f4dd2bb7f1a6695b5c880df821920b994a6) by Timothée Mazzucotelli). [Issue #152](https://github.com/mkdocstrings/griffe/issues/152)
- Respect `ClassVar` annotation ([60e01c1](https://github.com/mkdocstrings/griffe/commit/60e01c126df4e0529fe3806f9c2637a5a45dd138) by Victor Westerhuis). [PR #150](https://github.com/mkdocstrings/griffe/pull/150), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)
- Add missing "other args" section aliases ([f5c0a0e](https://github.com/mkdocstrings/griffe/commit/f5c0a0ee70c34063ea38a8e76dcba4923f9673cb) by Timothée Mazzucotelli).

### Code Refactoring

- Move utils from cli to respective modules ([c6ce49e](https://github.com/mkdocstrings/griffe/commit/c6ce49eb75c1799982b40a7862a1a7888f0fab93) by Timothée Mazzucotelli).

## [0.27.1](https://github.com/mkdocstrings/griffe/releases/tag/0.27.1) - 2023-04-16

[Compare with 0.27.0](https://github.com/mkdocstrings/griffe/compare/0.27.0...0.27.1)

### Bug Fixes

- Actually parse warnings sections ([bc00da5](https://github.com/mkdocstrings/griffe/commit/bc00da5e9dfe4b2aee906000759e0c1e0a2f893b) by Timothée Mazzucotelli).
- Allow Raises and Warns items to start with a newline ([f3b088c](https://github.com/mkdocstrings/griffe/commit/f3b088c02b3be86934125b142876b0dfb3702677) by Victor Westerhuis). [PR #149](https://github.com/mkdocstrings/griffe/pull/149), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

## [0.27.0](https://github.com/mkdocstrings/griffe/releases/tag/0.27.0) - 2023-04-10

[Compare with 0.26.0](https://github.com/mkdocstrings/griffe/compare/0.26.0...0.27.0)

### Features

- Implement basic handling of Alias for breaking changes ([aa8ce00](https://github.com/mkdocstrings/griffe/commit/aa8ce009c8d69f7830bc46bc80dac34907b8ae83) by Yurii). [PR #140](https://github.com/mkdocstrings/griffe/pull/140), Co-authored-by: Timothée Mazzucotelli [pawamoy@pm.me](mailto:pawamoy@pm.me)

### Bug Fixes

- Support `Literal` imported from `typing_extensions` ([3a16e58](https://github.com/mkdocstrings/griffe/commit/3a16e5858649f7d786ef8a60b9dfd588f406cd9d) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#545](https://github.com/mkdocstrings/mkdocstrings/issues/545)
- Fix parameter default checking logic and diff tests ([1b940fd](https://github.com/mkdocstrings/griffe/commit/1b940fd270b3e51dc0f62edb500a6a3e85908953) by Timothée Mazzucotelli).

## [0.26.0](https://github.com/mkdocstrings/griffe/releases/tag/0.26.0) - 2023-04-03

[Compare with 0.25.5](https://github.com/mkdocstrings/griffe/compare/0.25.5...0.26.0)

### Breaking Changes

- `AliasResolutionError` instances don't have a `target_path` attribute anymore. It is instead replaced by an `alias` attribute which is a reference to an `Alias` instance.
- Lots of positional-or-keyword parameters were changed to keyword-only parameters.

### Deprecations

- The `griffe.agents.extensions` module was moved to `griffe.extensions`. The old path is deprecated.

### Features

- Support newer versions of `editables` ([ab7a3be](https://github.com/mkdocstrings/griffe/commit/ab7a3be3902af5f4af1d1e762b2b6e532826569f) by Timothée Mazzucotelli): the names of editable modules have changed from `__editables_*` to `_editable_impl_*`.
- Provide a JSON schema ([7dfed39](https://github.com/mkdocstrings/griffe/commit/7dfed391c7714a9d1aea9223e1f8c9403d47e8bb) by Timothée Mazzucotelli).
- Allow hybrid extension to filter objects and run multiple inspectors ([f8ff53a](https://github.com/mkdocstrings/griffe/commit/f8ff53a69a3a131998649d1a9ba272827b7f2adc) by Timothée Mazzucotelli).
- Allow loading extension from file path ([131454e](https://github.com/mkdocstrings/griffe/commit/131454eece81da33cd7f1a8bf2ae030950df8441) by Timothée Mazzucotelli).
- Add back `relative_filepath` which now really returns the filepath relative to the current working directory ([40fe0c5](https://github.com/mkdocstrings/griffe/commit/40fe0c53be8ff72f254bd88e9c9cf6df36d3bcb9) by Timothée Mazzucotelli).

### Bug Fixes

- Fix JSON schema for ending line numbers (and add test) ([318c6b4](https://github.com/mkdocstrings/griffe/commit/318c6b41c0160070de1b10118d210cacd5f2e711) by Timothée Mazzucotelli).
- Prevent cyclic aliases by not overwriting a module member with an indirect alias to itself ([c188a95](https://github.com/mkdocstrings/griffe/commit/c188a95b823e876f89ba9046df2cb06348f92459) by Timothée Mazzucotelli). [Issue #122](https://github.com/mkdocstrings/griffe/issues/122)
- Prevent alias resolution errors when copying docstring or labels from previously existing attribute ([48747b6](https://github.com/mkdocstrings/griffe/commit/48747b6d14bdf1be03cfa5bbf849771e3e6801b0) by Timothée Mazzucotelli).
- Fix Google admonition regular expression ([ef0be5f](https://github.com/mkdocstrings/griffe/commit/ef0be5f8f276a5ef2397ad89c0cfce0e1b41020e) by Timothée Mazzucotelli).
- Add back `griffe.agents.extensions` module (deprecated) ([7129477](https://github.com/mkdocstrings/griffe/commit/7129477184f0b88d3bf165dfe8e1f6158c30914a) by Timothée Mazzucotelli).
- Forward class attribute docstrings to instances ([7bf4952](https://github.com/mkdocstrings/griffe/commit/7bf49528541e211af37c2ac5c1a74a4523699c65) by Rodrigo Girão Serrão). [Issue #128](https://github.com/mkdocstrings/griffe/issues/128), [PR #135](https://github.com/mkdocstrings/griffe/pull/135)
- Prevent errors related to getting attributes in the inspector ([5d15d27](https://github.com/mkdocstrings/griffe/commit/5d15d276259a4b9a70fbe490d86234e667711180) by Timothée Mazzucotelli).
- Catch "member does not exist" errors while expanding wildcards ([a966022](https://github.com/mkdocstrings/griffe/commit/a9660220c0b5e9e786877efa228452a643e93c76) by Timothée Mazzucotelli).
- Catch more inspection errors ([4f6eef9](https://github.com/mkdocstrings/griffe/commit/4f6eef9b0fbcdf56d61ac4bec9dc4ef3b90dd116) by Timothée Mazzucotelli).

### Code Refactoring

- Log final path after resolving alias ([c7ec7f7](https://github.com/mkdocstrings/griffe/commit/c7ec7f7ca029492ced68737851d66256c5035f70) by Timothée Mazzucotelli).
- Move extensions one level up ([67ebd71](https://github.com/mkdocstrings/griffe/commit/67ebd71f9b0933f08b263d0b21520dc0b1a5c4ff) by Timothée Mazzucotelli).
- Set default `when` value on extension base classes ([e8ad889](https://github.com/mkdocstrings/griffe/commit/e8ad8893aaad2549bff134a7bf3dfe5a86bfc960) by Timothée Mazzucotelli).
- Rename `relative_filepath` to `relative_package_filepath` to better express what it does ([6148f85](https://github.com/mkdocstrings/griffe/commit/6148f85c56848c6bb3e7df8986f1bb208e7083cf) by Timothée Mazzucotelli).
- Show file name and line number in alias resolution error messages ([c48928d](https://github.com/mkdocstrings/griffe/commit/c48928df4a75be35771d39bf96699d801485b31d) by Timothée Mazzucotelli).

## [0.25.5](https://github.com/mkdocstrings/griffe/releases/tag/0.25.5) - 2023-02-16

[Compare with 0.25.4](https://github.com/mkdocstrings/griffe/compare/0.25.4...0.25.5)

### Bug Fixes

- Fix parsing empty lines with indentation in Google docstrings ([705edff](https://github.com/mkdocstrings/griffe/commit/705edff6c208281bdab387a464799de613b087b5) by Timothée Mazzucotelli). [Issue #129](https://github.com/mkdocstrings/griffe/issues/129)

## [0.25.4](https://github.com/mkdocstrings/griffe/releases/tag/0.25.4) - 2023-01-19

[Compare with 0.25.3](https://github.com/mkdocstrings/griffe/compare/0.25.3...0.25.4)

### Bug Fixes

- Fix creation of aliases to modules when inspecting ([54242cb](https://github.com/mkdocstrings/griffe/commit/54242cbdbbcb68785942fa327113cd6508815fa9) by Timothée Mazzucotelli).
- Support (setuptools) editable packages with multiple roots ([bd37dfb](https://github.com/mkdocstrings/griffe/commit/bd37dfb16b43fac53207b426ee02218e57a5d5d1) by Gilad). [PR #126](https://github.com/mkdocstrings/griffe/pull/126)

## [0.25.3](https://github.com/mkdocstrings/griffe/releases/tag/0.25.3) - 2023-01-04

[Compare with 0.25.2](https://github.com/mkdocstrings/griffe/compare/0.25.2...0.25.3)

### Bug Fixes

- Fix parsing of annotations in Numpy attributes sections ([18fa396](https://github.com/mkdocstrings/griffe/commit/18fa39612b828e2892665b7367f7cdf76908970c) by Timothée Mazzucotelli). [Issue #72](https://github.com/mkdocstrings/griffe/issues/72)

## [0.25.2](https://github.com/mkdocstrings/griffe/releases/tag/0.25.2) - 2022-12-24

[Compare with 0.25.1](https://github.com/mkdocstrings/griffe/compare/0.25.1...0.25.2)

### Bug Fixes

- Make sure passage through aliases is reset ([79733f4](https://github.com/mkdocstrings/griffe/commit/79733f4d03f3f66b948dc17c57404349d9e72c9a) by Timothée Mazzucotelli). [Issue #123](https://github.com/mkdocstrings/griffe/issues/123)
- Ignore cyclic alias errors when updating target aliases ([bb62b2f](https://github.com/mkdocstrings/griffe/commit/bb62b2f744d221efedeba1cb33151b3787d2ee57) by Timothée Mazzucotelli). [Issue #123](https://github.com/mkdocstrings/griffe/issues/123)

## [0.25.1](https://github.com/mkdocstrings/griffe/releases/tag/0.25.1) - 2022-12-20

[Compare with 0.25.0](https://github.com/mkdocstrings/griffe/compare/0.25.0...0.25.1)

### Bug Fixes

- Pass through aliases earlier to prevent infinite recursion ([e533f29](https://github.com/mkdocstrings/griffe/commit/e533f29258838a1e171dea702fb033bfa68ed089) by Timothée Mazzucotelli). [Issue #83](https://github.com/mkdocstrings/griffe/issues/83), [#122](https://github.com/mkdocstrings/griffe/issues/122)

## [0.25.0](https://github.com/mkdocstrings/griffe/releases/tag/0.25.0) - 2022-12-11

[Compare with 0.24.1](https://github.com/mkdocstrings/griffe/compare/0.24.1...0.25.0)

### Breaking changes

- Parameter `only_known_modules` was renamed `external` in the expand_wildcards() method of the loader.
- Exception `UnhandledEditablesModuleError` was renamed `UnhandledEditableModuleError` since we now support editable installation from other packages than `editables`.

### Highlights

- Properties are now fetched as attributes rather than functions, since that is how they are used. This was asked by users, and since Griffe generates signatures for Python APIs (emphasis on **APIs**), it makes sense to return data that matches the interface provided to users. Such property objects in Griffe's output will still have the associated `property` labels of course.
- Lots of bug fixes. These bugs were discovered by running Griffe on *many* major packages as well as the standard library (again). Particularly, alias resolution should be more robust now, and should generate less issues like cyclic aliases, meaning indirect/wildcard imports should be better understood. We still highly discourage the use of wildcard imports

### Features

- Support `setuptools` editable modules ([abc18f7](https://github.com/mkdocstrings/griffe/commit/abc18f7b94cea7b7850bb9f14ebc4822beb1d27c) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#463](https://github.com/mkdocstrings/mkdocstrings/issues/463)
- Support merging stubs on wildcard imported objects ([0ed9c36](https://github.com/mkdocstrings/griffe/commit/0ed9c363b6b064361d311acee1732e757899291b) by Timothée Mazzucotelli). [Issue #116](https://github.com/mkdocstrings/griffe/issues/116)

### Bug Fixes

- Prevent cyclic alias creation when expanding wildcards ([a77e4e8](https://github.com/mkdocstrings/griffe/commit/a77e4e8bbba8a24d9f604eaff4cc57c6851c14c3) by Timothée Mazzucotelli).
- Don't crash and show hint when wildcard expansion fails ([336faf6](https://github.com/mkdocstrings/griffe/commit/336faf6dff679c970e594151a7a5d2bd99f52af6) by Timothée Mazzucotelli).
- Register top module after inspection ([86454ec](https://github.com/mkdocstrings/griffe/commit/86454ececfa8e88b0f1024bde49e6dd0cb8542d0) by Timothée Mazzucotelli).
- Set alias attributes early ([2ac1a9b](https://github.com/mkdocstrings/griffe/commit/2ac1a9bafb632daa491b3d26f2c39d74c9b31e3d) by Timothée Mazzucotelli).
- Allow writing attributes on aliases ([c8f736e](https://github.com/mkdocstrings/griffe/commit/c8f736efcee354d2c47675413955390e80e77425) by Timothée Mazzucotelli).
- Don't crash on inspection of functions signatures ([051e337](https://github.com/mkdocstrings/griffe/commit/051e337306006a60b4ae0da030a6fb912db1f05c) by Timothée Mazzucotelli).
- Don't crash on inspection of method descriptors' docstrings ([09571bb](https://github.com/mkdocstrings/griffe/commit/09571bb6ffebe041ac9fdd143fc4a1cb239dda63) by Timothée Mazzucotelli).
- Fix stats computing (handle stubs and namespace packages) ([a81f8dc](https://github.com/mkdocstrings/griffe/commit/a81f8dcf9e8eedc3a42cfdaaaaa28ec9379e2c4b) by Timothée Mazzucotelli).
- Support documenting multiple items for optional tuples ([727456d](https://github.com/mkdocstrings/griffe/commit/727456deba90ac01a04119371b72c011755360b6) by Timothée Mazzucotelli). [Issue #117](https://github.com/mkdocstrings/griffe/issues/117)
- Fix comparing names with strings ([37ae0a2](https://github.com/mkdocstrings/griffe/commit/37ae0a2f37c7e446c890d9e1204edddfb3591dc7) by Timothée Mazzucotelli). [Issue #114](https://github.com/mkdocstrings/griffe/issues/114)
- Fix deepcopy crashing because of `__getattr__` ([11b023b](https://github.com/mkdocstrings/griffe/commit/11b023b8bc0575313a9aea1f6ef99944c8b02537) by Timothée Mazzucotelli). [Issue #73](https://github.com/mkdocstrings/griffe/issues/73), [PR #119](https://github.com/mkdocstrings/griffe/pull/119)

### Code Refactoring

- Prevent reloading of failed modules ([8ef14ab](https://github.com/mkdocstrings/griffe/commit/8ef14ab6389bb06e1903c7628dd1d811f2af101a) by Timothée Mazzucotelli).
- Rename `only_known_modules` parameter to `external` ([5f816c6](https://github.com/mkdocstrings/griffe/commit/5f816c67222f9aa1bd008782430501a2de26d5a4) by Timothée Mazzucotelli).
- Rework alias creation decision in the inspector ([f434943](https://github.com/mkdocstrings/griffe/commit/f434943579e02fb02c28f7e2be65293f6ab6b657) by Timothée Mazzucotelli).
- Resolve alias chain recursively ([6cdd3b2](https://github.com/mkdocstrings/griffe/commit/6cdd3b2ed4170347282118c06407b587cd65fd36) by Timothée Mazzucotelli).
- Don't try to stubs-merge identical modules ([7099971](https://github.com/mkdocstrings/griffe/commit/7099971e441d5dd804c0304f010343a558685f9a) by Timothée Mazzucotelli).
- Load properties as attributes ([5c97a45](https://github.com/mkdocstrings/griffe/commit/5c97a45087e0ba8c39a9745d9c5248c4c35909a8) by Timothée Mazzucotelli). [Issue mkdocstrings/python#9](https://github.com/mkdocstrings/python/issues/9)
- Use a cyclic relationship map for inspection ([9a2a711](https://github.com/mkdocstrings/griffe/commit/9a2a7117d2d9d7b8327e640e8760594349531627) by Timothée Mazzucotelli). [PR #115](https://github.com/mkdocstrings/griffe/pull/115)

## [0.24.1](https://github.com/mkdocstrings/griffe/releases/tag/0.24.1) - 2022-11-18

[Compare with 0.24.0](https://github.com/mkdocstrings/griffe/compare/0.24.0...0.24.1)

### Bug Fixes

- Support nested namespace packages ([d571f8f](https://github.com/mkdocstrings/griffe/commit/d571f8f726d50b34c84fbdaa6db3b2059cfe9dec) by Timothée Mazzucotelli).

## [0.24.0](https://github.com/mkdocstrings/griffe/releases/tag/0.24.0) - 2022-11-13

[Compare with 0.23.0](https://github.com/mkdocstrings/griffe/compare/0.23.0...0.24.0)

The "Breaking Changes" and "Deprecations" sections are proudly written with the help of our new API breakage detection feature ! Many thanks to Talley Lambert ([@tlambert03](https://github.com/tlambert03)) for the initial code allowing to compare two Griffe trees.

### Breaking Changes

- All parameters of the load_git function, except `module`, are now keyword-only.
- Parameter `try_relative_path` of the load_git function was removed.
- Parameter `commit` was renamed `ref` in the load_git function.
- Parameter `commit` was renamed `ref` in the `tmp_worktree` helper, which will probably become private later.
- Parameters `ref` and `repo` switched positions in the `tmp_worktree` helper.
- All parameters of the resolve_aliases method are now keyword-only.
- Parameters `only_exported` and `only_known_modules` of the resolve_module_aliases method were removed. This method is most probably not used by anyone, and will probably be made private in the future.

### Deprecations

- Parameters `only_exported` and `only_known_modules` of the resolve_aliases method are deprecated in favor of their inverted counter-part `implicit` and `external` parameters.

  - Example before: `loader.resolve_aliases(only_exported=True, only_known_modules=True)`
  - Example after: `loader.resolve_aliases(implicit=False, external=False)`

### Features

- Add CLI command to check for API breakages ([90bded4](https://github.com/mkdocstrings/griffe/commit/90bded46ccaab0417ed57ed11d3b67597f3845ba) by Timothée Mazzucotelli). [Issue #75](https://github.com/mkdocstrings/griffe/issues/75), [PR #105](https://github.com/mkdocstrings/griffe/pull/105)
- Add function to find API breaking changes ([a4f1280](https://github.com/mkdocstrings/griffe/commit/a4f1280a2b65fabc4caa4448d556ac3e83b2f0d0) by Talley Lambert and Timothée Mazzucotelli). [Issue #75](https://github.com/mkdocstrings/griffe/issues/75), [PR #105](https://github.com/mkdocstrings/griffe/pull/105)

### Bug Fixes

- Fix labels mismatch staticmethod-classmethod in inspector ([25060f6](https://github.com/mkdocstrings/griffe/commit/25060f6dad686c73bd32203dc1b3ac789fdc4aef) by Timothée Mazzucotelli). [Issue #111](https://github.com/mkdocstrings/griffe/issues/111)
- Prevent infinite loop while looking for package's parent folder ([f297f1a](https://github.com/mkdocstrings/griffe/commit/f297f1a6550ecadf77c34effe45802327340b1c4) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#72](https://github.com/mkdocstrings/mkdocstrings/issues/72)
- Fix comparing names and expressions ([07bffff](https://github.com/mkdocstrings/griffe/commit/07bffff71845d3c9e66007a6a7de269f17312d2b) by Timothée Mazzucotelli).

### Code Refactoring

- Rename some parameters in Git module ([9ad7a2c](https://github.com/mkdocstrings/griffe/commit/9ad7a2c1abde97556d9b4657bef4231e1ef6fa19) by Timothée Mazzucotelli).
- Set parameters as keyword-only ([44c01be](https://github.com/mkdocstrings/griffe/commit/44c01bec147add34ba3f5ac716ac6722540e3ba7) by Timothée Mazzucotelli).
- Remove stars from parameters names ([91dce14](https://github.com/mkdocstrings/griffe/commit/91dce14d7fa3c8c2075a3319fdd7636443fe6cbc) by Timothée Mazzucotelli).
- Refactor CLI to use subcommands ([760b091](https://github.com/mkdocstrings/griffe/commit/760b0918c60911386932cec720418af8d3360c1b) by Timothée Mazzucotelli). [PR #110](https://github.com/mkdocstrings/griffe/pull/110)
- Rename parameters used when resolving aliases ([3d3a4eb](https://github.com/mkdocstrings/griffe/commit/3d3a4eb99e587bd9dd7bfadca4c45737fb886139) by Timothée Mazzucotelli).

## [0.23.0](https://github.com/mkdocstrings/griffe/releases/tag/0.23.0) - 2022-10-26

[Compare with 0.22.2](https://github.com/mkdocstrings/griffe/compare/0.22.2...0.23.0)

### Features

- Support `typing_extensions.overload` ([c29fad5](https://github.com/mkdocstrings/griffe/commit/c29fad58c721399badfc93ff8e0f10a6f92c359e) by Nyuan Zhang). [PR #108](https://github.com/mkdocstrings/griffe/pull/108)

### Bug Fixes

- Log debug instead of errors when failing to parse NumPy annotations for additional sections ([568ff60](https://github.com/mkdocstrings/griffe/commit/568ff60621c0b5cc35ac0e0d0209fa3bc1b2ba8a) by Sigurd Spieckermann). [Issue #93](https://github.com/mkdocstrings/griffe/issues/93), [PR #109](https://github.com/mkdocstrings/griffe/pull/109)
- Don't strip too many parentheses around a call node ([bb5c5e7](https://github.com/mkdocstrings/griffe/commit/bb5c5e71f95c537ca2d19299b157a0bbf59e5279) by Timothée Mazzucotelli). [PR #107](https://github.com/mkdocstrings/griffe/pull/107)
- Guard against more alias resolution errors ([2be135d](https://github.com/mkdocstrings/griffe/commit/2be135d8ab88d6f97175c958e31e76b0d7d8f934) by Timothée Mazzucotelli). [Issue #83](https://github.com/mkdocstrings/griffe/issues/83), [PR #103](https://github.com/mkdocstrings/griffe/pull/103)

## [0.22.2](https://github.com/mkdocstrings/griffe/releases/tag/0.22.2) - 2022-09-24

[Compare with 0.22.1](https://github.com/mkdocstrings/griffe/compare/0.22.1...0.22.2)

### Bug Fixes

- Log debug instead of errors when failing to parse Numpy annotations ([75eeeda](https://github.com/mkdocstrings/griffe/commit/75eeeda2f1181ae680b3d47df3814bad200220d3) by Timothée Mazzucotelli). [Issue #93](https://github.com/mkdocstrings/griffe/issues/93)
- Don't crash on unsupported module names (containing dots) ([6a57194](https://github.com/mkdocstrings/griffe/commit/6a571949000a3d2910990337f96751c0cac7e815) by Timothée Mazzucotelli). [Issue #94](https://github.com/mkdocstrings/griffe/issues/94)
- Show correct docstring line numbers on Python 3.7 ([edd4b6d](https://github.com/mkdocstrings/griffe/commit/edd4b6d23f4399960db4e16a8c269318aef033d6) by Timothée Mazzucotelli). [Issue #98](https://github.com/mkdocstrings/griffe/issues/98)
- Fix parsing of Numpy docstring with an Examples section at the end ([3114727](https://github.com/mkdocstrings/griffe/commit/3114727296891fdd5cacecf487652774ee6e4fc8) by Timothée Mazzucotelli). [Issue #97](https://github.com/mkdocstrings/griffe/issues/97)
- Don't crash on unsupported item in `__all__` (log a warning instead) ([9e5df0a](https://github.com/mkdocstrings/griffe/commit/9e5df0aea8e615217554e5204221a35c9df25938) by Timothée Mazzucotelli). [Issue #92](https://github.com/mkdocstrings/griffe/issues/92)
- Prevent infinite recursion while expanding exports ([68446f7](https://github.com/mkdocstrings/griffe/commit/68446f7ab94536596dccb690fb2cac613cd32460) by Timothée Mazzucotelli).
- Add missing check while expanding wildcards ([7e816ed](https://github.com/mkdocstrings/griffe/commit/7e816ed141d6f13bf1ae7c758c32e68cc663fe0e) by Timothée Mazzucotelli).

## [0.22.1](https://github.com/mkdocstrings/griffe/releases/tag/0.22.1) - 2022-09-10

[Compare with 0.22.0](https://github.com/mkdocstrings/griffe/compare/0.22.0...0.22.1)

### Bug Fixes

- Always use `encoding="utf8"` when reading text files ([3b279bf](https://github.com/mkdocstrings/griffe/commit/3b279bf61afabc7312e9e58745fd19a53d97ac74) by Rudolf Byker). [Issue #99](https://github.com/mkdocstrings/griffe/issues/99), [PR #100](https://github.com/mkdocstrings/griffe/pull/100)

## [0.22.0](https://github.com/mkdocstrings/griffe/releases/tag/0.22.0) - 2022-06-28

[Compare with 0.21.0](https://github.com/mkdocstrings/griffe/compare/0.21.0...0.22.0)

### Features

- Support forward references ([245daea](https://github.com/mkdocstrings/griffe/commit/245daeabc8130bd7ecab86f55c4906d9161b9e73) by Timothée Mazzucotelli). [Issue #86](https://github.com/mkdocstrings/griffe/issues/86)

### Code Refactoring

- Safely parse annotations and values ([b023e2b](https://github.com/mkdocstrings/griffe/commit/b023e2be509f3ac39dbe1ed9adf21247e4416e53) by Timothée Mazzucotelli).

## [0.21.0](https://github.com/mkdocstrings/griffe/releases/tag/0.21.0) - 2022-06-25

[Compare with 0.20.0](https://github.com/mkdocstrings/griffe/compare/0.20.0...0.21.0)

### Features

- Add `load_git` function allowing to load data from a specific git ref ([b2c3946](https://github.com/mkdocstrings/griffe/commit/b2c39467630c33edc914dd7e6dc96fb611267905) by Talley Lambert). [Issue #75](https://github.com/mkdocstrings/griffe/issues/75), [PR #76](https://github.com/mkdocstrings/griffe/pull/76)

### Bug Fixes

- Fix detecting and merging stubs for single-file packages ([6a82542](https://github.com/mkdocstrings/griffe/commit/6a825423a9dfd86343532c2872980240f2e98b74) by Talley Lambert). [Issue #77](https://github.com/mkdocstrings/griffe/issues/77), [PR #78](https://github.com/mkdocstrings/griffe/pull/78)
- Fix parsing ExtSlice nodes when getting values ([b2fe968](https://github.com/mkdocstrings/griffe/commit/b2fe9684f274786decdf9fb395bebc5057235eda) by Timothée Mazzucotelli). [Issue #87](https://github.com/mkdocstrings/griffe/issues/87)
- Don't trigger alias resolution when merging stubs ([2b88627](https://github.com/mkdocstrings/griffe/commit/2b88627862b8db50045cc97ae5644abd36f36b5a) by Timothée Mazzucotelli). [Issue #89](https://github.com/mkdocstrings/griffe/issues/89)
- Fix handling of .pth files ([f212dd3](https://github.com/mkdocstrings/griffe/commit/f212dd3b92f51a64795fdbb30aefd0a730393523) by Gabriel Dugny). [Issue #84](https://github.com/mkdocstrings/griffe/issues/84), [PR #85](https://github.com/mkdocstrings/griffe/pull/85)

## [0.20.0](https://github.com/mkdocstrings/griffe/releases/tag/0.20.0) - 2022-06-03

[Compare with 0.19.3](https://github.com/mkdocstrings/griffe/compare/0.19.3...0.20.0)

### Features

- Add `as_json` and `from_json` convenience methods on objects ([5c3d751](https://github.com/mkdocstrings/griffe/commit/5c3d7511d2465e16805fa564c3d60d44618410d8) by Talley Lambert). [PR #74](https://github.com/mkdocstrings/griffe/pull/74)

### Bug Fixes

- Fix unparsing of f-strings ([9ca74bd](https://github.com/mkdocstrings/griffe/commit/9ca74bd144167de9506cf5b0725a784e52f5e67a) by Timothée Mazzucotelli). [Issue #80](https://github.com/mkdocstrings/griffe/issues/80)
- Don't crash when overwriting a submodule with a wildcard imported attribute ([bfad1cc](https://github.com/mkdocstrings/griffe/commit/bfad1ccf079e69fa0161754d9f1f7edd5819f943) by Timothée Mazzucotelli). [Issue #72](https://github.com/mkdocstrings/griffe/issues/72), [#79](https://github.com/mkdocstrings/griffe/issues/79), [mkdocstrings/mkdocstrings#438](https://github.com/mkdocstrings/mkdocstrings/issues/438)

## [0.19.3](https://github.com/mkdocstrings/griffe/releases/tag/0.19.3) - 2022-05-26

[Compare with 0.19.2](https://github.com/mkdocstrings/griffe/compare/0.19.2...0.19.3)

### Bug Fixes

- Support USub and UAdd nodes in annotations ([1169c51](https://github.com/mkdocstrings/griffe/commit/1169c51bd6ae04f491fa5e50cae93d99e8ce920d) by Timothée Mazzucotelli). [Issue #71](https://github.com/mkdocstrings/griffe/issues/71)

## [0.19.2](https://github.com/mkdocstrings/griffe/releases/tag/0.19.2) - 2022-05-18

[Compare with 0.19.1](https://github.com/mkdocstrings/griffe/compare/0.19.1...0.19.2)

### Bug Fixes

- Don't crash on single line docstrings with trailing whitespace (Google) ([8d9ccd5](https://github.com/mkdocstrings/griffe/commit/8d9ccd531dd91c6fbfa0922a0133680f881733b0) by Timothée Mazzucotelli).

## [0.19.1](https://github.com/mkdocstrings/griffe/releases/tag/0.19.1) - 2022-05-07

[Compare with 0.19.0](https://github.com/mkdocstrings/griffe/compare/0.19.0...0.19.1)

### Bug Fixes

- Don't crash on nested functions in `__init__` methods ([cd5af43](https://github.com/mkdocstrings/griffe/commit/cd5af43f3a98d54d822015818b7aa0ef15159286) by Timothée Mazzucotelli). [Issue #68](https://github.com/mkdocstrings/griffe/issues/68)

## [0.19.0](https://github.com/mkdocstrings/griffe/releases/tag/0.19.0) - 2022-05-06

[Compare with 0.18.0](https://github.com/mkdocstrings/griffe/compare/0.18.0...0.19.0)

### Features

- Add `load` shortcut function for convenience ([f38a42d](https://github.com/mkdocstrings/griffe/commit/f38a42ddd7ac9d58f36627d9f2a69f4acd65df50) by Timothée Mazzucotelli).
- Support loading (and merging) `*.pyi` files ([41518f4](https://github.com/mkdocstrings/griffe/commit/41518f4aa9e00756a910067cf6f01f07ca7327da) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#404](https://github.com/mkdocstrings/mkdocstrings/issues/404)
- Improve support for call nodes in annotations ([45e5bf5](https://github.com/mkdocstrings/griffe/commit/45e5bf53d509344b3f28118836d356903c64bbf3) by Timothée Mazzucotelli). [Issue #66](https://github.com/mkdocstrings/griffe/issues/66)
- Support `dataclass` decorators on classes ([f579431](https://github.com/mkdocstrings/griffe/commit/f579431474cc4db687e4264f5062074654dec2f3) by Timothée Mazzucotelli).

### Code Refactoring

- Handle absence of values ([190585d](https://github.com/mkdocstrings/griffe/commit/190585d3482bfc3a72694910529b7a0aac35444c) by Timothée Mazzucotelli).
- Simplify decorators to labels function ([04e768f](https://github.com/mkdocstrings/griffe/commit/04e768fb621898faf7a96cc7e7170f10da876664) by Timothée Mazzucotelli).
- Always sort labels when serializing ([bd2504b](https://github.com/mkdocstrings/griffe/commit/bd2504bdb43df3e290c88bd8d25903823f5fc2d6) by Timothée Mazzucotelli).

## [0.18.0](https://github.com/mkdocstrings/griffe/releases/tag/0.18.0) - 2022-04-19

[Compare with 0.17.0](https://github.com/mkdocstrings/griffe/compare/0.17.0...0.18.0)

### Features

- Add CLI option to disallow inspection ([8f71a07](https://github.com/mkdocstrings/griffe/commit/8f71a07c17de4cfb2b519dc2b4086f102de4d325) by Timothée Mazzucotelli).
- Support complex `__all__` assignments ([9a2128b](https://github.com/mkdocstrings/griffe/commit/9a2128b8d4533119b705ec47fc1eca404b4282ef) by Timothée Mazzucotelli). [Issue #40](https://github.com/mkdocstrings/griffe/issues/40)
- Inherit class parameters from `__init__` method ([e195593](https://github.com/mkdocstrings/griffe/commit/e195593b181690313c9e447c8bc2befa72fd6e09) by François Rozet). [Issue mkdocstrings/python#19](https://github.com/mkdocstrings/python/issues/19), [PR #65](https://github.com/mkdocstrings/python/pull/65). It allows to write "Parameters" sections in the docstring of the class itself.

### Performance Improvements

- Avoid using `__len__` as boolean method ([d465493](https://github.com/mkdocstrings/griffe/commit/d4654930577186fb6d3e89ea1561a2daf15b3a65) by Timothée Mazzucotelli).

### Bug Fixes

- Don't crash on unhandle `__all__` assignments ([cbc103c](https://github.com/mkdocstrings/griffe/commit/cbc103c91836db2e235a46a0f9048c1230de507d) by Timothée Mazzucotelli).
- Handle empty packages names in CLI ([52b51c4](https://github.com/mkdocstrings/griffe/commit/52b51c49a14783c986beb851abd33cbcd0ab8729) by Timothée Mazzucotelli).
- Don't crash on Google parameters sections found in non-function docstrings ([4a417bc](https://github.com/mkdocstrings/griffe/commit/4a417bc6c0e83b42fe1a74a4a8b0881d3955075f) by Timothée Mazzucotelli). [Issue mkdocstrings/python#19](https://github.com/mkdocstrings/python/issues/19)

### Code Refactoring

- Improve "unknown parameter" messages ([7191799](https://github.com/mkdocstrings/griffe/commit/7191799c92d7544f949c5870cf2867e02d406c57) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#423](https://github.com/mkdocstrings/mkdocstrings/issues/423)
- Set property label on `@cached_property`-decorated methods ([bc068f8](https://github.com/mkdocstrings/griffe/commit/bc068f8123c5bcbe4dce272dda52840019141b06) by Timothée Mazzucotelli).

## [0.17.0](https://github.com/mkdocstrings/griffe/releases/tag/0.17.0) - 2022-04-15

[Compare with 0.16.0](https://github.com/mkdocstrings/griffe/compare/0.16.0...0.17.0)

### Features

- Handle properties setters and deleters ([50a4490](https://github.com/mkdocstrings/griffe/commit/50a449069de89bb83da854b1bbd1681ec68f0395) by Timothée Mazzucotelli).
- Handle `typing.overload` decorator ([927bbd9](https://github.com/mkdocstrings/griffe/commit/927bbd9fe7712e8d0fc9763fb51d89bef3173350) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#308](https://github.com/mkdocstrings/mkdocstrings/issues/308)
- Set labels on functions using decorators ([1c1feb2](https://github.com/mkdocstrings/griffe/commit/1c1feb264c748f4a78ffebf3b9ea1966f2533522) by Timothée Mazzucotelli). [Issue #47](https://github.com/mkdocstrings/griffe/issues/47)
- Add `runtime` attribute to objects/aliases and handle type guarded objects ([2f2a04e](https://github.com/mkdocstrings/griffe/commit/2f2a04ea498aa50133b1404f3bc3498a25648545) by Timothée Mazzucotelli). [Issue #42](https://github.com/mkdocstrings/griffe/issues/42)
- Support pkg-style namespace packages ([efba0c6](https://github.com/mkdocstrings/griffe/commit/efba0c6a5e1dc185e96e5a09c05e94c751abc4cb) by Timothée Mazzucotelli). [Issue #58](https://github.com/mkdocstrings/griffe/issues/58)

### Code Refactoring

- Remove useless attribute ([c4a92b7](https://github.com/mkdocstrings/griffe/commit/c4a92b7e2cbe240a376d5d6944b7b0d23255648b) by Timothée Mazzucotelli).
- Improve Google warnings ([641089a](https://github.com/mkdocstrings/griffe/commit/641089aed53423894df8733941e404f7e6505b94) by Timothée Mazzucotelli).
- Remove useless import nodes generic visits ([f83fc8e](https://github.com/mkdocstrings/griffe/commit/f83fc8e629451abd4f4eadfe34b448fb3b77b9b6) by Timothée Mazzucotelli).

## [0.16.0](https://github.com/mkdocstrings/griffe/releases/tag/0.16.0) - 2022-04-09

[Compare with 0.15.1](https://github.com/mkdocstrings/griffe/compare/0.15.1...0.16.0)

### Features

- Warn about unknown parameters in Numpy docstrings ([23f63f2](https://github.com/mkdocstrings/griffe/commit/23f63f255eef5aa2dbaa1765f93634ecaf94dbb3) by Timothée Mazzucotelli).
- Warn about unknown parameters in Google docstrings ([72be993](https://github.com/mkdocstrings/griffe/commit/72be993c95460a6465a4e70a95b79ae4095db541) by Kevin Musgrave). [Issue mkdocstrings/mkdocstrings#408](https://github.com/mkdocstrings/mkdocstrings/issues/408), [PR #63](https://github.com/mkdocstrings/griffe/issues/63)

### Bug Fixes

- Don't crash on unhandled AST nodes while parsing text annotations ([f3be3a6](https://github.com/mkdocstrings/griffe/commit/f3be3a68141e24a9c0c6b9a87e3f22e75a168d80) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#416](https://github.com/mkdocstrings/mkdocstrings/issues/416)

## [0.15.1](https://github.com/mkdocstrings/griffe/releases/tag/0.15.1) - 2022-04-08

[Compare with 0.15.0](https://github.com/mkdocstrings/griffe/compare/0.15.0...0.15.1)

### Bug Fixes

- Don't overwrite existing (lower) members when expanding wildcards ([9ff86e3](https://github.com/mkdocstrings/griffe/commit/9ff86e369d8fb3a6eeb7d94cd60c87fa26bf74b4) by Timothée Mazzucotelli).
- Don't insert admonition before current section (Google parser) ([8d8a46f](https://github.com/mkdocstrings/griffe/commit/8d8a46fca7df917c4bba979128d94d3b79252ff5) by Timothée Mazzucotelli).
- Handle aliases chains in `has_docstrings` method ([77c6943](https://github.com/mkdocstrings/griffe/commit/77c69430ddc74fedaa33fa65afd59ac546900829) by Timothée Mazzucotelli).
- Actually check for docstrings recursively ([15f4193](https://github.com/mkdocstrings/griffe/commit/15f4193b764f85dcab042ab193e984bebf151029) by Timothée Mazzucotelli).

## [0.15.0](https://github.com/mkdocstrings/griffe/releases/tag/0.15.0) - 2022-04-03

[Compare with 0.14.1](https://github.com/mkdocstrings/griffe/compare/0.14.1...0.15.0)

### Features

- Support `ignore_init_summary` in Numpy parser ([f8cd147](https://github.com/mkdocstrings/griffe/commit/f8cd14734603d29e6e72c9a350f663dccdeb36b4) by Timothée Mazzucotelli). [Issue #44](https://github.com/mkdocstrings/griffe/issues/44)
- Enable cross-references for Numpy docstrings annotations ([e32a73c](https://github.com/mkdocstrings/griffe/commit/e32a73c9e100cf0778768c4a1f76152d9aecc451) by Timothée Mazzucotelli). Issues [#11](https://github.com/mkdocstrings/griffe/issues/11), [#12](https://github.com/mkdocstrings/griffe/issues/12), [#13](https://github.com/mkdocstrings/griffe/issues/13), [#14](https://github.com/mkdocstrings/griffe/issues/14), [#15](https://github.com/mkdocstrings/griffe/issues/15), [#16](https://github.com/mkdocstrings/griffe/issues/16), [#17](https://github.com/mkdocstrings/griffe/issues/17), [#18](https://github.com/mkdocstrings/griffe/issues/18)
- Retrieve annotations from parent in Numpy parser ([8d4eae3](https://github.com/mkdocstrings/griffe/commit/8d4eae353cbd42f47fe6f8101e6e1f8be4054c84) by Timothée Mazzucotelli). Issues [#29](https://github.com/mkdocstrings/griffe/issues/29), [#30](https://github.com/mkdocstrings/griffe/issues/30), [#31](https://github.com/mkdocstrings/griffe/issues/31), [#32](https://github.com/mkdocstrings/griffe/issues/32)
- Parse annotations in Iterator/Generator for Google docstrings ([f0129ef](https://github.com/mkdocstrings/griffe/commit/f0129efa2046089355ee62c48f23eb0189b054ce) by Timothée Mazzucotelli). [Issue #28](https://github.com/mkdocstrings/griffe/issues/28)

### Bug Fixes

- Fix missing "receives" entry in Google parser ([35d63fb](https://github.com/mkdocstrings/griffe/commit/35d63fbd566fa439a255c3f44ffeb4a9474db7f9) by Timothée Mazzucotelli).
- Fix serialization of Windows paths ([b7e8da8](https://github.com/mkdocstrings/griffe/commit/b7e8da868cd6ec8230f2d58a8f3c38248f7c97b2) by Timothée Mazzucotelli).

### Code Refactoring

- Be less strict on spacing around ":" in Numpy docstrings ([aa592b5](https://github.com/mkdocstrings/griffe/commit/aa592b5f38b71e6eadd883257d2239fceec43752) by Timothée Mazzucotelli).
- Be less strict in Numpy regular expressions ([603dc0e](https://github.com/mkdocstrings/griffe/commit/603dc0e21aa12754ec4f76ffc40869bf8519935d) by Timothée Mazzucotelli).
- Rename variables in Numpy module ([4407244](https://github.com/mkdocstrings/griffe/commit/4407244a2e4b59c988c61e4c7b9f07532cad5b3c) by Timothée Mazzucotelli).

## [0.14.1](https://github.com/mkdocstrings/griffe/releases/tag/0.14.1) - 2022-04-01

[Compare with 0.14.0](https://github.com/mkdocstrings/griffe/compare/0.14.0...0.14.1)

### Bug Fixes

- Retrieve default value for non-string parameters ([15952ed](https://github.com/mkdocstrings/griffe/commit/15952ed72f6f5db3a4dec2fc60cb256c838be6a3) by ThomasPJ). [Issue #59](https://github.com/mkdocstrings/griffe/issues/59), [issue mkdocstrings/python#8](https://github.com/mkdocstrings/python/issues/8), [PR #60](https://github.com/mkdocstrings/griffe/pull/60)
- Prevent infinite recursion while expanding wildcards ([428628f](https://github.com/mkdocstrings/griffe/commit/428628f423192611529b9b346cd295999d0dad25) by Timothée Mazzucotelli). [Issue #57](https://github.com/mkdocstrings/griffe/issues/57)

## [0.14.0](https://github.com/mkdocstrings/griffe/releases/tag/0.14.0) - 2022-03-06

[Compare with 0.13.2](https://github.com/mkdocstrings/griffe/compare/0.13.2...0.14.0)

### Features

- Ignore `__doc__` from parent classes ([10aa59e](https://github.com/mkdocstrings/griffe/commit/10aa59ef2fbf1db2c8829e0905bea88406495c41) by Will Da Silva). [Issue #55](https://github.com/mkdocstrings/griffe/issues/55), [PR #56](https://github.com/mkdocstrings/griffe/pull/56)

## [0.13.2](https://github.com/mkdocstrings/griffe/releases/tag/0.13.2) - 2022-03-01

[Compare with 0.13.1](https://github.com/mkdocstrings/griffe/compare/0.13.1...0.13.2)

### Bug Fixes

- Fix type regex in Numpy parser ([3a10fda](https://github.com/mkdocstrings/griffe/commit/3a10fda89c2e32e2d8acd89eb1ce8ab20a0fc251) by Timothée Mazzucotelli).
- Current module must not be available in its members' scope ([54f9688](https://github.com/mkdocstrings/griffe/commit/54f9688c11a1f7d3893ca774a07afe876f0b809c) by Timothée Mazzucotelli).
- Allow named sections after numpydoc examples ([a44d9c6](https://github.com/mkdocstrings/griffe/commit/a44d9c65cf24d2820e805d23365f38aab82c8c07) by Lucina). [PR #54](https://github.com/mkdocstrings/griffe/pull/54)

## [0.13.1](https://github.com/mkdocstrings/griffe/releases/tag/0.13.1) - 2022-02-24

[Compare with 0.13.0](https://github.com/mkdocstrings/griffe/compare/0.13.0...0.13.1)

### Bug Fixes

- Don't cut through wildcard-expanded aliases chains ([65dafa4](https://github.com/mkdocstrings/griffe/commit/65dafa4660e8c95687cad4d5c5145a56f126ae61) by Timothée Mazzucotelli).
- Fix docstrings warnings when there's no parent module ([e080549](https://github.com/mkdocstrings/griffe/commit/e080549e3eaf887a0f037a4457329eab35bd6409) by Timothée Mazzucotelli). [Issue #51](https://github.com/mkdocstrings/griffe/issues/51)

### Code Refactoring

- Use proper classes for docstrings sections ([46eddac](https://github.com/mkdocstrings/griffe/commit/46eddac0b847eeb75e4964a3186069f7698235b0) by Timothée Mazzucotelli). [Issue mkdocstrings/python#3](https://github.com/mkdocstrings/python/issues/3), [PR #52](https://github.com/mkdocstrings/griffe/pull/52)

## [0.13.0](https://github.com/mkdocstrings/griffe/releases/tag/0.13.0) - 2022-02-23

[Compare with 0.12.6](https://github.com/mkdocstrings/griffe/compare/0.12.6...0.13.0)

### Features

- Implement `trim_doctest_flags` for Google and Numpy ([8057153](https://github.com/mkdocstrings/griffe/commit/8057153823711d8f486b1c52469090ce404771cb) by Jeremy Goh). [Issue mkdocstrings/mkdocstrings#386](https://github.com/mkdocstrings/mkdocstrings/issues/386), [PR #48](https://github.com/mkdocstrings/griffe/pull/48)

### Bug Fixes

- Rename keyword parameters to keyword arguments ([ce3eb6b](https://github.com/mkdocstrings/griffe/commit/ce3eb6b5d7caad6df41496dd300924535d92dc7f) by Jeremy Goh).

## [0.12.6](https://github.com/mkdocstrings/griffe/releases/tag/0.12.6) - 2022-02-18

[Compare with 0.12.5](https://github.com/mkdocstrings/griffe/compare/0.12.5...0.12.6)

### Bug Fixes

- Support starred parameters in Numpy docstrings ([27f0fc2](https://github.com/mkdocstrings/griffe/commit/27f0fc21299a41a3afc07b46afbe8f37757c3918) by Timothée Mazzucotelli). [Issue #43](https://github.com/mkdocstrings/griffe/issues/43)

## [0.12.5](https://github.com/mkdocstrings/griffe/releases/tag/0.12.5) - 2022-02-17

[Compare with 0.12.4](https://github.com/mkdocstrings/griffe/compare/0.12.4...0.12.5)

### Bug Fixes

- Fix getting line numbers on aliases ([351750e](https://github.com/mkdocstrings/griffe/commit/351750ea70d0ab3f10c2766846c10d00612cda1d) by Timothée Mazzucotelli).

## [0.12.4](https://github.com/mkdocstrings/griffe/releases/tag/0.12.4) - 2022-02-16

[Compare with 0.12.3](https://github.com/mkdocstrings/griffe/compare/0.12.3...0.12.4)

### Bug Fixes

- Update target path when changing alias target ([5eda646](https://github.com/mkdocstrings/griffe/commit/5eda646f7bc2fdb112887fdeaa07f8a2f4635c12) by Timothée Mazzucotelli).
- Fix relative imports to absolute with wildcards ([69500dd](https://github.com/mkdocstrings/griffe/commit/69500dd0ce06f4acc91eb60ff20ac8d79303a281) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#382](https://github.com/mkdocstrings/mkdocstrings/issues/382)
- Fix accessing members using tuples ([87ff1df](https://github.com/mkdocstrings/griffe/commit/87ff1dfae93d9eb6f735f9c1290092d61cac7591) by Timothée Mazzucotelli).
- Fix recursive wildcard expansion ([60e6edf](https://github.com/mkdocstrings/griffe/commit/60e6edf9dcade104b069946380a0d1dcc22bce9a) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#382](https://github.com/mkdocstrings/mkdocstrings/issues/382)
- Only export submodules if they were imported ([98c72db](https://github.com/mkdocstrings/griffe/commit/98c72dbab114fd7782efd6f2f9bbf78e3f4ccb27) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#382](https://github.com/mkdocstrings/mkdocstrings/issues/382)

## [0.12.3](https://github.com/mkdocstrings/griffe/releases/tag/0.12.3) - 2022-02-15

[Compare with 0.12.2](https://github.com/mkdocstrings/griffe/compare/0.12.2...0.12.3)

### Bug Fixes

- Always decode source as UTF8 ([563469b](https://github.com/mkdocstrings/griffe/commit/563469b4cf320ea38096846312dc757a614d8094) by Timothée Mazzucotelli).
- Fix JSON encoder and decoder ([3e768d6](https://github.com/mkdocstrings/griffe/commit/3e768d6574a45624237e0897c1d6a6c87e446016) by Timothée Mazzucotelli).

### Code Refactoring

- Improve error handling ([7b15a51](https://github.com/mkdocstrings/griffe/commit/7b15a51fb9dd4722757f272f00402ce29ef2bd3f) by Timothée Mazzucotelli).

## [0.12.2](https://github.com/mkdocstrings/griffe/releases/tag/0.12.2) - 2022-02-13

[Compare with 0.12.1](https://github.com/mkdocstrings/griffe/compare/0.12.1...0.12.2)

### Bug Fixes

- Fix JSON unable to serialize docstring kind values ([91e6719](https://github.com/mkdocstrings/griffe/commit/91e67190fc4f69911ad6ea3eb239a74fc1f15ba6) by Timothée Mazzucotelli).

### Code Refactoring

- Make attribute labels more explicit ([19eac2e](https://github.com/mkdocstrings/griffe/commit/19eac2e5a13d77175849c199ba3337a66e3824a2) by Timothée Mazzucotelli).

## [0.12.1](https://github.com/mkdocstrings/griffe/releases/tag/0.12.1) - 2022-02-12

[Compare with 0.11.7](https://github.com/mkdocstrings/griffe/compare/0.11.7...0.12.1)

### Features

- Add `ignore_init_summary` option to the Google parser ([81f0333](https://github.com/mkdocstrings/griffe/commit/81f0333b1691955f6020095051b2cf869f0c2c24) by Timothée Mazzucotelli).
- Add `is_KIND` properties on objects ([17a08cd](https://github.com/mkdocstrings/griffe/commit/17a08cd7142bdee041577735d5e5ac246c181ec9) by Timothée Mazzucotelli).

## [0.11.7](https://github.com/mkdocstrings/griffe/releases/tag/0.11.7) - 2022-02-12

[Compare with 0.11.6](https://github.com/mkdocstrings/griffe/compare/0.11.6...0.11.7)

### Bug Fixes

- Keep only first assignment in conditions ([0104440](https://github.com/mkdocstrings/griffe/commit/010444018ca6ba437e70166e0da3e2d2ca6bbbe8) by Timothée Mazzucotelli).
- Support invert unary op in annotations ([734ef55](https://github.com/mkdocstrings/griffe/commit/734ef551f5c5b2b4b48de32033d4c2e7cff0a124) by Timothée Mazzucotelli).
- Fix handling of missing modules during dynamic imports ([7a3b383](https://github.com/mkdocstrings/griffe/commit/7a3b38349712c5b66792da1a8a9efae1b6f663a7) by Timothée Mazzucotelli). [Issue mkdocstrings/mkdocstrings#380](https://github.com/mkdocstrings/mkdocstrings/issues/380)
- Fix getting lines of compiled modules ([899461b](https://github.com/mkdocstrings/griffe/commit/899461b2f48622f334ceeaa6d73c935bacb540ea) by Timothée Mazzucotelli).

### Code Refactoring

- Get annotation with the same property on functions ([ecc7bba](https://github.com/mkdocstrings/griffe/commit/ecc7bba8880f90417a21830e0e9cccf30f582399) by Timothée Mazzucotelli).

## [0.11.6](https://github.com/mkdocstrings/griffe/releases/tag/0.11.6) - 2022-02-10

[Compare with 0.11.5](https://github.com/mkdocstrings/griffe/compare/0.11.5...0.11.6)

### Bug Fixes

- Fix infinite loop in Google parser ([8b7b97b](https://github.com/mkdocstrings/griffe/commit/8b7b97b6f507dc91b957592e1d247d79bd3e9a5b) by Timothée Mazzucotelli). [Issue #38](https://github.com/mkdocstrings/griffe/issues/38)

## [0.11.5](https://github.com/mkdocstrings/griffe/releases/tag/0.11.5) - 2022-02-08

[Compare with 0.11.4](https://github.com/mkdocstrings/griffe/compare/0.11.4...0.11.5)

### Bug Fixes

- Fix building title and kind of Google admonitions ([87ab56c](https://github.com/mkdocstrings/griffe/commit/87ab56cfe5458b313527bc2eb47ea418fcb231ab) by Timothée Mazzucotelli). [Issue mkdocstrings#379](https://github.com/mkdocstrings/mkdocstrings/issues/379)

## [0.11.4](https://github.com/mkdocstrings/griffe/releases/tag/0.11.4) - 2022-02-07

[Compare with 0.11.3](https://github.com/mkdocstrings/griffe/compare/0.11.3...0.11.4)

### Bug Fixes

- Don't trigger alias resolution while checking docstrings presence ([dda72ea](https://github.com/mkdocstrings/griffe/commit/dda72ea56b091d1c9bc1b7aa369548328894da29) by Timothée Mazzucotelli). [Issue #37](https://github.com/mkdocstrings/griffe/issues/37)

## [0.11.3](https://github.com/mkdocstrings/griffe/releases/tag/0.11.3) - 2022-02-05

[Compare with 0.11.2](https://github.com/mkdocstrings/griffe/compare/0.11.2...0.11.3)

### Bug Fixes

- Fix getting params defaults on Python 3.7 ([0afd867](https://github.com/mkdocstrings/griffe/commit/0afd8675d2d24302d68619f31adbe5ac5d8ff5a7) by Timothée Mazzucotelli).

## [0.11.2](https://github.com/mkdocstrings/griffe/releases/tag/0.11.2) - 2022-02-03

[Compare with 0.11.1](https://github.com/mkdocstrings/griffe/compare/0.11.1...0.11.2)

### Code Refactoring

- Factorize docstring annotation parser ([19609be](https://github.com/mkdocstrings/griffe/commit/19609bede6227998a1322dbed6fcc1ae2e924bc8) by Timothée Mazzucotelli).

## [0.11.1](https://github.com/mkdocstrings/griffe/releases/tag/0.11.1) - 2022-02-01

[Compare with 0.11.0](https://github.com/mkdocstrings/griffe/compare/0.11.0...0.11.1)

### Code Refactoring

- Rename RST parser to Sphinx ([a612cb1](https://github.com/mkdocstrings/griffe/commit/a612cb1c8d52fabe5a1ebaf892e9b82c67d15a30) by Timothée Mazzucotelli).

## [0.11.0](https://github.com/mkdocstrings/griffe/releases/tag/0.11.0) - 2022-01-31

[Compare with 0.10.0](https://github.com/mkdocstrings/griffe/compare/0.10.0...0.11.0)

### Features

- Support matrix multiplication operator in visitor ([6129e17](https://github.com/mkdocstrings/griffe/commit/6129e17c86ff49a8e539039dcd04a58b30e3648e) by Timothée Mazzucotelli).

### Bug Fixes

- Fix name resolution for inspected data ([ed3e7e5](https://github.com/mkdocstrings/griffe/commit/ed3e7e5fa8a9d702c92f47e8244635cf11a923f2) by Timothée Mazzucotelli).
- Make importer actually able to import any nested object ([d007219](https://github.com/mkdocstrings/griffe/commit/d00721971c7b820e16e463408f04cc3e81a14db6) by Timothée Mazzucotelli).

### Code Refactoring

- Always use search paths to import modules ([a9a378f](https://github.com/mkdocstrings/griffe/commit/a9a378fc6e47678e08a22383879e4d01acd16b54) by Timothée Mazzucotelli).
- Split out module finder ([7290642](https://github.com/mkdocstrings/griffe/commit/7290642e36341e64b8ed770e237e9f232e05eada) by Timothée Mazzucotelli).

## [0.10.0](https://github.com/mkdocstrings/griffe/releases/tag/0.10.0) - 2022-01-14

[Compare with 0.9.0](https://github.com/mkdocstrings/griffe/compare/0.9.0...0.10.0)

### Bug Fixes

- Fix infinite recursion errors in alias resolver ([133b4e4](https://github.com/mkdocstrings/griffe/commit/133b4e4bf721fc7536a1ca957f13f7c9f83bf07a) by Timothée Mazzucotelli).
- Fix inspection of nodes children (aliases or not) ([bb354f2](https://github.com/mkdocstrings/griffe/commit/bb354f21e7b079f4c1e8dd50297d53810c18450e) by Timothée Mazzucotelli).
- Fix relative to absolute import conversion ([464c39e](https://github.com/mkdocstrings/griffe/commit/464c39eaa812a927190469b18bd910e95e3c1d3c) by Timothée Mazzucotelli).

### Code Refactoring

- Rename some CLI options ([1323268](https://github.com/mkdocstrings/griffe/commit/13232685b0f2752d92428ab786d428d0af11743b) by Timothée Mazzucotelli).
- Return the loader the to main function ([9c6317e](https://github.com/mkdocstrings/griffe/commit/9c6317e5afa25dd11d18906503b8010046878868) by Timothée Mazzucotelli).
- Improve logging messages ([b8eb16e](https://github.com/mkdocstrings/griffe/commit/b8eb16e0fedfe50f2c3ad65e326f4dc6e6918ac0) by Timothée Mazzucotelli).
- Skip inspection of some debug packages ([4ee8968](https://github.com/mkdocstrings/griffe/commit/4ee896864f1227e32d40571da03f7894c9404579) by Timothée Mazzucotelli).
- Return ... instead of Ellipsis ([f9ae31d](https://github.com/mkdocstrings/griffe/commit/f9ae31d0f4c904a89c7f581aaa031692740edaef) by Timothée Mazzucotelli).
- Catch attribute errors when cross-referencing docstring annotations ([288803a](https://github.com/mkdocstrings/griffe/commit/288803a3be93c4e077576ed36dded2a76ce33955) by Timothée Mazzucotelli).
- Support dict methods in lines collection ([1b0cb94](https://github.com/mkdocstrings/griffe/commit/1b0cb945dba619df7ce1358f7961e4bd80f70218) by Timothée Mazzucotelli).

### Features

- Compute and show some stats ([1b8d0a1](https://github.com/mkdocstrings/griffe/commit/1b8d0a1c91e03dfa5f92ad9c6dff02863a43fc01) by Timothée Mazzucotelli).
- Add CLI options for alias resolution ([87a59cb](https://github.com/mkdocstrings/griffe/commit/87a59cb7af5f8e7df9ddba41fb4a4b65cb264481) by Timothée Mazzucotelli).
- Support Google raises annotations cross-refs ([8006ae1](https://github.com/mkdocstrings/griffe/commit/8006ae13bc27d117ce6b8fdc8ac91dc8541a670f) by Timothée Mazzucotelli).

## [0.9.0](https://github.com/mkdocstrings/griffe/releases/tag/0.9.0) - 2022-01-04

[Compare with 0.8.0](https://github.com/mkdocstrings/griffe/compare/0.8.0...0.9.0)

### Features

- Loader option to only follow aliases in known modules ([879d91b](https://github.com/mkdocstrings/griffe/commit/879d91b4c50832620ce6ee7bdcc85107a6df9a1f) by Timothée Mazzucotelli).
- Use aliases when inspecting too ([60439ee](https://github.com/mkdocstrings/griffe/commit/60439eefb4635e58e4bd898e5565eab48a5c91d0) by Timothée Mazzucotelli).

### Bug Fixes

- Handle more errors when loading modules ([1aa571a](https://github.com/mkdocstrings/griffe/commit/1aa571a112e3b2ca955c23f2eef97b36f34bcd8c) by Timothée Mazzucotelli).
- Handle more errors when getting signature ([2db85e7](https://github.com/mkdocstrings/griffe/commit/2db85e7f655c1e383ba310f40195844c2867e1b9) by Timothée Mazzucotelli).
- Fix checking parent truthfulness ([6129e50](https://github.com/mkdocstrings/griffe/commit/6129e50331f6e36bcbee2e07b871abee45f7e872) by Timothée Mazzucotelli).
- Fix getting subscript value ([1699f12](https://github.com/mkdocstrings/griffe/commit/1699f121adc13fcc48f81f46dfca85946e2fb74f) by Timothée Mazzucotelli).
- Support yield nodes ([7d536d5](https://github.com/mkdocstrings/griffe/commit/7d536d58ffc0faa4caf43f09194d88c35fc47704) by Timothée Mazzucotelli).
- Exclude some special low-level members that cause cyclic issues ([b54ab34](https://github.com/mkdocstrings/griffe/commit/b54ab346308bb24cba66be9c8f1ee8599481381d) by Timothée Mazzucotelli).
- Fix transforming elements of signatures to annotations ([e278c11](https://github.com/mkdocstrings/griffe/commit/e278c1102b2762b74bf6b83a2e97a5f87b566e2e) by Timothée Mazzucotelli).
- Detect cyclic aliases and prevent resolution errors ([de5dd12](https://github.com/mkdocstrings/griffe/commit/de5dd12240acf8a203a86b04e458ce33b67ced9e) by Timothée Mazzucotelli).
- Don't crash while trying to get the representation of an attribute value ([77ac55d](https://github.com/mkdocstrings/griffe/commit/77ac55d5033e83790c79f3303fdbd05ea66ab729) by Timothée Mazzucotelli).
- Fix building value for joined strings ([6154b69](https://github.com/mkdocstrings/griffe/commit/6154b69b6da5d63c508ec5095aebe487e491b553) by Timothée Mazzucotelli).
- Fix prevention of cycles while building objects nodes ([48062ac](https://github.com/mkdocstrings/griffe/commit/48062ac1f8356099b8e0e1069e4321a467073d33) by Timothée Mazzucotelli).
- Better handle relative imports ([91b42de](https://github.com/mkdocstrings/griffe/commit/91b42dea73c035b2dc20db1e328a53960c51a645) by Timothée Mazzucotelli).
- Fix Google parser missing lines ending with colon ([2f7969c](https://github.com/mkdocstrings/griffe/commit/2f7969ccbf91b63ae22deb742250068c114fe1a9) by Timothée Mazzucotelli).

### Code Refactoring

- Improve alias resolution robustness ([e708139](https://github.com/mkdocstrings/griffe/commit/e708139c9bd19be320bdb279310560212872326f) by Timothée Mazzucotelli).
- Remove async loader for now ([acc5ecf](https://github.com/mkdocstrings/griffe/commit/acc5ecf2bb45dcebdd56d763a657a1075c4a3002) by Timothée Mazzucotelli).
- Improve handling of Google admonitions ([8aa5ed0](https://github.com/mkdocstrings/griffe/commit/8aa5ed0be4f1902dbdfbce9b4a9c7ac619418d43) by Timothée Mazzucotelli).
- Better handling of import errors and system exits while inspecting modules ([7ba1589](https://github.com/mkdocstrings/griffe/commit/7ba1589552fb37fba3c2f3093058e135a6e48a27) by Timothée Mazzucotelli).
- Empty generic visit/inspect methods in base classes ([338760e](https://github.com/mkdocstrings/griffe/commit/338760ea2189e74577250b8c3f4ffe91f81e6b6e) by Timothée Mazzucotelli).

## [0.8.0](https://github.com/mkdocstrings/griffe/releases/tag/0.8.0) - 2022-01-02

[Compare with 0.7.1](https://github.com/mkdocstrings/griffe/compare/0.7.1...0.8.0)

### Features

- Support getting attribute annotation from parent in RST docstring parser ([25db61a](https://github.com/mkdocstrings/griffe/commit/25db61ab01042ad797ac5cdea0b2f7e2382191c1) by Timothée Mazzucotelli).
- Handle relative imports ([62b0927](https://github.com/mkdocstrings/griffe/commit/62b0927516ca345de61aa3cc03e977d4d37220de) by Timothée Mazzucotelli).
- Support wildcard imports ([77a3cb7](https://github.com/mkdocstrings/griffe/commit/77a3cb7e4198dc2e2cea953c5f621544b564552c) by Timothée Mazzucotelli).
- Support configuring log level (CLI/env var) ([839d78e](https://github.com/mkdocstrings/griffe/commit/839d78ea302df004fba1b6fad9eb84d861f0f4aa) by Timothée Mazzucotelli).
- Support loading `*.py[cod]` and `*.so` modules ([cd98a6f](https://github.com/mkdocstrings/griffe/commit/cd98a6f3afbbf8f6a176aa7780a8b916a9ee64f2) by Timothée Mazzucotelli).
- Support inspecting builtin functions/methods ([aa1fce3](https://github.com/mkdocstrings/griffe/commit/aa1fce330ce3e2af4dd9a3c43827637d1e220dde) by Timothée Mazzucotelli).

### Code Refactoring

- Handle extensions errors ([11278ca](https://github.com/mkdocstrings/griffe/commit/11278caea27e9f91a1dc9cc160414f01b24f5354) by Timothée Mazzucotelli).
- Don't always try to find a module as a relative path ([e6df277](https://github.com/mkdocstrings/griffe/commit/e6df2774bfd631fd9a09913480b4d61d137bc0c6) by Timothée Mazzucotelli).
- Improve loggers patching ([f4b262a](https://github.com/mkdocstrings/griffe/commit/f4b262ab5a3d874591324adc2b5ffff214c7e7da) by Timothée Mazzucotelli).
- Improve dynamic imports ([2998195](https://github.com/mkdocstrings/griffe/commit/299819519b7eb9b07b938d22bfb3a27e3b05095d) by Timothée Mazzucotelli).

## [0.7.1](https://github.com/mkdocstrings/griffe/releases/tag/0.7.1) - 2021-12-28

[Compare with 0.7.0](https://github.com/mkdocstrings/griffe/compare/0.7.0...0.7.1)

### Code Refactoring

- Only log warning if async mode is used ([356e848](https://github.com/mkdocstrings/griffe/commit/356e848c8e233334401461b02a0188731b71a8cf) by Timothée Mazzucotelli).

## [0.7.0](https://github.com/mkdocstrings/griffe/releases/tag/0.7.0) - 2021-12-28

[Compare with 0.6.0](https://github.com/mkdocstrings/griffe/compare/0.6.0...0.7.0)

### Features

- Support more nodes on Python 3.7 ([7f2c4ec](https://github.com/mkdocstrings/griffe/commit/7f2c4ec3bf610ade7305e19ab220a4b447bed41d) by Timothée Mazzucotelli).

### Code Refactoring

- Don't crash on syntax errors and log an error ([10bb6b1](https://github.com/mkdocstrings/griffe/commit/10bb6b15bb9b132626c525b81f3ee33c3bb5746f) by Timothée Mazzucotelli).

## [0.6.0](https://github.com/mkdocstrings/griffe/releases/tag/0.6.0) - 2021-12-27

[Compare with 0.5.0](https://github.com/mkdocstrings/griffe/compare/0.5.0...0.6.0)

### Features

- Support more AST nodes ([cd1b305](https://github.com/mkdocstrings/griffe/commit/cd1b305932832ad5347ce829a48a311e3c44d542) by Timothée Mazzucotelli).

### Code Refactoring

- Use annotation getter for base classes ([8b1a7ed](https://github.com/mkdocstrings/griffe/commit/8b1a7edc11a72f679689fa9ba9e632907f9304f8) by Timothée Mazzucotelli).

## [0.5.0](https://github.com/mkdocstrings/griffe/releases/tag/0.5.0) - 2021-12-20

[Compare with 0.4.0](https://github.com/mkdocstrings/griffe/compare/0.4.0...0.5.0)

### Features

- Add support for Python 3.7 ([4535adc](https://github.com/mkdocstrings/griffe/commit/4535adce19edbe7e9cde90f3b1075a8245a6ebc8) by Timothée Mazzucotelli).

### Bug Fixes

- Don't propagate aliases of an alias ([8af48f8](https://github.com/mkdocstrings/griffe/commit/8af48f87e2e6bb0f2cf1531fa10287a069f67289) by Timothée Mazzucotelli).
- Don't reassign members defined in except clauses ([d918b4e](https://github.com/mkdocstrings/griffe/commit/d918b4efcedcedbec6db214ade8cde921d7e97b2) by Timothée Mazzucotelli).

## [0.4.0](https://github.com/mkdocstrings/griffe/releases/tag/0.4.0) - 2021-11-28

[Compare with 0.3.0](https://github.com/mkdocstrings/griffe/compare/0.3.0...0.4.0)

### Features

- Add a prototype 'hybrid' extension ([8cb3c16](https://github.com/mkdocstrings/griffe/commit/8cb3c1661223378a2511fd42a0693d0fbfe924d8) by Timothée Mazzucotelli).
- Allow passing extensions config as JSON on the CLI ([9a7fa8b](https://github.com/mkdocstrings/griffe/commit/9a7fa8bd88752ca1a074179db3a4c7fc41b68028) by Timothée Mazzucotelli).
- Support names for returns, yields and receives sections items ([1c5a4c9](https://github.com/mkdocstrings/griffe/commit/1c5a4c95738615ea9bb6a816c61d078e6133100a) by Timothée Mazzucotelli).
- Store aliases on each object ([91ba643](https://github.com/mkdocstrings/griffe/commit/91ba643b3e8e9a8f56f3280f699a18b1e654ccd7) by Timothée Mazzucotelli).
- Support inspection/introspection ([3a0587d](https://github.com/mkdocstrings/griffe/commit/3a0587dbf26f288722c7d27e781d0887c5cdf641) by Timothée Mazzucotelli).
- Support multiple return, yield and receive items ([0fc70cb](https://github.com/mkdocstrings/griffe/commit/0fc70cbcc07c63ecf1026e4bef30bd0ff3f73958) by Timothée Mazzucotelli).
- Support namespace packages ([2414c8e](https://github.com/mkdocstrings/griffe/commit/2414c8e24b7ba7ee986d95b301662fd06ef350fe) by Timothée Mazzucotelli).

### Bug Fixes

- Fix extensions loader ([78fb70b](https://github.com/mkdocstrings/griffe/commit/78fb70b77076b68fa30592caa5e92a91f0ce2caa) by Timothée Mazzucotelli).
- Avoid visiting/inspecting multiple times ([75a8a8b](https://github.com/mkdocstrings/griffe/commit/75a8a8b7145e1872cbecf93f8e33749b51b5b77b) by Timothée Mazzucotelli).
- Set modules collection attribute earlier ([592c0bd](https://github.com/mkdocstrings/griffe/commit/592c0bde6b6959615bc56030758098c8e45119a2) by Timothée Mazzucotelli).
- Support inequality nodes ([b0ed247](https://github.com/mkdocstrings/griffe/commit/b0ed247c9fe42a324a4e8e4a972676afbaa26976) by Timothée Mazzucotelli).
- Handle Div nodes for values ([272e4d6](https://github.com/mkdocstrings/griffe/commit/272e4d64b5ca557732af903d35aefbe405bd3ac0) by Timothée Mazzucotelli).

### Code Refactoring

- Set log level to INFO ([718e73e](https://github.com/mkdocstrings/griffe/commit/718e73ebb6767c0b10c03482d6f92cf135778ec7) by Timothée Mazzucotelli).
- Add target setter ([7f0064c](https://github.com/mkdocstrings/griffe/commit/7f0064c154459b4f4da7fc25bc49f8dd1e4fd2c0) by Timothée Mazzucotelli).
- Reorganize conditions ([15ab876](https://github.com/mkdocstrings/griffe/commit/15ab8763acc92d9160b847dc878f8bdad7f0b705) by Timothée Mazzucotelli).
- Avoid recursion loops ([ea6acec](https://github.com/mkdocstrings/griffe/commit/ea6acec10c0a805a9ae4e03ae0b92fb2a54cf79b) by Timothée Mazzucotelli).
- Update aliases when replacing a member ([99a0f8b](https://github.com/mkdocstrings/griffe/commit/99a0f8b9a425251ddcde853f2ad9ee95504b2127) by Timothée Mazzucotelli).
- Reorganize code ([31fcdb1](https://github.com/mkdocstrings/griffe/commit/31fcdb1cbe0eceedc59cc7c1c692dc4ef210ef53) by Timothée Mazzucotelli).
- Replace DocstringException with DocstringRaise ([d5ed87a](https://github.com/mkdocstrings/griffe/commit/d5ed87a478411aeb8248e948dbb6c228b80f5fbe) by Timothée Mazzucotelli).
- Refactor loaders ([d9b94bb](https://github.com/mkdocstrings/griffe/commit/d9b94bbcb55c29268ab1e077420e2b0d5297638c) by Timothée Mazzucotelli).
- Improve typing ([e08bcfa](https://github.com/mkdocstrings/griffe/commit/e08bcfac68aa22dc4bc58914b3340c1743f87ee7) by Timothée Mazzucotelli).

## [0.3.0](https://github.com/mkdocstrings/griffe/releases/tag/0.3.0) - 2021-11-21

[Compare with 0.2.0](https://github.com/mkdocstrings/griffe/compare/0.2.0...0.3.0)

### Features

- Handle aliases and their resolution ([67ae903](https://github.com/mkdocstrings/griffe/commit/67ae9034ac25061bc7d5c6def63715209643ca20) by Timothée Mazzucotelli).
- Resolve annotations in docstrings ([847384a](https://github.com/mkdocstrings/griffe/commit/847384a322017ca94bd40d4342eb4b8b42858f91) by Timothée Mazzucotelli).
- Resolve annotations ([6451eff](https://github.com/mkdocstrings/griffe/commit/6451effa01aa09cd3db1584fe111152de649e525) by Timothée Mazzucotelli).
- Add lines property to objects ([7daf7db](https://github.com/mkdocstrings/griffe/commit/7daf7db9ae58fb13985d1adacbde5d0bec2a35e4) by Timothée Mazzucotelli).
- Allow setting docstring parser and options on each object ([07a1d2e](https://github.com/mkdocstrings/griffe/commit/07a1d2e83c12bfa0f7b0dd35149b5cc0d0f600d6) by Timothée Mazzucotelli).
- Get attributes annotations from parent ([003b990](https://github.com/mkdocstrings/griffe/commit/003b99020f45b350d29329690d18f6c6cb3821f9) by Timothée Mazzucotelli).
- Draft extensions loader ([17ccd03](https://github.com/mkdocstrings/griffe/commit/17ccd03cadc5cbb230071e78beab96a0b97456a1) by Timothée Mazzucotelli).
- Add properties to objects ([0ec301a](https://github.com/mkdocstrings/griffe/commit/0ec301a5e97bee6556b62cb6ee35af9976f8410b) by Timothée Mazzucotelli).
- Handle .pth files when searching modules ([2a2e182](https://github.com/mkdocstrings/griffe/commit/2a2e1826fe0235c5bd47b5d6b1b64a30a81a3f4b) by Timothée Mazzucotelli).
- Add `default` property to docstring parameters ([6298ba3](https://github.com/mkdocstrings/griffe/commit/6298ba34d4e769568e519e21549137df3649e01b) by Timothée Mazzucotelli).
- Accept RST and Numpy parsers ([1cf147d](https://github.com/mkdocstrings/griffe/commit/1cf147d8df0491104efd084ce3308da77fc2c817) by Timothée Mazzucotelli).
- Support data (attributes/variables) ([dce84d1](https://github.com/mkdocstrings/griffe/commit/dce84d106cf067f11305f804a24cfd7d5643d902) by Timothée Mazzucotelli).
- Add Numpy-style parser ([ad5b72d](https://github.com/mkdocstrings/griffe/commit/ad5b72d174433764e85f937ea1096c0f458532f8) by Timothée Mazzucotelli).
- Support more section kinds in Google-style ([9d3d047](https://github.com/mkdocstrings/griffe/commit/9d3d0472d0bb55352b371de3da0816419fcf59e0) by Timothée Mazzucotelli).
- Add docstring section kinds ([b270483](https://github.com/mkdocstrings/griffe/commit/b2704833bc74131269306b9947ea2b46edafd349) by Timothée Mazzucotelli).
- Accept initial arguments when creating container ([90c5956](https://github.com/mkdocstrings/griffe/commit/90c59568bb6cdbf18efe182bd821973f2a133663) by Timothée Mazzucotelli).
- Add an RST-style docstring parser ([742e7b2](https://github.com/mkdocstrings/griffe/commit/742e7b2e2101d0679571645584c5a6d3077a9764) by Timothée Mazzucotelli).

### Performance Improvements

- Improve JSON encoder perfs ([6a78eb0](https://github.com/mkdocstrings/griffe/commit/6a78eb0b707a148356fb5bc69d9d0c2115239074) by Timothée Mazzucotelli).

### Bug Fixes

- Handle serialization of Posix paths ([3a66b95](https://github.com/mkdocstrings/griffe/commit/3a66b95a4c91e6160d161acc457c66196adaa4fe) by Timothée Mazzucotelli).
- Fix list annotation getter ([5ae800a](https://github.com/mkdocstrings/griffe/commit/5ae800a8902a28b5241192c0905b1914e2bfe906) by Timothée Mazzucotelli).
- Show accurate line number in Google warnings ([2953590](https://github.com/mkdocstrings/griffe/commit/29535902d53b553906f59295104690c9417eb79f) by Timothée Mazzucotelli).
- Fix assignment names getters ([6990846](https://github.com/mkdocstrings/griffe/commit/69908460b4fe47d1dc3d8d9f6b43d49dee5823aa) by Timothée Mazzucotelli).
- Fix async loader (passing parent) ([57e866e](https://github.com/mkdocstrings/griffe/commit/57e866e4c48f4646142a26c6d2537f4da10e3a2c) by Timothée Mazzucotelli).
- Fix exception name ([4b8b85d](https://github.com/mkdocstrings/griffe/commit/4b8b85dde72a552091534b3293399b844523786f) by Timothée Mazzucotelli).
- Fix Google sections titles logic ([87dd329](https://github.com/mkdocstrings/griffe/commit/87dd32988a9164c47dadf96c0c74a0da8af16bd8) by Timothée Mazzucotelli).
- Prepend current module to base classes (still needs resolution) ([a4b1dee](https://github.com/mkdocstrings/griffe/commit/a4b1deef4beb0e9e79adc920d80232f04ddfdc31) by Timothée Mazzucotelli).
- Fix Google admonition regex ([3902e74](https://github.com/mkdocstrings/griffe/commit/3902e7497ef8b388c3d232a8116cb3bd27fdaad2) by Timothée Mazzucotelli).
- Fix docstring getter ([1442eba](https://github.com/mkdocstrings/griffe/commit/1442eba93479f24a4d90cd9b25f57d304a65cd6c) by Timothée Mazzucotelli).
- Fix getting arguments defaults in the Google-style parser ([67adbaf](https://github.com/mkdocstrings/griffe/commit/67adbafe04de1c8effc124b26565bef59adfb393) by Timothée Mazzucotelli).
- Fix getting arguments annotations in the Google-style parser ([8bcbfba](https://github.com/mkdocstrings/griffe/commit/8bcbfbae861be4c3f9c2b8841c8bc86f39611168) by Timothée Mazzucotelli).

### Code Refactoring

- Export parsers and main function in docstrings module ([96469da](https://github.com/mkdocstrings/griffe/commit/96469dab63a28c061e1d064528f8e07f394c2d81) by Timothée Mazzucotelli).
- Remove top exports ([cd76694](https://github.com/mkdocstrings/griffe/commit/cd7669481a272d7c939b61f6ff2df1cb55eab39e) by Timothée Mazzucotelli).
- Reorganize exceptions ([7f9b805](https://github.com/mkdocstrings/griffe/commit/7f9b8055aa069816b3b55fd02730e97e37a6bea4) by Timothée Mazzucotelli).
- Avoid circular import ([ef27dcd](https://github.com/mkdocstrings/griffe/commit/ef27dcd6cc85590d1982ee14b7f520d379d658b8) by Timothée Mazzucotelli).
- Rename index to [new] offset ([c07cc7d](https://github.com/mkdocstrings/griffe/commit/c07cc7d916d613545073e1159d86c65d58d98b37) by Timothée Mazzucotelli).
- Reorganize code ([5f4fff2](https://github.com/mkdocstrings/griffe/commit/5f4fff21d1da7e1b33554cfb8017b23955999ad5) by Timothée Mazzucotelli).
- Use keyword only parameters ([d34edd6](https://github.com/mkdocstrings/griffe/commit/d34edd629589796d53dbc29d77c5f7041acea5ab) by Timothée Mazzucotelli).
- Default to no parsing for serialization ([8fecd9e](https://github.com/mkdocstrings/griffe/commit/8fecd9ef63f773220bb85379537c4ad25ea0e4fd) by Timothée Mazzucotelli).
- Always extend AST ([c227ae6](https://github.com/mkdocstrings/griffe/commit/c227ae62ee5a3cc764f2c6fc9185400f0c9c48e7) by Timothée Mazzucotelli).
- Set default for kwargs parameters ([7a0b85e](https://github.com/mkdocstrings/griffe/commit/7a0b85e5fd255db743c122e1a13916cdc3eb46ff) by Timothée Mazzucotelli).
- Rename visitor method ([3e0c43c](https://github.com/mkdocstrings/griffe/commit/3e0c43cbed6cec563367f80e86f245b3ba89694c) by Timothée Mazzucotelli).
- Improve typing ([ac86f17](https://github.com/mkdocstrings/griffe/commit/ac86f17bfbfc98d3c41f1830e4356fecc2ed76fc) by Timothée Mazzucotelli).
- Fix typo ([a9ed6e9](https://github.com/mkdocstrings/griffe/commit/a9ed6e95992381df41554a895ed6304ca61048f7) by Timothée Mazzucotelli).
- Rewrite ParameterKind ([90249df](https://github.com/mkdocstrings/griffe/commit/90249df0b478f147fc50a18dfb56ad96ad09e78c) by Timothée Mazzucotelli).
- Add bool methods to docstrings and objects ([548f72e](https://github.com/mkdocstrings/griffe/commit/548f72ed5289aa531c125e4da6ff72a1ff34124d) by Timothée Mazzucotelli).
- Allow setting docstring parser and options on each docstring ([752e084](https://github.com/mkdocstrings/griffe/commit/752e0843bc7388c9a2c7ce9ae2dce03ffa9243e3) by Timothée Mazzucotelli).
- Skip attribute assignments ([e9cc2cd](https://github.com/mkdocstrings/griffe/commit/e9cc2cdd8cae1d15b98ffaa60e777b679ac55e23) by Timothée Mazzucotelli).
- Improve visitor getters ([2ea88c0](https://github.com/mkdocstrings/griffe/commit/2ea88c020481e78060c90d8307a4f6a68047eaa2) by Timothée Mazzucotelli).
- Use relative filepath in docstring warnings ([e894df7](https://github.com/mkdocstrings/griffe/commit/e894df767262623720a45c0b5c16fed544fae106) by Timothée Mazzucotelli).
- Set submodules parent earlier ([53767c0](https://github.com/mkdocstrings/griffe/commit/53767c0c4ef90bfe405dcffd6087e365b98efafc) by Timothée Mazzucotelli).
- Rename Data to Attribute ([febc12e](https://github.com/mkdocstrings/griffe/commit/febc12e5e33bbbdd448298f2cc277a45fd986204) by Timothée Mazzucotelli).
- Rename arguments to parameters ([957856c](https://github.com/mkdocstrings/griffe/commit/957856cf22772584bcced30141afb8ca6a2ac378) by Timothée Mazzucotelli).
- Improve annotation support ([5b2262f](https://github.com/mkdocstrings/griffe/commit/5b2262f9cacce4044716661e6de49a1773ea3aa8) by Timothée Mazzucotelli).
- Always set parent ([cae85de](https://github.com/mkdocstrings/griffe/commit/cae85def4af1f67b537daabdb1e8ae9830dcaec7) by Timothée Mazzucotelli).
- Factorize function handling ([dfece1c](https://github.com/mkdocstrings/griffe/commit/dfece1c0c73076c7d87d4df551f0994b4c2e3b69) by Timothée Mazzucotelli).
- Privatize stuff, fix loggers ([5513ed5](https://github.com/mkdocstrings/griffe/commit/5513ed5345db185e7c08890ca08de17932b34f51) by Timothée Mazzucotelli).
- Use keyword only arguments ([e853fe9](https://github.com/mkdocstrings/griffe/commit/e853fe9188fd2cd2ccc90e5fa1f52443bb00bab7) by Timothée Mazzucotelli).
- Set default values for Argument arguments ([d5cccaa](https://github.com/mkdocstrings/griffe/commit/d5cccaa6ee73e14ca4456b974fba6d01d40bf848) by Timothée Mazzucotelli).
- Swallow extra parsing options ([3d9ebe7](https://github.com/mkdocstrings/griffe/commit/3d9ebe775e1b936e89115d166144610b3a90290c) by Timothée Mazzucotelli).
- Rename `start_index` argument to `offset` ([dd88358](https://github.com/mkdocstrings/griffe/commit/dd88358d8db78636ba5f39fcad92ff5192791852) by Timothée Mazzucotelli).
- Reuse parsers warn function ([03dfdd3](https://github.com/mkdocstrings/griffe/commit/03dfdd38c5977ee83383f95acda1280b3f9ac86b) by Timothée Mazzucotelli).

## [0.2.0](https://github.com/mkdocstrings/griffe/releases/tag/0.2.0) - 2021-09-25

[Compare with 0.1.0](https://github.com/mkdocstrings/griffe/compare/0.1.0...0.2.0)

### Features

- Add Google-style docstring parser ([cdefccc](https://github.com/mkdocstrings/griffe/commit/cdefcccff2cb8236003736545cffaf0bd6f46539) by Timothée Mazzucotelli).
- Support all kinds of functions arguments ([c177562](https://github.com/mkdocstrings/griffe/commit/c177562c358f89da8c541b51d86f9470dd849c8f) by Timothée Mazzucotelli).
- Initial support for class decorators and bases ([8e229aa](https://github.com/mkdocstrings/griffe/commit/8e229aa5f04d21bde108dca517166d291fd2147a) by Timothée Mazzucotelli).
- Add functions decorators support ([fee304d](https://github.com/mkdocstrings/griffe/commit/fee304d44ce33286dedd6bb13a9b7200ea3d4dfa) by Timothée Mazzucotelli).
- Add async loader ([3218bd0](https://github.com/mkdocstrings/griffe/commit/3218bd03fd754a04a4280c29319e6b8d55aac015) by Timothée Mazzucotelli).
- Add relative file path and package properties ([d26ee1f](https://github.com/mkdocstrings/griffe/commit/d26ee1f3f09337af925c8071b4f24b8ae69b01d3) by Timothée Mazzucotelli).
- Add search and output option to the CLI ([3b37692](https://github.com/mkdocstrings/griffe/commit/3b3769234aed87e100ef917fa2db550e650bff0d) by Timothée Mazzucotelli).
- Load docstrings and functions arguments ([cdf29a3](https://github.com/mkdocstrings/griffe/commit/cdf29a3b12b4c04235dfeba1c8ef7461cc05248f) by Timothée Mazzucotelli).
- Support paths in loader ([8f4df75](https://github.com/mkdocstrings/griffe/commit/8f4df7518ee5164e695e27fc9dcedae7a8b05133) by Timothée Mazzucotelli).

### Performance Improvements

- Avoid name lookups in visitor ([00de148](https://github.com/mkdocstrings/griffe/commit/00de1482891e0c0091e79c14fdc318c6a95e4f6f) by Timothée Mazzucotelli).
- Factorize and improve main and extensions visitors ([9b27b56](https://github.com/mkdocstrings/griffe/commit/9b27b56c0fc17d94144fd0b7e3783d3f6f572d3d) by Timothée Mazzucotelli).
- Delegate children computation at runtime ([8d54c87](https://github.com/mkdocstrings/griffe/commit/8d54c8792f2a98c744374ae290bcb31fa81141b4) by Timothée Mazzucotelli).
- Cache dataclasses properties ([2d7447d](https://github.com/mkdocstrings/griffe/commit/2d7447db05c2a3227e6cb66be46d374dac5fdf19) by Timothée Mazzucotelli).
- Optimize node linker ([03f955e](https://github.com/mkdocstrings/griffe/commit/03f955ee698adffb7217528c03691876f299f8ca) by Timothée Mazzucotelli).
- Optimize docstring getter ([4a05516](https://github.com/mkdocstrings/griffe/commit/4a05516de320473b5defd70f208b4e90763f2208) by Timothée Mazzucotelli).

## [0.1.0](https://github.com/mkdocstrings/griffe/releases/tag/0.1.0) - 2021-09-09

[Compare with first commit](https://github.com/mkdocstrings/griffe/compare/7ea73adcc6aebcbe0eb64982916220773731a6b3...0.1.0)

### Features

- Add initial code ([8cbdf7a](https://github.com/mkdocstrings/griffe/commit/8cbdf7a49202dcf3cd617ae905c0f04cdfe053dd) by Timothée Mazzucotelli).
- Generate project from copier-pdm template ([7ea73ad](https://github.com/mkdocstrings/griffe/commit/7ea73adcc6aebcbe0eb64982916220773731a6b3) by Timothée Mazzucotelli).
